05:26:30 <shapr> well crap
05:26:36 <shapr> that bites ass.
05:26:45 <yusri> what now?
05:26:48 <yusri> keep missing people?
05:26:51 <shapr> as far as I can tell, there are no remaining copies of the HaskellWikiInHaskell *anywhere*
05:26:54 <shapr> heh, no :)
05:26:55 <yusri> sheesh, you complain a lot. ;)
05:26:59 * shapr grins
05:27:03 <shapr> yah I probably do
05:27:42 <shapr> what's up in your life yusri?
05:27:55 <yusri> little
05:28:01 <yusri> Going to waste some money today
05:28:10 <yusri> I'm going to shool for a few weeks here
05:28:20 <yusri> devoid of any IT applicances
05:28:25 * yusri shivers in fear
05:28:48 <yusri> so I'm going to buy a PS2 today to waste my time while away, keep my mind of all the porgramming I'm missing
05:29:09 <shapr> what kind of school is devoid of IT appliances?
05:29:44 <yusri> Managerial/supervisory training
05:29:53 <yusri> My laptop died :(
05:30:12 <shapr> suckage
05:30:22 <shapr> (the laptop death, not the school :)
05:30:30 <yusri> It's one of those fairly general, conceptual, think-outside-the-box kind of classes
05:30:36 <yusri> so the school too
05:30:47 <yusri> Though it's necessary for my pay raise
05:31:35 <shapr> what do you do for a living?
05:32:48 <yusri> general linguistic translation
05:33:09 <yusri> usually treaties and goverment/coorporation contracts
05:33:15 <shapr> wow, that's hardwork
05:33:19 <shapr> *very* hard work
05:33:29 <yusri> very tedious, very exacting
05:33:44 <shapr> I hope it pays very well
05:33:49 <yusri> obviously wording and nuance are important :)
05:33:55 <shapr> yah, really
05:34:13 <yusri> It pays enough, I guess.  Though I wouldn't complain if they doubled it ;)
05:34:23 <shapr> heh
05:34:40 <shapr> my significant other does translations of scientific documents sometimes
05:34:44 <shapr> (among other things)
05:34:56 <shapr> and I get to see just how difficult it really is
05:35:02 <yusri> Ah- what lang?
05:35:41 <shapr> she does german, french, english, and some dutch translations
05:35:54 <shapr> and we're both learning finnish (though *very* slowly)
05:36:15 <yusri> Ah- I know very little norwegian, which I suppose is fairly similar (?)
05:36:30 <shapr> I don't think so
05:36:42 <shapr> with the disclaimer that I am not a linguist :)
05:36:53 * yusri is; will ahev to look ;)
05:36:56 <shapr> I think that most of the scanned in avian languages are closely related except for finnish
05:37:13 <Heffalump> oh, shapr, I got ghc with hopengl to compile. No idea if it works, though :-)
05:37:13 <shapr> norwegian, swedish, and danish sound pretty similar,
05:37:19 <shapr> Heffalump: awesome!
05:37:28 <Heffalump> only problem, it's nearly 200MB worth of debs
05:38:07 <yusri> Ah, i recall- finnish is an oddity
05:38:14 <shapr> yusri: those last three sound a lot like a strange dutch and german mixture
05:38:22 * yusri nods
05:38:42 <shapr> one third dutch, one fifth german, one fifth english, a few french words, and some other random stuff..
05:39:04 * yusri nods
05:39:19 <yusri> languages like that make me yearn for my [relatively] pure arabic.
05:40:11 <shapr> finnish is very pure in that respect
05:40:24 <shapr> estonian is the closest thing to finnish, and it's not very close
05:40:33 * yusri looks at the time and realizes he needs to sleep
05:40:39 <shapr> g'night yusri
05:40:48 <yusri> sorry to cut you off- these ARE my favourite- but I need to crash
05:41:05 <shapr> no worries :)
05:41:26 <shapr> talk to ya tomorrow
05:42:26 <yusri> prob just a nap- too much to do
05:42:50 <shapr> heh
05:45:12 * xbill hacks the kernel.
05:45:25 * shapr hacks his locale
05:54:38 <Yurik> hi
05:54:44 <Yurik> shapr are you here?
05:55:39 <Yurik> guys, can anybody say where can I read any good tutorial on ASN.1 and BER/PER?
05:56:51 <shapr> hi Yurik 
05:56:55 <shapr> are you serious?
05:57:00 <shapr> why do you want to know about ASN.1?
05:57:09 <shapr> it's most evil technology I've ever had to learn!
05:57:16 <shapr> but, yes I can point you to lots of info on it
05:57:27 <Yurik> well, just read some introduction on it (in Erlang/OTP docs and some webpages)
05:57:32 <shapr> I also know that erlang and Haskell have excellent ASN.1 tools
05:57:35 <Yurik> and found that it is quite interesting in E/AS
05:57:41 <shapr> really? how so?
05:58:26 <Yurik> Using ASN.1 usage seems to be very nice in E/AS to support non-native method implementors to exchange data..
05:58:40 <shapr> I think *anything* would be better than ASN.1
05:58:52 <Yurik> ?
05:59:08 <shapr> I've been working with ASN.1 for the last six months or so
05:59:24 <shapr> I'm writing an X.509 PKI timestamp client in Java
05:59:28 <shapr> rfc3161
05:59:46 <shapr> and, in my humble opinion, ASN.1 is *evil*
05:59:58 <shapr> I'd recommend XML far above it.
06:00:42 <shapr> er, let me give some detailed examples:
06:00:56 <shapr> there are about eight basic datatypes in ASN.1
06:01:12 <shapr> but one type is called ANY
06:01:22 <shapr> and it can be a any other ASN.1 datatype
06:01:48 <shapr> but in 99% of the cases I've seen, it's actually an OCTET STRING (just a bunch of bytes)
06:02:15 <shapr> still sounds ok, until you realize that most people embed another ASN.1 structure in there
06:02:27 <shapr> so...
06:02:47 <Yurik> hmm. isn't ASN.1 widely used?
06:02:53 <shapr> yes it is
06:03:04 <shapr> and there's no central repository for ASN.1 definitions
06:03:14 <shapr> nor for OID definitions
06:03:27 <Yurik> so even in framework of one project you propose to use XML?
06:03:31 <shapr> and there are at least three different syntaxes (1988, 1991, 1994, and I think maybe a  1997)
06:03:42 <shapr> I'd say "anything other than ASN.1"
06:03:48 <Yurik> heh
06:04:08 <shapr> I could go into extreme detail about why I think ASN.1 is the most evil technology I've had to deal with...
06:04:11 <shapr> do you want more detail?
06:04:32 <Yurik> yep, I want. I want to make a right decision
06:04:37 <shapr> ok
06:04:49 <shapr> just a moment, let me get some urls together
06:04:58 <shapr> first, the layman's guide to a subset of ASN.1
06:05:24 <shapr> http://www.rsasecurity.com/rsalabs/pkcs/
06:05:39 <shapr> near the bottom of that page, you'll see the layman's guide.
06:06:07 <Yurik> I see
06:06:34 <shapr> I have an asn.1 response that's been sent back from a timestamp server, want me to send you the file?
06:06:35 * Yurik is downloading layman.ps.gz
06:06:47 <shapr> http://www.cs.auckland.ac.nz/~pgut001/
06:06:51 <shapr> that's peter gutmann's homepage
06:07:00 <shapr> he has a fascinating view of the X.509 standards
06:07:31 <shapr> if you need to work with ASN.1 you *will* need his dumpasn1.c code
06:07:34 <shapr> as well as his list of Object Identifiers
06:08:08 <shapr> there are two books about ASN.1 that are available from ... oss.com I think...
06:08:11 <shapr> and they're free
06:08:17 <shapr> and I've read both of the books
06:08:22 <shapr> and I've read the layman's guide
06:08:31 <shapr> and I *still* have daily problem with encoding and decoding ASN.1
06:08:33 <shapr> not only that...
06:08:47 <shapr> but there around 30 different encodings for ASN.1 that I'm aware of
06:08:53 <shapr> and at least three major encodings
06:08:59 <shapr> those being BER, PER, and DER
06:09:25 <shapr> there's even XER, the XML encoding, but that's used so that you can encode something, and the actually look at it in a text editor
06:09:40 <shapr> "then actually"
06:09:45 <Yurik> well, seems that I understand why ASN.1 can be an evil technology..
06:10:02 <shapr> yes, especially because the standards don't cover everything themselves
06:10:10 <shapr> some asn.1 parsers allow empty elements
06:10:16 <shapr> some require a NULL in empty elements
06:10:27 <shapr> some disallow both of those
06:11:09 <shapr> you will need a piece of software to automatically compile your ASN.1 specification file into a chunk of code that can turn it into an ASN.1 representation
06:11:22 <shapr> then, you'll need at least one encoder to encode that representation
06:11:40 <shapr> I require two encoders/decoders at work, for DER and for BER
06:11:50 <Yurik> well, as I see, erlang has ASN compiler..
06:12:12 <shapr> oss.com sells their ASN.1 compiler for USD $25,000 
06:12:19 <shapr> it comes in C++ and Java flavors
06:13:02 <shapr> <Yurik> Using ASN.1 usage seems to be very nice in E/AS to support non-native method implementors to exchange data..
06:13:30 <shapr> ASN.1 is not a good way to exchange data with another platform/language/host
06:13:35 <shapr> that's my solid opinion
06:13:41 <Yurik> well, probably you're right :-)
06:14:01 <Yurik> so, what will be better? XML (I'm very pessimistic on wide XML usage)
06:14:03 <shapr> I've spent three weeks straight trying to debug a very simple ASN.1 encoding problem
06:14:03 <Yurik> ?
06:14:22 <shapr> one of the great strengths of XML is that I can read its contents even with Notepad
06:14:35 <shapr> trying to debug ASN.1 is a complete and total nightmare
06:15:05 <shapr> my overall opinion of cross-anything encoding is leaning towards lisp-style SEXPs lately
06:15:14 <shapr> XML is second on my list
06:15:47 <Yurik> SEXP? what is this?
06:15:48 <shapr> want me to explain why?
06:15:58 <shapr> Lisp source code is most often written in Cambridge Polish notation: from a set of atomic symbols, you build Symbolic EXPressions (S-exp or SEXP -- once was SEX), a SEXP being either atomic, or a list of smaller SEXP, read and written as the parenthesized space-separated sequence of the representations of its components
06:16:10 <shapr> that's a short quote from this page: http://tunes.org/Review/Languages.html
06:16:23 <shapr> if you jump down to the LISP section, they have some interesting stuff
06:16:56 * shapr takes a moment to compose his thoughts on the subject of data interchange
06:18:52 <Yurik>  written as the parenthesized space-separated
06:18:52 <Yurik>           sequence of the representations of its components
06:18:52 <Yurik> <shapr> that's a short quote from this page:
06:19:03 <Yurik> sorry, cut-n-paste
06:19:04 <Yurik> :-)
06:21:15 <shapr> no worries
06:21:18 <shapr> ok, I've been thinking about it
06:21:28 <shapr> I read a funny quote somewher
06:21:47 <shapr> it said "some has a problem, they need to match some text, they decide to use regular expressions... now they have two problems"
06:22:07 <shapr> what it means to me is that regular expressions are powerful, but can easily bite you if you don't know what you're doing with them
06:22:32 <shapr> that's why I'm the only person I work with who uses regular expressions, no one else understands them well enough to use them
06:23:07 <shapr> with ASN.1, it can be useful, but it's so much more complex than regular expressions that it has fifty-nine ways to bite you for ever one way it could be useful
06:23:14 <shapr> er, "every one"
06:25:17 <Yurik> heh :-)
06:25:38 <shapr> so...
06:25:44 <shapr> I'd say that ASN.1 isn't useless
06:26:09 <Yurik> I understand your point of view concerning ASN.1 :-)
06:26:11 <shapr> but it's so complicated that you should write your own ASN.1 parser before you use it, because otherwise it will suck away your sanity.
06:27:09 <shapr> if you still decide to use it, I'll help you howevery I can, but I would strongly recommend against using it.
06:28:31 <Yurik> probably I will not use ASN.1. I do not like such kinda techs... so complicated and can really make a kinda harm ( :)) )...
07:54:47 <shapr> hi tmoertel 
07:54:50 <shapr> what's up?
07:55:03 <shapr> your Haskell, Perl, and XSLT article is nifty
07:55:08 <tmoertel> howdy. just stoppin' by to see what's going on
07:55:26 <tmoertel> thanks. hope it wasn't seen as overly harsh.
07:55:38 <shapr> I liked it
07:55:47 <shapr> I've given the url to a bunch of people to read
07:55:47 <tmoertel> (I *like* XSLT, but its weaknesses drive me crazy.)
07:55:51 <shapr> yah, I understand
07:56:34 <shapr> I just figured out how to generate a ssh2 public key
07:56:38 <shapr> now I gotta see if it works
07:57:09 <shapr> tmoertel: written any cool code lately?
07:57:33 * tmoertel got a phone call . . .
08:04:32 * tmoertel is back
08:04:47 <tmoertel> still there?
08:05:06 <shapr> yah sure
08:05:07 <shapr> what's up?
08:06:01 <tmoertel> Let's see, Haskell-wise, I've been doing a few of John Hughes' courses online.
08:06:55 <tmoertel> The "Designing and Using Combinators: The Essence of Functional Programming" course is wonderful.
08:07:12 <shapr> I suspect it would still be a bit over my head... but maybe not...
08:07:16 <tmoertel> His paper on Global Variables in Haskell is also a great read.
08:08:25 <shapr> do you do much programming outside of Haskell?
08:08:36 <shapr> I can guess you do since you deal with XSLT and Perl at least
08:08:59 <tmoertel> Yes. Mostly Perl, C, C++, bash, SGML/XML-related.
08:09:23 <tmoertel> Perl and Haskell are my favorites.
08:10:01 <tmoertel> How 'bout yourself?
08:10:10 <shapr> Python and Haskell are currently my favorites
08:10:22 <shapr> but I'm having lots of fun with Joy lately
08:10:34 <shapr> I do Java at one of my jobs also
08:10:38 <tmoertel> I'm not familiar w/ Joy. What's it like?
08:10:53 <shapr> it's a concatenative stack based functional lang
08:11:06 <shapr> kind of like PostScript/Forth meets Haskell, and they have kids
08:11:06 <tmoertel> Postfix?
08:11:09 <shapr> yah, very
08:11:27 <tmoertel> Is it used for embedded stuff, like Forth?
08:11:29 <shapr> I didn't know postfix/stack languages existed before I found Joy, it's fun!
08:11:47 <tmoertel> One of my favorites is the Unix 'dc' program!
08:11:50 <shapr> heh
08:12:04 <shapr> yah, the concatenative group talks about that occasionally
08:12:25 <tmoertel> Can you give me a line or two of Joy code to give me a feel?
08:12:34 <shapr> sure, just a moment
08:13:04 <shapr> jewel and I are working on a connected graph path finder in Joy
08:13:14 <shapr> DEFINE pairs == [["ward" "shae"] ["shae" "irene"] ["shae" "al"] ["al" "jewel"] ["irene" "lynda"] ["lynda" "jewel"]] .
08:13:19 <shapr> DEFINE buildFilter == [] cons [first] swap concat [=] concat .
08:13:26 <shapr> DEFINE collectEdges == pairs swap buildFilter filter .
08:13:49 <tmoertel> Postfix-riffic!
08:13:54 <shapr> totally
08:14:00 <tmoertel> Stack-mazing!
08:14:10 <shapr> absolutely!
08:14:21 <shapr> it's great fun
08:14:30 <tmoertel> Are you on the pragprog list?
08:14:33 <shapr> sure!
08:14:52 <tmoertel> Did you work on the circuit exercise from one of Prof. Hughes' lectures?
08:14:59 <shapr> nope, not yet
08:15:31 <tmoertel> I just did it last night. Very fun.
08:16:57 <shapr> I keep getting distracted into doing fun stuff
08:17:04 <shapr> well, other fun stuff :)
08:17:05 <tmoertel> It happens. ;-)
08:17:09 <shapr> I really enjoy using Haskell
08:17:22 <shapr> I'd like to be able to recommend it to my bosses
08:17:35 <tmoertel> Every time I do work in mainstream languages, I miss foldr.
08:17:44 <tmoertel> Woe to me without foldr!
08:17:59 <shapr> happily for me, Python has map, filter, and reduce (foldr)
08:18:07 <shapr> that's what got me into FP
08:18:43 <shapr> I realized how amazingly useful those commands are
08:19:07 <tmoertel> Foldr doesn't really shine w/o lazy eval.
08:19:15 <tmoertel> Then, it's a thing of beauty.
08:19:17 <shapr> I have a feeling that the referential transparency requirement of FPLs ends up creating far more orthogonality in the languages
08:19:32 <shapr> well, more than procedural languages
08:19:40 <tmoertel> True, true.
08:19:56 <shapr> yesterday I hypothesized that higher order functions in FP work like metaclasses in OOP
08:20:00 <shapr> what do you think about that?
08:20:27 <tmoertel> Interesting hypothesis.
08:20:59 <shapr> btw, there's also the #loty channel here
08:21:12 <tmoertel> I checked it last night, but it was dead. Active now?
08:21:23 <shapr> not so much the last week or two
08:21:45 <shapr> hi Yurik!
08:21:52 <shapr> did you decide anything about ASN.1?
08:21:58 <Yurik> shapr hi
08:22:05 <Yurik> seems that decided not to use it :-)
08:22:09 * shapr cheers
08:22:22 <Yurik> hehe
08:22:29 <shapr> tmoertel: hey, have you heard of the sf.net/projects/haskell-libs/ project?
08:22:46 <tmoertel> I just checked it out last night. The idea is to collect snippets, right?
08:23:03 <shapr> that's part of it
08:23:18 <shapr> another part of it is to write up some of the standard libraries that are missing
08:23:26 <shapr> such as smtplib, imaplib, poplib
08:23:53 <tmoertel> I've got some lazy base64 and quoted-printable stuff I could contribute.
08:23:58 <shapr> coool!
08:24:06 <shapr> that would rock :)
08:24:18 * Yurik has downloaded USSR Anthem and got merry modd :o)
08:24:27 <Yurik> s/modd/mood/
08:25:50 <shapr> tmoertel: can you think of any haskell libs you'd use if they existed?
08:25:56 <Yurik> sounds from childhood.. yeah :-)
08:26:36 <tmoertel> Yes: we need more robust XML support, easy HTTP (ala Perl's LWP::Simple), ...
08:27:19 <tmoertel> modules for common text-processing shells...
08:27:22 <shapr> hm, you think HaXML needs improving?
08:27:29 <shapr> what kind of modules?
08:27:42 <shapr> stuff like sort,uniq,tr,comm ?
08:27:54 <shapr> I don't know perl, what does LWP::Simple do?
08:27:58 <shapr> wget?
08:28:16 <tmoertel> Yes. HaXML's support for % entities in DTD -> Haskell type leads to undesireble type duplication.
08:28:53 <tmoertel> *Example* perl -MLWP::Simple -e'getprint("http://www.moertel.com/~thor/icfp2001/")'
08:29:10 <shapr> I don't know anything about that, do you have a small snippet of code that shows the duplication of % entities?
08:29:46 <shapr> sounds like the wget binary, urllib in python
08:29:58 <shapr> or httplib
08:30:37 <tmoertel> Many DTDs use % entities to define common classes of content:
08:30:47 <tmoertel> <!ENTITY  % inline      '#PCDATA|br|emph|strong|link|img|footnote'>
08:31:07 <tmoertel> And then those entities are referenced throughout the DTD:
08:31:17 <tmoertel> <!ELEMENT para (%inline;)*>
08:31:49 <tmoertel> <!ELEMENT intro (%inline;)*>
08:32:16 <tmoertel> But when HaXML constructs a type for Para and Intro, it will expand %inline into the Br Emph Strong Link Img like so:
08:32:39 <tmoertel> Para_Br Para_Emph Para_Strong Para_Link Para_Img *and*
08:33:00 <tmoertel> Intro_Br Intro_Emph Intro_Strong Intro_Link Intro_Img, and so on
08:33:02 <shapr> hm
08:33:53 <shapr> what would be better?
08:33:58 <tmoertel> So you end up writing wacky handlers to get all the Br's, Emph's, ...
08:34:22 <tmoertel> It would be better i f you could tell HaXML not to expand certain entities.
08:35:12 <tmoertel> So you could create a "meta element" Inline that contained Inline_Br, Inline_emph, etc.and Para and Intro could each include Inline
08:35:30 <tmoertel> rather than the expansion of Inline into all its components.
08:35:49 <shapr> that makes sense to me
08:36:03 <tmoertel> So, maybe we could do some work on HaXML, too.
08:37:16 <shapr> sounds like it :)
08:37:42 <shapr> since you said 'we' would you like for me to add you to the list of developers on haskell-libs ?
08:38:18 <tmoertel> Sure.
08:38:25 <shapr> ok
08:39:25 <shapr> same name? tmoertel?
08:40:12 <tmoertel> Yup.
08:45:17 <tmoertel> I see that the current tasks are smtplib and imaplib.
08:47:46 <shapr> welcome to the haskell-libs project!
08:48:04 <shapr> oh, do you want to be an admin?
08:48:04 <tmoertel> Yup. I can see that I'm on the list hoiw. Thanks.
08:48:38 <tmoertel> No, that's okay.
08:48:45 <shapr> yah, imaplib and smtplib were two projects that seemed needed
08:49:01 <shapr> I actually think that poplib and smtplib would be best
08:49:29 <shapr> or at least, most likely to be used by a lot of people
08:49:48 <shapr> but I don't know the needs of the entire community by any means
08:50:06 <shapr> ah, sandwiches are good things.... sometimes obsessive means I forget to eat
08:50:27 <shapr> ahem, "obsessive coding"
08:50:29 <shapr> whoops
08:50:34 <tmoertel> So is espresso. Nothing cuts through "code fog" like it.
08:50:51 * shapr slurps on a cup of coffee
08:51:08 <shapr> btw, what part of the world do you live in?
08:51:17 * tmoertel laments his empty espresso cup.
08:51:31 <tmoertel> Glorious Pittsburgh.
08:51:33 <tmoertel> You?
08:51:47 <shapr> well, I'd email you some of my coffee, but I'm afraid what it might do to the computer
08:52:02 <shapr> I'm in snowy Tornio, Finland
08:52:09 <shapr> where sweden, finland, and the gulf of bothnia touch
08:52:29 <tmoertel> I hear folks drink a lot of coffee in that part of the world. True?
08:52:46 <shapr> er, I'd say more alcohol than coffee actually
08:53:03 <Yurik> tmoertel programmers drink a lot of coffee. in every part of the world :-)
08:53:04 <tmoertel> Hmm.. Probably isn't so good for the code. ;-)
08:53:16 <shapr> understandably so, the winters near the arctic circle get depressing
08:53:26 <tmoertel> True.
08:53:32 <shapr> I'm originally from Birmingham, Alabama, only been here ~2.5 years
08:53:50 * Yurik tried to avoid drinking alcohol a lot
08:53:51 <tmoertel> Now, that's what I call a move!
08:53:54 * Yurik tries to avoid drinking alcohol a lot
08:54:45 <shapr> yah, me too
08:54:48 <shapr> I try to avoid it
08:55:41 * Yurik got a bad vodka-n-beer trip few days ago :-(
08:57:42 <shapr> hm, any latin experts here?
08:58:11 <tmoertel> If so, I'm not oen of them.
08:58:15 <tmoertel> s/oen/one/
08:58:18 <shapr> heh :)
08:58:36 <shapr> tmoertel: any suggestion for the haskell-libs group?
08:58:56 <shapr> juhp suggested that I announce its existence on the haskell list and solicit lib suggestions and contributors there
08:59:20 <tmoertel> That would be a good idea.
08:59:33 <shapr> any other suggestions?
08:59:46 <tmoertel> You might also want to ask about orphaned research projects.
08:59:53 * Heffalump tries to remember what happened to the Haskell libraries project that was discussed there
09:00:11 <shapr> Heffalump: it turned into the haskell-libraries mailing list, which has very little traffic
09:00:20 <shapr> at least, that's what I've seen
09:00:22 <tmoertel> There's a lot of good stuff that started well but never was finished.
09:00:30 <Heffalump> hmmm :/
09:00:32 <shapr> yah, I'd like to collect stuff like that
09:00:38 <Heffalump> maybe the new FFI stuff would help
09:00:46 <Heffalump> s/would/will/
09:00:47 <shapr> for example, I found a Hsh.hs, a minimal demo Haskell shell
09:01:11 <shapr> and someone just finished writing an LDAP client in Haskell that might show up in the CVS tree if they approve
09:01:14 <Igloo> Someone here was doing that for his project. I wonder how he got on
09:01:25 <shapr> Igloo: was doing what?
09:01:26 <Heffalump> igloo: doing what?
09:01:29 <Igloo> Haskell shell
09:01:30 <shapr> collecting stuff?
09:01:32 <shapr> ah
09:01:53 <shapr> "here" meaning your physical location?
09:01:55 <shapr> or #haskell ?
09:02:03 <Heffalump> and who, if the former?
09:02:08 * shapr pries proper out of Igloo
09:02:13 <shapr> ahem, "proper nouns"
09:03:07 <Heffalump> the problem with a Haskell shell is that dynamically loading Haskell scripts isn't actually possible
09:03:07 * shapr googles for haskell shell
09:03:13 <Heffalump> http://www.informatik.uni-bonn.de/~ralf/software/examples/Hsh.html
09:03:16 <Igloo> Physically here, and Gareth
09:03:23 <Heffalump> Gareth who?
09:03:31 <Igloo> nullity...ermmm...
09:03:35 <Heffalump> ah, right.
09:03:42 <Igloo> It was hugs based I think
09:03:46 <shapr> Heffalump: yah, dennisb and xbill helped me clean up Hsh.hs so that it works with ghc5
09:03:53 <Heffalump> Gareth Smith
09:04:09 <Igloo> Oh, OK, I was never going to get that
09:04:25 <Heffalump> shapr, ah, cool
09:04:55 <shapr> Heffalump: yah, I'll be putting it in as the first snippet for haskell-libs
09:05:17 <shapr> I'd really like to see a haskell shell that could load haskell scripts
09:05:28 <shapr> even if has to recompile and restart itself :)
09:05:53 <Heffalump> I guess if it was based around ghci, it'd be feasible
09:05:56 <Heffalump> but that's rather big
09:06:05 <shapr> better than nothing
09:06:35 <Heffalump> hmm.
09:06:38 <Heffalump> hi ski
09:06:43 <shapr> hi ski!
09:06:45 <ski> hi Heffalump 
09:06:47 <ski> hi shapr
09:06:58 <shapr> w00, we got 17 people on at the same time
09:07:02 <shapr> I think that's a record
09:07:28 <ski> how many are (at least a little) active of them ? (approx.)
09:07:35 <ski> aha
09:07:41 <ski> :)
09:08:18 <Heffalump> hmm. What dynamic loading needs is essentially some kind of reflection module
09:08:55 <shapr> Heffalump: that's something you wished for yesterday, right?
09:08:59 <shapr> what would that involve?
09:09:51 * tmoertel is on the phone (again) . . .
09:10:07 <shapr> tmoertel: tell me you have a nice comfy headset ;)
09:10:29 <Heffalump> well, firstly a runtime library that could load up a haskell module (including parsing and type-checking)
09:10:48 <ski> that would be fun.
09:11:08 <Heffalump> then, represent the types of the things that module exported in a Haskell data structure, and return those to the function that called it
09:11:41 <Heffalump> and finally, provide a means for the functions in the newly loaded module to be actually called
09:12:08 <Heffalump> that strikes me as the nastiest bit, conceptually
09:12:20 <Heffalump> because if that module defines data types that are needed to call it
09:12:43 <shapr> then you have to dynamically create them?
09:12:59 <Heffalump> the function doing the calling needs to dynamically construct instances of that data type. So there'd need to be some kind of marshalling
09:13:06 <Heffalump> well, instances of them, yes
09:13:20 <shapr> Python has an interesting solution... there's a "new" module
09:13:36 <shapr> which can turn an instance into any other instance, even one that doesn't exist
09:14:06 <Heffalump> well, Haskell is strongly typed, so...
09:14:14 <shapr> yah...
09:14:26 <shapr> Python is strongly typed also
09:14:30 <ski> should one be able to load *any* module into the system with this ?
09:14:31 <shapr> but dynamically strongly typed
09:14:59 <Heffalump> errm, Python doesn't give types to higher-order functions, does it?
09:15:02 <shapr> ski: I'd be happy with just enough to let me define new commands for a haskell shell myself
09:15:10 <ski> (i.e. even modules that one don't know the interface of yet ..)
09:15:12 <Heffalump> ski: ideally, yes
09:15:18 <shapr> Heffalump: huh?
09:15:22 <shapr> oh
09:15:24 <Heffalump> shapr: I could be wrong
09:15:35 <shapr> no, functions don't require that a certain type show up in the args
09:15:44 <shapr> you can pass in anything you want
09:15:52 <Heffalump> ski: that's why I said that it'd need to represent the types of the functions exported by the module in some Haskell data structure
09:15:54 <ski> to bad ..
09:16:00 <ski> hmm
09:16:10 <shapr> ski: you have a solution in mind that covers some modules?
09:16:37 <Heffalump> but I guess a scheme that had a hard-coded interface would be an ok start
09:17:05 <shapr> yah, anything at all would be a good start
09:17:41 <ski> shapr : well, one perhaps down-sized solution would be to dynamically load modules with known interfaces (like the signatures in ML, say). so you know what constants and functions to expect and their corresponding types so you just have to check that dynamically ..
09:17:54 <shapr> Gareth Smith did some nifty stuff
09:18:29 <Heffalump> shapr: he did? URL?
09:18:33 <ski> shapr : that way one have to know *what* is to be imported, but the actual implementation could be provided dynamically
09:18:43 <shapr> Heffalump: http://www.comp.lancs.ac.uk/computing/research/cseg/projects/sol/
09:18:51 <shapr> fascinating, reminds me of Kansas from Self
09:19:01 <shapr> and Nebraska is the Squeak version of that idea
09:19:03 <Heffalump> that sounds like the wrong person
09:19:07 <shapr> oh
09:19:07 <ski> shapr : though, sadly, this ain't as general as what we'd really like :(
09:19:16 <Heffalump> since the person we were referring to is a third year undergraduate in Oxford :-)
09:19:20 <shapr> ohhh
09:19:35 <shapr> Heffalump: yah, probably is someone different then :)
09:19:41 <shapr> ski: it's an excellent start
09:19:52 <Heffalump> hmm.
09:19:57 <ski> hmm
09:20:01 <shapr> hmm
09:20:04 <Heffalump> hugs can be made into a dynamic library without too much hassle.
09:20:11 * shapr bows to peer pressure and hmmms some more
09:20:23 <Heffalump> (I've linked it up to an IRC bot, for example)
09:20:27 <shapr> whoa, cool
09:20:36 <shapr> you have a haskell irc bot???
09:20:39 <ski> perhaps one could have some special construct like :  dynimport "Foo.hs" FooInterface in ...
09:21:05 <Heffalump> shapr: errm, I never bound in the IO monad, so all the Haskell can do is evaluate things.
09:21:14 <Heffalump> which isn't really much use
09:21:18 <ski> perhaps s/"Foo.hs" FooInterface/"Foo.hs" :: FooInterface/ or sumpthing.
09:21:40 * Heffalump would rather not add syntax to Haskell, that sounds like hard work
09:21:47 <shapr> Heffalump: it's more haskell+irc integration than I've seen before
09:22:38 <shapr> ski: sounds nifty
09:22:41 <Heffalump> it wasn't very hard, but I seem to have lost it.
09:22:53 <shapr> aw :(
09:22:59 <shapr> that would be a cool snippet
09:22:59 <Heffalump> oh, found it again.
09:23:07 <shapr> yay!
09:23:31 <Heffalump> it's only 100 lines of C and a Makefile
09:23:38 <Heffalump> (as a module for eggdrop)
09:23:44 <Heffalump> oh, and obviously the hugs sources
09:23:55 <shapr> cool :)
09:24:29 <shapr> sounds like something worth putting online
09:24:36 <Heffalump> yeah, I guess
09:24:52 <ski> it seems to me, that to be able to use (e.g. call) entities from a dynamically imported module, one either have to be able to get a hold of their identifiers, somehow (e.g. with something like abovementioned construct) or to get all entities from the module in a tuple, say, returned from a function. do you agree ?
09:25:09 <ski> that haskell+irc things sounds interesting
09:25:46 <Heffalump> ski: well, if the module had a previously defined interface, then the name of the interface functions would be defined too
09:26:09 <ski> Heffalump : yes, that's at least a start.
09:26:43 <ski> Heffalump : but the more general problem of an unknown module seems more difficult
09:26:46 <Heffalump> and if it didn't, then using dynamic imports wouldn't help, since you wouldn't know the types or the names
09:27:19 <Heffalump> ski: not hugely, the library doing the work could return a list of functions with their types
09:27:30 <Heffalump> s/function/function name/
09:27:41 <Heffalump> then if it had a means to call them, say dynCall
09:27:44 <Heffalump> you'd just do
09:27:50 <Heffalump> dynCall "function" [args]
09:28:02 <ski> so what are we after here ?  a sort of shell/read-eval-print-loop/toplevel that is able to do these things or do we wan't to do these things in any code in a program ?
09:28:12 <Heffalump> dynCall would be type String -> [DynamicValue] -> DynamicValue
09:28:30 <Heffalump> ideally the latter, though the former would be a good start :-)
09:28:31 <ski> ok
09:28:35 <shapr> yah, I agree
09:28:56 * Heffalump wonders just how sick an idea it would be to interface to hugs using the FFI
09:29:05 <shapr> uh?
09:29:12 <ski> um
09:29:21 <Heffalump> the FFI allows calling external libraries
09:29:26 <Heffalump> hugs is an external library
09:29:27 <Heffalump> so...
09:29:32 <ski> ok, yes, that was it.
09:29:43 <shapr> heh, cool :)
09:29:55 <ski> whose FFI ? hugs or irc or what ?
09:30:06 <Heffalump> ski: Haskell (i.e. hugs, ghc, ...)
09:30:28 <ski> Heffalump : to call hugs from hugs/ghc ? hehe
09:30:43 <shapr> you've been doing too much recursion ;)
09:30:47 <Heffalump> :-)
09:30:51 <Heffalump> I did say it would be sick.
09:31:03 <shapr> entertaining as well
09:31:17 <Heffalump> but actually if hugs was a dynamic library it wouldn't have too much overhead
09:31:30 <ski> though, i've sometimes used ! to escape to the shell and then restarted hugs from that shell .. :)
09:31:44 <ski> could well be
09:32:04 <ski> (not intentionally, i.e.)
09:32:51 <Heffalump> but you never tried to call into the second hugs from code running in the first hugs :-)
09:32:57 * ski going for drink,brb
09:33:17 * shapr goes afk for a bit
09:33:27 <Heffalump> actually, if you used System.system "runhugs ...", with read and show, you'd have an interface right away
09:33:31 <shapr> heh!
09:34:15 <Heffalump> but that's sick.
09:37:31 <ski> that's possible, though i didn't get any cursor in the recursively started hugs, nor any keyboard echo, IIRC.
10:01:18 * shapr returns
10:01:39 * ski returned some minutes ago
10:01:56 * tmoertel is off the phone
10:02:00 <shapr> hi tmoertel!
10:02:09 * shapr considers rebooting emacs
10:02:26 <ski> hi tmoertel, i don't know you, do i ?
10:02:34 <ski> shapr : why ?
10:02:42 <tmoertel> ski: I don't know, *do* you know me? ;-)
10:02:48 <shapr> because ionwm and and emacs are fighting
10:02:56 * shapr introduces tmoertel 
10:03:07 <tmoertel> Howdy, ski! Nice to meet you.
10:03:16 <shapr> this is Tom Moertel, whose recent credits include a popular article posted to kuro5shin.org
10:03:17 <ski> shapr : ionwm ? (window manager ?)
10:03:21 <shapr> ski: yup
10:03:40 <ski> Nice to meet you too, tmoertel !
10:03:58 <shapr> Tom Moertel is also seen on the haskell mailing lists, and has recently been recruited into the haskell-libs project
10:04:03 * shapr gives the podium to tmoertel 
10:04:27 <shapr> oh, and let me introduce ski as well
10:05:01 <shapr> ski has patiently answered all of my Haskell questions with detailed, thorough, and comprehensible answers
10:05:13 <tmoertel> excellent.
10:05:16 * tmoertel gets phone again!
10:05:20 <shapr> He's a resident of sweden, and has seen John Hughes giving lectures :)
10:05:37 <shapr> that's about all I know of ski..
10:05:58 <shapr> ski: how would you introduce yourself?
10:06:09 * tmoertel is off the phone now (was the wife)
10:06:15 <ski> well
10:07:45 <ski> i think i could be described as a person much interested in programming languages. how they work, their differences, similarities, used concept, etc.. . My most favourite prog.lang. i think is haskell :)
10:08:09 <tmoertel> And the language you like least? What would that me?
10:08:26 <tmoertel> s/me/be/
10:08:58 <ski> so i'm interested in computers, programming, hardware (though i don't know so much), and many diverse scientific (and not so scientific) things..
10:09:07 <ski> hmm
10:10:27 <ski> well, it's kinda hard to think of a language one likes the least (cuz they have different strength and weaknesses), hmm. maybe the idiotic BASIC on my pocket calculator :-(
10:10:51 <ski> it has no strings !! *sniff*
10:12:53 <tmoertel> ski, shapr: what your handle on K5?
10:13:40 <ski> tmoertel : well, i haven't been much on this kuro5hin.org, looking around for your article that shapr mentioned ..
10:14:30 <ski> tmoertel : you know what it's named ? (yes, of course you do ;)
10:14:54 <tmoertel> It's the first one at http://www.kuro5hin.org/user/tmoertel/stories
10:15:32 <ski> thanks, lemme se what you have written then..
10:16:38 <ski> Heffalump : are you gone ?
10:16:59 <Igloo> He is
10:17:08 <ski> Igloo : ok
10:21:59 <ski> ok, quite interesting article (though i don't know any XML or XSLT ..)
10:22:09 <ski> (only skimmed it)
10:22:24 <tmoertel> re-reading it now, it comes off as more of a rant than I had intended
10:24:21 <ski> oh, why ?
10:24:52 <tmoertel> I actually like XSLT, which makes its limitatations all the more annoying.
10:25:03 <tmoertel> When reading the article, my fondness for XSLT fails to come thru.
10:25:15 <ski> oh, ok.
10:25:59 <tmoertel> It's a good solution for 80% of 80% of the problems that it was designed to accommodate.
10:27:00 <ski> well, me don't know muchabout XML. so is XSLT a prog.lang (domain...) ?
10:27:01 <tmoertel> It should have been good for 80% of 100% of the problems.
10:27:33 <ski> ahm..
10:27:46 <tmoertel> XSLT is a transformation language that maps one type of XML document into another document, often also XML.
10:28:15 <ski> but XML is a markup-lang, no ? (or is it prog.lang too ?)
10:28:23 <tmoertel> It just so happens that XSLT templates are purely-functional programs (Turing complete).
10:28:29 <tmoertel> XML is indeed a markup language.
10:28:50 <ski> that's what i thought i remembered.
10:28:57 <tmoertel> XSLT is an XML "application," which effectively makes XSLT "programs" insanely verbose.
10:29:29 <tmoertel> Much of XSLT templates are XML boilerplate, and having XSLT be XML makes it conveneint to mix in boilerplate.
10:29:41 <tmoertel> But for the rest of the transformation process, this verbosity is haunting.
10:29:46 <ski> is it a way to treat a certain-style XML-doc. as a program (the transformer, i.e.) ?
10:30:02 <ski> ok
10:31:14 <tmoertel> Take a look at http://www.kuro5hin.org/comments/2002/1/13/223854/606/8#8
10:31:47 <ski> ok, will do promptly.
10:32:06 <tmoertel> That's what a simple Haskell foldl idiom looks like when expressed as XSLT.
10:33:58 <tmoertel> You can make out what's going on, but the S/N ratio is vanishingly small.
10:34:17 <ski> i've not yet come to grips with it ..
10:35:04 <ski> this choose/otherwise is a conditional, yes ?
10:35:30 <tmoertel> Yes. Effectively and if-then-else, in this use.
10:36:22 <ski> and call-template is sortof a call to a function in a variable, yes ?
10:36:53 <tmoertel> call-template calls a named template (= function).
10:37:49 <ski> target is succesivly, the list elements .. ?
10:38:01 <ski> and input the base .. ?
10:38:28 <tmoertel> Right. $subsitutions contains a list of target-replacement pairs that we iterate over via recursion and an index.
10:39:06 <ski> ok, now i get it.
10:39:51 <ski> but i don't think i could have easily written this even if i had a table of the apprpriate "functions" to use ..
10:40:06 <ski> very verbose :)
10:40:18 <tmoertel> It's not to bad once you learn to see through the blinding verbosity. ;-)
10:40:36 <tmoertel> But the lack of support for functional idioms is painful.
10:40:56 <ski> i can imagine ..
10:40:57 <tmoertel> Especially since it's a system that enforces purely functional evaluation.
10:41:40 <tmoertel> XSLT's predecessor was DSSSL, which was based upon a purely-functional variant of scheme.
10:42:15 <ski> ah,ok.
10:42:16 <tmoertel> The programming part of DSSSL transformations was *much* better. But it's domain-specific support for SGML/XML was weak.
10:42:40 <tmoertel> Many people thought that DSSSL required too much programming.
10:42:49 <tmoertel> My guess is that XSLT was an overreaction to this criticism.
10:43:07 <ski> possibly
10:43:16 <tmoertel> It provides a lot of built-in domain support but weak programming support.
10:43:26 <tmoertel> Maybe XSLT 2.0 will achieve a better balance.
10:43:36 <tmoertel> Until then, there's HaXML. ;-)
10:44:12 <ski> would it be a good idea to incorporate (more syntactically) some functional idioms into the language, for say mapping,folding and similar
10:44:40 <tmoertel> Yes, that's what I want.
10:45:34 <ski> so that people scared of programming, so to speak, could use some special syntactic forms specialized for the domain (say like for in C), to make them more comfortable ..
10:46:07 <ski> instead of scary words like higer-order function application
10:46:12 <tmoertel> It would also be nice if templates (=~ functions) were first-class types.
10:46:21 <ski> s/higer/higher/
10:48:03 <ski> if it's gonna be purely functional, then it should have either at least some common idioms built-in or the ability to create them yourself (or better, provided in a more or less standard library). but perhaps then it is ging to look more programming-like ..
10:49:22 <tmoertel> There's an EXSLT project that exists to correct many of XSLT 1.0's deficiencies using the library approach.
10:49:36 <ski> mmm
10:50:43 <ski> so, you've been at the haskell mailing-list alot ?  (i haven't read there so much ..)
10:51:16 <tmoertel> I haven't posted much. Mostly announcements re. GHC for Red Hat 6.2.
10:51:49 <ski> you're a developer/porter for GHC ?
10:52:25 <tmoertel> I just build the packages for Red Hat Linux 6.2.
10:52:28 <shapr> ahem, got distracted by a cute woman
10:52:34 <tmoertel> It happens. ;-)
10:52:41 <shapr> yes :)
10:52:46 * shapr reads the scrollback
10:52:48 <ski> :)
10:52:58 <ski> ok
10:54:43 * tmoertel must swap out a tape in the backup system . . . brb
10:58:56 * tmoertel is back, tape drive is happy.
11:03:08 * ski reading a little comp.lang.functional
11:04:54 <shapr> I'm not a member of kuro5hin
11:05:01 <shapr> I considered it, but it never happened
11:05:01 <ski> ok, simple question to clear the silence :). which do you prefer, type classes or parametrized modules ?
11:05:44 <tmoertel> As in Haskell vs. ML?
11:05:45 <ski> well, i haven't been involved with it much (yet ?) so i ain't either.
11:05:53 <ski> yes, basically.
11:06:30 <ski> (one comp.lang.functional thread is named type class VS struct/functor)
11:06:57 <ski> oh,ok.
11:08:04 <tmoertel> I think that parameterized modules would be a good addition to Haskell.
11:08:56 * tmoertel must depart to help wife unload car of groceries . . .
11:09:00 <shapr> have fun!
11:09:00 <ski> i'm missing it. and perhaps and experimential additional feature could be explicit laws (in type classes or at top-level)
11:09:13 <ski> same !
11:09:45 <shapr> how would parameterized modules affect Haskell?
11:10:07 <ski> so we could state the functor and numeric and monad laws explicitely (and statically check them !)
11:10:52 <ski> hmm, well i guess in a similar way as the ML's, though one could perhaps have interesting interactions with type classes ..
11:14:15 * shapr doesn't know ML
11:14:23 <ski> ah, ok. 
11:14:37 <shapr> I'm still an FP newbie
11:15:09 <ski> well, in ML one can specify a module interface ("signature") independently of a module
11:16:37 <ski> so one can have one signature PriorityQueue, say. and some different modules providing implementations of these modules. ArrPriQueue : PriorityQueue,ListPriQueue : PriorityQueue, and so on, ok ?
11:17:46 <ski> the signature is (more or less) a list of names+types of function and values as well as types, that a module has to provide to match (implement) the signature.
11:18:36 <ski> a simple signature (in SML) might be
11:18:49 <ski> signature EQ =
11:18:52 <ski>    sig
11:18:57 <ski>       type t
11:19:08 <ski>       val eq : t -> t -> bool
11:19:10 <ski>    end;
11:19:33 <ski> this can more or less correspond to the Eq class in haskell, say
11:19:51 <ski> u with me so far ?
11:20:37 <shapr> I think so
11:20:52 <shapr> it sounds a lot like an interface in Java
11:21:01 <shapr> ever more than type classes 
11:21:08 <ski> it's a lot like it, i think.
11:21:33 <ski> now if we also have defined a SET signature say :
11:21:38 <ski> signature SET =
11:21:40 <ski>    sig
11:21:44 <ski>       type elt
11:21:49 <ski>       type set
11:21:58 <ski>       val empty : set
11:22:10 <ski>       val add : elt -> set -> set
11:22:19 <ski>       val mem : elt -> set -> bool
11:22:21 <ski>    end;
11:23:01 <ski> now we can define a "functor" (parametriced module) taking a module of signature EQ as argument :
11:23:33 <ski> functor Set (Eq : EQ) : SET  with type elt = Eq.t  =
11:23:38 <ski>    struct
11:23:45 <ski>       type elt = Eq.t
11:23:52 <ski>       type set = elt list
11:24:02 <ski>       val empty = []
11:24:16 <ski>       fun add elt set = elt :: set
11:24:45 <shapr> what's an elt?
11:24:54 <ski>       fun mem elt [] = false
11:25:19 <ski>       |   mem elt (x::xs) = if Eq.eq x elt then true else mem elt xs
11:25:22 <ski>    end;
11:25:31 <ski> elt is short for element
11:25:46 <shapr> oh
11:26:17 <ski> so this is an implementation of a SET provided an implementation of an EQ is given as an argument.
11:26:36 <ski> thats an example of parametriced module, ok ?
11:26:44 <shapr> that's wild
11:27:18 * shapr continues thinking about that
11:27:26 <ski> a whole module can take another module as an argument (with types and everything) !!  one can make many nice things with this
11:28:15 <shapr> it sounds like it'd be really useful for the strategy pattern
11:28:21 <ski> also, the good module system in ML's makes one think more about splitting a project into appropriate modules, instead of lumping all functions and types in a single file/module :(
11:28:26 <shapr> and command pattern too
11:28:27 <shapr> hmm
11:28:39 <ski> strategy pattern ? command pattern ?
11:28:51 <shapr> from the DesignPatterns book
11:29:26 <ski> (BTW, this example was stolen from the usenet thread (and converted from O'Caml), cuz i know SML better)
11:29:47 <shapr> heh, ok :)
11:30:23 <ski> i've not read that book, though iv'e heard of similar "pattern" (not knowing exactly what is meant)
11:30:47 <ski> maybe you could try to explain.
11:34:14 * shapr thinks
11:34:20 <shapr> ok, well
11:34:23 <shapr> the visitor pattern for example
11:34:26 <ski> no need to hurry
11:34:43 <shapr> the way it works is that it walks a tree structure
11:34:46 <ski> ok, what is meant by a visitor pattern
11:34:55 <ski> ok, go on
11:35:00 <shapr> it's a guy that operates on stuff in a tree
11:35:08 <shapr> er, guy should probably be object :)
11:35:19 <ski> (or, function ?)
11:35:24 <shapr> ERC>sure
11:35:25 <shapr> oops
11:35:54 <shapr> a visitor walks a tree of objects, and calls the 'visit' method on those object, and passes itself as an argument
11:36:47 <shapr> each of those objects calls a method on the visitor, but they call "visit" + mytype
11:37:03 <shapr> so if I'm a Foo, I'd call "visitFoo" on the visitor that was passed to me
11:37:43 <shapr> so....
11:38:01 <ski> so is it, sort of, a certain idiom for getting certain things done ?
11:38:03 <shapr> a visitor encapsulates an algorithm that can be quickly swapped out for another algorithm
11:38:05 <shapr> right
11:38:28 <ski> ok
11:38:38 <shapr> if your algorithms change often, and your node types change rarely, a visitor is a very useful structure
11:38:57 <ski> though, i'm not sure why the visitor calls the Foo and then the Foo calls the visitor again ?
11:39:16 <shapr> er, there's a really good reason, but I forget what it is
11:39:38 <shapr> I think it's so you can write different logic to deal with different types of nodes
11:40:11 <ski> so it is sort of like what is encapsulated in map or foldr or foldl, right ?
11:40:20 <shapr> right
11:40:27 <ski> ok
11:40:41 <shapr> but it's more like a foldl that either does stuff, or recursively calls foldl
11:40:56 <ski> these strategy and command patterns, are they similar ?
11:41:02 <ski> ok
11:41:32 <shapr> command pattern is where you have a 'command' superclass and the subclasses each encapsulate a command
11:41:50 <ski> hmm
11:42:15 <shapr> commands as objects give you nice abilities such as emacs style hooks, ability to optimize before execution
11:42:17 <shapr> that kind of stuff
11:42:39 <shapr> strategy is where you have something, for example a sort object
11:42:48 <shapr> and there are lots of ways to sort stuff
11:42:58 <ski> okay
11:43:18 <shapr> so you have a strategy object that encapsulates a certain strategy instance, and you can swap strategies on your Sort class
11:43:52 <shapr> DesignPatterns should really be called "programming idioms" or something
11:43:54 <ski> ok, sortof like Sorter.changeStrategy(fooStrategy)
11:44:00 <shapr> right
11:44:12 <shapr> Sorter.setStrategy(BubbleSort)
11:44:20 <shapr> Sorter.setStrategy(QuickSort)
11:44:26 <shapr> Sorter.setStrategy(BinarySort)
11:44:45 <shapr> there a buncha these patterns
11:45:36 * shapr grabs the book off the shelf behind him
11:46:13 <shapr> abstract factory, factory method, builder, prototype, singleton
11:46:23 <ski> so, what's the point of setting the strategy of the Sorter object. is it such that because this Sorter object probably is shared and referenced in lots of places in the program, and one wan't to transparently and quickly change all these occurances to use the new strategy (instead of having to construct new sorter objects and distrivute them some other way)
11:46:27 <shapr> adapter, bridge, composite, decorator, facade, 
11:46:59 <ski> s/distrivute/distribute/
11:47:39 <shapr> "strategy, define a family of algorithms, encapsulate each one, and make them interchangable. Strategy lets the algorithm vary independently from clients that use it
11:47:41 <shapr> "
11:47:49 <shapr> that's the two line summary
11:48:24 <ski> ah,ok. could be quite nifty for software engineering stuff, i presume.
11:48:32 <shapr> yah, it is
11:48:52 <shapr> it's interesting to notice how few of these have any place in haskell
11:49:43 <ski> hmm, well how do you mean ?
11:50:31 <shapr> the needs and pressures are different
11:50:50 <ski> like, haskell isn't so much focussed with different software engineering stuff, but rather nifty ways to define special and general functions ?
11:50:55 <shapr> a function is the main abstraction in Haskell
11:51:01 <shapr> right
11:51:02 <ski> well, yes.
11:51:13 <shapr> you make a general function, you make specific flavors of it
11:51:27 <ski> ok, with you.
11:51:44 <shapr> what else is there?
11:52:24 <ski> abstractions, you mean ?
11:52:49 <ski> or nice facilities that help to structure and manage large pieces of code.
11:58:19 <ski> i guess that languages that have large mainstream use have evolved many things that isn't directly coding (i.e. getting things to work/done) but more managing and structuring facilities)
11:59:07 <shapr> currently the most popular is objects
11:59:13 <shapr> FPLs use functions
11:59:19 <shapr> and now, some of them use modules
11:59:26 <ski> yes.
12:00:09 <ski> some larger quantity than subroutine/procedure/function is needed, at least, i think.
12:00:31 <ski> then be it objects or modules or both or perhaps something more exotic.
12:01:33 <ski> (generally speaking, not specifically for haskell (though IMHO the modules system needs improvement))
12:06:19 <shapr> what could be more exotic?
12:06:29 <shapr> first class modules is an interesting idea
12:07:39 <ski> well, i don't know exactly. but i suppose some other could be invented. maybe this is what aspect (or related Adaptive) is soewhat about.
12:07:45 <ski> yes.
12:08:33 <shapr> aspect oriented programming seems to be all about systematically pre/post/wrap hooking functions
12:08:48 <shapr> adaptive I'm not sure about
12:09:16 <shapr> urf, I'm getting tired, I think I'll go play tribes2 for awhile...
12:09:25 <shapr> thanks for the information ski :)
12:09:31 <ski> ok
12:09:37 <shapr> I'll think on modules and parameterization
12:09:41 <shapr> it's a fascinating subject
12:09:42 <ski> staying here for the time being
12:09:53 <shapr> I may be back soon, OpenGL in linux is being unhappy lately
12:09:55 * shapr waves
12:10:04 * ski waves back
14:43:38 <ski> bye
15:24:39 <Yurik> gene9 hi
15:25:06 <gene9> hi Yurik
15:26:18 * Yurik -> smoke
15:56:34 <water> yo
