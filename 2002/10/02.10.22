03:49:38 <Marvin--> Errrrrrr
03:50:14 <Marvin--> When I run hws from the src dir (./hws -d..) it loops and takes all the CPU, when I run it from the top dir, (./src/hws -d.) it doesn't
05:38:19 <systems> what is the most complete/popular haskell implementation 
05:39:24 <ayrnieu> GHC and Hugs are complete/popular; nhc seems to have some interesting features.
05:40:30 <ayrnieu> GHC has GHCi, an interactive Haskell read-eval-print-loop similar to what Hugs has except that it also allows bindings to be made.
05:41:04 <ayrnieu> (and it has much more of a startup-delay)  Hugs can't compile to native code.
05:41:05 <systems> thanx :)
05:42:09 <ayrnieu> You're welcome.  www.haskell.org has a page on Haskell implementations.
05:57:11 <shapr> goood morning #haskell!
05:57:22 <shapr> how is everyone today?
05:58:35 <Igloo> Struggling on  :-)
05:59:34 <shapr> hi Igloo, it's freezing here, lots of snow on the ground...
05:59:55 <shapr> just like an Igloo :-)
06:00:41 <Igloo> :-)
06:00:53 <shapr> is there some way I can make a handle that wraps some codec code?
06:00:54 <BlizzNL> shapr: trying to grasp monads
06:01:06 <shapr> BlizzNL: is it working? what do you understand so far?
06:02:30 <shapr> I'd like to write lists, etc to a socket, and have them invisibly encoded and decoded for the other end of the socket
06:03:09 <o3> evening
06:03:16 <shapr> hey o3
06:03:41 <shapr> I wonder if Handle is a typeclass
06:03:42 * shapr looks
06:03:56 <BlizzNL> shapr: yeah it just a matter of reading the right articles
06:13:18 <o3> is it possible to talk to C++ libraries with the FFI?
06:15:27 <shapr> hi tez
06:15:34 * shapr bounces
06:16:10 <tez> Hello
06:16:14 <shapr> what's up?
06:46:46 <tez> Not much
06:52:54 <Heffalump> o3: well, in as much as you can write C wrapper functions for them
06:54:55 <o3> Heffalump: yeah, i figured as such ... was thinking of making a haskell binding for wxwindows, but i doesn't have C bindings.  ouch
06:55:39 <Heffalump> well, the FFI does support cplusplus calling convention directly
06:55:56 <Heffalump> i.e. the FFI report defines it
06:56:02 <Heffalump> I dunno if implementations have to support it, though
06:56:29 <Heffalump> no, they don't
06:59:08 <o3> thought as much :)
07:56:18 <bas> so there IS a haskell channel... anyone have experience with generic-haskell?
07:56:39 <cleverdra> How is 'generic-haskell' different from 'haskell'?
07:57:49 <bas> you can do 'generic programming' in it... for example you can make a generic function 'zip' which will work on all types of datastructures, trees, list, etc...
07:58:16 <bas> you only have to declare the function once...
07:58:36 <bas> generic-haskell.org has some info on it...
07:58:36 <shapr> hi bas
07:58:44 <bas> hi shapr...
07:58:52 <shapr> I think BlizzNL is learning about generic-haskell
07:59:41 <bas> i can see that his nick has a NL in it, so he's probably in holland somewhere, that's also the place where most generic-haskell research takes place...
07:59:46 <BlizzNL> shapr: yep
08:00:02 <shapr> gr == groningen?
08:00:11 <bas> yep...
08:00:16 <shapr> cool
08:00:21 <bas> u?
08:00:31 <shapr> north finland :-)
08:00:42 <shapr> moving to sweden though
08:00:47 <shapr> originally from Alabama
08:00:48 * BlizzNL is from UoUtrecht
08:00:58 <shapr> I'm a professional programmer with no formal education.
08:01:21 <shapr> just a massive desire to learn
08:01:32 <bas> that's good...
08:02:03 <shapr> how long have you been using Haskell?
08:02:26 <bas> for 2 and a half years now...
08:02:33 <shapr> nice
08:02:41 <shapr> what do you do with it?
08:03:01 <bas> BlizzNL: i went to a colloquium of johan jeuring yesterday, who was here in groningen...
08:03:39 <BlizzNL> bas: johan jeuring is great.
08:04:21 <bas> shapr: do a lot of rapid prototyping for formal problems i need to solve in haskell...
08:04:35 <shapr> what kind of formal problems?
08:04:41 * shapr is just a programmer
08:04:50 <bas> BlizzNL: what's your relationship with jeuring?
08:05:07 <BlizzNL> bas: He teached me about generic programming ! ;)
08:06:02 <bas> shapr: i like using haskell for knapsack problems, that kinda things go really easy in it...
08:06:10 <bas> BlizzNL: still a student?
08:07:19 <bas> shapr: do you use haskell regularly in your professional neighboorhood?
08:07:22 <BlizzNL> bas: yes he is associated to the Software Technology Group in Utrecht and I am a Software Technology MSc student.
08:08:09 <shapr> bas: I do use Haskell regularly, but I haven't yet been paid for it.
08:08:26 <shapr> I do web stuff mostly, so I'm trying to get integration with Zope, xmlrpc, etc
08:09:29 <bas> BlizzNL: okay... what kind of MSc's are available in utrecht? software Tech sounds like a engineering MSc, or am i wrong?
08:10:31 <bas> shapr: learning zope myself at this moment, already know a lot of python, how easy is the content management with zope?
08:10:56 <shapr> once you know zope, you can do very much stuff with very little effort
08:11:06 <BlizzNL> bas: well check out http://www.cs.uu.nl/groups/ST/ for more info, but it kinda abstract looking into problems of software construction
08:11:14 <shapr> zope is a bit exciting to learn though :-)
08:11:46 <bas> shapr: i already have it running, it looks great that's for sure...
08:19:45 * BlizzNL has to go. Bye
08:19:56 <shapr> yah, zope is spiffy
08:20:02 <shapr> I can help you with it if you have any questions.
08:24:03 <Marvin--> 'afternoon
08:24:12 <shapr> hi marvin!
08:24:13 <shapr> hi hal!
08:24:23 <shapr> hey, I have a socket handle question.
08:24:29 * Marvin-- grins at "Even John Hughes didn't notice the bug."
08:24:40 <shapr> hal: yah, that's high praise :-)
08:24:51 <Heffalump> :-)
08:25:20 <hdaume> haha :)
08:25:35 <Marvin--> I find 'deriving Num' to be a bit obscure
08:25:44 <shapr> so I want to write a Haskell list to a socket handle, and have it encoded before actually being written
08:25:52 <Marvin--> But I suppose all the "deriving" stuff is specified
08:25:58 <shapr> I thought of using a typeclass, but that's kind of cheesy feeling
08:26:12 <shapr> could I put the implicit encoding/decoding into a monadic call?
08:26:16 <hdaume> Marvin--: and here I am wanting something like "deriving (MArray IOUArray _ IO)" :)
08:26:20 <Marvin--> shapr: ? Why? I'd definitely have some sort of 'Serializable' class
08:26:35 <Marvin--> hdaume: !!! Go stand in the corner, now!
08:26:36 <Marvin--> ;)
08:27:11 <shapr> marvin: trying to write Jelly.hs
08:27:36 <shapr> jelly serializes a list by putting ['list'] ++ list_to_serialize
08:27:37 <Marvin--> shapr: nod, isn't that about serialization?
08:27:53 <shapr> since I can't unify the type of any random list with list_type | [Char]
08:27:59 <shapr> seemed better to implicitly encode it
08:28:18 <Marvin--> shapr: uh, but you can't send a list over a socket in python...
08:29:21 <bas> i think i am missing something, how are haskell and python connected?
08:30:07 <Marvin--> bas: through jelly ;)
08:30:09 <shapr> bas: they're not, so far
08:30:28 <shapr> marvin: banana serializes lists
08:30:32 <Marvin--> shapr: oh
08:30:40 <bas> shapr: so it was just some python talk...?
08:30:45 <shapr> no, not really
08:30:52 <Marvin--> shapr: I don't know the whole architecture
08:30:54 <shapr> I'm writing Haskell code to talk to a Python server framework
08:31:13 <bas> sounds like fun
08:31:21 * Marvin-- ponders how to merge twisted and hws-wp
08:31:28 <shapr> marvin: banana does bit level codec, jelly does symbolic stuff and deals with references, instances, etc
08:31:34 <Marvin--> shapr: ah
08:31:54 <shapr> pb actually hangs on a socket and makes/handles requests
08:32:20 <Marvin--> For those of you who are familiar with Data.Dynamic, is it horribly ugly to put a version number in the mkTyCon string?
08:33:02 <Marvin--> So that different "versions" with the same type name can't be erroneously casted wrong...
08:43:34 <Marvin--> meh
08:45:05 <shapr> yah, what he said.
08:58:52 * shapr bounces
08:59:16 <shapr> marvin: you really think Serializable is a better solution?
09:00:29 <Marvin--> shapr: Since I'm not sure what you're trying to do, I'm not sure :/
09:01:35 <shapr> I'm trying to take a list of [1] and have it serialized as ['list',1]
09:01:45 <shapr> well, that's the jelly part of it
09:03:08 <hdaume> hehe, i think there's a reason why getArgs and getProgName are IO actions...in ghci you can change them :)
09:03:59 <Marvin--> shapr: I wouldn't call that serialization...
09:04:39 <shapr> well, it's part of turning instances into network passable references
09:04:46 <Marvin--> shapr: Where is the final data->string translation?
09:05:12 <shapr> in banana
09:05:33 <shapr> thing is, lists have to be homogenous in Haskell
09:05:47 <shapr> is there some way to unify the type of any list with that of [Char] ?
09:05:57 <Marvin--> So, there's no interaction between hsjelly and anything except hsbanana (below) or haskell program (above)?
09:07:26 <shapr> the haskell program should only speak to PB
09:07:36 <shapr> PB has transparent references to remote objects
09:08:20 <Marvin--> what I mean is, will only haskell programs touch hsjelly?
09:08:24 * shapr tries to think of a better description
09:08:50 <Marvin--> if so, why do you want to turn [1] into (the very pythonic) ['list',1]?
09:09:02 <shapr> because that's what I need to send to the python side
09:09:33 <Marvin--> no, you need to send the serialization that in *python* corresponds to ['list',1]
09:09:46 <shapr> right
09:09:48 <shapr> hm
09:09:54 <shapr> hmmm
09:10:03 <Marvin--> (but I don't know what that is, so...)
09:10:04 <shapr> so I should really stick Jelly and Banana together
09:10:21 <shapr> into one module that understands the python specific encodings
09:10:43 <Marvin--> Jelly is aware of instances and stuff, while Banana is just aware of "primitive" types?
09:10:47 <shapr> right
09:11:13 <Marvin--> then I think it'll be *very* hard to decouple jelly and banana in haskell
09:11:20 <Marvin--> partly because of homogenous lists
09:11:49 <Marvin--> granted, banana will be a subset of 'banana jelly'
09:12:16 <Marvin--> how's it done in java?
09:12:28 <Marvin--> Object[] and new String("list")?
09:12:44 <Marvin--> hmm, that was silly, "list" is an object too
09:13:22 <Marvin--> in any case, feels sensible to discuss this on #twisted :)
09:20:35 * Marvin-- ponders whether to incorporate MimeTypes.hs in the core plugin or make a separate mime plugin like in apache
11:38:38 * ludde had an exam today
11:39:05 * shapr bounces
11:39:09 <shapr> hi ludde, how was your exam?
11:39:37 <ludde> I didn't quite know what the main similarities & differences between haskell and prolog were, but apart from that, it was pretty easy
11:40:13 <ludde> it was in the course programming languages
12:07:32 <dark> ludde: That sounds like a strange question anyway.
12:43:37 <ludde> dark: I read that you were making a chunk library, i think? look at http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/Lab2/Chunk.hs
12:43:55 <dark> ludde: Yeah, I'll check it out.  Thanks.
12:46:49 <dark> ludde: Hmm, pretty similar to what I already have, except that I _want_ blocking output (they do tricks to make it nonblocking).  What I'm stuck on is making a lazy hGetChunks.
12:47:20 <dark> There's a straightforward way to do it (duplicating most of hGetContents), but it would involve too many crimes against nature :)
12:47:52 <ludde> hmm, ok
12:48:15 <Marvin--> dark: lazy strictness *is* a crime against nature ;)
12:49:04 <dark> Marvin: Lazy strictness?
12:49:10 <ludde> is it considered bad to modify the show:ed version of a datatype to make some type tricks?
12:49:32 <ludde> make=do
12:49:36 <Marvin--> dark: reading lazily from a handle
12:49:58 <dark> That reminds me, is it bad to use "show" as a general tostring function?  Is there some kind of Stringable class?
12:50:21 <dark> Marvin: But it's oh so convenient :)  It means I can do decompression while waiting for the network.
12:51:11 <dark> Hmm, I _could_ do it strictly, by passing a process_chunk function as a parameter.
12:51:52 <dark> Maybe I'll settle for a strict get-chunks function.  But that reduces its value as a library module, I think.  That leads to the question, do I _want_ anyone using my code as a library?
13:22:55 <ludde> is there some way to rewrite "\a -> a . read" into shorter syntax? can I use (.read) ?
13:24:51 <nde> I just played with ghci and it looks like you can.
13:25:41 <Heffalump> yes, since . is an operator and therefore can be sectioned
13:25:53 <Heffalump> the definition of (.read) is \a ->a.read
13:26:20 <dark> But notice how much clearer (. read) is :)
13:29:04 <Heffalump> well, can be
13:29:22 <Heffalump> I sometimes get a bit confused by right sections and end up mentally turning them into the lambda abstraction in my head
13:30:38 <ludde> my code is like this:
13:30:39 <ludde> fmap :: String -> String -> HtmlCode ()
13:30:39 <ludde> fmap "submit" = sethandler submit
13:30:39 <ludde> fmap _        = \_ -> mainpage
13:30:43 <ludde> where: submit :: String -> HtmlCode ()
13:30:50 <ludde> and
13:30:50 <ludde> sethandler :: (Read a, Show a) => (a -> HtmlCode ()) -> String -> HtmlCode ()
13:30:51 <ludde> sethandler = (. read)
13:31:19 <ludde> fmap's first string is a script name, the second string contains the encoded parameters
13:32:18 <ludde> i don't really like fmap though, i would like to have a list, or a sequence of combinator applications.. would that be possible?
13:32:45 <Heffalump> fmap already exists, btw
13:32:59 <ludde> oh, whatever, it's just a name :)
13:33:01 <Heffalump> (in the Functor class, not with the same type signature or effect as yours)
13:33:21 <Heffalump> hmm.
13:33:28 <toadx> ludde: which html library are you using (just curious)
13:33:29 <ludde> do you understand my question?
13:33:32 <Heffalump> sort of
13:33:35 <ludde> toadx: I made my own
13:33:45 <ludde> toadx: It's a bit similar to WASH/CGI
13:34:03 <ludde> the submit script looks like:
13:34:03 <ludde> submit name = page "hi" [] $ do
13:34:03 <ludde>   text $ "Hi " ++ name
13:34:42 <ludde> so in order to use that, i would call: fmap "submit" (show "ludde")
13:34:52 <ludde> and then fmap would return the HtmlCode() that constructs that page
13:35:02 <toadx> ludde: is it supposed to be better that WASH/CGI, or is it just a learning exercise
13:35:05 <ludde> a page that says "Hi Ludde"
13:35:45 <ludde> toadx: it's a school project, but i want to fix the bad thing in wash/cgi, which is that it has a history log of all previous IO and responses.
13:36:56 <toadx> ludde: sounds interesting, I am playing around with wash/cgi for some projects now, so I will definately look at what you have done if you finish it
13:37:08 <ludde> hehe, ok :)
13:39:29 <ludde> hmm
13:39:34 <ludde> i think i solved my problem
13:39:43 <ludde> handler "submit" submit <|> defaulthandler mainpage
13:40:25 <ludde> handler :: (Read a, Show a) => String -> (a -> HtmlCode()) -> (String -> String -> HtmlCode ())
13:40:40 <ludde> defaulthandler :: (Read a, Show a) => (a -> HtmlCode()) -> (String -> String -> HtmlCode ())
13:40:58 <Heffalump> cool.
13:44:42 <ludde> is it possible to define a custom show method for a data type?
13:44:49 <ludde> err, s/method/function/
13:47:35 <dark> If only Handle were a typeclass.
13:48:11 <dark> I want to use gzopen and friends :)
13:48:36 <Marvin--> oh dear god :)
13:48:55 <nde> ludde: instance Show Foo where show x = ...
13:49:15 <ludde> nde: okay
13:49:18 <ludde> Marvin--: what is it?
13:49:21 <ludde> nde: thanks
13:49:54 <Marvin--> ludde: oh nothing, just the lunatic by name of dark ;)
13:50:15 <ludde> oh
13:50:34 <Marvin--> Richard Gere really needs to practice his Irish accent
13:53:21 <dark> Marvin: well I got discouraged by the interface for the inflate and deflate functions :)  They communicate by passing this huge struct around, of which the caller is supposed to inspect and modify specific members.  Apparently function arguments are out of style.
13:53:37 <Marvin--> dark: ugh
14:06:34 <dark> Hmm.  I could avoid this pain with a different pain: instead of reading from the socket, fork gzip and hook it up directly to the socket.
14:06:50 <dark> That will make checking for transfer errors harder :)
14:08:32 <dark> Hmm, no, that would tie me forever to FTP's one-stream-per-file mode.
14:15:49 <dark> Bah, I hate it when I come up with a better design that doesn't need the stuff I've already written.
14:16:57 <shapr> I think that's kinda cool
14:17:17 <shapr> plus, my better designs almost always require that I wrote the code, and realized halfway through what was wrong with it.
14:17:31 * shapr thinks about encoding monads
14:17:48 * shapr wanders off to shoot people
14:33:35 <dark> Hmm is there a library function for creating a temporary file?
14:34:26 <Heffalump> man 3 mktemp
14:34:49 <Heffalump> which tells you to use man 3 mkstemp
14:36:55 <Marvin--> which tells you to use man 3 tmpfile
14:37:58 <dark> Yeah, there doesn't seem to be a sane function among them.
14:38:28 <dark> tmpfile is bad because it doesn't honour TMPDIR.
14:39:57 <dark> Also: "An error message may be written to stdout if the stream cannot be opened".  Bastards.
14:40:00 <Marvin--> mkstemp is bad because there's weirdness with permissons
14:40:08 <Marvin--> dark: gee, how nice
14:40:57 <Marvin--> and mktemp plain sucks :)
14:42:06 <dark> mkstemp may be the best of the bunch.
14:43:00 <hdaume> untilM (return . isJust) (catch (do r <- randomR; h <- openFile (tmpdir ++ show r) WriteMode; return (Just h)) (\_ -> return Nothing))
14:43:02 <dark> I'll probably be better off writing my own function for it.
14:43:09 <Marvin--> can you create a Handle given an fd?
14:43:16 <hdaume> <--- my standard temp file solution :)
14:43:46 <dark> Cool, I didn't know there was an untilM :)
14:43:57 <Marvin--> me neither, hmm :)
14:44:00 <hdaume> dark: i'm not sure that there is ;)
14:44:10 <hdaume> dark: i think i just have it in my set of utility functions ;)
14:44:19 <Marvin--> doh ;)
14:44:36 <Marvin--> sounds useful though
14:51:24 <dark> I'm more and more tempted to ignore System.IO and create some sort of Stream typeclass instead.
14:52:12 <Marvin--> class FILE f where ;)
14:52:36 <Marvin--> make it a decorator like java's I/O ;)
14:52:40 <dark> Well the point of a typeclass would be that various things could act as files :)  For example, Strings.
14:53:44 <dark> Hmm, is it possible to make an instance for String?
14:53:58 <dark> If not, it could be faked with a newtype, I guess.
14:54:57 <dark> Of course, writing to a String stream wouldn't be very haskellish.
14:55:33 <Marvin--> how would you write to it anyway?
14:55:57 <hdaume> i don't think you could use strings...you'd have to use packedstrings, or some such
14:56:16 <Marvin--> put :: Stream s => s -> String -> IO () feels like an interface you'd want to support, right?
14:57:13 <Marvin--> "The instance type must be of form (T a b c) where T is not a synonym ..."
14:57:48 <dark> Yeah, and [Char] has too many explicit types.
14:58:28 <dark> I think it's so that the compiler knows how to deal with [a].  It would be awkward if there were different instances for [Char] and [Int], if all you know is [a] :-)
15:00:48 <dark> But as for interfaces, I'd probably make three classes: ReadStream, WriteStream, and Stream, where types can choose which to implement.  (Stream itself would be for meta-information)
15:01:10 <Marvin--> eh, ghc5-doc is broken
15:01:16 <Marvin--> or at least has broken links
15:01:18 <dark> Yeah, I noticed.
15:01:35 <dark> It also has much less documentation than the pre-haddock version.
15:02:01 <dark> Didn't file a bug because reportbug was broken :)
15:02:25 <dark> I got into the habit of poking around the library code anyway.
15:07:37 <Marvin--> heh
15:07:43 * Marvin-- files a bug
15:08:33 <Marvin--> d'oh
15:08:37 <Marvin--> there already was a bug for it
15:08:58 <Marvin--> but it was called "Docs missing" so I didn't spot it before hitting send
15:09:38 <Marvin--> but it's 92 days old, sheesh
15:10:07 <Heffalump> you should see the age of some Debian bugs...
15:16:10 <Marvin--> oh I know, believe me
15:17:52 <dark> hdaume: Using openFile for temp files isn't secure, it doesn't use O_EXCL
15:17:57 <dark> I'll have to go through Posix.
15:18:03 <hdaume> durn
15:20:24 <Marvin--> eek, the implementation of the stat stuff in Posix ain't pretty
15:20:47 <Marvin--> fileSize stat = unsafePerformIO $ _casm_ ``%r = ((struct stat *)%0)->st_size;'' stat
15:21:12 <Marvin--> can't become much more low-level than that :)
15:22:02 <Marvin--> bleh
15:22:10 * Marvin-- adds some {} to make the code more readable
15:24:56 <dark> My open_temphandle function is now a 12-line monstrosity, but it w0rx0rs :-)
15:25:12 <dark> Sorry, w0rx0rzz.
15:26:51 <Marvin--> l33t
15:39:07 <dark> Hmm, getting from a Posix Fd to a Handle is not easy :)
15:44:34 <Marvin--> what's wrong with fdToHandle?
15:46:32 <Marvin--> http://193.11.232.159:21398/Core.hs <- phew, today's work
15:48:58 <Marvin--> time to sleep
15:49:46 * Blizz_nl is looking into RH linux for the first time since 1998. A damn lot of eyecandy in the install procedure!
15:49:57 <Marvin--> yeah, but does it do .deb? ;)
15:50:14 <Heffalump> that's what alien is for :-)
15:50:38 <Marvin--> I thought it was for rpm->deb ;)
15:51:16 <Blizz_nl> Marvin--: debian package manager is a world of its own. RPM will spit it out ;)
15:51:18 <dark> Marvin: I didn't see fdToHandle, it was in PosixIO and I was looking at PosixFiles :)
15:52:29 <Marvin--> dark: oh, then I see why it would be tricky ;)
15:52:35 <dark> Hmm, this open_tempfile implementation will go into an infinite loop if all 1000000 possible filenames already exist.
15:52:44 <Marvin--> dark: grep Handle hslibs/posix/*.* :)
15:55:32 <dark> Yay, it compiles :)
15:55:59 <dark> Tomorrow's task will be to write a generic pipeline function, so that I don't have to go through the shell.
15:56:52 <Marvin--> heh
15:56:53 <Marvin--> g'night
15:57:26 <dark> I won't be needing Chunks or libz after all :)  I realized that instead of shoveling data around very quickly, I could just leave it where it was.
16:03:32 <hdaume> question: when i use ghc-pkg to install a library, it ellicits an error from ld: "illegal option -- x"  how can I fix this?
16:04:59 <Heffalump> why is ghc-pkg calling ld?
16:05:14 <hdaume> i have --auto-ghci-libs
16:05:25 <hdaume> (this is for the haskell foundation libraries, aka the new edison)
16:05:37 <Heffalump> ah
16:06:04 * hdaume doesn't know anything about ghc-pkg
16:08:38 <hdaume> alternatively, how can i just make the .o from the .a?
16:09:11 <Heffalump> I thought ghc-pkg just adds the appropriate entries to packages.conf
16:09:29 <hdaume> that's what i thought, but apparently it's calling ld ;)
16:09:34 <Heffalump> heh
16:09:53 <hdaume> i'm executiong "ghc-pkg --auto-ghci-libs -u < hfl.pkg"
16:10:00 <hdaume> where hfl.pkg is very vanilla
16:10:21 <hdaume> it says "building GHCi library '/nfs/isd/hdaume/projects/hfl/lib/HShfl.o'..."
16:10:43 <hdaume> then there are three reports of illegal options from /usr/ccs/bin/ld : "x", "-" and "w"
16:10:51 <hdaume> then I get the ld usage screen dump :)
16:11:09 <hdaume> then ghc-pkg continues on it's way and updates the config
16:11:26 <hdaume> hfl is listed in the installed packages, but when i try to use it, ghc complains it can't find HShfl.o (because it's not there)
16:12:31 <Heffalump> what OS?
16:12:36 <hdaume> solaris
16:12:45 <Heffalump> does it have the GNU tools installed?
16:12:56 <hdaume> ld -V gives "ld: Software Generation Utilities - Solaris Link Editors: 5.8-1.275"
16:13:03 <hdaume> probably somewhere... ;)
16:13:14 * Heffalump suggests you find that and point it at the GNU ld
16:13:26 <hdaume> okay :)
16:15:08 <hdaume> grrr....so frustrating :)
17:16:37 <shapr> is there a Haskell implementation of stratified monad transformers a la Espinoza?
17:16:52 <Pseudonym> Er... can you explain what they are?
17:17:36 <shapr> supposedly they're spiffier than the standard monad transformers, because they operate on the entire category rather than a single monad
17:18:03 <Heffalump> huh?
17:18:12 <shapr> one claim is that they allow monad transformers to interact with each other
17:18:34 <Heffalump> is this the paper from PLI this year?
17:18:48 <Heffalump> (URL?)
17:18:50 <shapr> nah, this is from '96 or so
17:18:54 <Pseudonym> http://citeseer.nj.nec.com/espinosa94building.html
17:19:21 <shapr> oh, espinosa, I misspelled it
17:19:40 <shapr> he implements stratified monad transformers in Scheme
17:19:50 <shapr> not that I dislike scheme, I just want to do stuff in Haskell
17:20:44 <shapr> I'm trying to understand monad transformers
17:21:05 <shapr> since I've just in the last coupla hours realized how much I want to use them.
17:21:40 * Heffalump suggests you use "standard" monad transformers for a while before trying to get involved with anything more complicated
17:21:57 <Pseudonym> Yes.
17:22:09 <Pseudonym> Start importing stuff in Control.Monad first.
17:22:15 <Heffalump> it took me a while to get my head round them when I started using them
17:22:37 <Heffalump> writing the bind operation really was a matter of trying lots of things until I got the right type signature
17:22:51 <Pseudonym> Have you read the modular interpreters paper?
17:22:55 <shapr> nope, not yet
17:23:07 <Pseudonym> That's a really good start.
17:23:09 <shapr> is that the LPS system paper?
17:23:13 <shapr> language proto system?
17:23:32 <Pseudonym> it's called "Monad Transformers and Modular Interpreters".  Mark Jones is one of the co-authors.
17:23:41 <shapr> thanks
17:23:43 * shapr looks
17:23:48 <Pseudonym> Gere we are:
17:23:49 <Pseudonym> http://citeseer.nj.nec.com/liang95monad.html
17:24:31 <Pseudonym> I also recommend the Ralph Hinze paper on deriving monad transformers.
17:24:43 <shapr> I didn't know he wrote one...
17:24:48 * shapr bounces happily
17:24:49 <Pseudonym> chttp://citeseer.nj.nec.com/234620.html
17:25:50 <Pseudonym> I found that really useful when constructing my own.
17:28:00 <shapr> when I first understood monads, it occurred to me that they're functional aspect oriented programming....
17:28:22 <shapr> I was amusing to a paper on "monads as the theoretical basis of AOP"
17:28:31 <shapr> er "was amused to find"
17:35:54 <dark> mapM_ try_close [3 .. 1024]
17:36:00 <dark> Brutal abuse of system calls )
17:36:08 <shapr> what does that do?
17:36:26 <Pseudonym> dark: Real C code does that too.
17:36:39 <Pseudonym> If you don't have a daemonize() call, that's what you have to do.
17:36:47 <dark> Pseudonym: The shell seems to get away with not doing it.
17:37:13 <shapr> hey.... arrows could get one step closer to transparent paralellization of programs
17:37:15 <shapr> hmm
17:37:15 <dark> shapr: Closes all file descriptors that might have been inherited from the parent, after forking.
17:37:49 <shapr> yes, part of the static info that could be made available is dependency information.
17:37:59 <Pseudonym> dark: What OS are you using?
17:38:22 <dark> Pseudonym: Debian
17:38:27 <Pseudonym> dark: man daemon
17:38:28 <shapr> arrows to Itanium EPIC code could be fun
17:38:49 <Pseudonym> Eeek.
17:39:01 <Pseudonym> Have you SEEN Itanium EPIC code?
17:39:08 <Heffalump> shapr: btw, check section 4.2 of the Espinosa paper - it says Haskell's type system can't cope
17:39:26 <Pseudonym> Heffalump: Can you expand?  What is lacking?
17:39:41 <Pseudonym> I suspect it's a fixpoint operator in the type system or something.
17:40:02 <shapr> I've seen a bit of EPIC code
17:40:20 <Heffalump> Pseudonym: you need to treat monads and monad transformers as values, apparently
17:40:23 <dark> Pseudonym: Maybe the shell uses close-on-exec liberally.
17:40:27 <Heffalump> I don't really understand what's going on yet
17:40:35 <Pseudonym> dark: Very possibly.
17:40:46 <Pseudonym> shapr: You're gonna love what I have to do soon.
17:40:52 <shapr> Pseudonym: what what?
17:40:54 * shapr bounces
17:41:03 <Pseudonym> shapr: Oh, it's mucking with EPIC code.
17:41:08 <shapr> oh, neat :-)
17:41:12 <Pseudonym> We have this highly fault-tolerant server.
17:41:19 <shapr> yah?
17:41:40 <dark> Hmm, cool, GHC's IO system also uses close-on-exec.
17:41:42 <Pseudonym> What I have to do is make sure the database that it manages is in a consistent state no matter what.
17:42:21 <Pseudonym> So... we have a test function.  I insert a seg-faulting instruction as the first instruction, run it, test the result.  Now the second instruction.  Repeat until you've done the whole function.
17:42:34 <Pseudonym> Truly, truly ugly.
17:42:42 <Pseudonym> We've already implemented it for the SPARC.
17:42:49 <Pseudonym> Doing it for the Itanium will be hell on earth.
17:42:51 <shapr> sounds painful
17:43:11 <Pseudonym> EPIC == unnecessarily painful
17:43:15 <Pseudonym> If you ask me.
17:45:01 * shapr grins
17:45:34 <Pseudonym> Intel == we don't need no steenking RISC
17:45:43 * shapr grins
17:45:45 <shapr> VLIW, yay
17:46:07 <Pseudonym> I must say, I do like predicate registers though.
17:46:26 * shapr only looked at the cute parallel part of the Itanium
17:46:33 <Pseudonym> I've always hated status registers.
17:46:42 <Pseudonym> Oh, predicate registers are COOL.
17:47:08 <Pseudonym> In an x86 or SPARC, you have a status register.
17:47:21 <Pseudonym> If you perform a comparison, it sets and resets some bits in a special register.
17:47:40 <Pseudonym> Then you can do stuff with it, like conditionally branch depending on the value of some bit in that register.
17:48:35 <Pseudonym> Problem is there's a lot of contention for the register in a superscalar CPU.
17:48:44 <shapr> makes sense
17:49:05 <Pseudonym> Enter the MIPS, which doesn't use one.  Instead, you ask for the result of the comparison to be put in a register.
17:49:31 <Pseudonym> So, for example, you might have (and this isn't the real MIPS opcode; I'm making it up) cmpne r1,r2,r3
17:49:44 <Pseudonym> Which sets r3 = 1 if r1 /= r2 and r3 = 0 otherwise.
17:49:57 <shapr> ok
17:50:03 <Pseudonym> The Itanium goes one step further.
17:50:20 <Pseudonym> It has 64 one-bit registers which you put the result of comparisons into.
17:50:29 <shapr> spiffy
17:50:30 <Pseudonym> Called "predicate registers".
17:50:41 <shapr> so you can just grab one and use it?
17:50:49 <Pseudonym> The neat part is that all instructions take a predicate register for conditional execution.
17:50:54 <shapr> and then 64 different things in the pipeline can do stuff at once
17:51:04 <Pseudonym> So if you want to say: int i = 0; if (x < 4) i = 1;
17:51:05 <shapr> mm, cool
17:51:07 <Pseudonym> You can do this:
17:51:18 <Pseudonym> r1 = 0
17:51:31 <Pseudonym> p1 = (x < 4)
17:51:35 <Pseudonym> (p1) r1 = 1
17:51:39 <Pseudonym> Soemthing like that.
17:51:46 <shapr> nice
17:51:47 <Pseudonym> The r1 = 1 is only executed if p1 is set.
17:52:09 <Pseudonym> Far fewer branches, so far fewer prefetch stalls.
17:52:29 <shapr> they still making itaniums?
17:52:34 <Pseudonym> Yes.
17:52:37 <shapr> I'd like to have a few
17:52:42 <Pseudonym> We have one box here.
17:52:44 <shapr> last I looked at prices, they were scary
17:52:59 <shapr> something like 2k euros for a single not-very-fast itanium
17:53:04 <Pseudonym> Yes.  Much nicer if HP lends it to you. :-)
17:53:05 <shapr> just the chip, not the mobo
17:53:29 <Pseudonym> It's no scarier than an equivalent Sun box.
17:53:56 <shapr> otoh, I purchased a dual Athlon MP @ 1.544GHz for 2.5k euros
17:53:58 <Pseudonym> Besides, Itaniums are not designed to be fast in a CPU speed sense.  They're meant to a) do a lot of work at once, and b) scale to many many CPUs in a single case.
17:54:26 <shapr> I'd like to have a 4-way Itanium here
17:54:42 <Pseudonym> And people in hell would like iced water, but it's not on the cards, is it?
17:54:43 <Pseudonym> :-)
17:54:50 <shapr> probably not...
17:54:55 <shapr> I'll go for a SPARC box next I think
17:55:00 <shapr> cheaper
17:55:12 <Pseudonym> E250 looks good to me.  14 CPU box.
17:55:26 * shapr is afraid to look at the price
17:55:48 <dark> Step 1: win lottery
17:55:48 <Pseudonym> If you bought a hundred of them at once like Pixar did, I'm sure Sun would cut you a deal.
17:56:02 <shapr> yah, well
17:57:07 <Pseudonym> dark: Step 0: enter lottery
17:57:13 <Pseudonym> That's where the theory falls down for me.
17:57:30 <shapr> same here
17:58:30 * shapr wonders if his manager (aka fiancee) would let him spend 15k euros on a dual sparcIII
17:58:44 <shapr> er, 20k euros
17:58:48 <shapr> yow
18:00:03 <Pseudonym> At a previous job we got two Sun E10000 servers.
18:00:08 <shapr> mmm =)
18:00:16 <Pseudonym> One was not enough for us, oh no...
18:00:39 <Pseudonym> Oh, sorry, not E250s that Pixar got.  They got E4500s.
18:00:49 <Pseudonym> Beg yer pardon.
18:01:00 <Pseudonym> Back to our E10ks... Nice machines.
18:01:23 <Pseudonym> The backplanes alone cost .75 million Australian dollars.
18:02:14 <Pseudonym> Sun threw those in for free, though.
18:02:22 <shapr> yeesh
18:03:10 <Pseudonym> What's the conversion rate from euros to USD?
18:04:44 <Heffalump> 1ish
18:04:44 <Pseudonym> Here we are:
18:04:50 <Pseudonym> http://www.anysystem.com/e450-special-1.html
18:05:02 <Pseudonym> Sun E450 second hand for only US$4k.
18:05:19 <Pseudonym> 4 CPU box.
18:06:14 <Pseudonym> Only 300MHz, but who's counting?  Haskell execution is memory-bound anyway. :-)
18:09:01 * shapr wonders if he could speed up his haskell programs by giving them more ram
18:09:22 <dark> shapr: Try heap profiling
18:09:46 <dark> There's a mode that says how much time is spent collecting garbage.
18:09:47 <shapr> the sun 100 looks pretty spiffy, and is only $1k
18:11:04 * shapr hopes the x86-64 will have 4-way mobos
18:12:32 <shapr> mmmm, 8-way :-)
18:13:07 <Pseudonym> There's diminishing returns with x86s.
18:13:16 <Pseudonym> The problem is cache coherency.
18:13:20 <shapr> I'd still like to play quake on it =)
18:13:31 <Pseudonym> I'm not sure you would.
18:13:52 <shapr> probably not.. I don't play quake.
18:14:07 <Pseudonym> More than four processors and the system spends more time bus handshaking than doing actual work.
18:14:15 <shapr> yuk
18:14:31 <Pseudonym> I think.
18:14:33 <shapr> how does sun get around that?
18:14:53 <Pseudonym> As I understand it, on the Pentium, all memory writes are cache-coherent.
18:15:15 <shapr> the new Intel SMP boxen have a custom host bus, and a single host<->PCI connector for each PCI slot
18:15:17 <Pseudonym> That is, if you write to memory on one CPU, then when another CPU wants to read that location, it's there.
18:15:29 <Pseudonym> The caches negotiate between themselves.
18:15:45 <Pseudonym> On Sun, cache synchronisation operations are explicit.
18:16:09 <Pseudonym> It's part of the implementation of locking operations like semaphores and mutexes.
18:16:41 <Pseudonym> It's kinda hard to explain./
18:16:56 <shapr> I think I understand
18:17:08 <Pseudonym> There's a really good book called "Unix Systems for Modern Architectures" which goes into this in really gory detail.
18:17:36 <Pseudonym> See, the thing is, it should be an error in your program if you write to some area of memory when you don't have exclusive access to it.
18:17:58 <Pseudonym> The x86 doesn't enforce this.
18:18:27 <shapr> segfault?
18:18:28 <Pseudonym> However, the x86-64 might enforce this, which would be good..
18:18:45 <Pseudonym> No segfault, no.
18:18:49 <Pseudonym> The bus just goes slower.
18:19:10 <Pseudonym> Because the caches for each CPU communicate more to keep in sync.
18:19:51 <Pseudonym> The x86 has correct semantics, it just has (IMO) the wrong performance profile.
18:20:17 <Pseudonym> It doesn't scale to more than a few CPUs.
18:20:47 <Pseudonym> OTOH, for two or even four CPU boxen, it does the trick nicely.
18:21:00 <Pseudonym> Don't expect it to work for 16 CPUs.
18:21:11 <shapr> hm, interesting
18:21:34 <shapr> hey, I had a cute idea for expandable machines
18:21:43 <shapr> make a fast and spiffy programmable backplane
18:21:57 <shapr> put all the components into tetrahedrons
18:22:11 <shapr> then when you need another drive, you buy another tetrahedron and plug it in
18:22:27 <Pseudonym> Interesting.  Like a 3D transputer array.
18:22:30 <shapr> right
18:22:45 <shapr> drives, CPUs, etc could be plugged on
18:23:29 <shapr> Linux has rudimentary support for asymmetric multiprocesing
18:23:39 <shapr> currently only for same CPU of different speed
18:24:11 <shapr> would be cool if you could buy a random CPU for whatever you're doing now (Alpha for FPU) and then Linux compiles itself for that new tetra
18:24:51 <shapr> cute idea, eh?
18:25:31 <Pseudonym> Or you just implement the .NET CLR on it...
18:25:32 * Pseudonym ducks
18:25:38 * shapr laughs
18:26:29 <shapr> you could have some neat tricks with a setup like that
18:26:41 <shapr> the smalltalk idea of a running image could be spiffy there
18:27:01 <shapr> if you have two of each basic piece, you could cut your system in half at runtime
18:27:10 <shapr> hardware mitosis =)
18:27:59 * shapr would like to design that system
18:29:02 <Pseudonym> A friend of mine once noted that Unix processes reproduce asexually.
18:29:11 <Pseudonym> Wouldn't it be funny if the reproduce sexually?
18:29:27 * Pseudonym forks the offspring of a Haskell compiler and Mozilla
18:29:41 * shapr laughs
18:29:56 <shapr> you'd end up with a beefalo
18:30:14 <shapr> hey
18:30:26 <shapr> monads are multisexual
18:30:32 <shapr> monad transformers that is
18:30:39 <shapr> multiple inheritance
18:30:52 <vtra238> hi pplz
18:30:57 * shapr pretends normalcy for a bit
18:31:01 <shapr> hi vtra238
18:31:12 <vtra238> i've got a really long type signature for a function
18:31:13 <shapr> Haskell questions?
18:31:16 <Pseudonym> G'day.
18:31:28 <vtra238> and i was wondering if i could put it on seperate lines or sumfin
18:31:33 <shapr> I think you can.
18:31:36 <Pseudonym> Yes.
18:32:01 <vtra238> ok yea i thought so
18:32:05 <Heffalump> it's subject to the same layout rules as everything else
18:32:16 <vtra238> ic
18:32:22 <shapr> whenever I see "monad transformers" I think of purely functional robots (ever see the series "transformers - more than meets the eye" ?)
18:32:28 <Heffalump> shapr: :-)
18:32:32 * shapr grins
18:32:41 <Pseudonym> This is my longest one so far:
18:32:45 <Pseudonym> forall b c.
18:32:58 <Pseudonym>  (a -> ((b -> m c) -> m c -> m c) -> (b -> m c) -> m c -> m c)
18:33:06 <Pseudonym>  > ((b -> m c) -> m c -> m c)
18:33:14 <Pseudonym>   -> (b -> m c)
18:33:19 <Pseudonym>  -> m c -> m c
18:33:23 <Pseudonym> I left out a - there
18:33:29 * shapr notes that it's 4:30 am here, must be the reason for such silliness
18:33:31 <Pseudonym> Try doing that on one line.
18:33:47 <Pseudonym> It's even a monad transformer, too.
18:33:51 <shapr> wow, cool
18:33:54 <dark> It looks like you have worse problems than line length there :)
18:34:06 * shapr hums "more than meets the type"
18:34:06 <Pseudonym> Yes.  It took me two days to derive it.
18:34:08 * Pseudonym kids you not
18:34:24 <Pseudonym> That's two days to derive the _type_, not the transformer.
18:34:38 * shapr wants a monad transmogrifier
18:35:20 <Heffalump> hmm, my regexp simplifier is suffering from slight over-enthusiasm
18:35:30 <Heffalump> it just simplified
18:35:39 <Heffalump> epsilon+{7};{7}*+({8}+{7};{7}*;{8});({8}+{7};{7}*;{8})*;{7};{7}*+({8}+{7};{7}*;{8});({8}+{7};{7}*;{8})* to {7}*
18:35:44 * shapr laughs
18:35:53 <Pseudonym> Cool.
18:35:59 <Pseudonym> Is it correct?
18:36:02 <Heffalump> no.
18:36:04 <Heffalump> well, I doubt it
18:36:14 <Heffalump> the rewrite rule it applied to do so certainly doesn't let it do that
18:36:16 <shapr> time for QuickCheck!
18:36:19 <Heffalump> SML :(
18:36:22 <shapr> oh
18:36:37 <Heffalump> the rule was just epsilon+A;A* ==> A*
18:36:56 <shapr> is that part of MAG ?
18:37:02 <shapr> well, MAG:TNG ?
18:37:14 <Heffalump> naah
18:37:19 <Pseudonym> Semicolon is or, plus is concatenation?
18:37:23 <Heffalump> if I was doing more stuff with MAG I'd stick with Haskell
18:37:28 <Heffalump> Pseudonym: other way around
18:37:32 <Pseudonym> OK.
18:37:48 <Heffalump> * binds more tightly than ; which binds more tightly than +
18:38:04 * shapr passes the edge of unconsciousness
18:38:07 <shapr> g'night folks
18:38:09 <Heffalump> nn
18:38:14 <Pseudonym> Night./
18:38:17 * shapr falls over
18:38:30 <Pseudonym> Let me try that on my regex engine.
18:38:38 <Pseudonym> It's in Haskell, so it works. :-)
18:38:41 <Heffalump> what does your regex engine do?
18:39:05 <Pseudonym> It compiles them and runs them.
18:39:17 <Heffalump> ah, ok
18:39:31 * Heffalump is currently trying to get from automata to simple regexps
18:39:34 <Pseudonym> It's actually an exercise in run-time compilation.
18:39:41 <Pseudonym> Ah.
18:39:43 <Pseudonym> That's hard.
18:39:50 <Pseudonym> Automata to complicated regexps is easy. :-)
18:39:57 <Heffalump> not /that/ easy
18:40:01 <Heffalump> how would you do it?
18:40:40 <Pseudonym> I'd do it by something like interval analysis, I would think.
18:41:10 <Heffalump> I had to use a (conveniently already existing) implementation of Tarjan's algorithm for applying regular algebras to graphs
18:41:12 <Pseudonym> The first observation is that each state in the automaton can be represented as a regex.
18:41:38 <Pseudonym> Oh, no!
18:41:42 <Pseudonym> I know what I'd do.
18:41:51 <Pseudonym> I'd convert the graph to a grammar first.
18:41:58 <Pseudonym> THen regularise the grammar.
18:42:03 <Pseudonym> Duh, of course.
18:42:21 <Heffalump> errm, how would you do either of those two things?
18:42:40 <Pseudonym> OK, first step is to make the grammar.
18:42:44 <Pseudonym> Give me a simple automaton.
18:43:22 <Heffalump> 1->2->3->4, 3->1, 4->2
18:43:34 <Pseudonym> Sorry, don't know this notation.
18:43:40 <Heffalump> I just made it up :-)
18:43:46 <Heffalump> 1,2,3,4 are states, -> are transitions
18:43:51 <Heffalump> hmm, those transitions need labels
18:43:54 <Pseudonym> Yes.
18:44:14 <Heffalump> 1 -a-> 2 -b-> 3 -c-> 4 , 3 -d-> 1 , 4 -e-> 2
18:44:20 <Pseudonym> OK.
18:44:29 <Pseudonym> This can be written as a grammar:
18:44:35 <Pseudonym> q1 ::= a a2
18:44:39 <Pseudonym> q1 ::= a 12
18:44:40 <Pseudonym> q1 ::= a q2
18:44:44 <Pseudonym> Blerg.
18:44:51 <Pseudonym> q2 ::= b q3
18:45:04 <Pseudonym> q3 ::= c q4 | d q1
18:45:05 <Pseudonym> And so on.
18:45:25 <dark> Now I have a Posix pipeline function so I can call gzip and tar :-)
18:45:30 <dark> Time to sleep on it, I think.
18:45:40 <Pseudonym> Night.
18:45:49 <dark> And catch SIGPIPE in the morning...
18:46:11 <Heffalump> ok.
18:46:42 <Heffalump> I guess that should have been obvious to me :-)
18:46:44 <Pseudonym> We need to know which ones are final states, too.
18:46:46 <Heffalump> now how do you regularise it?
18:46:50 <Heffalump> 4.
18:47:03 <Pseudonym> OK, so: q4 ::= e q2 | lambda
18:47:09 <Pseudonym> Where lambda is of course the empty string.
18:47:33 <Pseudonym> OK.
18:47:42 <Pseudonym> Now assuming that q1 is the start state... is it?
18:47:47 <Heffalump> yes
18:47:50 <Pseudonym> Right.
18:47:55 <Pseudonym> We start with q4.
18:48:14 <Pseudonym> Substitute in the nonterminals until we hit instances of q4.
18:48:23 <Pseudonym> q4 ::= e q2 | 1
18:48:28 <Pseudonym> q4 ::= e b q3 | 1
18:48:42 <Pseudonym> q4 ::= e b (c q4 | d q1) | 1
18:48:44 <Pseudonym> Oh, hang on.
18:48:45 * Pseudonym thinks
18:48:52 <Pseudonym> Trying to remember how I used to do this.
18:49:09 <Pseudonym> Oh, we topologically sort first.
18:49:13 <Pseudonym> That's right.
18:49:34 <Heffalump> the graph has cycles...
18:49:40 <Pseudonym> Yes, and it's a SCC.
18:49:51 <Heffalump> I was about to offer to partition it into SCCs :-)
18:49:56 <Pseudonym> :-)
18:51:14 <Pseudonym> Oh, I remember.
18:51:26 <Pseudonym> We substitute q4 in all places first.
18:51:46 <Pseudonym> q3 ::= c (e q2 | lambda) | d q1
18:51:57 <Pseudonym> That eliminates q4.
18:52:10 * Pseudonym thinks
18:52:22 <Pseudonym> There's some order that you can do it so that you always end up with rules of the form:
18:52:27 <Pseudonym> q ::= A q | B
18:52:36 <Pseudonym> Which you then replace with q ::= A* B
18:52:50 <Pseudonym> It's been AGES since I did this.
18:55:22 <Pseudonym> Oh, uhm...
18:57:37 * Heffalump discovers that his connection froze
18:57:44 <Pseudonym> Ah.
18:57:49 <Pseudonym> OK, I think I remember this.
18:57:53 <Pseudonym> It's taken several goes.
18:58:12 <Pseudonym> The thing you have to do next is to introduce a final state.
18:58:16 <Pseudonym> qf ::= lambda
18:58:22 <Pseudonym> Then rewrite, say:
18:58:38 <Pseudonym> q4 ::= e q2 | qf
18:58:43 <Pseudonym> I forgot that step.
18:59:02 <Pseudonym> Then one by one you eliminate the intermediate states.
18:59:11 <Pseudonym> Are you with me?
18:59:28 <Heffalump> umm
18:59:35 <Pseudonym> Here's the grammar:
18:59:37 <Pseudonym> q1 ::= a q2
18:59:37 <Pseudonym> q2 ::= b q3
18:59:37 <Pseudonym> q3 ::= c q4 | d q1
18:59:37 <Pseudonym> q4 ::= e q2 | qf
18:59:37 <Pseudonym> qf ::= lambda
18:59:45 <Heffalump> ok.
18:59:48 <Pseudonym> Right.
19:00:00 <Pseudonym> Now you pick a state to eliminate (not q1 or qf).
19:00:07 <Heffalump> ok.
19:00:12 <Pseudonym> We'll start with q4.
19:00:19 <Heffalump> what do you do when you reach a recursive state?
19:00:26 <Pseudonym> I'll get to that when we get there.
19:03:39 <Heffalump> ok.
19:04:14 <Heffalump> q1 ::= a q2, q2 ::= b q3, q3 ::= c e q2 | c qf | d q1, qf ::= lambda
19:04:36 <Heffalump> doing q2 next:
19:04:51 <Heffalump> q1 ::= a b q3, q3 ::= c e b q3 | c qf | d q1, qf ::= lambda
19:05:07 <Heffalump> can't do q3, since it's recursive.
19:14:08 <Heffalump> hi
19:14:32 <ab> hello
19:14:48 <Chilli> ab: it seems my emails are being read ;-)
19:14:58 <Chilli> Hi Heffalump
19:15:03 <ab> I'm busy procrastinating from writeup :)
19:15:03 <Heffalump> morning Chilli
19:15:17 <Chilli> ab: :-)
19:16:07 <Heffalump> aaargh!
19:16:10 <Heffalump> of all the dumb mistakes
19:16:24 <Heffalump> matchre_list dict (varlist v) res = extend_list dict v []
19:16:25 * Chilli looks puzzled
19:16:41 <Heffalump> I spot that I should bind the variable v to res, and go and bind it to [] instead.
19:16:43 <Chilli> ab: I am busy procrastinating from doing 1011 slides...
19:16:48 <Heffalump> (see my troubles with regexps above)
19:17:47 <Chilli> Heffalump: regexp simplifier for what?
19:18:09 <Heffalump> complicated regexps :-)
19:18:10 <Chilli> Hi Balial
19:18:12 <ab> Chilli: ah, excellent :)
19:18:33 <Heffalump> I want to print out, in readable form, the regexps from some automata I have
19:18:33 <Balial> g'day all
19:18:56 <Heffalump> so I'm just making the complex regexps, and then applying some rewrite rules to get rid of obvious stupidities
19:19:07 <Chilli> Heffalump: some random automata youhappen to have lying around...
19:19:17 <Heffalump> chilli: errm, essentially :-)
19:19:27 <Chilli> aha, ic
19:19:50 <Heffalump> we have these "chip-chop" matrices arising from an initial regular expression
19:20:23 <Heffalump> the elements of the matrix are the automata corresponding to the "chip-chop"s of the initial RE, and I want to print them out as REs themselves
19:21:12 <Pseudonym> Sorry, back.
19:21:18 <Pseudonym> Boss key. :-)
19:21:19 <Chilli> what do you mean by chip-chop matrices?
19:21:42 <Pseudonym> OK.  Heffalump: q1 ::= a b q3, q3 ::= c e b q3 | c qf | d q1, qf ::= lambda
19:21:52 <Pseudonym> You can eliminate q3 by noting that:
19:22:08 <Pseudonym> q ::= A q | B is the same as q ::= A* B
19:22:11 <Pseudonym> In this case:
19:22:23 <Pseudonym> q3 ::= (c e b)* (c qf | d q1)
19:22:30 <Pseudonym> Or perhaps:
19:22:47 <Pseudonym> q3 ::= (c e b)* c qf | (c e b)* d q1
19:22:48 <Heffalump> the "chop" operator "/" is defined by T <= S/R == T;R <= S
19:23:06 <Heffalump> Pseudonym: hmm, ok
19:23:09 <Pseudonym> Then keep going until you only have q1 and qf left.
19:23:21 <Heffalump> the "chip" operator "\" is defined by T <= R/S == R;T <= S
19:23:37 <Heffalump> where R,S,T are languages (not necessarily regular ones)
19:24:22 <Heffalump> iff E is regular, E only has a finite number of chops
19:25:01 <Heffalump> make a matrix whose rows and columns are indexed by those chops, and calculate the elements by taking the chips of the row index from the column index
19:25:08 <Heffalump> that's the chip-chop matrix.
19:25:36 <Chilli> ok, and why would I want to do that?
19:26:17 <Chilli> find certain equiv expression?
19:26:25 <Heffalump> no, incremental program analysis
19:26:51 <Heffalump> suppose you have a program P, modelled by the set of paths through that program, where a path is a list of statements
19:27:30 <Heffalump> P satisfies the regular expression E if all the paths match up with E
19:27:44 <Chilli> ok
19:28:06 <Heffalump> so E might represent some useful analysis of your program, like "this statement can be eliminated as dead code"
19:29:08 <Chilli> is this part of the ILX analysis stuff?
19:29:21 <Pseudonym> You've lot me.  How do you represent, say, dead code elimination as a regular expression?
19:29:29 <Heffalump> It's IL we're analysing, not ILX, but yeah
19:29:41 <Chilli> ok
19:29:44 <Heffalump> Pseudonym: can I do constant propagation, it's easier to write?
19:29:48 <Pseudonym> SUre.
19:30:53 <Heffalump> if all the paths from method entry to a node N satisfy {}*;{X:=C};{not(def(X))}*;{V:=X}
19:31:06 <Pseudonym> Right.
19:31:09 <Heffalump> then you can translate V:=X into V:=C
19:31:17 <Pseudonym> OK, I see.
19:31:40 <Pseudonym> Have you read Cliff Click's PhD thesis on combining analyses?
19:31:46 <Heffalump> V,X and C are actually meta-variables that get instantiated to whatever program variables/constants are appropriate
19:31:57 <Heffalump> nope, reference?
19:32:12 <Pseudonym> I don't think it's online.  He mailed me a copy.
19:32:23 <Pseudonym> Hang on, I'll put it somewhere where you can get it.
19:32:26 * Heffalump finds it with Google
19:32:51 <Pseudonym> Oh, here it is.
19:33:00 <Heffalump> ftp://ftp.cs.rice.edu/public/cliffc/thesis.ps.gz
19:33:07 <Pseudonym> He does a similar kind of thing, only he doesn't go via regular expressions.
19:34:28 <Pseudonym> He does, however, use DFA minimisation on the analysis domain to get much the same effect.
19:34:39 <Heffalump> oh, the URL doesn't work
19:34:44 <Pseudonym> http://citeseer.nj.nec.com/520866.html
19:34:49 <Pseudonym> Citeseer always works. :-)
19:36:23 <Pseudonym> Incidentally, his optimiser is now in the Java HotSpot compiler.
19:37:35 <Heffalump> the idea of our stuff is to make it possible to define lots of analyses in one framework
19:37:55 <Heffalump> from the abstract, his seems to be about some very specific (albeit very important) ones
19:38:25 <Pseudonym> Actually his idea is that the union of two analyses is often greater than the sum of their parts.
19:38:59 <Chilli> Pseudonym: not very suprising thesis
19:39:10 <Pseudonym> For example, an analysis which does both conditional constant propagation and dead code elimination together does better than running them separately.
19:39:20 <Pseudonym> No, not surprising.
19:39:24 <Heffalump> oh, yes
19:39:39 <Pseudonym> Except that he's come up with a way to combine two analyses mechanically.
19:40:28 <Pseudonym> Lunch.  BBIAB
19:40:34 <Heffalump> I'll be asleep, probably
