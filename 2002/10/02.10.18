00:01:32 <Logan> Are there any really good online resources discussing the Hindley-Milner type system?  Like the type inference algorithm and such?
00:02:05 <sethk> There are, hold on a second, I'll see how good my memory is...
00:02:43 <Logan> Searching with Google, I've found a few light-weight descriptions, but most of what I find are papers that extend on HM, and refer to original papers that aren't available online.
00:02:50 <Logan> And I don't feel like hiking to the library. :P
00:05:36 <sethk> I didn't find the one I'm thinking of, and it may have been in a book.
00:05:54 <sethk> I'd be surprised, though, if there isn't one floating around somewhere.
00:06:43 <sethk> On the other hand ( :-)  ) most papers on the net are more recent...
00:07:16 <sethk> The originals may in fact not be online.
00:10:59 <Logan> I keep finding references to the inference algorithm being simple, but that doesn't help me any. :P
00:11:21 <Logan> And I lack the functional programming background (my school doesn't teach this sort of stuff at all).
00:15:41 <Jii> argh, very frustrating, i learned about some (relatively trivial) emacs feature (ctrl-alt-l) in the summer, and i've been using it ever since, but today i remembered i learned something emacs-related but didn't remember exactly what, it was really difficult to find out the thing again (ie. the original source of the revelation) :)
00:16:32 <sethk> Logan:  That isn't unusual; the people who really study functional programming are a relative handfull
00:18:03 <sethk> Logan:  Microfilm at the library may be the only option...
00:18:56 <Logan> How applicable do you think HM might be to non-functional languages?
00:19:33 <sethk> Logan:  Definitely very applicable.  For example, Python uses a very similar algorithm.
00:20:00 <Logan> I didn't know that.
00:20:36 <sethk> Python does the type checking at run time, which is definitely not as good, but the inference algorithm is similar.
00:21:20 <Logan> I've been thinking about what I'd like to see in an imperative language, and wondering how to implement some things.
00:22:50 <sethk> Python is a good example of borrowing ideas from different language families.
00:23:25 <Jii> is it the hindley-milner system that provides means for even logical proving?
00:24:38 <Logan> sethk: That's basically what I had in mind.  Only I want static type checking. :P
00:25:12 <Logan> I figure if I think on this enough and implement it, I might come up with a thesis idea (or at least get a usable programming language out of it).
00:25:13 <sethk> Jii:  No, not if I understand what you mean by that.
00:26:06 <sethk> Logan:  There are still a number of intractable language theoretic issues that make this VERY non-trivial.
00:27:01 <Logan> sethk: Like what?
00:27:46 <sethk> Logan:  The most well known problems are with the imperative and OO languages.
00:28:15 <sethk> Logan:  More fundamentally, no one has found a way to do multidimensional decomposition in a reasonable way.
00:28:18 <Jii> sethk, but, (in some sense) is it true that you can do logical proving within for example haskell's type system?
00:28:30 <Logan> sethk: I'm afraid I don't know what that means.
00:28:57 <sethk> Logan:  Hold on a second, I'm looking for a citation that I have here...
00:29:28 <sethk> Jii:  Tell me what you mean by logical proving.  Proving an algorithm to be correct?  Proving that code does what you think it does?
00:30:01 <Logan> sethk: No rush on the citation, I'm going to bed shortly, but if you post it I'll check it out when I wake up.
00:30:51 <sethk> Logan:  OK, if I forget drop me an email at seth@cql.com
00:31:11 <Logan> Ok, thanks.  Good night.
00:31:30 <Jii> sethk, well, the specific issue one friend of mine mentioned was a red-black tree data type that (the data type itself) ensures that the code that modifies that tree keeps it balanced
00:32:11 <Jii> sethk, but it was half speculation as we didn't have any code to examine :)
00:32:29 <Jii> sethk, he overheard it from some professor of our department :)
00:33:05 <sethk> Yes, in a sense this is true...
00:33:32 <Jii> the idea was that the source _doesn't compile_ if it doesn't mantain the balance rules
00:33:36 <sethk> But the reasoning is somewhat circular.
00:33:48 <sethk> Because it depends on the correctness of the implementation.
00:34:22 <sethk> In other words, if you coded it properly, yes, but it isn't obvious whether a compile error is caused by a coding error of a more mundane sort.
00:34:42 <sethk> Because you may have messed up when you coded the type definition.
00:34:53 <Jii> well, i see that i can't make the point (at least it seems so) :)
00:35:23 <Jii> (the whole idea is a bit vague still in my mind, too :)
00:38:11 <sethk> Haskell makes things easier because the is a very close correspondance between the algorithmic description and the implementing code...
00:38:28 <sethk> But it doesn't eliminate entirely the possibility of a dumb coding error.
00:39:16 <Jii> but this wasn't what i was talking about, but, nevermind, i bring it up again when i have the idea explicit in my mind :)
00:40:01 <sethk> OK, I was thinking about your red/black tree example.
00:40:59 <Jii> (i mean, i was talking about red/black tree, but not what you were talking about :)
00:42:24 <sethk> Perhaps, but I think I understood.  When you are talking about proving correctness, you have to note your assumptions, such as "if the type definition is coded correctly, then XXXXX can't happen."
00:44:50 <Jii> oh, yes, i didn't try to imply that one cannot make mistakes in coding the type definition
00:45:45 <sethk> Then the assertion that an error won't compile is correct with that qualification.
00:45:55 <Jii> i wasn't interested in making bug-free programs, rather, just intrigued by the fact that you can even do such thing :)
00:47:00 <Jii> yes, i guess so
00:47:13 <sethk> That is what makes a purely functional language unique.  With other languages such questions are provably undecidable.
04:21:31 * dark flops about.
04:55:58 <dark> Hmm my programming style seems to have morphed into one that regularly confused ghc about line numbers.
04:57:12 <dark> I don't know what's doing it, but fairly often it's off by 10 lines or more.
05:14:43 <Igloo> I've found errors often are claimed to be at the beginning of do blocks
05:17:44 <dark> I'll keep an eye out for that :)  I have lots of do blocks in this program.  In fact... I think the only non-IO functions are in small utility modules.
07:44:44 <shapr> yay! SimonMar put HWS under a BSD license, and added it to the fptools cvs repos
07:45:47 <Igloo> What licence was it before?
07:46:14 <shapr> none whatsoever
07:46:48 <Igloo> Ah, so you were in breach of copyright law then  :-)
07:46:56 <shapr> probably so
07:47:07 <shapr> but I only distributed patches against it, not the code itself
07:47:17 <Heffalump> even so
07:47:23 <Heffalump> they're derived works :-)
07:47:25 <shapr> hmm
07:47:26 <shapr> scary thought
07:47:32 <shapr> and excellent point
07:47:33 <Igloo> By testing it you were in breach of copyright law
07:47:38 <shapr> yow
07:47:39 <Igloo> By downloading it, actually
07:47:51 <shapr> somebody shoot the recording industry
07:47:59 <Heffalump> that's nothing to do with the recording industry
07:48:04 <ayrnieu> shapr - the feds will be at your door shortly.  Please go silently.
07:48:04 <Heffalump> it's the way copyright law works
07:48:12 <shapr> ayrnieu: noooo, please nooo
07:48:21 <Heffalump> you can argue that by making it available on a web server he was implicitly giving permission for people to download it
07:48:28 <Heffalump> (copyright law pre DMCA, that is)
07:48:31 <shapr> imho, the current copyright law was pushed into place by the recording industry
07:48:46 <Heffalump> yes, IM pre-DMCA
07:48:48 <shapr> yah, post DMCA, please go quietly, you've broken the law
07:49:20 <shapr> the US is getting to the point of having conflicting laws such that you can arrest anyone you don't like.
07:49:22 <shapr> that's upsetting.
07:49:46 <ayrnieu> and special courts for everything.
07:50:39 * shapr tries to find HWS in his now updated cvs tree
07:50:42 <ayrnieu> You kill someone?  You've still got rights.  You kill several people?  You still got rights?  You install Perl on a system in the course of consulting work?  DO NOT PASS GO, DO NOT COLLECT $200
07:50:52 <andersca> what's hws?
07:51:22 <shapr> haskell web server
07:51:29 <shapr> ayrnieu: that is kinda scary
07:52:20 <ayrnieu> http://www.stonehenge.com/merlyn/ "I believe the implications of this landmark case are very scary for the industry at large."
07:57:35 <dark> I think it'd be pretty hard to argue that diffs without contexts are derived works.
07:58:23 <dark> On the other hand, AIUI that's exactly what the Phantom Edit is :)
07:58:27 <Heffalump> if you removed the context information and the - lines, it'd be pretty hard to apply the diff
07:58:57 <Heffalump> though I guess a program other than patch could do it
07:59:00 <Igloo> Not if it was purely additive
07:59:20 <dark> Heffalump: It'll work fine against exactly the version you generated it from.  Just use an diff --ed and patch --ed
07:59:22 <Heffalump> but if the only use of something is as a modification for something else, then said something is covered by the copyright restrictions of the something else, AIUI
08:00:46 <dark> Heffalump: Exactly the other way around, I think.  Copyright is lifted for the parts from the original work that you _have_ to use in order to be compatible with it.  This is how the FSF was able to duplicate the command-line interface of unix tools :)
08:01:36 <Heffalump> compatibility and derived works are different things
08:01:39 <Heffalump> the FSF wasn't allowed to use any of the source for the other things for their own implementations
08:03:33 <dark> Yeah but surely the list of command-line options is also part of the work.
08:05:03 <ayrnieu> dark - as much as the placement of a steering wheel on a car is.
08:05:39 <dark> Hmm, let's try the book equivalent of patches.  Suppose I told you to get a copy of Starship Troopers (first paperpack edition), and tear out pages 3, 27, and 141, and cross out every other word, plus every word that starts with an 'n', and read the remaining words in reverse order to find a Satanic message.  Would I need a license from the Heinlein estate to give out these instructions?
08:06:02 <dark> (Now I wonder if anyone will actually try this :)
08:06:37 <ayrnieu> dark - your example does not include any part of Starship Troopers.
08:07:31 <dark> ayrnieu: Just like ed diffs don't include any part of the original work.
08:07:34 <dark> Oh, girlfriend interrupt :)  I have to go to the store.
08:08:14 <ayrnieu> dark - no, but ed diffs are hardly as common or useful as context diffs.
08:08:43 <ayrnieu> (dark - I'm not saying that your example is *wrong*, just that I'd like to hear another that includes part of the work)
08:10:10 <dark> ayrnieu: You're right, but I prefer to argue about that after the principle of patches is out of the way :)
08:10:21 <dark> ayrnieu: Otherwise the discussion gets hopelessly mixed.
08:11:40 <ayrnieu> dark - OK.  Moving to that point, then, I don't see how your instructions could possibly require a license.
08:11:52 <dark> ayrnieu: Hmm, easy generalization: I don't want to specify an exact edition, so instead of giving page numbers, I quote paragraphs from the book to show where to start and end.
08:12:45 <ayrnieu> dark - your desire doesn't quite match your act; why don't you quote chapter numbers and paragraph numbers?
08:13:11 <ayrnieu> or, nevermind.
08:13:28 <ayrnieu> People often quote text from a book in this way: chapter names, subsection headers.
08:14:13 <dark> ayrnieu: I don't recall offhand if Starship Troopers has separate chapters :)  Certainly it doesn't have paragraph numbers.
08:14:49 <dark> Anyway, I do have to go now.
08:15:09 <ayrnieu> dark - it has paragraphs which can be numbered =)  but you can for research and such quote from it anyway, I don't see you can't also quote them in your instructions.
08:15:12 <ayrnieu> OK, bye.
08:52:47 <dark> Well, while I was at the store I realized the futility of discussing the limits of copyright, in a world where an artist can be successfully sued for copying one minute of silence.
08:54:25 <hdaume> ?!
08:54:49 <dark> hdaume: Does this mean I should dig up references? :)
08:55:14 <hdaume> yes
08:55:40 <hdaume> or just explain
08:57:54 <dark> hdaume: Well it's quite literal.  Some of the context is at http://www.cbc.ca/artsCanada/stories/silencea020702  (found just now with google)
08:59:54 <dark> Ah, here's an article that includes the settlement: http://www.cnn.com/2002/SHOWBIZ/Music/09/23/uk.silence/
09:00:53 <dark> I'll admit that an out-of-court settlement stretches the meaning of "successfully sued" a bit, but it involved a large payment.
09:04:43 <hdaume> '4 minutes and 33 seconds' is a great song *grin*
09:06:26 <ayrnieu> Imaginary Landscape no. 4 is fairly popular, I think.
09:07:11 <hdaume> never heard it...wasn't cage also the one who wrote 'piano burning'?
09:07:23 <hdaume> sorry, "wrote" should be in quotes ;)
09:07:31 <dark> hdaume: I don't know, I like silence I can sing along to :)
09:07:54 <hdaume> *grin*
09:29:14 <shapr> hi dark!!
09:31:40 <dark> shapr: Hello :)  We're discussing the virtues of Haskell on #debian-devel.
09:31:57 <shapr> w00
09:33:03 <liiwi> uh oh
09:33:53 * shapr drops by to listen
09:35:59 <dark> Would you say that Haskell is an ideal language for writing compilers?
09:36:04 <shapr> I would, yes.
09:36:23 <shapr> but that's mostly because it has Monads and Arrows already supported.
09:36:41 <dark> I never figured out what Arrows were for.
09:39:54 <dark> Compilers are probably a good fit because conceptually they're pure functions.
09:42:07 <ibid> everything is a pure function --- from world to world :-)
09:43:19 <dark> ibid: Not if you require interaction :)
09:44:05 <ibid> ok, everything is a pure function from a list of events to list of events
09:45:23 <ibid> but really, monadic programs can be seen as functions from world to world (but the world is hidden under hofs)
09:45:39 <dark> ibid: You'd have to include a notion of strictness, since input events can depend on output events :)
09:45:45 <ayrnieu> a function in C can be seen the same way, but mapping in this directly is less useful.
09:45:52 <ayrnieu> in this direction.
09:46:18 <dark> ibid: In my roguelike game I actually have a World type, and lots of World -> World functions :)
09:46:35 <ayrnieu> dark - your roguelike game?
09:46:41 <ibid> dark: the user is strict :-)
09:47:14 <dark> ayrnieu: One of my haskell projects is writing a roguelike game.  I call it "mage".  Currently it mostly has grand visions :)  In practice you can walk around a cave level and open and close doors.
09:48:11 <ayrnieu> dark - yay.  What kind of development model are you using?  Can I play?
09:48:18 <hdaume> aaargh.  i have 'newtype S a = S a' and i want to define 'instance MArray IOUArray a IO => MArray IOUArray (S a) IO' but ghc doesn't like this :(
09:48:34 <dark> ayrnieu: Currently it's the "I'm too ashamed of the code to show it to anyone" model :)
09:49:03 <ayrnieu> dark - sigh, OK.
09:49:05 <dark> ayrnieu: Actually I haven't figured out yet how to publish an arch project if I have no ftp server at my ISP.
09:50:50 * ayrnieu wonders why 'cvs co fptools' is failing on fptools/testsuite/utils/normalise_errmsg
09:56:17 <Segora> re
09:57:18 <shapr> dark: check out the Yampa stuff, I think Arrows will help push Haskell into the world of general purpose programming
09:59:09 <dark> I went and put it up at http://www.xs4all.nl/~dark/mage-1.0pre35.tar.gz in case anyone is interested :)
09:59:18 * shapr quickly grabs
10:00:48 <dark> shapr: So far it seems general-purpose enough for me :)  I sometimes have to push my mind in unusual directions, but I remember having to do the same to understand pointers.
10:01:24 <shapr> the idea of class and instance was hard for me the first time
10:01:29 <shapr> pointers weren't hard for me
10:01:38 <shapr> monads were hard for me, arrows are a lot simpler.
10:02:12 <shapr> I still think the idea of separate class and instance is nonsensical
10:02:19 <dark> The thing I miss most in Haskell is flexible exceptions.  But C doesn't have those at all :)
10:02:32 <shapr> how are Haskell exceptions not flexible?
10:03:04 <shapr> the only thing I miss in Haskell is a coupla years of paying work involving it ;-)
10:03:05 <hdaume> dark: hve you seen Control.Monad.Error?
10:03:32 <shapr> I want a job writing Haskell.
10:03:38 <ibid> about the only things i miss in c are algebraic types, generic polymorphism and a good module system
10:03:54 <shapr> I miss referential transparency in most languages.
10:03:54 <dark> The only one available to user code is userError, and that only carries a String.  Even if you muck around in GHC's IOBase to get at the IOError definition, they're still carry only a limited amount of data.  I haven't found a nice way to represent an error in renaming a file, for example.
10:03:59 <shapr> and partial application...
10:04:23 <shapr> and I miss first class functions and map and filter in Java
10:04:25 <dark> I would like to be able to translate FTP reply codes into the appropriate IO errors, for example :)
10:04:33 <shapr> why can't you?
10:04:40 <ayrnieu> I miss what shapr just missed =) , and also Haskell's syntax in general
10:04:40 <shapr> do you have an FTP module?
10:05:12 <shapr> I really like significant whitespace.
10:05:17 <ibid> yes, fcfs would be cool...
10:05:53 <shapr> partial application is cute, but not really worthwhile without fcfs and HOFs like map/filter/etc
10:06:16 <ayrnieu> 'fcfs'?
10:06:57 <shapr> first class functions
10:07:20 <shapr> Haskell is a logical next step after Python
10:07:25 <shapr> at least, seems that way to me.
10:07:42 <shapr> I started drastically overusing map/filter/lambda in Python
10:07:53 <ibid> actually, i sometimes miss global state in haskell... maybe i should learn sml :-)
10:08:12 <shapr> ibid: John Hughes just did a Globals.hs thing for config files
10:08:12 <ayrnieu> ibid - you can have global state in Haskell =)
10:08:14 <dark> hdaume: I looked at it just now :)  Not sure how well it would work here, would I have to change all my IO functions to ErrorT ErrorType IO?  And use lift on all IO actions?  Sounds verbose.
10:08:50 <ayrnieu> globalVar = unsafePerformIO newEmptyMutVar  -- IIRC
10:08:57 <ibid> ayrnieu: with no notational overhead?
10:09:07 <ibid> shapr: url?
10:09:19 <shapr> it was on the mailing list...
10:09:21 <dark> shapr: An error when renaming a file should carry both filenames.  If it's over FTP, I'd want to include the reply code and reply message too.
10:09:24 <shapr> in the last two months even
10:09:36 <ayrnieu> ibid - I don't know what you mean by that, sorry.
10:09:44 <shapr> dark: why is that hard?
10:09:55 <hdaume> dark: perhaps -- i've never used it :)
10:09:55 <dark> shapr: I already made a Util.Directory module to add filenames to the System.Directory functions :)
10:10:06 <dark> shapr: Well, IOError only has provision for one filename.
10:10:29 <ibid> ayrnieu: no monad overhead essentially
10:10:38 <dark> I could stuff everything into userError and do fancy string parsing at the catching end, but that's not why I'm using Haskell :)
10:10:44 <shapr> yah, I agree
10:11:05 <hdaume> does anyone know if Word64# is always a 64 bit word, regarless of platform?
10:11:06 * shapr hasn't looked at exceptions in Haskell much
10:11:14 <shapr> hdaume: why wouldn't it be?
10:11:19 <dark> One thing I could do is play with the Dynamic type and GHC's DynamicError.
10:11:26 <hdaume> shapr: cuz sometimes C is weird about those things...
10:11:39 <dark> hdaume: It should be, I relied on it in one program :)
10:11:47 <hdaume> ok
10:12:12 <dark> It'll probably be implemented on top of Integer for those platforms though.
10:12:22 <hdaume> yuck!
10:12:26 <dark> oh, wait, Word64# with the hash.
10:12:35 <dark> I don't actually know about that one :)
10:12:38 <hdaume> maybe i'll just use a pair of words
10:12:39 <shapr> yah, should be a raw unboxed 64 bits
10:13:38 <ayrnieu> ibid - I've never actually used this; I don't recall that it had particular overhead, but I don't know what you mean.  Certainly a mutable variable poses problems with referencial transparency, so you've *some* overhead.
10:14:27 <ibid> shapr: message subject?
10:14:51 <ibid> ayrnieu: of course it breaks reftran
10:16:05 <shapr> ibid: there was a thread on how to do config files recently
10:16:32 <dark> I think there's a proposal for global context on haskell.org.
10:18:09 <ibid> essentially, it is very easy to make interface decisions that cause a need for a global rewrite for some cases
10:18:27 <shapr> isn't that part of what's good about monads?
10:18:43 <shapr> that you can change the interface without changing everything?
10:19:32 <dark> Well I know I'm currently dedicating a lot of text to a Verbosity option, it's everywhere.
10:20:02 <shapr> hm
10:20:27 <ibid> i wrote a translator in cp-style, but i made it not pass the symtab to the continuation
10:20:36 <dark> On the other hand it is sort of nice that I can substitute Silent for the real verbosity in some places.
10:21:15 <ibid> when i realized that certain valid design decisions about the input language would require me to rewrite it to pass it around, i got depressed
10:21:35 <ibid> shapr: monads give the code a too imperative flavour imho
10:22:15 <shapr> is there a middle ground?
10:22:17 <ayrnieu> ibid - what is 'too' imperative about it?
10:23:05 <ibid> ayrnieu: isn't it obvious
10:23:16 <dark> I think it's not monads in general that cause this, but the practice of stuffing everything into the IO monad.  I find myself having to sequence actions just because they're both IO, even though they're unrelated.
10:23:20 <ayrnieu> ibid - I'm afraid that it's not, at least from my perspective.
10:23:59 <ibid> actually, i think a dynamically scoped variable would be an answer...
10:24:32 <ayrnieu> ibid - a single-threaded 'state' array with a stack for each variable-name?
10:24:38 <ibid> for this particular problem
10:25:04 <ibid> stack for each variable - argh, no
10:25:16 <ibid> FiniteMap is quite sufficient :-)
10:25:22 <ibid> assuming it's persistent, and i think it is
10:25:37 <ibid> i mean efficiently persistent
10:26:02 <Segora> dark: there was something like unsafeInterleaveIO if I am not mistaken
10:29:32 <BlizzNL> I am trying to figure out some scary code, but it uses @ quite some times, what is it?
10:30:00 <ibid> in patterns?
10:30:05 <Segora> name binding
10:30:19 <ibid> x@(x:xs) means, bind the whole thing to x, and bind the head to x, and bind the tail to xs
10:30:33 <Segora> too many x's ;)
10:30:43 <ayrnieu> blizz - didn't I tell you about this before?
10:30:43 <BlizzNL> Segora, ibid: great thnx
10:30:58 <dark> Segora: Yes but it's unsafe :-)
10:31:30 <ibid> true
10:31:42 <ibid> l@(x:xs) means, bind the whole thing to l, and bind the head to x, and bind the tail to xs
10:31:47 <BlizzNL> no i don't think so (99.99% sure), but we could check the logs ;)
10:31:57 * shapr notes that this channel is continually increasing in spiffiness
10:33:07 <ayrnieu> shapr - how so?
10:33:14 <shapr> more people, better discussions.
10:33:19 <Segora> dark: only if you make wrong assumptions about the interdependencies of your IO actions ;)
10:33:22 <ayrnieu> Blizz - that's OK, if you're only 0.01% sure that I told you =)
10:33:27 <shapr> actually, it's possible the discussions have always been this spiffy, but my understand was just smaller.
10:33:58 <dark> spiffiness is in the groog of the spiffer?
10:34:15 <dark> Segora: I'd be much happier with the compiler figuring that out :-)
10:34:52 <ayrnieu> dark - is art in the eye of the viewer or the eye of the maker?
10:35:03 <Segora> dark: then you have to restructure your code and move stuff out of the IO Monad into structures that capture the attributes of your actions more accurately.
10:35:03 <ayrnieu> (or the hand of the maker, if you prefer)
10:35:42 <shapr> whatever the answer, I'm getting more out of the discussions now.
10:35:51 <Segora> dark: (in this case you have to type a lot more)
10:36:21 <ayrnieu> shapr - you said once that you were interested in implementation Joy in Haskell.  Have you thought more about that?
10:36:30 <shapr> yah, I have
10:36:56 <shapr> but most of my recent thought have been "how can I get Okasaki's ICFP2002 paper on "implementing postfix languages in haskell""
10:37:27 <shapr> another possibility would be to add postfix op parsing to the standard stuff in Parsec
10:37:35 <shapr> currently in only does prefix and infix
10:38:05 <shapr> hi marvin!
10:38:13 <shapr> hey, did you get SimonMar's email about the license change?
10:38:25 <shapr> HWS is BSD! yay!
10:39:22 <shapr> and he added HWS to the fptools cvs tree
10:39:36 <dark> Segora: More typing isn't really a problem, as long as it doesn't mean ending up with verbose code :)
10:39:50 * ayrnieu reads http://groups.google.com/groups?threadm=7dokuv%24103i%241%40news.missouri.edu
10:40:10 <dark> ayrnieu: I'd say art is in the eye of the viewer, but I'm not about to support that opinion on #haskell :-)
10:40:11 <Marvin--> shapr: I know, I've been exchanging some mails with him ;)
10:40:22 <shapr> yay!
10:41:21 <shapr> how did your presentation go?
10:41:32 <Marvin--> so-so, better than others'
10:41:39 <ayrnieu> dark - if art is in the eye of the viewer, then why isn't spiffiness in the groog of the spiffee? =)
10:41:45 <Marvin--> Koen seemed to think it was a cool project though
10:41:51 <shapr> is groog dutch for grok?
10:42:01 <Marvin--> though he grinned at the total-non-type-safety
10:42:19 <shapr> you can do type safety stuff with o3's runtime loader code
10:42:25 <shapr> I don't know anything about the code you're using now.
10:43:03 <shapr> o3 suggests using Dynamic types to improve type safety
10:44:33 * shapr wonders if Lulea uni offers Haskell courses
10:45:39 <cleverdra> This, except for ayrnieu's (possibly sent) message, is the last thing I saw: <Marvin--> so-so, better than others'
10:46:20 <shapr> cleverdra: you can look at the logs, I have to sometimes when I get bumped
10:46:46 <shapr> might be able to get Okasaki's postfix paper from ACM digital library
10:46:49 * shapr keeps looking
10:47:04 <shapr> here's where the paper is mentioned: http://www.cse.unsw.edu.au/~chak/hw2002/
10:47:14 <shapr> ACM lib is mentioned at the bottom
10:48:04 <shapr> requires login...
10:48:48 <cleverdra> I've gone the other way, I suppose, in trying to implement the semantics of a Forth-like language before dealing with its syntax.
10:49:37 <Marvin--> shapr: dynamic types might be cool, yeag
10:50:57 <shapr> I can't figure out how to navigate through the ACM website, and I'm not a member so I can't use search.
10:50:59 <shapr> that's irritating
10:51:07 <shapr> how expensive is it to become a member?
10:52:43 * Marvin-- goes errrrr
10:52:53 <Marvin--> I just checked out fptools but can't find hws there?!
10:53:16 <shapr> nor can I
10:53:24 <shapr> I was wondering that myself
10:53:31 <Marvin--> but there is a commit message to cvs-fptools
10:53:58 <shapr> ?
10:54:28 * shapr cvs up again
10:54:54 <Marvin--> http://www.haskell.org/pipermail/cvs-fptools/2002-October/001669.html
10:56:21 <Marvin--> can't see it on cvsweb either
10:56:21 <Marvin--> hmm
10:56:43 <shapr> I vaguely recall there being a lag between the actual cvs and the publically available repos
10:57:03 <Marvin--> oh, okay
10:57:09 <Marvin--> I don't have time to fiddle with it anyway ;)
10:57:19 <shapr> I do...
10:57:24 <shapr> my woman just went off for the weekend
10:57:36 <Marvin--> I've got an exam on Monday, and heaps of assignments to correct
10:57:40 <Marvin--> heh
10:58:23 <shapr> I'd like to add a plugin api to HWS, and then port ErrorLogger and AccessLogger to that api, but I don't want to run over your project...
10:58:26 <ibid> btw, the interpreter assignment was way harder than i imagined, they are still doing it... (and i'm going to call it off)
10:58:37 <shapr> ibid: aww :-(
10:58:45 <cleverdra> ibid - what was the assignment?
10:58:55 <shapr> do you think your students enjoyed working on it?
10:59:05 <ibid> shapr: some of them. most didn't.
10:59:08 <shapr> it sure looks cool
10:59:29 <Marvin--> shapr: if you do it, Koen won't be too happy with me :P
10:59:44 <shapr> right, I'll do something else
10:59:50 <ibid> cleverdra: http://www.mit.jyu.fi/antkaij/opetus/okp2002/demo/demo3/ -- to understand and improve this (add subroutine support)
11:00:03 <ibid> they had no prior exposure to haskell...
11:01:54 * shapr checks on the progress of putting runtime plugins into hIDE
11:08:29 <liiwi> hIDEous?
11:09:45 <shapr> heh
11:09:53 <shapr> haskell IDE :-)
11:10:12 <shapr> hm, they haven't really gotten it together yet.
11:10:45 <shapr> well, I could try add the .so reloading code, see if that works.
11:15:05 * shapr reads Linker.c
11:18:59 <Marvin--> err, how the heck would you make a record typeable?
11:19:14 <Marvin--> hmm
11:19:43 <hdaume> Marvin--: i think i asked that q on the mailing list a while back...i don't remember the response, but it's there somewhere :)
11:20:40 <Heffalump> wdym "typeable"?
11:21:52 <Heffalump> oh, as in Data.Dynamic.Typeable ?
11:21:58 <Marvin--> yeah
11:22:25 <Marvin--> hmm, maybe it's not harder than typeOf x = mkAppTy (mkTyCon "FooBar") [typeOf (foo x), typeOf (bar x)]
11:22:38 <Heffalump> yeah
11:22:46 <hdaume> yeah, that's it :)
11:23:07 <Marvin--> oh well :) I always tell my students "try not to think too much", and I guess it applies to me too :-)
11:23:17 <Heffalump> it really ought to be inferred automatically
11:23:34 <Heffalump> is there a instance Typeable a,Typeable b => Typeable (a,b) ?
11:23:40 <Marvin--> yep
11:23:50 <Heffalump> pity you can't do that for records.
11:24:15 <Marvin--> heh, well, there's a slight difference ;)
11:28:18 <Marvin--> how the *** can IO be typeable?
11:28:27 <Marvin--> that sounds like black magic
11:33:16 <Heffalump> you can pass around an IO computation just like anything else, surely?
11:33:59 <Marvin--> well, yeah
11:34:14 <Marvin--> but anything that does tricky things with IO is black magic to me
11:34:56 <Segora> IO actions are values like all the others. nothing special. ;)
11:36:21 <Marvin--> I know, I know
11:39:27 <Marvin--> shapr: I don't see how this makes it much safer though, if the symbol I'm looking for isn't of type Dynamic, it'll still segfault...
11:41:18 <Heffalump> shapr: to answer your ACM question, I think it's $100 without Digital Library and $200 with
11:41:25 <shapr> yow
11:41:36 <andersca> if you're a student it's cheaper
11:41:47 <shapr> Marvin: I have no idea how it makes it safer, hopefully I can pass the buck to someone like Heff
11:42:31 <Heffalump> makes what safer?
11:42:47 <shapr> I just know that o3 said that Dynamic types can make runtime loading more typesafe
11:43:14 <Heffalump> yeah, cos you have the exported functions use Dynamic types
11:43:31 <Heffalump> then when you use fromDyn to get the type you actually expected, you get a Nothing if it turns out not to have it
11:43:54 <Heffalump> sorry, fromDynamic
11:43:58 <Marvin--> yeah yeah, but if you try to load a module function that's *not* a Dynamic, you're screwed anyway
11:44:03 <Heffalump> oh, yeah
11:44:30 <Marvin--> at which point you might as well assume that the plugin specifies the right type anyay
11:44:59 <Heffalump> if the "standard" is that the plugin specifies Dynamic, then it's easier to find broken plugins
11:45:05 <Heffalump> you don't need to find broken plugin/app combinations
11:45:13 <Marvin--> well, yeah
11:45:24 <Marvin--> it makes API changes easier
11:45:34 <Marvin--> is there a paper on the Dynamic module somewhere?
11:45:45 <Marvin--> I recognize a lot of the naming from Typing Haskell in Haskell, but...
12:11:18 <Marvin--> Hmm, I think I'm a bit confused by this anyway
12:11:24 * shapr als
12:11:25 <shapr> o
12:11:36 <shapr> I don't understand the Dynamic module
12:12:37 <Marvin--> I can see that if I have a type like t a I want to have [typeOf (undefined :: t a -> a) x]
12:13:04 <Marvin--> but if I have a data Foo = Foo Int | Bar String, should the list be empty, or say something about Int and String?
12:13:34 * shapr wishes the Haskell docs included sample code
12:14:52 <ayrnieu> Yes, that would be helpful.
12:15:01 * Marvin-- digs up THIH again
12:15:12 <shapr> THIH?
12:15:17 <shapr> we need an infobot
12:15:20 <Marvin--> Typing Haskell in Haskell
12:15:43 <ayrnieu> Generally, all documentation should strive to approach the level of Perl's (on most dimensions; Haskell needn't throw away its academic papers).
12:16:15 * shapr swears at ACM
12:18:11 <Marvin--> Maybe it should be the general case that the list should have as many elements as there are "stars" in the type's kind?
12:18:20 <shapr> yow, $200 just for the portal to computing literature
12:18:45 <ayrnieu> shapr - information wants to be expensive
12:18:48 <Marvin--> And I don't lose information about non-type variable things, because the TyCon is unique (or should be)
12:18:50 <Marvin--> ayrnieu: hoho
12:19:14 <ayrnieu> shapr - are you going to fork that over?
12:20:09 <shapr> not likely
12:20:14 <Marvin--> but then, if my Plugin type doesn't have any type variables, it has the kind *, so it should have an empty list as well...?
12:24:30 * Marvin-- decides that's it
12:24:54 <Marvin--> shapr: I'm trying to google for typeable records and stuff, but can't find anything useful :/
12:32:29 * shapr looks in his local archive of haskell lists
12:38:50 <shapr> I can't find it...
12:39:19 <shapr> I vaguely recall seeing a thread on that, maybe you could ask on haskell or haskell-cafe ?
12:41:25 <Heffalump> if you have a data Foo = .., shouldn't the typeRep just say "Foo []"?
12:41:30 <Heffalump> i.e. yes, the list should be empty
12:42:26 <Marvin--> yeah, I'm thinking that too
12:42:36 <Marvin--> at least from my "kind" reasoning
12:43:11 <Marvin--> and that would mean that records aren't different from anything else
12:43:17 <Heffalump> oh, true
12:43:21 <Heffalump> oh, no
12:43:35 <Heffalump> the record itself should have an appropriate TypeRep that mentions the field types
12:43:43 <Heffalump> but if you have data/newtype Foo = Foo { ... }
12:43:48 <Heffalump> then you just say "Foo []", I think
12:44:05 * Heffalump disappears
12:44:21 <Marvin--> well, since the record is just a bunch of functions, that's "automagic"
12:44:39 <Marvin--> but can you use a record "free" of a constructor?
12:48:44 * Marvin-- goes to correct assignments instead
12:58:07 <ludde> Marvin--: you have no old programspråk exams? (except for the 2 ones on the homepage) ?
13:01:42 <Heffalump> Marvin--: I'm fairly sure you can use a record free of a constructor, BICBW
13:01:43 <Marvin--> ludde: nope
13:02:00 <Marvin--> Heffalump: and I'm pretty sure I tried that "the other day"
13:02:11 <Marvin--> Heffalump: wouldn't that sort of conflict with the layout syntax?
13:02:20 <Marvin--> maybe not
13:02:53 <Heffalump> YM layout-free syntax
13:02:55 <Heffalump> hmm, maybe.
13:03:03 * Heffalump pokes Igloo, he'll know
13:04:24 <shapr> has anyone seen Chris Okasaki's homepage lately?
13:04:40 <shapr> he was at cmu, and also at columbia.edu, those are both gone
13:05:29 <shapr> yay!!
13:06:12 <Heffalump> he's at USMA now
13:06:20 <shapr> yah, I just discovered :-)
13:06:29 <shapr> http://www.eecs.usma.edu/Personnel/okasaki/
13:07:08 <shapr> whoa, that's west point
13:08:00 <shapr> hey ayrnieu, the postfix paper is up there
13:08:06 <Heffalump> sheesh, the external hyperlinks have to go via a CGI script!
13:08:42 <shapr> on his homepage?
13:09:03 <shapr> oh, I see
13:09:06 <shapr> and the CGI is asp
13:09:08 <shapr> even better
13:09:32 <Igloo> You need a constructor
13:09:53 <Marvin--> oh for ***
13:10:11 <Igloo> Was that what I was being prodded about?
13:10:12 * Marvin-- gives up on remembering which groups he's been talking Swedish with and which groups he's been talking English with
13:10:25 <ayrnieu> shapr - yay, thanks.  How did you find it?
13:10:31 <Marvin--> Igloo: not the ***, but the constructor, yes :)
13:10:45 * Marvin-- decides to always write the assignment comments in English
13:10:58 <dark> Programming should always be in English.
13:11:03 <shapr> ayrnieu: hours of searching
13:11:09 <Heffalump> igloo: about whether records can be used without a constructor
13:11:10 <Igloo> You could write them all in Swahili to make it fair
13:11:18 <Marvin--> dark: this isn't programming, this is me commenting these solutions to programming assignments :)
13:11:23 <shapr> dark: I disagree, I'd like to make a spoken programming language based on lojban
13:11:24 <Marvin--> s/these/their/
13:11:24 <Heffalump> He can only do that if he knows enough Swahili to do so, which seems unlikely
13:11:39 <dark> Oh :)  Hmm, maybe an abstract notation? You could draw little pictures of what you think of the solutions.
13:11:46 <Marvin--> good idea
13:11:49 <shapr> oh, that's better
13:12:05 <Marvin--> it falls on the part where I send the results back in a text-only mail though
13:12:10 * ayrnieu draws a frowny face next to the bogo-sort.
13:12:11 <Igloo> New instances need the constructor or yo wouldn't know which one you were constructing (the field names can be shared)
13:12:17 <Marvin--> I guess I could attach a .png or something
13:12:26 <shapr> on in unicode
13:12:31 <Heffalump> ah, so you can only use records inside a data/newtype?
13:12:32 <shapr> or
13:12:46 <Igloo> Yes
13:12:56 <Marvin--> Heffalump: told ya ;)
13:13:03 <ayrnieu> 'type' justs make an alias, right?  Where is this particularly useful?
13:13:12 <Marvin--> ayrnieu: saves typing?
13:13:22 <Marvin--> (ah-hah, ah-hah, as in hitting keys that is)
13:13:23 <ludde> Marvin--: you have a set of standard comments, and then you copy & paste, or are most of the comments personally written?
13:13:26 <shapr> also ensures type safety in some cases
13:13:39 <shapr> not type safety, name safety
13:13:40 <Heffalump> type never helps ensure type safety
13:13:42 <ayrnieu> shapr - in what cases?
13:13:43 <Heffalump> ah, yes
13:13:43 <shapr> significant name safety
13:13:50 <Marvin--> ludde: most of it is personally written, but when I came to the semantics part I have started copy&pasting some things
13:13:54 <Heffalump> well, sort of
13:14:01 <Heffalump> mostly it helps with encapsulation
13:14:01 <Igloo> area :: Width -> Height -> Area is more readable too, although not enforced by the type checker
13:14:09 <dark> It can help document stuff, like with FilePath.
13:14:18 <shapr> significant names add meaning to the type, very much worthwhile
13:14:24 <Marvin--> like "Your semantics specifies arbitrary-precision arithmetics, but when you compile the code to C, you are limited to 32-bit arithmetic" and stuff like that
13:14:28 <shapr> yah, built-in docs
13:14:29 <Heffalump> that's not really a safety thing though
13:14:44 <shapr> it's a usage safety thing :-)
13:14:47 <ludde> okay
13:15:26 <Heffalump> there's no real safety, since you can still shoot yourself in the foot
13:15:35 <shapr> well
13:15:35 <shapr> hm
13:15:36 <Heffalump> it's just an aid to memory, in that sense
13:15:59 <shapr> it's unenforced type safety
13:16:12 <dark> shapr: Also known as type unsafety :-)
13:16:22 <shapr> if you see "bah humbug" :: FilePath where type FilePath = String
13:16:27 <shapr> you know something is broken
13:16:41 <Heffalump> why?
13:16:42 <dark> I like to use String, but I tend to avoid type synonyms in other contexts, they make it too easy for me to _think_ the types are being checked, and get it wrong.
13:16:50 <Heffalump> "bah humbug" could actually be a FilePath.
13:16:54 <shapr> that's true
13:17:04 <shapr> what about "Dear Sirs, ..." ?
13:17:05 * shapr grins
13:17:08 <dark> My FilePaths magically become String inside the FTP module anyway :)
13:17:18 <ayrnieu> This incredibly secret and important message will not be encrypted or given physical security -- we will rely on unforced information security.
13:17:26 <shapr> ok ok, I give up :-)
13:17:31 <Marvin--> shapr: :)
13:17:47 <shapr> otoh, Chuck Moore says that typefulness is just a programmer crutch
13:18:00 <shapr> I've been trying to figure out if he's brilliant or stupid.
13:18:06 <ayrnieu> shapr - what about typeful programming?
13:18:27 <shapr> he said that real programmers don't need types.
13:18:40 <shapr> he wrote Forth, so I don't think he's completely stupid.
13:18:40 <dark> I went and spent about 300 lines on making actual newtypes for a lot of common string types in my program :)  I think the type checking was worth it... and then I saw ways to store some of them as structured data instead of String, which really made things nicer because I could use the derived Ord for sorting them the "expected way" (i.e. version--1.10 > version--1.9)
13:18:41 <Marvin--> ... and real programmers don't need compilers?
13:19:14 <shapr> I think that he's saying that types are just another tool, like logic is just another tool
13:19:26 <dark> shapr: It's arrogance to think that programmers can do without crutches :)  Programming is too difficult for humans.
13:19:27 * ayrnieu notes that, even in Forth, and even in Chuck's Forth (for a long time, though not recently), implicit types were still given to stack elements.
13:19:28 <shapr> logical thinking doesn't help you when your girlfriend is crying on your shoulder, don't even try it =)
13:19:32 <Heffalump> I don't think there's anything shameful in admitting you need a crutch.
13:19:56 <ayrnieu> : foo ( ca n xt -- x0..xn2 n2 )
13:20:17 <Heffalump> static type systems eliminate a wide range of bugs, which is always a good thing
13:20:31 <shapr> I always wondered about that...
13:20:39 <shapr> Java claims that, and it's not true in Java.
13:21:01 <shapr> A large portion of Java programs are not statically typed.
13:21:07 <dark> ... Java claims a lot of things :)
13:21:16 <shapr> that's true, they even claim improved programmer productivity.
13:21:18 * shapr gags
13:21:35 <shapr> so I wonder...
13:21:53 <shapr> what possible crutches are there that exist outside of the world of types?
13:22:06 <Heffalump> You can't have a completely static type system as well as dynamic method dispatch...
13:22:12 <dark> I've seen that "eliminate a wide range of bugs" in action.  At least, ghc seems to warn about exactly the kinds of mistakes I tend to make :)
13:22:18 <shapr> heh
13:22:18 <Heffalump> compilers and assemblers
13:22:22 <shapr> that's a good point.
13:22:30 <dark> shapr: garbage collection
13:22:40 <dark> data encapsulation :-)
13:22:50 <dark> Modularization is a big crutch.
13:22:55 <shapr> yah
13:23:08 <Heffalump> get rid of compilers and assemblers and the rest all go away too :-)
13:23:17 <Marvin--> oh, crutches are good
13:23:25 <shapr> my transcendental monad moment has gotten me thinking about other ways of doing things
13:23:32 <Heffalump> especially if you have a broken leg
13:23:34 <Marvin--> Yay, a few groups actually passed the assignment
13:23:38 <shapr> yay!
13:24:07 <shapr> monads do modularization in a totally different way
13:24:10 <dark> The attempts at "evolved code" show this, btw -- sometimes they find solutions that a human programmer would never have thought of -- and would never use :-)
13:24:23 <shapr> oh that sounds cool
13:24:27 <shapr> you have any urls about that?
13:24:32 <dark> Hmm *think*
13:24:41 <Heffalump> dark: because it's unmaintainable, you mean?
13:24:44 <shapr> it's like, programming is just an unnatural act....
13:24:52 <shapr> so maybe those evolved programs have something
13:24:53 <dark> Heffalump: Yeah, hard to modify without running the evolver again.
13:25:20 <dark> shapr: I just remember reading about it, I don't even remember where or by whom.  Might have been Hofstadter.
13:25:36 <shapr> I can now explain monads to the average person, but it won't help them unless they already understand the essential complexity of programming.
13:25:44 <Marvin--> heh, Hofstadter
13:25:49 <shapr> hm, I haven't got his later books, I'll add them to the top of my list.
13:25:54 <shapr> right after Okasaki's book.
13:26:26 <shapr> btw, it's easier to explain monads to a non-programmer than a procedural programmer.
13:26:28 <Heffalump> shapr: ITYM the essential complexity of doing sequential programming in a functional program
13:26:44 --- topic: 'ICFP 2002 Robot Analysis and Visualization Toolkit 0.9 http://tea.moertel.com/~thor/ravt/ || We put the Funk in Funktion || See logs @ http://tunes.org/~nef/logs/haskell/ || Gtk+HS 0.14.10 released http://www.cse.unsw.edu.au/~chak/haskell/gtk/ || ICFP is over <Erwin> Your mother asked you to write COM program? Who are you, Dilbert?'
13:26:44 --- topic: set by andersca on [Tue Oct 15 06:21:46 2002]
13:26:55 <Heffalump> is that domain name for clog new?
13:27:11 <shapr> more than that, monads are also important for combinator modules
13:27:21 <shapr> that's part of the strength of monadic abstractions
13:27:28 <shapr> nah, clog has always been there
13:28:24 <Heffalump> combinator modules aren't always monadic
13:29:11 <shapr> yes, but the monad interface/api is good for combinators
13:29:18 <shapr> and combinators are good for abstraction
13:29:23 <dark> shapr: One such thing is illustrated by GNU superopt, it found some instruction sequences for common operations that were shorter than the processor designers said was possible.
13:29:39 <shapr> wow, neat
13:29:40 <Heffalump> s/is/can be/
13:29:54 <shapr> right, can be :-)
13:30:33 <shapr> I've been trying to explain combinators and monads to #python and some people I know in real life
13:31:30 * Marvin-- pours a whisky and continues correcting :/
13:31:46 * shapr considers running off to shoot people in CounterStrike
13:32:28 <ludde> is alcohol & thinking a good combination?
13:32:35 <shapr> not for me
13:32:43 <ludde> :)
13:32:55 <Marvin--> works for the depression at least
13:32:58 <shapr> if I were correcting student papers, alcohol would probably help though :-)
13:33:36 <shapr> I enjoy teaching motivated students. I fear and loathe being forced to teach those who do not want to learn.
13:33:57 <Marvin--> oh I suspect most of them *want* to learn
13:34:02 <Marvin--> the problem is that they *don't* ;)
13:34:11 * shapr doesn't understand that
13:36:32 <shapr> ayrnieu: this postfix paper seems to require the flattening paper, have you already gotten that far?
13:36:41 <shapr> if I want to learn something, I just do.
13:37:17 <shapr> my only limitations are whether the information is available to me or not.
13:37:37 <Marvin--> nah, I shouldn't be too hard on them, I made mistakes too when I took the course myself
13:38:12 <shapr> humans learn best/fastest by doing, and by doing it wrong.
13:39:18 <Marvin--> shapr: cvs up now :-)
13:39:24 <shapr> ok :-)
13:39:37 <Marvin--> weird delay though
13:40:32 <shapr> yay hws!
13:41:40 <Marvin--> yup :)
13:42:13 <shapr> hm, he still has the inet_ntoa stuff in there
13:42:17 <shapr> I wonder if it'll compile now.
13:42:19 * shapr tries
13:42:27 <Marvin--> he said it would compile with 5.04
13:42:31 <shapr> spiffy
13:42:41 <Marvin--> (but he hadn't tested actually *running* it :))
13:43:08 <shapr> oh
13:45:04 <ludde> Marvin--: will you correct the smalltalk lab4:s ?
13:46:20 <Marvin--> ludde: I'm afraid so :(
13:46:33 <shapr> seems to compile happily
13:46:39 <ludde> how ambitious do they have to be? we submitted ours, but we're unsure if it's enough.
13:48:16 <Marvin--> shapr: goody
13:48:34 <Marvin--> ludde: we'll see... I don't have time to look at it right now :/
13:48:43 <ludde> ok
13:50:19 <shapr> seems to run
13:50:27 <shapr> let's see if it's really serving files....
13:51:48 <Marvin--> and what the *** is up with people who can't keep deadlines?!
13:53:49 <dark> Marvin--: They're students.  Suppose you're 18, living in a strange town away from your parents for the first time, with raging teenage hormones.  What's more important, getting an assignment in before the deadline, or making it with the girl in the other dorm?
13:55:10 <shapr> seems to work
13:55:20 <Marvin--> shapr: referring to dark or to hws? ;)
13:55:24 <shapr> hws
13:55:29 <shapr> but he's right :-)
13:55:36 <shapr> minor problem with HWS
13:55:59 <shapr> it tried to bind to port 80 when I ran it non-root, and did not bind, nor did it mention that fact
13:56:08 <Marvin--> heh
13:56:39 <shapr> oh boy
13:56:41 <shapr> it did mention that fact
13:56:51 <shapr> I have a 20MB error log
13:57:43 <Marvin--> 20MB?!
13:57:49 <shapr> yah, it kept trying to bind...
13:58:05 <shapr> one line of error log for each unsuccessful attempt to bind
13:58:21 <shapr> not good on a fast system
13:58:39 <Marvin--> ugh
13:58:47 <shapr> 250,000 times it tried to bind :-)
13:59:05 <Marvin--> lol
13:59:09 <hdaume> haha
13:59:17 <shapr> so, when do I get to write HWS plugins? ;-)
13:59:24 <dark> At least you know it's fast :)
13:59:28 <Marvin--> shapr: meh
13:59:31 <shapr> hah, that's true
13:59:41 <Marvin--> shapr: Next Sunday I suppose, I *have* to be finished by then :P
13:59:45 <shapr> w00, yay!
13:59:52 * shapr bounces happily
14:00:07 * Marvin-- wishes he could summon up some more enthusiasm as well :P
14:00:32 <shapr> thing is, I can use HWS for paying work...
14:01:00 <dark> Paying work, cool.
14:01:09 * shapr wants to get an xml-rpc HWS plugin
14:01:11 * hdaume wonders what this 'pay' thing is
14:01:28 <dark> hdaume: It's a way to Make Money Fast!
14:02:06 <Marvin--> 1. Write a Haskell Web Server
14:02:07 <shapr> I get the big bucks. both of them.
14:02:08 <Marvin--> 2. ???
14:02:10 <Marvin--> 3. Profit!
14:02:15 <shapr> right!
14:02:16 * shapr laughs
14:02:31 <shapr> marvin: is that a south park quote? the underwear gnomes?
14:02:35 <Marvin--> yeah
14:02:40 * shapr laughs more
14:02:44 <Marvin--> too bad it's a bit over-used
14:04:55 * shapr gives it up and runs off to play counterstrike
14:05:12 <shapr> bbl
20:28:23 <sethk> Hello?
20:54:27 <o3> afternoon
