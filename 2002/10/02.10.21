00:11:12 <Heffalump> morning
00:12:32 <Jii> gosh, it's -10 celcius here
00:13:24 <clausen> !!!!
00:13:33 * clausen never experience < -2 :)
00:18:31 <Jii> in january and february it's going to be near -30
00:18:40 <Jii> sucks ;-)
00:23:28 * clausen wants to go live in RJ.  35°C 100% every day baby yeah!
00:23:35 <clausen> 100% humidity
00:23:41 <clausen> (RJ == Rio de Janeiro)
00:25:01 <Jii> but snow is kinda nice too
00:25:11 <Jii> although i don't do much skiing anymore
00:27:25 * clausen can't tolerate cold weather :/
00:28:11 <Jii> we somehow get used to it :)
00:29:10 <Jii> it's funny how something like -5 C feels warm in january :)
02:35:44 <Jii> därk
02:52:03 <dark> hmm is there some simple way to do a reverse sort?
02:52:14 <dark> I guess there is (reverse . sort) :)
02:52:50 <Igloo> Or you could sortBy a function that sorts the other way round, which will be different WRT stability
02:53:46 <Igloo> reverse . sort . reverse is the simplest way to do it if you care about stability, though
02:54:03 <dark> Nah, I don't care about stability.
02:54:53 <dark> This is just sorting to prettify output.
02:55:07 <Heffalump> sortBy an inverted comparison function would be most efficient then
02:55:17 <Heffalump> reverse . sort would be least hassle
03:01:41 <dark> I wonder if I need to make a Util.Ord module to hold things like reversed compares and subcompares :)
03:01:54 <Heffalump> :-)
03:08:20 <dark> I have seven Util modules already.  My testament to the inadequacy of the standard libraries :)
03:09:35 <Heffalump> :-)
03:23:46 <dark> Hmm, laziness question: If I use sequence (or mapM), and then use only part of the resulting list, is the rest evaluated?
03:24:21 <dark> (This is in the IO monad)
03:24:29 <Heffalump> shouldn't be
03:24:59 <Heffalump> oh
03:25:03 * Heffalump thinks more carefully
03:25:23 <Heffalump> sequence [a,b,c] becomes
03:25:29 <Heffalump> do a' <- a
03:25:31 <Heffalump>    b' <- b
03:25:34 <Heffalump>    c' <- c
03:25:39 <Heffalump>    return [a',b',c']
03:26:18 <Heffalump> which desugars to a >>= (\a' -> b >>= (\b' -> c >>= (\c' -> return [a',b',c']))))
03:26:57 <Heffalump> and I think the bind operation in IO is strict
03:27:08 <Heffalump> though IO does have some lazy operations, e.g. file reading
03:27:30 <dark> Hmm.  I guess this is good and wholesome in some situations.  Especially sequence_ :-)
03:27:55 <dark> Oh well, time for another "let loop" :-)
07:20:42 <ludde> is "<expr2> ::= <expr3> { '+' <expr3> }" left or right associative?
07:21:20 <Heffalump> neither
07:21:34 <Heffalump> since it doesn't allow repetition of expr2s
07:22:01 <ludde> but { } is repeating
07:22:12 <ludde> EBNF syntax
07:22:51 <Igloo> If either I would say left
07:23:03 * cleverdra wonders if there's a QC language with more of a Haskellish nature.
07:23:15 <ludde> the alternative would be to write <expr2> ::= { <expr3> '+' } <expr3>
07:24:14 <Marvin--> I consider   <A> { <B> <A> }  to be right-associative and  { <A> <B> } <A>  to be left-associative
07:25:23 <Heffalump> oh, sorry.
07:26:00 <Igloo> My logic would be "<expr2> ::= <expr3> { '+' <expr3> }" -> "<expr2> ::= <expr3> '+' <expr3> { '+' <expr3> }" which is left sasoc if you put brackets round the left bit
07:27:52 <ludde> Igloo: that's what I thought too
07:36:18 <ludde> with artithmetical expressions you can use reverse polish notation to get rid of all the ( ), would it be possible to do the same thing with haskell code?
07:37:50 <Igloo> That only works because functions and data are distinct
07:38:09 <cleverdra> ludde - consider currying in that context.
07:38:09 <Igloo> Assuming I'm right in thinking that (1+2)*(3+4) == 1 2 + 3 4 + * in RPN
07:38:29 <ludde> Igloo: yeah that's RPN
07:39:13 <cleverdra> where f :: Int -> Int -> Int, how would you evaluate the RPN expression 1 2 f f ?
07:39:33 <Heffalump> f (f 1 2)
07:40:28 <ludde> i guess the problem is that with standard operators, you know the number of arguments in advance, but you can't know the number of arguments to haskell functions, since they can be partially evaluated?
07:40:32 <Heffalump> ludde: there was a paper about that in the Haskell workshop
07:40:36 * Heffalump looks for an online version
07:41:05 <Heffalump> the "New" section in http://www.eecs.usma.edu/Personnel/okasaki/pubs.html
07:41:07 <cleverdra> ludde - you still couldn't get rid of *all* the parentheses, or how would you pass (+1) to map?
07:45:08 <dark> You can get rid of all the parentheses by using $ everywhere :-)
07:45:24 <dark> And let expressions.
07:46:10 <ludde> Heffalump: cool
07:47:05 <Heffalump> :-)
07:54:27 <cleverdra> # seems fairly popular as a left-associative $
07:55:06 <dark> I don't think I've ever had a need for that.
07:55:41 <cleverdra> It's used in HaskellScript to mimic method invocation.
07:55:59 <dark> Ah, I see.
07:56:32 <Marvin--> oh, cool
07:57:22 <ludde> is # defined in the prelude?
07:57:43 <Marvin--> I keep trying to use # for comments
07:57:53 <cleverdra> whost <- getHostItem "WScript"; word <- whost # whostCreateObject "Word.Application"; word # W.setVisible 1; word # getDocuments ## add
07:58:01 <cleverdra> ludde - I don't think so.
07:58:19 <ludde> heh, why not use -> instead of # :=
07:58:20 <ludde> :=)
07:58:35 <Marvin--> because -> is used for function types?
07:58:36 <ibid> it's reserved?
07:58:44 <ludde> oh, oops
07:59:39 <dark> Hmm but does it need to be reserved?  The parser should be able to distinguish type signatures from expressions.  But it also conflicts with the lambda notation.
08:02:23 <dark> It should be possible to steal -> for this, I don't think it creates actual ambiguities.
08:12:55 <BlizzNL> How can a function which takes a MyType as a parameter return something of IO MyType ? (foo :: MyType -> IO MyType)
08:13:57 <Igloo> foo = return
08:15:45 <BlizzNL> Igloo: of course, thnx
08:15:56 <cleverdra> data Coin = Heads | Tails
08:16:24 <cleverdra> flipCoin = do n <- Random.RandomRIO (1,2); if n == 1 then return Heads else return Tails
08:16:42 <cleverdra> flipCoin :: IO Coin
08:17:50 <cleverdra> or 'return $ if n == 1 then Heads else Tails'
08:22:38 <cleverdra> and 'randomRIO'
08:55:01 <hdaume> morning
08:57:59 <o3> morning
08:58:07 <o3> i gotta stop this "start hacking at 2am" thing
08:58:43 <cleverdra> start getting up at 6AM
09:00:23 <o3> cleverdra: it'll all be okay after today (i have a presentation today, that's all :)
09:06:27 <dark> If I get up too early, I usually can't program all day.
09:07:03 <o3> dark: i find it hard to code during the day.  daytime is for going outside, enjoying sun, etc, not staring at monitors :)
09:07:22 <dark> o3: Not much chance of that in Finland :)
09:07:29 <dark> It's dark outside, and freezing.
09:07:59 <dark> I can't even go play in the snow, there's no snow yet.
09:08:11 <cleverdra> o3 - go outside, enjoy sun, stare at monitor =)
09:09:50 <o3> dark: move to australia? :)
09:12:14 <Marvin--> dark: we've got snow in Göteborg :P
09:12:22 <Marvin--> it's melting away though
09:12:36 <ludde> snow sucks
09:12:47 <dark> Marvin: Don't worry, you'll get more :)
09:13:07 <ludde> Marvin--: will you correct the exams?
09:13:19 <Marvin--> ludde: thank god no
09:13:20 <BlizzNL>  I have a function which expects a tuple with 2 ints. (foo :: (Int, Int) -> Int ) but I have another function foo2 which returns a tuple of floats. I want to do something like (foo foo2) but it complains it needs ints and gets floats. I know I can round them normally but now I don't because round doesn't work on a tuple. How can I solve this nicely?
09:13:30 <ludde> Marvin--: heh, ok.. marcin does it all by himself?
09:13:37 <Marvin--> ludde: yup, poor him
09:13:44 <ludde> hehe
09:13:48 <ludde> it's that bad?
09:14:00 <Marvin--> mainly, it's *a lot* of people
09:14:26 <ludde> okay
09:14:27 <hdaume> BlizzNL: roundTuble (a,b) = (round a, round b), right?  if round is the rounding function
09:14:32 <dark> I think there's a standard library function for f (x, y) = (f x, f y), but I forgot its name.
09:14:41 <dark> Maybe fmap works on tuples :)
09:15:08 <BlizzNL> hdaume: yeah great
09:15:18 <hdaume> dark: there's not, i don't think
09:15:45 <dark> Then maybe it's time for map2, map3, etc :)
09:16:21 <Marvin--> dark: doesn't Functor require a * -> * type?
09:17:11 <Marvin--> dark: yay, that's why tuples suck :)
09:17:16 <dark> Marvin: Hmm, yeah.
09:17:38 <o3> template haskell solves this problem, right?
09:17:44 <dark> Maybe there should just be a standard Pair type, using tuples for pairs is a bit of an abuse.
09:17:52 <dark> (Where a Pair is always two elements of the same type)
09:19:05 <hdaume> dark: yeah, but then you're going to have huge code duplication for Pair and (,) and it will get confusion (methinks)
09:19:13 <dark> Of course it would be nice to have a concise notation for pairs... an infix constructor maybe.
09:19:30 <dark> hdaume: We would have to go back in time and make everyone use Pair instead of (,) in the first place :)
09:19:58 <Marvin--> we need a haskell time machine
09:20:02 <Marvin--> maybe Guido'll lend us his?
09:20:25 <Marvin--> data Pair a = a :, b?
09:20:51 <Marvin--> or is , disallowed for operators?
09:21:42 <cleverdra> (,,) 1 2 3
09:22:00 <Marvin--> well, the (,,,,,,,,) things are special cases
09:22:08 <cleverdra> Yes, I see what you mean now.
09:22:26 <dark> Marvin: It seems to be disallowed.
09:22:29 <Marvin--> Prelude> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
09:22:36 <Marvin--> [insert cute pretty-printing]
09:22:53 <cleverdra> allowing it would be confusing, I think: [a,b] (a list of one element or two?)
09:23:18 <dark> cleverdra: This wouldn't be a bare comma... it seems that comma isn't allowed in the character set.
09:23:20 <cleverdra> err, bad example.
09:23:28 <Marvin--> Failed to find interface decl for `Data.Tuple.(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)'
09:23:29 <Marvin--> dang
09:24:02 <Marvin--> is here a zip63 function?
09:24:04 <dark> In any case, it would be data Pair a = a :, a
09:24:06 <dark> no b :)
09:24:26 <Marvin--> dark: yeah, the b was a typo on my part
09:24:40 <ludde> will haskell always evaluate things lazily?
09:24:56 <dark> ludde: that's a complicated question :)
09:24:58 <cleverdra> ludde - I think so, if it can.  Why?
09:25:10 <Marvin--> isn't ST strict?
09:25:22 <Marvin--> or "may be strict"?
09:25:25 <hdaume> ludde, if you don't tell it not to and if it won't make any difference (i.e., it might evaluate something strictly if you won't be able to tell)
09:25:31 <ludde> would it be okay to use "undefined" as a return value, if you are sure that the value should never be used
09:25:33 <dark> You can have strict elements of datatypes.  And there's a strictness operator.
09:25:44 <hdaume> (ST would be a way to tell it not to, as would strict datatypes, as would seq, etc...)
09:25:45 <Marvin--> ludde: I prefer to use (error "Don't evaluate this")
09:26:08 <ludde> hmm, okay
09:26:17 <Marvin--> ludde: but that depends on the context I suppose
09:26:26 <dark> Also, pattern matching can be stricter than you would expect.  Or at least, stricter than I would expect :)
09:26:29 <ludde> yeah.. but error is better in my context
09:26:36 <Marvin--> dark: re ~? :)
09:27:10 <ludde> is there some way to check if a value is undefined?
09:27:18 <hdaume> ludde: evaluate it :)
09:27:25 <ludde> but then it would crash :)
09:27:30 <Marvin--> ludde: how would you put it in Eq if it's undefined? :)
09:27:45 <dark> Marvin: Yeah but I'm also thinking of multiple cases, where the strict left-to-right top-to-bottom evaluation can lead to more strictness than I expect.
09:27:53 <Marvin--> ludde: go solve the halting problem first ;)
09:27:58 <dark> Hmm, I used "strict" in two different ways there.
09:28:03 <hdaume> ludde: no, that would be bad
09:28:06 <Marvin--> dark: true
09:28:39 <ludde> is there exception handling in haskell? so my exception handler would be invoked if someone tried to evaulate undefined ?
09:28:53 <hdaume> ludde: if it happens in the IO monad, you can 'catch' it
09:29:11 <ludde> using "try" ?
09:29:20 <hdaume> try...or catch...or bracket...
09:29:27 <ludde> okay
09:29:35 <hdaume> catch mightThrowAnException (\e -> print e)
09:29:50 <ludde> cool
09:30:00 <ludde> that one will catch uses of undefined ?
09:30:09 * hdaume thinks so...
09:30:14 <dark> I've never been able to use 'try'.
09:30:23 <ludde> I've used try a few times
09:30:33 <Marvin--> hdaume: but does undefined use that?
09:30:55 <hdaume> Marvin--: i think so...
09:30:57 * hdaume checks
09:31:19 <Marvin--> x <- return (1 == undefined) `catch` \e -> do putStrLn ("D'oh!" ++ show e); return False
09:31:21 <dark> Might be a GHC extension, actually.  It has richer exceptions than haskell98 requires.
09:31:29 <Marvin--> When I evaluate x I get  *** Exception: Prelude.undefined
09:31:43 <hdaume> hrm, yeah
09:31:48 <hdaume> i know i did this somehow
09:31:56 <Marvin--> and that's regardless of -fglasgow-exts
09:31:58 <Marvin--> or not
09:32:01 <ludde> but hmm
09:32:05 <hdaume> you have to use Exception.catch
09:32:16 <ludde> what is the value of x if the expression failed?
09:32:18 <Marvin--> ah
09:32:26 <ludde> ah
09:32:28 <ludde> never mind
09:32:39 <hdaume> off to get coffeee...back in a bi
09:32:40 <hdaume> t
09:32:44 <Marvin--> I'm off for dinner
09:35:09 <ludde> is there some function, maybe_default :: Maybe a -> a -> a, which returns the 2nd argument if the Maybe is Nothing, or the Just a value otherwise?
09:36:04 <dark> ludde: Probably fromMaybe in the Maybe module.
09:36:17 <dark> There's also a maybe function, which one is nicer depends on what you want to do.
09:36:19 <cleverdra> maybe_default Nothing x = x; maybe_default Just x _ = x -- otherwise
09:36:26 <ludde> cool
09:36:32 <ludde> cleverdra: err, yeah
09:36:37 <ludde> cleverdra: i know :)
09:36:49 <ludde> cleverdra: i just wondered if there was a built-in function already
09:36:50 <cleverdra> Oh, OK.
09:36:51 <dark> cleverdra: I prefer using library functions for greater readability :)
09:37:11 <cleverdra> Haskell Barbie: Knowing what's in the Prelude is *hard* =)
09:37:39 <dark> I often end up handling Maybe with a case, though.
09:37:59 <ludde> if there's a lot of Maybe:s you get a lot of case :)
09:38:01 <dark> I guess I'd be happier with a maybe function that took the Maybe type as its first argument, rather than last.
09:38:17 <cleverdra> flip maybe -- ?
09:38:29 <dark> maybe takes *three* arguments :)
09:38:49 <dark> I could define my own maybe, but that would damage the minds of innocent readers.
09:39:00 <cleverdra> oh.  rrot f a b c = f c a b
09:39:42 <cleverdra> (oops, that's 'rot'; rrot f a b c = b c a)
09:39:49 <dark> Hmm, I could roll it into a maybeM function.  Monads are where Maybe types get difficult.
09:40:25 <dennisb> maybe_default = flip $ flip maybe id
09:40:25 <dennisb> and don't say that haskell isn't fun
09:41:15 <ludde> i think it's hard to read code that uses those argument-fiddling functions
09:41:41 <dennisb> I don't think I would write that function like that, but it's fun anyway!
09:42:09 <hdaume> fwiw, in the case ofa  two argument function where i want to provide only the second argument, i like to use sections.  for instance (`fromMaybe` someMaybe)
09:42:22 <ludde> fwi
09:42:25 <ludde> fwiw?
09:42:27 <dark> ludde: It can be good if used sparingly.  For example I have this disassembly table that hands some opcodes to gen_add and others to flip gen_add
09:42:31 <hdaume> for what it's worth
09:43:02 <ludde> hdaume: yeah, i use that too
09:43:33 <ludde> hdaume: or.. hmm... I'd write it like (fromMaybe someMaybe) without the ´´, is that the same thing?
09:44:08 <hdaume> ludde: but that applies the first argument.  here's i'm assuming someMaybe has type Maybe a.
09:44:22 <ludde> oh
09:44:40 <ludde> i see
09:44:52 <ludde> another tool to my toolbox :)
09:44:55 <dark> So, does haskell need trinary sections?
09:45:06 <hdaume> yuck
09:45:37 <dark> It could be generalized with help of _
09:46:03 <dark> (f a _ c _ e) is a function that takes two arguments
09:46:30 <dark> Heh, I managed to scare off hdaume :)
09:46:34 <hdaume> :)
09:46:40 <ludde> dark: that's true
09:46:45 <cleverdra> hdaume?  *** Quit: hdaume ("(f a _ c _ e) is a function that takes two arguments")
09:46:46 <hdaume> someone actually suggested that...there's a full proposal for it, but i don't remember where it is
09:46:46 <dark> I guess at that point you might as well use lamdas.
09:47:04 <hdaume> for some reason my client crashed
09:47:14 <ludde> i don't quite understand how to use flip when the argument is not a function of two arguments
09:47:41 <ludde> then it will only flip the first two arguments, i guess
09:47:48 <dark> ludde: (flip f) a b c is just f b a c
09:47:48 <cleverdra> ludde - if the function takes three arguments, the result is a function that takes one argument
09:48:10 <dennisb> yes, all functions in haskell takes one argument
09:48:16 <cleverdra> What's the type of _ ?
09:48:22 <ludde> dark: ok
09:48:42 <dark> cleverdra: _ as a wildcard
09:49:22 <cleverdra> dark - I know that it is, in pattern-matching, but how does this relate to the interpretation of (f a _ c _ e) ?
09:49:37 <hdaume> the idea is that (f a _ c _ e)  ==> \b d -> f a b c d e
09:49:38 <dark> cleverdra: I was proposing an extension to section notation.
09:49:43 <dark> Well, not _seriously_ proposing :)
09:49:58 <hdaume> the problem is that what is (f _ (b _) (_ e))?  does it go in linear order?
09:50:03 <cleverdra> dennisb - that's true, but it's also confusing in the context of 'functions' that take multiple arguments.
09:50:10 <dennisb> cleverdra: you can see it as syntactic sugar
09:50:34 <cleverdra> dark, dennisb - *oh*, OK.  Nifty.
09:50:54 <dark> hdaume: hmm... no order at all, I think.  (f _ (b _) (_ e)) would become \a -> f a (b _) (_ e)
09:51:20 <dark> Where f just ends up getting two functions as arguments.
09:52:24 <dark> Erm, I'm not sure what (_ e) would mean :)
09:52:39 <hdaume> dark: so that's outer-in ordering :).  but then something like (f (_ a) _) would mean \b c -> f (c a) b
09:52:45 <hdaume> which i think is counterintuitive
09:52:45 <dark> \a -> a e perhaps?
09:52:48 <dennisb> _ e    ==>  \f -> f e
09:53:16 <hdaume> dark, dennisb: yeah, that is the intentions
09:53:34 <dark> hdaume: No (f (_ a) _) would be a function that takes _one_ argument.
09:53:56 <dark> f would take two arguments, the first of which is a function type.
09:54:10 <dark> Where f gets the other argument for (_ a) is its own business :)
09:54:20 <dennisb> I would say:   f (_ a) _   ==> \x -> f (\g -> g a) x
09:55:18 <dark> Yeah, what he said :)  But you need to keep the outer parens to make it a section.
09:55:23 <hdaume> dark, dennisb: right, so then (f (_ a) _) b c means (f (c a) b), which i think can be counter intuitive, becfause it essentially requires you to count parentheses
09:56:04 * dennisb don't get it
09:56:32 <dark> hdaume: I think you're somehow assuming that f will apply its third argument to its first argument.
09:57:28 <hdaume> let's just say it's not immediately obvious to me from looking at ((f _) _ (b (_ _)) which order the arguments will go in
09:58:02 <hdaume> but i would *expect* them to simply go in linear order.  that is ((f _) _ (b (_ _))) x y z q ==> ((f x) y (b (z q)))
09:58:39 <dark> Well, (f _) _ simplifies to just (f _)
09:58:56 <hdaume> i think in the proposal that was made, the idea was to number them, so you get something like ((f _#1) _#2 (b (_#3 _#4))) so you can anticipate the order
09:59:14 <dennisb> hdaume: that's not the proposal I would make
09:59:14 <cleverdra> dark - why doesn't that also simplify to 'f' ?
09:59:25 <dark> cleverdra: I guess it does :)
09:59:40 <dark> hdaume: But I would expect nesting not to change the meaning of a section :)
10:00:10 <hdaume> i dunno...to each his own...i think i would just find it very confusing :)
10:00:28 <dark> hdaume: Suppose f is just const.  I don't see why (const (_ a) _) should ever take more than one argument.
10:00:34 <cleverdra> Why couldn't the order be strictly left->right ?
10:00:52 <ludde> how does the list monad work?
10:00:53 <dark> cleverdra: To preserve the meaning when nesting them.
10:02:00 <dark> If I nest sections, I don't expect weirdness when I do (map (+1)) fs.  Why should fs become the first argument to +?  Same if I do (map (_ + 1) _) fs
10:02:08 <hdaume> ludde: it's like nondeterminism
10:02:24 <ludde> hdaume: how do you mean?
10:03:09 <hdaume> dark: true...i still don't like it tho :)...i think _ to me implies too much linear ordering
10:03:22 <hdaume> hdaume: think of the list as storing all possible outcomes of the computation
10:03:23 <dennisb> take the example (const (_ a) _) and compare it to (const (+ a) _)
10:04:41 <dennisb> the first argument to const is a function in each case. Just because you have several _ in the same expression does not mean that you would change the whole expression to a function filling in these _
10:04:49 <dark> dennisb: That's a bit of an awkward example, since + is an operator and _ presumably is not.
10:04:59 <dark> This changes the role of a in (+ a)
10:06:50 <dennisb> well, forget about the example :-)
10:07:08 <dark> I'll stick with (map (_ + 1) _) as example :)
10:07:20 <dennisb> I like the _ at least
10:07:39 <dennisb> dark: that's a better one
10:08:17 <dennisb> I somehow didn't see your example before, but now I see it above
10:09:08 <cleverdra> (map (_ 1) _) (-) [1..]
10:09:18 <cleverdra> (map (_ 1) _) [1..] (-)
10:10:04 <dark> Anyway... it's probably just as easy to write it out with lambda, and a lot clearer :)
10:10:56 <dark> cleverdra: I think those would be mistyped.  The _ in (_ 1) comes from the list.
10:10:57 <dennisb> map (_ 1) _   ==>  map (\f -> f 1) _   ==>    \xs -> map (\f -> f 1) xs
10:11:39 <cleverdra> dark - I realized that the first was wrong, yes.
10:12:01 <cleverdra> but... now I realize that both are wrong.
10:12:07 <dark> Unless you're using hdaume's semantics.  I guess this would be an opportunity to compare usefulness.
10:13:20 <dark> Writing these out with sections or lambda might be better in all cases :)
10:13:59 <cleverdra> What are 'sections'?
10:14:18 <dennisb> dark: maybe it is, but in some cases it might be useful. There are lots of constructs that can be missused anyway
10:14:32 <dennisb> cleverdra: expressions like (+4)
10:15:17 <cleverdra> ah.
10:17:16 <dark> dennisb: Yeah but it should earn back the cost of explaining it to new Haskell programmers :)
10:18:34 <dennisb> dark: agree, lambdas are not so bad after all
10:18:44 <ludde> bleh, why do I get:
10:18:44 <ludde> Action: openFile
10:18:44 <ludde> Reason: file is locked
10:18:51 <ludde> i'm the only one accessing the file
10:19:42 <dennisb> ludde: use lsof if you got it and make sure noone else is using it
10:19:59 <ludde> dennisb: i'm sure no one is using it, it's a temp file.. it has a random name
10:20:25 <ludde> i'm doing both readFile and writeFile on it though
10:20:37 <ludde> maybe haskell doesn't close the file properly between the reads and writes?
10:20:40 <hdaume> ludde: that's probably a bad idea :)
10:20:43 <dennisb> ludde: true
10:20:46 <hdaume> haskell is *really bad* at closing files
10:20:48 <hdaume> :)
10:20:56 <ludde> how should I do then? :)
10:21:08 <hdaume> use openFile and hClose explicitly
10:21:10 <dennisb> ludde: open and close the files yourself
10:21:15 <ludde> oh, hrm
10:21:32 <dennisb> but even then it can be a problem due to the strange semantics of hClose and lazy evaluation
10:21:59 <cleverdra> alternatively, you could open in read-write, seek to the beginning of the file, and then truncate after writing.
10:22:08 <hdaume> yeah, but it's not nearly as bad, because using readFile leaves the file in a "semi-closed state", whereas hclosing it will actually close it
10:23:00 <dark> Hmm I didn't know that.  I'll have to check my own readFile usage :)
10:23:38 <dark> If I evaluate the length of the string returned by readFile, can I be sure the file has been closed?
10:24:44 <hdaume> nope
10:25:11 <hdaume> because what if the handle isn't to a file, but to stdin or a socket or something.  there might be more there at some point in the future, even if you've read all that's there now
10:25:37 <dark> I thought that would just make length not terminate.
10:26:21 <hdaume> dark: i don't think so, but i could be wrong.  if you do 'main = interact (show . length)' it will work fine
10:27:37 <dark> Hmm.  There's a point where I did length contents `seq` hClose hdata, in the belief that that would work.
10:27:44 <Marvin--> hdaume: but not until it gets an eof, right?
10:28:02 <Marvin--> eek, seq
10:28:04 <dark> And other points where I rely on readFile closing the file once I've used all of the returned data.
10:28:19 <dark> Marvin: It's the only way I knew to be sure I had all the data before closing the descriptor :)
10:28:19 <hdaume> dark: that's a bad assumption
10:28:54 <dark> hdaume: I don't consider it "all used" until I've seen the [] :-)
10:29:34 <hdaume> yes, but just because you've seen the [] doesn't mean the file will be closed
10:30:07 <hdaume> i use a combination of deepSeq and the 'readFileClose' and 'readFileCloseBy' functions defined in http://www.isi.edu/~hdaume/Util.hs
10:30:39 <Marvin--> aaaaaaaaaaaaaargh
10:30:58 <hdaume> :)
10:31:01 * Marvin-- got a mail from one of his students full of "u" instead of "you"
10:31:05 <Marvin--> hdaume: not that ;)
10:31:24 <hdaume> hehe :)
10:31:33 <hdaume> i don't see what u think is wrong with that
10:32:03 <cleverdra> Marvin - reply: "I tried to read your message, if it was a message (my Cryptanalyst says 'yes', though he can't decipher it), and failed.  Please re-send in English."
10:32:15 <hdaume> haha
10:32:24 <dark> hdaume: Your beginsWith looks like isPrefixOf from Data.List :)
10:32:32 <cleverdra> Marvin - or at least not Hyperreductionist X, where X is a language.
10:32:42 <Marvin--> cleverdra: :-)
10:33:07 <ludde> u r 5t00p1d! My 14b 15 c0rr3c7 bu7 u f41l3d 17!
10:33:25 <ludde> Marvin--: what would you do if you got that? ;)
10:33:40 <Marvin--> ludde: reply "u 5uXx0rz"
10:33:56 <ludde> hehe
10:34:00 <Marvin--> or maybe a few more z at the end
10:34:22 <hdaume> dark: yeah, i know :)...i wrote a lot of that when i was unfamiliar with much of the std libs
10:34:32 <ludde> Marvin--: in that mail you just got, why not answer with u and lots of silly acronyms, in the reply you write? :)
10:34:57 <ludde> Marvin--: then he'll see how bad it looks
10:34:57 <Marvin--> hdaume: isn't splitWhile pretty much span? :)
10:35:00 <Marvin--> ludde: :)
10:35:32 <cleverdra> Yes.  Hypererudite replies to Hyperreductionism!
10:35:41 <Marvin--> yay, map2, map3 and map4 ;)
10:35:47 <cleverdra> Or you could quote his message with appropriate translations.
10:35:51 <dark> But different map2 than I would want :)
10:35:58 <Marvin--> dark: true
10:36:14 <dark> hdaume: Looks like you're going to have pieces torn off your module :)
10:36:49 <Marvin--> hdaume: and why isn't Errored a monad? ;)
10:37:05 <hdaume> hdaume: because i didn't know about monads back then :)
10:37:23 * Marvin-- waves to hdaume *over here*
10:37:52 <hdaume> i haven't touched that code for a while out of fear that it would break some of my programs :)
10:37:56 <Marvin--> heh
10:37:58 <hdaume> even though much of it is terrible
10:38:17 <cleverdra> Where could I find an example of a small program that creates and uses a monad?
10:39:24 <dark> hdaume: Maybe it's time to look at the DEPRECATED pragma :)
10:39:42 <hdaume> dark: haha...good point.  i have better things to do with my time, though, like chat on #haskell
10:39:56 * hdaume wonders if you can deprecate an entire module :)
10:40:13 <dark> I don't know about small, but http://www.xs4all.nl/~dark/mage-1.0pre35.tar.gz defines and uses a RandT monad.
10:40:25 <dark> Oh, RandT is a monad transformer, that might be out of bounds for "small" :)
10:40:52 <dark> hdaume: Yeah... put it in a separate package called "sucks" :)
10:40:53 <Marvin--> celeverdra: http://www.google.com/search?q=monads+working+haskell+programmer
10:41:10 <hdaume> dark: now that's just mean ;)
10:41:11 <Marvin--> hdaume: I was about to suggest mv $1 deprecated/ ;)
10:41:36 <dark> I'd like to have RandT as a straight monad, actually, but that would mean duplicating much of the State monad.
10:41:49 <cleverdra> for x in ...; do yes|mv $x deprecated; done
10:41:49 <Marvin--> .oO(we need a hsh so we can write 'flip mv deprecated' instead)
10:42:45 <dark> Marvin: hsh wouldn't be difficult, just write the appropriate module and run ghci
10:43:19 <Marvin--> dark: I know :)
10:43:30 <hdaume> dark: yeah, but then you have to write things like 'ls ["-l",".."]' which is just ugly
10:43:37 <dark> cleverdra: You use Red Hat?
10:43:46 <cleverdra> dark - no.  Why?
10:44:01 <dark> cleverdra: I wondered why you'd think mv needed "yes" piped into it :)
10:44:32 <Marvin--> maybe it's easier to write a 'flip' shellscript ;)
10:45:03 <cleverdra> ah, no; I use a derived distribution that appears to have -i functionality all the time.
10:46:22 <dark> Marvin: I think it could be a one-line function :)
10:48:44 <cleverdra> main = do a <- getArgs; putStrLn $ unwords a
10:49:15 <dark> That reminds me, does anyone know why getArgs and getProgName are IO actions?
10:49:30 <dark> I don't see why they would change during execution.
10:50:02 <cleverdra> They would change between executions; is that important?
10:50:10 <ludde> they depend on the outside world?
10:51:08 <Marvin--> dark: feel free to use unsafePerformIO and see what blows up
10:51:22 <dark> Marvin: This was the route I was hoping to avoid :)
10:51:30 <Marvin--> dark: :)
10:51:51 <dark> Currently I'm doing nasty tricks with embedding %P in strings and expanding it to getProgName later.
10:53:04 <Marvin--> **shrug** try to define progName = unsafePerformIO getProgName...?
10:53:42 <hdaume> i got the impression from Koen that there was actually a pure version of that function
10:54:56 <Marvin--> oh? Can't say I know of that
10:55:02 <dark> Marvin: Not unless I'm sure it won't blow up for anyone else either.  This is in a version control system :)
10:55:18 <dark> Well, s/system/tool/.  It's a single program.
10:57:01 <Marvin--> hdaume: any clue on the name of that function?
10:57:06 <Marvin--> bring out Ye Olde grep?
11:00:55 <hdaume> no idea :)
11:04:56 <dark> Hmm, getProgName is not even as lightweight as I expected.
11:05:12 <cleverdra> How not-lightweight is it?
11:05:47 <dark> It allocates space for a copy of the entire arg array, and then does some parsing to get the basename of arg 0.
11:06:33 <dark> No, I'm misreading... it just allocates space for two pointers.
11:07:29 <cleverdra> and it still gets the basename?
11:07:48 <dark> Yeah.
11:08:09 <cleverdra> sigh.  Information-losing.  Is there a related function that doesn't do this?
11:09:43 <dark> There doesn't seem to be.  And the basic function getProgArgv isn't exported.
11:10:08 <dark> Hmm, but it's a ccall... it should be possible to declare another ccall to it in my own code :)
11:10:48 <dark> the unsafeIO approach might actually be more safe than that, though.
11:11:07 <cleverdra> Why do you think so?
11:11:28 <hdaume> i can't think of a situation where the upIO wouldn't be safe
11:11:30 <dark> Well, I have no guarantee that getProgArgv will keep the same type in the future.
11:14:27 * hdaume is off to a midterm...bbl
11:18:04 <BlizzNL> I am having some problems within a do statement. I want to do something like:
11:18:11 <BlizzNL> -> do if SomeClauseTrue the drawInWindow w (lineto x1 y1 x2 y2)
11:18:14 <BlizzNL>    return (s) -- return the string in no matter what (so i don't use else) but hugs is quarrelling with me 'bout it ;)
11:18:39 <BlizzNL> s/the/then
11:19:43 <Marvin--> BlizzNL: you must have an else
11:20:23 <Marvin--> BlizzNL: you could do if foo then bar else return (); return s
11:20:32 <Marvin--> BlizzNL: or use the 'when' function in Monad :-)
11:21:22 <BlizzNL> Marvin--: yeah when is nice, but that's not the point I need to return a string because the type of my function requires this
11:27:52 <Marvin--> BlizzNL: uh
11:37:06 * cleverdra takes a moment to ponder the logic of using nonfunctional JavaScript links to 'wav' files when functional HTML would suffice.
11:37:28 <Marvin--> http://www.hamsterrepublic.com/james/technomancy/
11:37:33 * Marvin-- laughs
11:39:09 <cleverdra> Yes, that's funny =)
11:41:10 <Marvin--> http://www.hamsterrepublic.com/james/bitphysics/ <- pretty good too
11:43:04 <ludde> how do I rewrite "forall a. LiftIO (IO a) (a -> Html)" so it only allows a such as (Read a,Show a)
11:44:49 <cleverdra> forall a. (Read a) (Show a) => LiftIO (IO a) (a -> Html)
11:45:32 <Marvin--> I'd say (Read a, Show a) => ...
11:46:40 <ludde> yes, thanks
12:23:43 <Marvin--> Would it be horribly ugly to pass a version number in mkTyCon when instantiating Typeable?
12:24:53 <Marvin--> instance Typeable Plugin where typeOf _ = mkAppTy (mkTyCon "...PluginV1") []
12:44:11 <andersca> hey Marvin--
12:44:36 <Marvin--> hullo
13:11:48 <dark> I wonder if I should make a module The.Usual which exports the modules that I use a lot :)
13:12:16 <Marvin--> andersca: the kennyfier was extraordinarily silly
13:12:17 <Marvin--> :P
13:15:00 <Marvin--> dark: siiigh :)
13:15:26 <Marvin--> import The.Usual (suspects)
13:33:41 <argv[0]> greetings
13:35:12 <dark> At some point I'll have to deal with signal handling.
13:35:23 <Marvin--> uh, I'm having problems understanding Parsec
13:35:26 <Marvin--> maybe I'm too used to Parsek
13:35:55 <Marvin--> Is there no basic "symbol" parser?
13:36:01 <Marvin--> I suppose the type would be Genparser tok st tok or something
13:39:40 <Marvin--> maybe I should use ReadP instead :)
13:45:30 <argv[0]> I've to do an n-tree that doesn't have a limited element number, to support things like a dictionary or a HD file tree. Any suggestions how can this be done?
13:49:06 <Marvin--> use a list?
14:12:13 <toadx`> "nice shooting captain"
14:18:14 <Clase> hi
14:18:20 <Clase> 4[dark4] 1
14:18:23 <Clase> thx for all
14:18:29 <Clase> finally i encounter the solution
14:18:50 <Clase> i only have come back for this
14:22:17 <Clase> now i must go
14:22:22 <Clase> thx again
14:22:22 <Clase> bye
14:22:51 <dark> Hmm, he never actually said what the problem was.
14:26:06 <Marvin--> and what's up with the colours anyway? :)
14:47:21 <Marvin--> I wonder how hard it would be to use SSL from haskell
14:51:52 <dark> Probably not much harder than using it from C, which is "pretty hard because there's hardly any documentation".
14:52:07 <Heffalump> just need to write the appropriate FFI stuff, I'd guess
14:52:32 <dark> I'd like to recommend focusing on GNU TLS rather than OpenSSL, to avoid licensing issues.
14:53:46 <Marvin--> true
14:53:57 <Marvin--> dark: hey, I know that, I've written a python module for openssl that we use at work :/
14:54:10 <Marvin--> 'course that was when GNU TLS was GPL and not LGPL
14:54:14 <dark> *sigh* I'll never get anywhere until I learn to spell "continuation" in one try.
14:54:20 <andersca> oh GNU TLS is LGPL now?
14:54:35 <Marvin--> andersca: yeah, it's been for a while, afaik
14:54:39 <andersca> yay
14:54:49 <andersca> the mozilla psm is lgpl too, right?
14:54:50 <Marvin--> andersca: someone *finally* convinced them that it was better
14:55:04 <Marvin--> andersca: isn't it (mpl or gpl)?
14:55:20 <andersca> all of mozilla is getting mpl+gpl+lgpl licensed
14:55:22 * andersca checks
14:56:29 <andersca> hmm, just mpl + gpl :/
14:56:55 <Marvin--> that's what I thought
14:59:34 <Marvin--> Heffalump: I don't know much about the FFI... How hard is it to map haskell list -> dynamically allocated C array with some terminator?
15:00:01 <Heffalump> I believe not hard, but I've used it very little, and in particular not since the standard was created.
15:00:48 <Marvin--> hmm, an array is C is mostly a ptr... Can the 'foreign import' handle pointer-to-pointer stuff?
15:01:33 <Heffalump> you'll need to write marshalling functions
15:01:52 <Heffalump> so foreign import the C function, and you'll end up with a function from Ptr -> Ptr or whatever
15:02:03 <Heffalump> then do the appropriate things to turn the list into a Ptr and back from a Ptr into a list
15:03:10 <Marvin--> ugh
15:03:40 <Heffalump> I think there's helper functions for this
15:03:45 <Heffalump> what did you expect? :-)
15:03:56 <Marvin--> I dunno
15:04:09 <Marvin--> guess I'm spoiled with the Python<->C layer
15:04:23 <Heffalump> how's that work?
15:04:55 <Marvin--> you can do just about anything from C that you normally do from Python
15:05:12 <andersca> yeah, it's cool
15:05:16 <Marvin--> all values are PyObject:s (or at least casted to PyObject:s)
15:06:10 <Heffalump> ah, so all the marshalling is done at the C end
15:06:24 <Marvin--> yeah, with a very rich API
15:06:34 <Heffalump> if you want to translate from something horribly type unsafe like C to something type safe like Haskell you'll need to do some work
15:06:39 <Marvin--> (not to mention well-documented)
15:06:44 <Marvin--> yeah
15:07:17 <Heffalump> read the FFI addendum and the GHC docs on doing FFI
15:07:27 <Marvin--> FFI addendum? whazzat?
15:07:51 <Marvin--> I think I found it
15:08:55 <Heffalump> linked from http://www.haskell.org/definition/
15:09:14 <Marvin--> I'd want to map some integer constants (or defined perhaps) to data types in Haskell I suppose... so you'd have  protocol_set_priority :: Session -> [Protocol] -> IO ()
15:10:46 <dark> hsc2hs might help with that.
15:11:21 <dark> It allows you to refer to constants defined in C header files.
15:12:26 <dark> If what's in the header files happens to be standardized, you could use a carefully constructed data declaration with a deriving Enum clause.
15:12:54 <Marvin--> eew :)
15:13:11 <dark> I think I did something like it once and just brute-forced a function definition that mapped (#const FOO) to Foo for each foo.
15:14:05 <dark> Anyway, I did an FFI module for ncurses in two days so it can't be hard :)  curses is the ultimate test of any C compatibility layer.
15:14:21 <dark> I had colors and line-drawing characters and everything.
15:14:29 <Marvin--> hehe
15:15:18 <dark> Being compatible with other implementations than ncurses would have been much harder... but the last time I saw such a system was in 1994.
15:16:55 <dark> Hmm, now I have a need for constructing elaborate pipelines from haskell, involving tar and gzip :)
15:17:52 <dark> I don't trust the popen function in hslibs/posix, it seems to assume that pipes have arbitrary amounts of buffering.
15:18:59 <Marvin--> hey shapr
15:19:24 <shapr> hi Marvin--, how's life?
15:19:33 <Marvin--> shapr: stressed, and tired
15:19:49 <shapr> yow
15:19:54 <shapr> too many papers to correct?
15:20:01 <Marvin--> yeah
15:20:05 <Marvin--> plus the exam today ;)
15:20:22 <Marvin--> and I don't know how much work the plugin stuff is, so I'm uncertain how far I've gotten
15:20:56 <shapr> I don't know what you endpoint is, but I would suggest switching ErrorLogger and AccessLogger to plugins
15:21:08 <Marvin--> dark: I suppose you could use hsc2hs at compile time, so it would be right<tm> every time
15:21:12 <shapr> since they're already integrated modules, that should be straightforward
15:21:21 <shapr> (I think)
15:21:23 <dark> Marvin: Exactly.
15:22:06 <Marvin--> shapr: the ErrorLogger is kinda tricky, since errors happen pretty much at any time... I don't think even apache has pluggable error loggers
15:22:21 <shapr> interesting point
15:22:30 <dark> Marvin: It doesn't work well when crosscompiling, unfortunately.
15:22:33 <shapr> well, why not start with AccessLogger and go on from there?
15:22:45 <dark> But I think ghc doesn't really cross-compile anyway.
15:23:10 <Marvin--> shapr: actually, the end point I have in mind is to completely rip out HWS's control structure and use plugins, plus provide a "core" plugin that does all HWS does
15:23:29 <shapr> that sounds *extremely* cool to me, and that's what I'd like to see also
15:23:51 <shapr> of course, at that point the webserver is a plugin that can load other plugins, right?
15:24:10 <shapr> marvin: are you thinking TwHisted as loudly as I am? ;-)
15:24:14 <Marvin--> but I'm afraid that either I'll have to radically change what a "request" and "response" in hws is, or handler funcs will have an icky type
15:24:22 <Marvin--> shapr: no I'm not :)
15:24:25 * shapr laughs
15:24:51 <Marvin--> shapr: but pbhs is an intriguing thought
15:25:17 <shapr> banana is finished, I'm working on jelly atm
15:25:24 <dark> Hmm, maybe I can use FFI to link to libz, and save myself a process.
15:25:49 <Marvin--> Man do I find weird links when searching for haskell stuff
15:25:54 <Marvin--> (like http://www.angelfire.com/ks3/loveshack/main/s8/8x08.html )
15:26:22 <Marvin--> shapr: cool
15:26:41 <shapr> problem with jelly is that [1] gets jellied as ['list',1]
15:26:43 <Marvin--> shapr: my latest crazy idea is hssl ;)
15:26:53 <shapr> hey, could be done...
15:26:59 <shapr> easier than you think
15:27:01 <Marvin--> of course it could
15:27:12 <shapr> I mean, with less work than you think
15:27:13 <Marvin--> but I really don't have the time ;)
15:27:25 <shapr> Dominic Steinitz wrote an LDAP browser in Haskell
15:27:45 <shapr> I have an older version of it lying around, it already does BER encoding of ASN.1
15:28:10 <Marvin--> I wasn't planning on doing an RFC-compliant implementation, I was thinking of interfacing with e.g. gnu tls
15:28:24 <dark> Marvin: Do you handle gzip compression in your code?
15:28:38 <shapr> so with jelly, I tried to figure out how to unify the type of any random list with [Char], but I think it's impossible.. so I figured I'd do it in the PB server thread
15:28:44 <Marvin--> dark: no, feel free to add a gzip plugin when I'm finished ;)
15:28:48 <shapr> just make it so when it jellies it
15:28:56 <dark> Marvin: I was hoping to borrow gzip code from you :-)
15:29:03 <Marvin--> dark: *pphhbbbt*
15:29:22 <dark> Marvin: I'll probably write an FFI module for libz tomorrow, you might be interested :)
15:29:29 <Marvin--> coo'
15:31:34 <dark> Oh, one thing I noticed with FFI is that due to ghc's eager inlining, you often have to #include the appropriate header files in all your modules.  There's a command-line option for that.
15:34:40 <Marvin--> yeah, that's the problem with inet_ntoa, was it not?
15:35:23 <dark> inet_ntoa was much worse, it inlined a function call that wasn't in any header :)
15:35:47 <dark> I "fixed" it by defining a copy of my_inet_ntoa in my own header workaround.h
15:35:48 <Marvin--> oh, right
15:36:06 <Marvin--> hrrrm, I need a catchier name than HWSWP
15:36:39 <dark> Yeah, definitely.  I'm surprised you could even start coding with that name.  I thought having a cool name was the first requirement :)
15:36:52 <Marvin--> not in my world
15:36:55 <Marvin--> :)
15:37:12 <dark> There are two requirements for hacking project names: 1. Must be a cool pun or acronym, 2. must need a FAQ entry explaining how to pronounce it
15:37:48 <Marvin--> (though when creating an imperative language for an assignment, a friend and I implemented a subset of python and called it 'warpd', which stands for 'warpd: a ridiculous python dialect')
15:38:34 <Marvin--> dark: and you must have a flashy web site, an ftp, a public cvs repository et.c. et.c. before you can even think of getting anything done
15:38:45 <andersca> was it dynamically typed?
15:39:01 <Marvin--> andersca: no, that's part of why it was ridiculous :-)
15:39:06 <andersca> haha
15:39:11 <Marvin--> but it *looked* like python ;)
15:39:51 <Marvin--> andersca: y'all have been pretty boring, it's all been either ada/pascal or c/java
15:40:09 <Marvin--> some cool things, but not many
15:41:01 <dark> Marvin: Never needed any of those :)  Besides, a cvs repository for a competing version control system would be silly.
15:41:34 <Marvin--> dark: You haven't read http://www.hamsterrepublic.com/james/technomancy/ then? :)
15:42:32 <Marvin--> (read esp. the part on Open Sourcery)
15:42:34 <andersca> Marvin--: we wrote a functional language for lab4 though
15:42:41 <Marvin--> andersca: yay
15:42:46 <Marvin--> andersca: so did we :)
15:42:55 <andersca> but it's monomorphic
15:43:23 <Marvin--> we had *cough* type inference
15:43:32 <andersca> that's very nice
15:43:54 <andersca> I was pondering adding support for polymorphic types
15:44:19 <Marvin--> it was also very tricky ;)
15:44:27 <andersca> I can understand
15:44:53 <andersca> dennisb is doing some interesting work on type specialization
15:45:00 <Marvin--> yeah, I read a bit about it
15:45:45 <andersca> it's cool that a function can be of type Int 5 -> Int
15:45:46 <andersca> :)
15:46:09 <dark> Marvin: This technomancy sounds like a good base for a role-playing game.
15:46:19 <Marvin--> dark: heh
15:47:08 <Marvin--> man I gotta sleep
15:49:23 <shapr> bwahaaa.. fenestredigitation
15:49:45 <dark> Cool, there's a libtar :)  I won't have to pipeline anything, I can just be lazy.
15:49:53 * shapr laughs very much
15:50:07 <shapr> that's great url
15:50:18 <shapr> it's also true... we learn magic spells all the time
15:50:28 * shapr is trying to master the magic of Arrows
15:50:40 <dark> Now I just need a gunzip :: String -> IO String that returns a lazy list.
15:51:03 <dark> Hmm.  Actually it should be [Word8] or something instead of String.  But hGetContents pretends to return String.  I bet it never heard of utf-8.
15:51:45 * shapr thinks that's a sucker bet
15:52:17 <dark> I might have to tinker with the guts of the IO module and make a hGetBytes or something.
15:52:30 <shapr> I think there's a way to do it, but I've forgotten what it is.
15:52:46 <shapr> check the haskell mailing list for the recent thread on lazy file io
15:53:14 <dark> Well I don't _want_ utf-8, I have 20 MB of gzipped data to decompress into a tarfile :)
15:54:19 <shapr> yow
15:54:24 <dark> In fact I might prefer a list of Array CChar buffers.
15:54:33 <dark> Or something similar :)
15:54:54 <dark> Yeah in this case I need to pipe a lot of data straight through my program.
15:55:15 <dark> Haskell doesn't seem well suited to that, even though I don't really need to touch the data with the Haskell code.
15:55:48 <dark> GHC seems to have an interface for reading from a handle into a buffer, but it's based on the old-style mutable arrays.
15:58:35 <dark> Hmm, even fdRead from hslibs/posix/PosixIO returns a String.
15:58:45 * hdaume returns
15:58:48 <shapr> hi Hal
15:58:53 <dark> In fact it goes to a lot of trouble to do so :(
16:02:58 <dark> I might have to make my own module for bulk data transfer.
16:12:22 * shapr reads docs
16:36:51 <o3> hmm, does anybody here know how to get rid of the date in latex's \maketitle command?
16:37:03 <o3> googling doesn't do much :(
16:50:42 <hdaume> \date{}
16:52:25 <o3> hdaume: you rock; merci!
16:55:25 <hdaume> :)
16:58:21 <o3> hdaume: now my one-page summary really is one page :)
17:00:02 <hdaume> you could always also use the bad \addtolength{\...}{1cm} or whatever :)
17:00:09 <hdaume> those remind me of unsafePerformIO  though :)
17:04:00 <o3> yeah, i was making my own title and using evil things like \Large and \vskip :)
17:41:49 <dark> Okay.  I'm making a module for passing around blocks of opaque data which I call Chunks.
17:42:06 <dark> Now I have to resist the extreme temptation to call the write-chunks-to-handle function "hBlowChunks".
17:42:45 <Heffalump> lol
