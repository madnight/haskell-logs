01:22:23 <Marvin--> morning blizz
01:36:22 <BlizzNL> hi Marvin--
01:59:43 <Marvin--> hmm, wonder if there are any curses bindings for haskell
02:15:20 <Igloo> If I had a pound...  :-)
02:16:14 <Igloo> Marvin: Hetris defines a partial direct interface - it should be fairly obvious how to extend it. www.comlab.ox.ac.uk/oucl/work/ian.lynagh/Hetris/ I think
02:20:12 <Marvin--> coo'
02:20:33 <Marvin--> I've been thinking on writing a breakout game in haskell, the stuff hetris uses are probably enough
02:21:09 <Marvin--> (just to taunt my brother who's been writing breakout in C++ as an assignment)
02:21:23 * Igloo should look at Hetris again and try to decide what to do about ACS_BLOCK etc
02:24:26 <Marvin--> the Hetris definition of a Piece is very cute :-)
02:25:24 * Marvin-- starts thinking of cyclic groups and Tetris being NP-hard
02:26:11 <Igloo> Thanks  :-)   Do you mean how it uses infinite lists for rotation?
02:26:40 <Marvin--> yeah
02:27:25 * Marvin-- hums and sings to Blind Guardian
02:27:27 * Igloo was thinking of either writing a Hetris AI or trying to show it was either always possible or find a counter example, but this might be beyond my means and is certainly beyond my current free time  :-)
02:28:08 <Marvin--> heh
02:29:05 <Igloo> I'd also like to write a GTK frontend so I can say "Look! See! Abstract modules good!
02:29:26 <Marvin--> Hmm, does vim 6 use mysyntaxfile?
02:30:01 <Marvin--> I'm having weird problems with lhaskell.vim
02:30:32 <Marvin--> when I'm opening a file from disk it looks just great, but when I have hidden the buffer and brings it up again, the code is all in the 'comment' colour
02:31:04 <Igloo> I don't use multiple buffers
02:31:12 <Igloo> What does ":set syntax" say?
02:31:27 <Marvin--> lhaskell
02:31:37 <Marvin--> I use plenty of buffers in gvim
02:32:12 * Igloo -> comlab
02:44:45 <Marvin--> hmm, cute, I didn't know you could "cast" stuff to abstract data types with the ffi
03:10:10 <Igloo> DYM Ptr Window?
03:17:29 <Marvin--> yeah
03:19:52 <Marvin--> --- Topic for #debian-devel is Use Haskell, the spicey programming language!
03:20:29 <Heffalump> cool, how come?
03:21:53 <Marvin--> I have no idea :)
03:22:04 <Heffalump> the person who set it has disappeared
03:22:08 <Heffalump> oh well
03:22:14 * Heffalump disappears too
03:43:33 <dash> spicey?
03:43:39 <dash> i figured that would be Cayenne
03:56:52 <Marvin--> yeah
04:56:23 <Blizz_> Can I use the partitioning programs provided with the RH8 cd under windows?
04:56:33 <Blizz_> oeps wrong channel ;)
04:56:50 <dark> Sure, if you import Data.List first :-)
04:57:15 <Blizz_> dark: great ;)
04:58:11 <cleverdra> blizz - you can use those partitioning programs that are meant to work under windows; the ones you use during normal installation are for Linux.
04:59:16 <Blizz_> yeah but I have a pc that doesn't boot from cdrom so I'll have to do it another way
04:59:33 <dark> For some reason there's no System.Devices.Disk.PC.MBR module.
05:00:02 <dark> Hashell will get nowhere this way :)
05:00:21 <cleverdra> blizz - the CD should have floppy images on it; I think redhat needs two.  rescue.bin and root.bin ?
05:04:51 <nerdlor> ERC>/whois nerdlor
05:05:27 <nerdlor> <oops... darned erc...>
05:09:14 <Blizz_> cleverdra: yeah you wa are right, but I was too lazy to create one. I fixed it with the disks now..
05:51:04 <Marvin--> 170 lines of code so far, and I've got a "breakout" with a ball bouncing on the walls, a moving paddle, and bricks that get removed when the ball hits them
05:51:31 <Marvin--> the ball doesn't bounce off the bricks yet though, and there's just one type of bricks, and there's no scorekeeping
05:51:46 <o3> Marvin--: opengl?
05:51:53 <Marvin--> o3: nah, ncurses :-)
05:52:11 * Marvin-- is doing it just to be able to taunt his brother
05:52:17 <o3> ah 8)
05:52:30 <o3> and who says sibling rivalry isn't productive
05:52:37 <Marvin--> they're writing breakout games in C++ as programming assignment
05:52:50 <Marvin--> and I keep telling him to learn to use a real language *cough*
05:52:59 <o3> haha
05:53:57 <dark> Marvin: But he'll still have to do the assignment.  You're just going to make him bitter and disillusioned about the educational system :)
05:54:23 <Marvin--> dark: oh he's already finished, he has to hand in the report on Friday or something
05:54:34 <dark> I mean, suppose he get the point that the only reason he's learning an obsolete language like C++ is so that he can get his little paper with "government-approved intellectual" stamped on it?  What then?
05:54:36 <Marvin--> dark: so when I see him next I intend to give him a tiny haskell program that does the same thing *grin*
05:54:59 <Marvin--> actually, not the same thing, since they're doing graphics too
05:55:15 <Marvin--> I can't for my life see why they are meddling with graphics in a newbie C++ course, but oh well
05:55:30 <Marvin--> IMO the course focuses on the wrong parts, but maybe that's just me
05:58:37 <dark> Marvin: Maybe it's to dispel the notion that graphics are difficult :)
05:59:16 <dark> In fact, graphics might be more easiliy grasped than abstract math.  "ball hits brick" is a lot easier to visualize than yet another fib :)
05:59:27 <Marvin--> but pixlex graphics?!
05:59:36 <Marvin--> pixled even
06:00:12 <Marvin--> of course it's not hard, it just takes a lot of time, time they could've spent learning about data structures and stuff like that
07:12:58 <Heffalump> if you have ;s do you also need { } around the list of ;d things?
07:13:15 <cleverdra> Heffalump - no
07:13:16 <Marvin--> not always, iirc
07:13:32 <Heffalump> ok, so where a=x mod 4; b=x mod 100; c=x mod 400 
07:13:34 <Heffalump> is probably valid?
07:13:44 <Heffalump> (too lazy to type in enough to test this myself)
07:13:47 <Igloo> Yes
07:13:53 <Heffalump> ta
07:14:00 <cleverdra> Heffalump - yes, if the 'where' is correct by layout.
07:14:22 <Igloo> But they probably meant `mod`
07:14:27 <cleverdra> Yeah.
07:15:49 <dark> But I thought we were switching to Haskell to relieve the impending shortage of semicolons.
07:16:07 <Heffalump> oh, I forgot that bit :-)
07:16:23 <Heffalump> they all seem to be getting that wrong
07:16:31 <Igloo> David Lecomber did too - dunno if you're actually supposed to care or not
07:17:14 <Heffalump> well, I do
07:17:15 <Marvin--> Heffalump: code on papers?
07:17:18 <Heffalump> Marvin--: yeah
07:17:27 <Marvin--> I was thinking "wtf, didn't they test it?" :)
07:17:48 <dark> It's actually pretty hard to write a ` that doesn't look like a ' :-)
07:18:08 <dark> Maybe it's because my 's are all over the place.
07:18:10 <Igloo> Nah, you just write a small \ high up
07:18:19 <Marvin--> Koen's pretty good at it
07:18:23 <Heffalump> it's kind of good that they learn the syntax without the crutch of the computer, but otoh you could argue doing so is a waste of time
07:18:31 * Igloo isn't sure if mine curve at all and hasn't got a pen handy to try
07:19:09 <cleverdra> Heffalump - I think it's helpful to at least begin with Emacs and haskell-mode; but, assuming that, I don't find paper-Haskell difficult at all.
07:20:10 <Igloo> If people used hugs earlier they might understand function application precedence
07:20:20 <dark> The layout rule might get confused by my inability to write on straight lines :-)
07:20:51 <dark> So this is code from students?
07:21:00 <Heffalump> hmm, two people trying to redefine fst to work on triples.
07:21:14 <Igloo> redefine or just use wrongly?
07:21:24 <Heffalump> redefine
07:21:45 <Igloo> That's not so bad then
07:21:48 <Heffalump> hmm, this guy is also giving a type signature for a constructor.
07:22:54 <cleverdra> Heffalump - that's odd; what does it look like?
07:23:43 <Heffalump> data Date a b c = MkDate a b c
07:23:51 <Heffalump> MkDate :: a -> b ->c -> Date a b c
07:25:18 <cleverdra> I guess he doesn't know that 'Date' is usable as the constructor there.
07:25:47 <Igloo> A lot of people seem to use that style
07:26:06 <Heffalump> the entire datatype was gratuitous, TBH
07:26:13 <Igloo> I don't, but it would sometimes come in handy when I want datat SomethingElse = Date Date | ...
07:26:45 <cleverdra> TBH?
07:26:49 <Heffalump> to be honest
07:27:28 <cleverdra> ah.
07:28:00 * Marvin-- has finished marking assignment :)
07:28:16 <Heffalump> we were expecting 25 people to take this course, but only 5 have handed work in
07:28:21 <Marvin--> ouch
07:28:22 <Heffalump> which is nice
07:28:31 <Heffalump> I suspect not many more than 5 actually intend to take it)
07:28:42 <Marvin--> okay
07:29:24 <cleverdra> What course is this?
07:29:26 <Igloo> MSc people then?
07:29:42 <Heffalump> MSc introduction to functional programming
07:29:49 <Heffalump> (it's also a first-year UG course, so pretty easy)
07:30:03 <Marvin--> now I just have the AFP examination tomorrow (i.e. convincing Koen I've learned something) and then I'm set for the next half of the semester (hrrm, which started Monday)
07:30:49 <Igloo> Marvin  :-)
07:32:43 <Marvin--> incidentally, I started teaching the next course yesterday ;)
07:32:52 <Marvin--> which was a totally pointless lesson
07:32:55 <Heffalump> an AFP course?
07:33:10 <Marvin--> nope, a basic course on data structures and stuff
07:33:53 <Marvin--> but the first lecture of the course was 1pm to 3pm, and my first lesson was 3pm to 5pm, the same day, and they were supposed to be working on exercises on basic complexity theory
07:34:00 <Marvin--> hellloooo, most of them didn't even have books yet
07:34:17 <Marvin--> and was I prepared for stepping in and sorta lecturing instead? nope
07:36:53 <Marvin--> all in all, pretty pointless :/
07:41:17 <Marvin--> I wonder how hard it would be to formally specify the semantics of a breakout game *ponder*
07:41:50 <dark> Depends on how many extra features you want :)
07:42:05 <Marvin--> I'd start out simple of course
07:42:47 <Marvin--> and since I'm working in curses-land, I don't have to worry too much about angles *grin*
07:42:50 <cleverdra> data Brick = Normal | Exploding | PowerUp Power | Death
07:43:01 <cleverdra> or is Haskell not formal enough?
07:43:19 <Marvin--> bah :)
07:43:40 <Marvin--> and I don't even have different bricks in this design
07:47:07 <cleverdra> The way I see it, breakout consists of a 'pit' which is a [[Char]] of the static elements of the screen, a 'ball' which consists of an index into the 'pit' and a vector (speed, direction), and a 'paddle' that consists of an index into the pit and possibly a variable width
07:48:54 <dark> A curses version might not have speed, just direction.
07:48:59 <dark> Otherwise you get into trouble :-)
07:49:03 <Segora> no
07:49:39 <Segora> make the ball position and speed reals and make sure the maximum move does not exceed 1 screen position in any direction
07:50:06 <dark> Hmm, that works:)
07:50:21 <Segora> with reals, you also get angles other than multiples of 45 degrees
07:51:11 <cleverdra> hm, should the width of the paddle also be a real?
07:51:27 <Marvin--> ick
07:51:30 <Segora> hmm
07:51:39 <dark> Probably not, try explaining to the player why the paddle missed even though a paddle character was right under the ball character.
07:51:51 <Marvin--> haha
07:51:53 <Segora> *g*
07:51:57 <cleverdra> Indeed.
07:52:40 <dark> Are you going to worry about scaling of height vs. width?
07:52:41 <Segora> you could use vt220 graphics characters to make the paddle move in fractions of character positions ;)
07:52:51 <Marvin--> ouch
07:53:01 <dark> True :)  Well, if the fractions are halves.
07:53:28 <dark> It would look cooler than "====" too.
07:53:32 <Segora> don't laugh - a friend of mine once made boulderdash in vax pascal for vt220 with user defined characters
07:53:51 * dark laughs.
07:53:54 <Segora> the graphics weren't half bad
07:54:15 <Segora> *g*
07:54:57 <dark> The line-drawing characters make most stuff look better, but I don't know if xterms support them.
07:56:10 <Igloo> They do with the right magic, which cursers ought to do for you
07:56:42 <Igloo> Curses has various characters available as ACS_*, but they are a bit of a pain to use from Haskell (as they aren't constant)
07:57:52 <Marvin--> hmm, can curses do the half-character-height stuff for me?
07:58:11 <dark> Igloo: Curses.hsc from my Mage game provides them :)
07:58:45 <dark> It reserves certain values of Char for them (there's a partial mapping of ACS chars to Unicode), and translates them on output.
07:58:51 <Marvin--> dark: gimme
07:59:02 <Marvin--> ;)
07:59:22 <dark> Marvin: http://www.xs4all.nl/~dark/mage-1.0pre35.tar.gz
07:59:34 <dark> Marvin: It doesn't have a license statement yet, but assume 2-clause BSD :-)
07:59:42 <Igloo> Ah, so you convert from Char to ACS_... at an output phase in the IO monad?
07:59:49 <dark> Igloo: Right.
08:00:02 <Igloo> Cool
08:00:17 <Marvin--> dark: this looks scary
08:00:20 <dark> Igloo: And I use small functions to give names to those values of Char, so that the caller doesn't have to guess.
08:00:21 <Igloo> I suspect I could do similarly in Hetris - it's just a pain that something that should be a nice constant isn't
08:00:29 <dark> Marvin: Are you familiar with hsc2hs?
08:00:47 <Marvin--> dark: not really, but I've been fiddling with Igloo's Curses.hsc, so...
08:01:16 <Igloo> I don't think that really uses it. Just substitutes a couple of types in
08:01:40 <dark> Igloo: Well I don't do much more :)
08:01:49 <dark> I just assumed it was the part Marvin considered scary.
08:02:31 <dark> trans_key #{const KEY_LEFT} = Key_LEFT
08:02:34 <dark> That sort of thing.
08:03:14 <dark> Oh, heh... Mage's Curses module assumes you don't use stdscr.  That might need some tinkering.
08:03:35 <cleverdra> stdscr?
08:03:39 <Marvin--> dark: no, I meant the sheer amount of code ;)
08:04:27 <dark> cleverdra: The curses name for the default window.
08:05:54 <dark> Marvin: hmm, yeah, it has a lot more module dependencies now than when I started.  GlyphWindow needs Util.Grid, etc.
08:06:23 <Marvin--> dark: I may steal Window.hs and Curses.hsc and stuff :P
08:06:32 <dark> Marvin: Amazingly, this was part of my effort to make the whole program less curses-dependent :)  I'd like to be able to support more than one windowing system.
08:06:35 <Marvin--> the window stuff was really cute
08:07:58 <dark> Marvin: Your brother might laugh at it if you try to point out how much simpler the Haskell version is, though :-)
08:08:07 <Marvin--> point ;)
08:08:18 <cleverdra> dark - is mage supposed to have wierdly positioned windows, though?
08:08:20 <dark> Marvin: Maybe you should hide the Curses module and pretend it comes with the standard libraries.
08:08:27 <Marvin--> dark: ;)
08:08:45 <Marvin--> dark: well, he gets to use a graphics library so why can't I use a curses library? :)
08:09:02 <Marvin--> but I have no idea what the requirements on their assignment is, the spec doesn't say, it was a really really bad spec
08:09:16 <dark> cleverdra: No, they don't even move around and they usually don't overlap.
08:09:58 <dark> cleverdra: It was just easier not to make a special case for stdscr, and then I realized that since I leave it blank, I can use it to implement clear_screen :-)
08:10:09 * Igloo gets around to looking at Hetris again
08:10:11 <cleverdra> dark - I'm referring to mage's behavior of showing the screen offset vertically and horizontally by twenty chars or so
08:10:38 <Marvin--> we need a haskell gaming site :-)
08:10:39 <dark> cleverdra: Hmm.  You mean that the map is not centered?
08:10:51 <cleverdra> oh, tetris is even easier; the only fun part is where you rotate the blocks.
08:10:58 <cleverdra> dark - oh, it's supposed to be centered?
08:11:18 <Igloo> clev: I have an infinite list (cycle states) and either do tail or drop 3 depending on which way you rotate
08:11:24 <dark> cleverdra: No, it's not :)  I wondered if you expected it to be.  The rest of the screen is blank in this version because I haven't written any of the parts that will use the status window yet.
08:11:41 <cleverdra> dark - it's not centered, but I'll look at it in view of the intent.
08:12:00 <cleverdra> dark - oh, OK.
08:12:27 <cleverdra> Igloo - oh, that's nifty.
08:12:41 <LaSalle_> YES!
08:12:47 <cleverdra> Igloo - you don't define all the rotations of each block though, do you?
08:12:48 <LaSalle_> finally i found a chatroom!
08:12:49 <Marvin--> LaSalle_?
08:12:52 <LaSalle_> hehe
08:13:05 <LaSalle_> i have only recently got given this server name
08:13:20 <dark> "chatroom"?
08:13:30 <Igloo> I do - they are sufficiently non-unifrm I think it would be hard not to
08:13:30 <LaSalle_> seems like there are a lot more programmers on this server than anywhere else...
08:13:38 <cleverdra> lasalle - /list gives you a list of channels.  You might find an IRC tutorial.
08:13:57 <Igloo> I guess a function that takes one configuration and the total number of configurations would work#
08:14:09 <LaSalle_> no...
08:14:19 <LaSalle_> i have been using undernet i meant
08:14:25 <LaSalle_> didn't know there is such a server...
08:14:29 <cleverdra> Igloo - no; look at this:
08:14:41 <LaSalle_> you guys are all functional programmers?
08:15:02 <Igloo> clev: It has to cope with not rotating the square for example
08:15:05 <Marvin--> we're all Haskell fans if that's what you mean
08:15:09 <dark> Igloo: It's consistently a rotation by 90, right?
08:15:12 <LaSalle_> soooo nice
08:15:30 <LaSalle_> someone can finally explain to me how monads work...
08:15:32 <LaSalle_> hehe
08:15:34 <cleverdra> ["        "
08:15:35 <LaSalle_> binding is it?
08:15:35 <cleverdra>  "<><><>  "
08:15:35 <cleverdra>  "    <>  "
08:15:35 <cleverdra>  "        "]
08:15:36 <dark> Igloo: Oh, I see... the square doesn't have a point to rotate around.
08:15:40 <Igloo> dark: Yes, but when you rotate a square the blocks occupied don't change
08:15:49 <cleverdra> ["        "
08:15:50 <cleverdra>  "  <><>  "
08:15:50 <cleverdra>  "  <><>  "
08:15:50 <cleverdra>  "        "]
08:16:18 <cleverdra> You don't have to treat any brick specially; you just read the current-brick a certain way to get the next brick.
08:16:28 <dark> rotate90, like yesterday? :)
08:17:07 <Igloo> clev: I will think about that some time - I didn't think too hard about it, but replicating what bsd-tetris did automatically didn't seem immediately obvious
08:17:09 <dark> lasalle: Currently we're discussing tetris implementations :)
08:17:29 <Marvin--> #haskell - yep, we do games
08:17:56 <LaSalle_> dark: cool ...some interesting
08:18:27 <LaSalle_> dark: know how to use monads instead of explicitly passing states around?
08:18:34 * Igloo thinks about adding FFI and hsc support to Haskell2LaTeX too
08:19:21 <dark> Marvin: I think games are a good way to stress a language's I/O features, anyway :)  And modeling a computer opponent can be fun.
08:19:31 * cleverdra does a lot of rotation in Sokoban to simply rule-definition.
08:19:37 <dark> lasalle: I just import Control.Monad.State :)
08:19:39 <cleverdra> err, well, I used to.
08:20:20 <Marvin--> type BreakoutM = StateT (Score,ExtraLives,...) IO, yay ;)
08:20:59 <LaSalle_> dark: my understand to >>= is still very limited...hehe i think i better read more b4 i use monads
08:21:23 <LaSalle_> understanding rather
08:21:30 <dark> I've always wanted to make an evil tetris, which always throws the block you need least.  Well, not always, it's constrained to make the frequency distribution look realistic.  And then see how long it takes people to catch on :)
08:22:16 <dark> lasalle: There's several ways to explain monads, and which one works best seems to depend on the person :)
08:22:18 <Igloo> Ahem
08:22:27 * Igloo gets tetrads made up of ^@s
08:22:45 <Marvin--> dark: and it's supposed to be open source too? ;)
08:22:59 <dark> lasalle: I think of >>= mainly as a sequencing operator.  It performs the computation on the left, then hands the result to the computation on the right.
08:23:23 <LaSalle_> i understand how to define a new data type with a hidden state included in it...
08:23:29 <dark> Marvin: Hiding the evilness would be a challenge :)
08:23:54 <Marvin--> :)
08:25:02 <cleverdra> Marvin - could you give an example use of BreakoutM ?
08:25:10 <dark> Marvin: Pretty difficult, in fact.  It'll have to have some measure of the quality of a position, then a way to figure out how a block can be placed to maximize this quality, then select the block shape that gives the lowest maximum.  All of that modeling might be more code than the game itself :)
08:26:12 <Marvin--> cleverdra: *shrug* I'd call addScore (brickScore brick)  when knocking out a brick?
08:26:27 <Marvin--> but I changed the state to a record instead of a tuple
08:26:44 <dark> Marvin: Did you have to lift all the IO operations or is there some simpler way?
08:27:01 <cleverdra> Marvin - that doesn't really show use :-(
08:27:05 <Marvin--> dark: the IO operations will have to use liftIO
08:27:08 <dark> LaSalle: Looking at the source for Control.Monad.State can be educational.
08:27:12 <Marvin--> cleverdra: no, I'm only in the design phase! :)
08:27:28 <Marvin--> maybe I should try to use arrows instead *ponder*
08:27:43 <dark> Marvin: It would make shapr happy...
08:27:47 <Marvin--> hehe
08:28:50 <LaSalle_> alirte
08:28:55 <Marvin--> does ghc support the arrow syntactic sugar?
08:29:08 <LaSalle_> but i think i should go to bed soon...it's 5:30 in the morning...
08:31:59 <cleverdra> LaSalle - isn't it about time to get up, then? =)
08:32:38 <LaSalle_> ahah you only get up from bed...
08:37:07 <Marvin--> ugh, do I really feel like learning arrows right now... sure, games is a typical example of reactive programming, but still...
08:37:32 <dark> Write it with monads first, then convert it to arrows as your first learning exercise :)
08:37:40 <Marvin--> heh
08:37:46 <dark> Then you can jump up and down about how much better it is with arrows.
08:38:01 <Marvin--> well, some parts would be much easier with arrows.. reacting to events for example
08:44:40 * Igloo looks at Dark's Curses.hsc and looks surprised by the similarities, but I guess there isn't a lot of freedom
08:45:14 <cleverdra> Igloo - were you really surprised, or did you only look surprised?
08:45:34 <Igloo> Do you have any reason to believe that KEY_UP is any more a constant than ACS_BLOCK is, Dark?
08:45:46 <Igloo> clev: I was really surprised, but only briefly
08:46:06 <cleverdra> KEY_UP is constantly ESC[A, SFAICT.
08:47:01 <Igloo> clev: YM in your experience...
08:47:07 * Igloo was askign Dark really since he also seems to have run into the ACS problems
08:47:07 <cleverdra> well, that or ESCOA -- but that's evil.
08:47:32 <cleverdra> Igloo - yes, 'SFAICT' is a super-qualifier of 'im my experience'
08:48:16 <cleverdra> Igloo - curiously, why do you think that he has?
08:49:38 <Igloo> Because he was talking about them earlier  :-)
08:52:24 <cleverdra> hm, OK.
09:12:46 <dark> Igloo: Hmm, I don't know what the curses standard (as far as it exists :) says about it.  On ncurses at least they're constants.
09:14:25 <Igloo> Bother, this works with --make but not if I compile things separately
09:14:38 <dark> There's also this:
09:14:58 <dark> "The has_key routine takes a key value from the above list, and  returns TRUE  or  FALSE according as the current terminal type recognizes a key with that value."
09:15:14 <dark> I think that means the KEY_ values have some existence outside the current terminal setting.
09:15:44 <dark> Igloo: Hmm, you mean mage?  What happens if you compile things separately?
09:16:15 <Igloo> ACS_BLOCK is still around at link time
09:16:25 <Igloo> I don't mean mage, but I suspect the same sill be true
09:17:04 <dark> Yeah I link with -lncurses '-\#include "curses.h"'
09:17:14 <dark> As far as I know it's not due to --make, but due to inlining.
09:17:23 <dark> I sort of cheat there:
09:17:37 <dark> foreign import ccall unsafe "curses.h & ACS_BLOCK" acs_block :: Ptr ChType
09:17:37 <Igloo> I have a suspicion more inlining happens when you use --make or something, but I'm just testing that now
09:17:57 <dark> This pretends that ACS_BLOCK is a variable name, and ghc believes me, so it happily inlines the reference in other modules.
09:20:59 <dark> Another sin in my Curses module is that it doesn't check for ERR returns much.
09:21:26 <dark> This is partly because I wouldn't know what to do about them anyway :)
09:22:02 <Heffalump> raise an exception?
09:22:04 <Igloo> I just had
09:22:05 <Igloo> errI f = do r <- f
09:22:05 <Igloo>             if r == cERR then do _ <- endwin
09:22:05 <Igloo>                                  error "curses returned an error"
09:22:05 <Igloo>                          else return ()
09:22:10 <dark> Yeah, but then what?
09:22:29 <Igloo> i.e. the program dies
09:22:45 <Heffalump> well, user code could handle it maybe
09:22:45 <dark> I guess I should raise an exception, catch it in the main loop, and then save and exit from there.
09:24:26 <Igloo> Grrr, now I can't make it compile at all. Oh well, I think adding it to wrap.c is the Right Thing to do anyway
09:24:48 <dark> Igloo: Make functions to return the ACS_ values?
09:24:52 <Igloo> Yeah
09:25:08 <dark> That's something I didn't want to do in a program that spends most of its time drawing maps on the screen :-)
09:25:53 <Igloo> Hmmm, I guess it won't be inlined at all
09:26:14 <Igloo> Oh well, I'd rather do it right than do it fast  :-)
09:26:25 <dark> I have a curses_wrapper.h :)
09:26:46 <cleverdra> Igloo - why do you say '_ <- endwin' instead of 'endwin' ?
09:27:02 <Igloo> No good reason  :-)
09:27:13 <dark> Officially endwin can also fail :)
09:27:29 <Igloo> I think I check for that when I call it for real
09:27:46 <dark> A lot of curses functions seem to return int for no good reason.
09:28:40 <Igloo> For example?
09:29:56 * Igloo was only going to spend a few minutes on this. Oh well  :-)
09:44:26 * Marvin-- rediscovers autofs
09:57:15 * Igloo gets confused by ncurses using # if it thinks you have a stupid terminal when you ask for ACS_BLOCK
09:57:36 <Igloo> I get very strange Chinesey looking things if I tell it TERM=linux
10:05:35 <dark> Well, like nl and nonl.  They're defined to return OK :)
10:06:27 <cleverdra> What does 'nonl' do?
10:06:48 <dark> It turns off newline translation.
10:06:58 <Igloo> You mean ncurses defines them to return OK, not curses
10:07:11 <Igloo> Oh, ermm, maybe not
10:07:18 <dark> How can they possibly fail, though?
10:07:48 <Igloo> No, the manpage is talking about ncurses. http://www.opengroup.org/onlinepubs/007908799/xcurses/nl.html
10:08:10 <Igloo> Presumably the underlying display device can be incapable of doing so
10:08:37 <Igloo> According to the standard you have to be prepared for them to fail, anyway
10:12:35 <dark> It doesn't define any errors, though :)
10:14:28 <Igloo> Neither do initscr or addch
10:25:31 <dark> Sorry for the long delays, by the way.  My girlfriend keeps dragging me away :)
10:26:51 <dark> Anyway, I thought colors were an ncurses extension.
10:27:49 <Igloo> Apparently not. The standard was created after the implementations, so I guess all/most of them supported colour
10:29:50 <dark> I wonder how utf8 terminals interact with ncurses.
10:29:58 <dark> It seems to have space for only 8-bit characters in chtype.
10:30:00 <Igloo> Hmmm, drawing at 2x, 2x+1 to fix the size ratio doesn't work when drawing boxes
10:30:14 <dark> I guess that would be enough, but it also assumes one chtype per character position :)
10:30:29 <dark> Igloo: The corners come out wrong?
10:30:56 <Igloo> The vertical lines and corners are doubled
10:31:23 <dark> I guess it's not so bad to have doubled vertical lines.
10:31:37 <dark> But the corners probably don't connect :)
10:32:32 <Igloo> Yeah
10:32:42 <Igloo> I think I'll need to do a bit more rearchitecting
10:34:43 <dark> Hmm, curses itself has primitives for drawing borders.
10:34:52 <dark> But only around windows, not arbitrarily.
10:34:57 <dark> I wonder why such a limitation.
10:35:36 * Igloo stops testing. Ahem  :-)
10:35:36 <dark> Maybe someone didn't like 13-argument functions :-)
10:35:49 <Igloo> I need to implement scoring so I can see how well I'm testing  :-)
10:35:56 <dark> Heh.
10:36:05 <Igloo> And improve the playability a bit too
10:36:58 <dark> And make it show scenes from Moscow in the background.
10:37:11 <Igloo> Am I missing a reference?
10:37:19 <Igloo> I think that'll wait for the GTK interface, anyway  :-)
10:38:57 <dark> Igloo: The first tetris game I played had those :)
10:39:04 <dark> Because it's a Russian game, you see.
10:39:29 <dark> It claimed to be the original Tetris, which I suppose means it wasn't.  (Why would the original make such a claim?)
10:39:50 <Igloo> Maybe I should just make it themeable...and support arbitrary pieces and stuff  :-)
10:40:13 <dark> Ooh, and pieces made from little wobbly balls strung together, like in same-gnome.
10:41:25 <dark> I have a tetrislike game somewhere that has little naked men and women falling, and you have to match them up in sex positions to make them disappear :)
10:41:40 <Igloo> lol
10:41:41 <dark> The game's creators were less imaginative than I, btw.
10:42:14 <Igloo> I like how that followed on from the little wobbly balls line  :-)
10:42:38 <dark> I guess "wobbly" has certain associations :)
10:43:44 <dark> I suppose if you allow every imaginable position, it wouldn't be a very difficult game :)
10:44:01 <Igloo> Mmmhmmm  :-)
10:44:12 <Igloo> Oooo, stage 2 GHC build done
10:48:30 * dark wonders if anyone what written an IRC server in Haskell.
10:48:58 <Igloo> s/what/has/?
10:49:06 <dash> hmmm
10:49:13 <dark> Er, yeah.
10:49:18 <dash> wli was doing a chat-thingy of some flavor, a along while back
10:49:26 <dash> a/along/long/
10:51:22 <dark> Of course, what IRC really needs is a better protocol :)
10:52:25 <dash> but then it isn't irc.
10:52:57 <Igloo> :-)
10:53:43 <engstad> Greets.
10:54:42 <dark> dash: It is if you call the protocol "IRCv6" :-)
10:56:31 * cleverdra struggles to produce an IO-ly incorrect program for an example.
10:56:49 <cleverdra> I remember doing this so *well* when I was first learning.
11:00:34 <Igloo> IO-ly incorrect?
11:41:59 <engstad> So, what is an intersection type? And what is rank 1 and rank 2 untersection types?
11:42:57 <cleverdra> I've no idea.  Where did you hear about it?
13:03:29 <engstad> whats a second order lamda-calculus?
13:04:25 <toadx> sounds like something from star trek
13:05:10 <engstad> Hehe...
13:05:27 <engstad> I know what a a lambda-calculus is, but the order?
13:06:00 <cleverdra> a lambda calculus that works on lambda-calculuses, I suppose.
13:06:08 <engstad> hmm
13:06:28 <engstad> i think its related to the type system.
13:06:43 <cleverdra> Are you reading the paper on typeful programming?
13:06:56 <engstad> Well, it is about intersection types.
13:12:10 <engstad> Ah, yes, a second order lambda calculus has type abstractions and type applications.
13:13:02 <andersca> hmm?
13:13:08 <andersca> how does that work? :)
13:13:39 <cleverdra> the 'typeful programming' paper talks about it, in addition to 'kinds' which is a third-order lambda calculus, I suppose.
13:14:10 <engstad> You know in lambda calculus that (\x. (1 + x)) 1, is an application of (regular) variables.
13:14:29 <andersca> yes
13:15:54 <engstad> For types, you could make "type-lambdas". I.e., so that applying a type (Integer) to a type-lambda (List), you get the type List Integer.
13:25:24 <whee> geh
13:25:36 <whee> compiling ghc under OS X is like pulling teeth :|
13:36:24 <engstad> Marwin: Do you know anything about intersection types?
13:44:51 <Marvin--> intersection types? no?
13:48:20 <engstad> It's pretty interesting.
13:51:56 <engstad> Basically, it is a refinement on the type theory of foralls. For instance, imagine the list type: forall T. (List T). Now, obviously a program will use a finite set of arguments to List, hence all the compiler needs to generate is:
13:52:40 <engstad> Assuming usages are [Int, Float] or Int /\ Float: List Int /\ List Float.
13:53:25 <Marvin--> hmm
13:53:59 <engstad> So, the whole idea is to restrict the universal quantifiers, thereby providing more optimization possibilies.
13:55:25 <engstad> The papers I'm reading is looking into subtyping relationsships with respect to this.
14:58:32 <Chilli> Moin
14:59:31 <Pseudonym> G'day.
14:59:50 <dark> Greetings
15:01:11 <dark> There seems to be a large overlap between #haskell and #debian-devel :)
15:02:36 <Pseudonym> Odd that Haskell isn't better packaged under Debian, then.
15:02:42 * Pseudonym ducks
15:02:52 <dark> You mean the docs?
15:03:12 <Pseudonym> I have no idea what I mean.
15:03:24 <dark> Well, the ghc5-doc package sucks :)
15:03:42 <Pseudonym> If you say so.  I always go to haskell.org/ghc when I need docs.
15:03:55 <Pseudonym> Who packages it, incidentally?>
15:03:57 <dark> Right, which is probably why it hasn't been fixed yet...
15:04:10 <dark> Michael Weber
15:06:18 * Pseudonym considered being a debian developer once
15:06:32 <Pseudonym> The investment of time detracts from coding.
15:07:37 * toadx is a fake debian developer
15:07:59 <Pseudonym> You mean you develop for Fake Debian?
15:08:04 <toadx> yes
15:08:26 <Pseudonym> The distro where the installation is great but the packaging is awful?
15:08:33 <Pseudonym> Or was that Bizarro Debian?
15:08:59 <toadx> err, something like that
15:17:48 <dark> Pseudonym: It doesn't take much time if you're as lazy about it as I am...
15:19:07 <Pseudonym> What are you responsible for?
15:19:14 * dark checks :)
15:19:17 * Pseudonym can be lazy, no problem there
15:19:42 <dark> cflow, cgoban, ftplib, hextype, mpack, pgp, and vrflash.
15:19:57 <dark> I think cgoban and pgp are the only ones that would be missed if they disappeared, and pgp for entirely the wrong reasons :)
15:20:00 <Heffalump> how many bugs do you have open? :-)
15:20:45 <dark> 18
15:20:51 <Pseudonym> One of these days, someone will have to find a good debian packaging mechanism for GHC packages.
15:20:59 <dark> Well, some of them are pgp ones that will never be fixed except by rm.
15:22:36 <Heffalump> what's wrong with the current packaging mechanism for them?
15:23:06 <Pseudonym> I should be able to apt-get a GHC package and have it ghc-pkg installed.
15:23:09 <dark> Pseudonym: Do you mean supplementary library packages, or GHC itself?
15:23:22 <Pseudonym> The former.
15:23:24 <dark> Hmm, they will have to track the ghc version exactly, right?
15:23:30 <Pseudonym> Probably.
15:23:41 <Pseudonym> Hopefully not forever.
15:24:01 <dark> That's always a pain, though.
15:24:07 <Chilli> Pseudonym: you'll alsways have to match the right compiler version
15:24:08 <Pseudonym> One of these days, the GHC people will learn not to break .hi and binary compatibility between minor versions.
15:24:20 <Pseudonym> But it won't be for a while for very good reasons.
15:24:23 <Heffalump> oh, right
15:24:31 <Chilli> with any language more sophisticated than C, it would be difficult and inefficient to do otherwise
15:24:51 <Pseudonym> I disagree with that.
15:24:51 <Chilli> not breaking .hi is easy
15:24:55 <Heffalump> it's fairly trivial, except for the need for an explicit dependence on GHC versions
15:24:56 <Pseudonym> Difficult, yes.
15:24:58 <Chilli> the other one is very difficult
15:25:21 <Heffalump> (IM packaging GHC packages, not the binary compatibility issue)
15:25:28 <dark> Heffalump: And that's not _difficult_ either :)  Just a pain.  The packages will always be broken on some architecture.
15:25:29 <Pseudonym> I seem to recall that O'Caml doesn't do it too badly.
15:25:53 <Pseudonym> Erlang works fine, but Erlang/OTP is mostly interpreted.
15:26:06 <Chilli> if you do cross module optimisation, the is not much chance
15:26:16 <Chilli> Erlang is ok and it pasys in performance
15:26:25 <Chilli> if you leave out cross-module optims it is not difficult
15:26:32 * Pseudonym nods
15:26:56 <Pseudonym> This is a problem, IMO.
15:27:13 <Chilli> Igloo: are you around?
15:27:31 <Igloo> Yup
15:27:44 <Chilli> you are playing with TH, aren't you?
15:28:20 <Igloo> As we speak  :-)  (well, almost)
15:29:06 <Chilli> we found that a lot of stuff doesn't work yet
15:29:27 <Chilli> I am just adding more literals (String and Integer)
15:29:35 <Chilli> and explicit type annotationbs in [| |]
15:30:01 <Chilli> and THSyntax is a big mess IMHO
15:30:19 <Igloo> Cool
15:30:23 <Igloo> In what way?
15:30:39 <Chilli> lots of stuff missing
15:30:44 <Igloo> Ah, yes
15:30:47 <Chilli> the naming conventions being bizarre
15:30:59 <Chilli> stuff like counter being exported
15:31:02 <Igloo> Like reifyExpr, which is the next thing I really need I think  :-/
15:31:08 <Chilli> NONINLINE missing at counter
15:31:13 <Chilli> (fixed that yesterday)
15:31:28 <Chilli> than these arguments to Match and Clause
15:31:32 <Chilli> *urgh*
15:31:49 <Chilli> each time I look at the module, I have this urge to delete it and rewrite it from scratch
15:32:10 <Chilli> and half the types are different from the paper
15:32:20 <Chilli> eg, lift producing an Exp instead of an Expr
15:32:36 <Igloo> I asked Simon a few things ages ago when I read the paper including about the type variables but he only answered one or two points from teh mail (in person at AFP)  :-(
15:33:13 <Chilli> from the email I sent him, it seems that much of these things orignated from Tim Sheard
15:33:13 <Igloo> Maybe he likes you better  :-)
15:33:26 <Igloo> Yeah
15:33:37 <Chilli> I think we should push for changing this stuff
15:34:02 <Chilli> (SPJ won't change it, I just want to get him to agree that we change it)
15:34:16 <Igloo> I don't understand that
15:34:39 <Chilli> the , should have been a .
15:34:48 <Igloo> I'd like to hear why Tim thnks it is a good idea. I've just got to the point in SPJs book (I forget which) where he does a similar thing for Haskell and it is useful
15:34:49 <Chilli> SPJ probably doesn't have the time to do much about it
15:34:56 <Chilli> but if we make a good case for a change
15:35:20 <Chilli> you mean the args to Clause etc?
15:35:33 <Igloo> Have you actually got a good case for the change? It makes the types a bit nicer but possibly restricts us in a way we are not aware of
15:35:54 <Chilli> well, I think I know why Tim did it this way
15:35:55 <Igloo> Things like Foo p d with p always being Pat and d always being Dec
15:36:06 <Chilli> but it won't help unless *all* types are parametrised like that
15:36:17 <Chilli> and they aren't
15:36:36 <Igloo> What's the reason? And why is none better than all?
15:37:10 <Chilli> the reason is that you can make the types non-recursive and modular
15:37:30 <Chilli> but he didn't do it for Exp, for example
15:38:23 <Igloo> Don't you just need to break the loop then?
15:39:12 <Chilli> you could give Exp an argument e
15:39:21 <Chilli> and subsitute it in all places where Exp mentions Exp
15:39:28 <Chilli> then you need to define
15:39:34 <Chilli>   type RealExp = Exp Exp
15:39:36 <Chilli> and so on
15:39:51 <Chilli> (that's not quite it, but something like that)
15:40:03 <Igloo> I see what you mean, but don't you just need to break the loop of dependencies in a cut (I think that's vaguely sane terminolgoy)?
15:41:25 <Chilli> you need to do it in a way that you can actually subistute other types
15:42:02 <Igloo> So if data Foo = Bar Bar and data Bar = Foo Foo then you only need to change data Bar = Foo f and you then have a DAG of dependencies?
15:42:18 <Igloo> No need to have data Foo = Bar b too
15:46:13 <Chilli> the point is that I don't see how this can be used in THSyntax without parametrising other types such as Exp
15:46:29 <Chilli> but that's only one of the things
15:46:56 <Chilli> the naming conventions are pretty awakward
15:47:08 <Chilli> and stuff like Q is a type instead of a newtype
15:47:28 <Igloo> Yes, that looks really nasty because the type system won't help you
15:47:33 <Chilli> (which means it impl can't be hidden during export; forgetting for the moment that there isn't an export list in the first place)
15:48:14 <Igloo> As it is you can put DotDot, Statement, RightHandSide etc in other modules and just import them from the module Exp and Dec are in
15:50:20 <Chilli> what does that help?
15:50:48 <Igloo> Maybe I misunderstood what you meant by modular
15:52:25 <Chilli> maybe I wasn't clear
15:52:48 <Chilli> may point is simply that anything that makes the THSyntax more complicated and serves no clear purpose should be removed
15:53:29 <Chilli> now, I vaguely remember a talk where Tim Sheard explained why he uses these parametrised constructions like Clause
15:53:38 <Igloo> I agree I would like either a reason for existence or the removal of such things, yes
15:54:01 <Chilli> and it had to do with breaking recursion and I think with exstensible definitions
15:54:25 * Igloo wishes I'd read SPJ's book quicker now  :-)
15:54:28 <Chilli> but as far as I remember to achieve these benefits, the technique must be applied to all data types
15:54:34 <Chilli> which book?
15:54:51 <Igloo> Implementing functional languages or the same words in the other order
15:54:52 <Chilli> I don't think that this is in any of SPJ's books
15:55:13 <Igloo> I think it mentioned something similar, BICBW
15:55:18 <Chilli> do you maybe mean this method of abstracting over the binders?  (which is also used in GHC)
15:55:29 <Igloo> Possibly
15:55:37 <Chilli> ok, that's something different
15:55:56 <Chilli> That might actually have been useful
15:56:22 <Chilli> essentially, I am not too happy about all idents in THSyntax being Strings
15:56:38 <Igloo> What do you want them to be?
15:56:39 <Chilli> that's going to bite us for transformaing larger programs, I guess
15:57:18 <Chilli> The method you (I think) were refering to in SPJ's book, would be to have something like
15:57:26 <Igloo> Oh, if we could get at the function too that would be really neat, but then it couldn't be one from teh current module due to GHC's restrictions. Hmmm.
15:57:42 * Igloo AFKs for a bit, sorry
15:57:47 <Chilli> data Exp bind = Var bind | Con bind | Lit Lit | ....
15:58:37 * Chilli gets a tee
15:59:48 <Igloo> Back
16:04:13 <Chilli> re
16:04:34 <Chilli> have you written much code with TH yet?
16:05:05 <Igloo> Exceedingly little. I have 2 ideas, one very complex and one extremely simple and evil
16:05:17 <Igloo> (the latter being writing C code the Haskell will be linked with)
16:06:07 <Igloo> The former being http://www.comlab.ox.ac.uk/oucl/work/ian.lynagh/Mandelbrot/
16:06:38 <Chilli> yeah, I have seen your mandelbort page
16:06:45 <Chilli> interesting idea
16:07:16 <Chilli> I didn't get the second one though
16:07:17 <Igloo> My supervisor wants to do this sort of thing, but I pointed out it involves reimplementing a Haskell interpretter for the general case
16:07:21 <Igloo> second one?
16:07:24 <Chilli> what kind of C code?
16:07:28 <Igloo> Oh, inlining?
16:07:32 <Chilli> second = latter idea
16:07:37 <Igloo> Oh, right
16:09:11 <Igloo> Basically generating "chtype acs_block(void) { return ACS_BLOCK; }" for many values of acs_block. It's really rather gratuitous  :-)
16:10:37 <Chilli> to get C constants into Haskell
16:10:44 <Chilli> kind of lit lits via TH?
16:10:46 <Igloo> Yeah
16:10:51 <Chilli> ok, ic
16:11:19 <Chilli> yeah, probably quite a lot of FFI stuff could be simplified via TH
16:12:04 <Chilli> ok, so you don't have much code that would break when names change in THSyntax
16:12:07 <Igloo> It means I'll get to have a go at modifying the internals to add support for the FFI stuff which will hopefully be good fun and a learning experience etc  :-)
16:12:19 <Chilli> my concern is to get this stuff fixed now while it does not inconvenience many
16:13:09 <Igloo> Good plan - I'd like to hear Tim defend himself if he hasn't disappeared off the face of the planet, though
16:13:42 <Chilli> sure
16:14:00 <Chilli> for the parametrised data types that makes sense
16:14:16 <Chilli> but I also think that there are quite number of things for which there is no defense
16:14:24 <Chilli> eg, lack of an export list for starters
16:14:29 <Chilli> and defining Q as a type
16:14:34 <Chilli> (rather than a newtype)
16:14:35 <Pseudonym> Paper deadline is always a good defence.
16:14:37 <Igloo> FWIW the names generally made sense to me, but the TH specific 3 I was guessing at (correctly as it happens)
16:15:06 <Igloo> His paper was based on his own implementation I think
16:15:13 <engstad> Hi all!
16:15:19 <Pseudonym> G'day engstad.
16:15:33 <Chilli> I just don't like that the naming isn't really orthogonal
16:15:55 <Chilli> eg, letE and caseE just because there names are keywaords in Haskell
16:16:05 <Chilli> but other similar constructions have no suffix E
16:16:11 <Igloo> Ah, I see
16:16:22 <Chilli> better choose a conventions, then, were there are no clashes
16:16:51 <Chilli> and abbrevs such as Rihs
16:17:03 <Chilli> why not just but a Q suffix at all the lifted types
16:17:12 <Chilli> are some such
16:17:22 <Chilli> then, it is clear how to derive these names
16:17:34 <Chilli> easier to memorise for everybody
16:18:06 <Chilli> it's not even orthogonal in its own logicv
16:18:40 <Chilli> well maybe it is, I guess Clause doesn't count as the base def
16:19:02 <Chilli> otherwise, we have Exp and Expr
16:19:08 <Chilli> but Clause, Cls, and Clse
16:19:29 <Chilli> maybe Tim can remember this, i can't
16:19:32 <dark> Needing all three sounds bad enough :)
16:19:49 <Chilli> dark: I can't agree mire
16:19:52 <Chilli> mire = more
16:20:02 <Chilli> and one of the three is useless IMHO
16:22:16 <dark> Twenty years from now, you might look back and think, "I could have fixed all this twenty years ago".  Don't let it happen to you!
16:22:40 <Chilli> :-)
16:24:38 <dark> I'm still painfully amused by the story of the wrong precedence of the bit operations (&, |, ^) in C.
16:25:13 <engstad> Wrong precedence?
16:25:19 <dark> When they realized it was wrong, they already had two implementations and six installations, it would be too much work to correct.
16:25:58 <Pseudonym> Nobody can remember the 15 odd precedence levels in C.
16:26:09 * Pseudonym finds it hard enough remembering the Haskell ones
16:26:13 <Chilli> Igloo: ok, String and Integer lits as well as (e :: t) syntax is now supported in [| |]
16:26:37 <Pseudonym> engstad: If you've ever combined &, | and ^ with >> and <<, you'll know why they're wrong
16:27:06 <engstad> The rule is that you always put () on each side of << and >>, what's wrong with that?
16:27:10 <engstad> ;-)
16:27:17 * Pseudonym laughs
16:27:20 <Igloo> Cool
16:27:25 <Igloo> (or in a few hours for me  :-)  )
16:27:46 <Chilli> Igloo: what sort of reify was it that you said you would need soon?
16:28:11 <dark> engstad: Somehow it often gives surprising (buggy) results.  I don't even remember the actual precedence, just that I always have to use parens, no matter what the usage :)
16:28:17 <engstad> Chilli: What are you talking about? (Lost the first part.)
16:28:19 <Igloo> I will want to be able to reify an entire function I think
16:28:20 <Chilli> (grr, except that I get a CVS conflict...)
16:28:42 <Chilli> engstad: Template Haskell
16:28:49 <Chilli> Igloo: hmm, ic
16:28:57 <dark> engstad: But I've several times had to fix bugs because people expect them to have the same approximate precedence as * and /, but it's way different.
16:28:57 <engstad> Ch: Interesting. Web-site?
16:29:28 <dark> It's not just with << and >>, but also with ==.
16:29:39 <engstad> *nod*'
16:30:15 <Igloo> I can't remember how urgent it is, but basically if I am going to unroll the MB function I need to know what it looks like. I could rewrite it as a single expression for now, though, so it isn't really a problem
16:31:26 <dark> Hmm, I don't think I ever used the precedence rules in haskell :)
16:31:33 <dark> Except that function application binds strongest.
16:32:31 <dark> Oh, I've used ++ being stronger than $
16:33:15 <dark> So obviously Haskell only needs two levels :-)
16:33:31 <Pseudonym> I don't like the associativity of $
16:33:34 <Igloo> I don't tend to use more than ' ' > * > + > $
16:33:40 <Pseudonym> Or $!
16:33:56 <dark> Pseudonym: Hmm, I often go map ... $ filter ... $ lines $ etc etc
16:34:06 <dark> Pseudonym: Works fine for me.
16:34:13 <Pseudonym> If I need that, I do map f . filter p . lines $ etc
16:34:17 * Igloo realises I should have remembered where my penultimate sentence started and deleted the beginning of it once I'd reached the end  :-)
16:34:52 <Pseudonym> OTOH, I often want to do this:
16:35:03 <dark> Igloo: If you're that concerned about correctness, then try not to switch pronouns halfway through a sentence :)
16:35:09 <dark> Igloo: It makes my AI programs crash.
16:35:11 <Pseudonym> f lazyarg $! strictarg lazyarg2 $! strictarg2
16:35:42 <Pseudonym> Or at least:
16:35:45 <Igloo> dark: Huh? Do you mean "Igloo realises" vs "I"?
16:35:47 <Pseudonym> f lazyarg $! strictarg1 $! strictarg2
16:35:52 <dark> Igloo: Yep.
16:36:13 <dark> Pseudonym: So your beef is with $! :)
16:36:13 * Pseudonym realises he shouldn't change person like I always do
16:36:15 <Igloo> Oh, that's just how I write /mes. Both ways feel wrong to me.
16:36:21 <Pseudonym> dark: That too. :-)
16:36:34 <dark> Igloo: If you feel the need to switch pronouns, try starting with "I" instead of "/me" :-)
16:36:41 <dark> Works for me.
16:36:55 <Pseudonym> You can probably change /me to I in a macro or somethign.
16:37:04 <dark> Bah, macros.
16:37:06 * dark waves his paw.
16:37:08 <Pseudonym> I tries it out.
16:37:38 <Igloo> "I've realised" seems clumsier or more formal
16:37:54 <Pseudonym> More formal would be to use the royal plural.
16:38:07 * Pseudonym is annoyed how papers do that even if there's only one author
16:38:10 <dark> "We, the combined personalities of Igloo, have hereby determined that..."
16:38:39 <dark> Pseudonym: Hmm, I do that in comments :)
16:38:49 <dark> Pseudonym: But it's not the royal or editorial "we", it's the "me and the reader" we.
16:39:13 <Pseudonym> Which seems presumptuous.
16:39:23 <Pseudonym> No I will _not_ prove your theorem.  That's your job.
16:39:48 <dark> Heh.
16:39:57 <dark> What happened to "an exercise left for the reader"?
16:40:09 <Pseudonym> Ah, yes.  Proof by delegation.
16:40:21 <dark> -- Note: We have to be careful about filenames colliding with directory names, because...
16:40:23 <dark> That sort of thing.
16:40:41 <dark> I think it would look weird with "I" there, actually.
16:40:42 <Pseudonym> Well that "we" is the programmer and the maintainer.
16:40:56 <Pseudonym> Even if they're the same person, the "we" refers to two different jobs.
16:41:00 <dark> Yeah but there's just me.  For now :)  I guess I'm anticipating that Iwon't be the only one for ever.
16:41:13 <dark> Another example:
16:41:14 <Pseudonym> Speaking through my maintainer hat...
16:41:29 <dark> -- We know the tag won't contain spaces, because...
16:41:40 <dark> That's a FYI, not a "must do" :)
16:41:43 <Pseudonym> That's the programmer and the implementation talking.
16:41:53 <dark> Do you object to that?
16:42:05 <dark> I guess the "We know" can be deleted without loss of information.
16:42:06 <Pseudonym> I guess not.
16:42:20 <Pseudonym> Or perhaps "without lots of information".
16:42:31 <dark> *scratch*
16:42:44 <Pseudonym> Ever read "Concrete Mathematics"?
16:42:55 <dark> Nope.
16:42:57 <Pseudonym> It's a Knuth et al book.
16:43:30 <Pseudonym> In the margins is a whole lot of feedback and commentary from students who took the course.
16:43:44 <dark> Actually printed in the margins?  Interesting :)
16:43:49 <Pseudonym> Including smartarse comments like "without lots of generality..."
16:44:12 <Pseudonym> Yes, it's actually quite a nice feature for a textbook.
16:44:16 <dark> And it's just begging for "I have a nice proof for this, but it doesn't fit in the margin".
16:44:31 <Pseudonym> "Warning, from here on in the examples get even more poorly motivated."
16:46:04 <dark> Hmm, here I switched pronouns:
16:46:22 <dark> -- To get exact compatibility we would also need isSpace, but I think that contradicts the requirement for the id to fit on one line.  We can accept tabs, though.
16:46:36 <dark> Note the cunning we => I => we transformation.
16:46:56 <Pseudonym> Indeed.
16:47:07 <Pseudonym> It would look weird to say "but we think..."
16:47:14 <dark> Yeah, arrogant :)
16:47:22 <Pseudonym> {- drunk.. we will fix later -}
16:47:28 <dark> *laugh*
16:48:44 <dark> I guess "the implementation and I" is the mode in which I use it.
16:49:22 <dark> And apparently the implementation can "be careful" but it can't "think" :)
16:50:01 <Pseudonym> And vice versa.
16:50:22 <Pseudonym> I can think but I can't be careful.
16:51:42 <dark> *scratch*
16:51:56 <engstad> Compatibility requires the use of isSpace, but it may contradict the requirement specification of fitting the id to one line.
16:52:22 <engstad> *shrug*
16:52:32 <dark> "Tabs are acceptable, though"
16:52:49 <dark> engstad: It doesn't really communicate the decision to not use isSpace, though.
16:53:49 <engstad> What's the "id" anyways?
16:53:59 <dark> engstad: User identity label.
16:55:32 <dark> This is a version control program.  The id is used to mark who committed what :)
16:55:35 <engstad> In order to be perfectly compatible it is neccessary to add isSpace, but that contradicts the requirement for the ID to fit on one line. Tabs are acceptable, though.
16:56:39 <dark> Hmm, should I use that instead? :)
16:58:08 <engstad> Compatibility => adding isSpace, but fitLine ID = \empty. ok(tabs).
16:58:55 <dark> Heh.
17:00:50 <engstad> Btw, in list comprehension (and also mathematical syntax), people use the verticle bar '|' for "such that", but I hate it. Instead I prefer ':'. So that, S = { |v| : v \dot u = 0}
17:01:06 <dark> Now that I'm thinking about it, the comment doesn't make much sense.  The requirement for the ID to fit on one line is operational.  Things break if it doesn't.  The only sense in which I would be compatible would be by being equally broken :)
17:01:37 <dark> Then again, that's what is sometimes meant by compatibility.
17:01:48 <dark> engstad: Hmm, does your vertical bar have a gap in it?
17:02:19 <engstad> A gap? No, I'm thinking of LaTeX.
17:02:28 <dark> engstad: Ah, you hate it because you want to free up the vertical bar for other things?
17:02:33 <engstad> Yes.
17:02:39 <engstad> It doesn't read well.
17:02:57 <dark> The colon actually has a linguistic "such that" meaning.
17:12:58 <engstad> Exactly.
17:14:49 <dark> Hmm, it's sort of already taken in Haskell :)
17:15:15 <dark> And the vertical bar matches up nicely with the guard syntax.
17:18:12 <engstad> Question. If you need to use a couple of monads, like one continuation monad, one state monad and so on, how do you usually go about it?
17:18:40 <dark> I haven't had occasion to :)
17:19:13 <dark> But I think I would stack a couple of monad transformers, and then curse about having to use "lift" on every line.
17:21:54 <engstad> Heh.
17:21:56 <dark> Hmm, I guess all the lifting could be avoided by adding instance declarations.
17:21:58 --- topic: set to 'mo' nads than you || We put the Funk in Funktion || See logs @ http://tunes.org/~nef/logs/haskell/ || Gtk+HS  0.14.10 released http://www.cse.unsw.edu.au/~chak/haskell/gtk/ || ICFP is over <Erwin> Your mother asked you to write COM program? Who are you, Dilbert? || Ganesh's HaskPerl challenge: make Haskell look like line noise too!' by ChanServ
17:25:57 <Igloo> What changed? Gtk+HS?
17:26:11 <Chilli> nothing chnages
17:26:19 <Chilli> ChanServ reverted to an old topic
17:26:24 <Chilli> for reasons that elude me
17:27:01 <Igloo> Oh, Chilli, do you know if it's possible to do work in the background while Gtk+HS "has control"? I got the impressino not because of the way all Haskell threads are a single OS thread
17:27:12 <Igloo> Desplitting possibly
17:27:54 <Chilli> Igloo: you are right (besides GTK+ is not thread-safe, as X is not)
17:28:06 <Chilli> what you can do is to use a timeout signal handler
17:28:40 <Chilli> to call back into Haskell land at regular intervals and then use Haskell's Concurrent. yield to make sure your background thread gets some wortk done befgore returning to GTK+
17:28:45 <Igloo> What I wanted to do was to sit there drawing a fractal but be able to respond to things like "stop" or a change of axes request
17:29:02 <Chilli> yes, that's easily possible using such a timeout handler
17:29:28 <Chilli> and because it is cooperative, you don't even have to worry much about races
17:29:29 <Igloo> It would either seem sluggish or take quite a hit, though  :-/
17:29:42 <Chilli> why?
17:30:13 <Chilli> all you want is return to GTK+ periodically, so it can check whether there are any outstanding events
17:30:17 <Igloo> Because it would spend some time not listening for events. I could be overestimating the hit taken
17:30:44 <Igloo> Yes, but very short periods if I want a seemingly instant response to the mouse being pressed
17:30:45 <Chilli> that's just a matter of granulairty
17:30:56 <Chilli> even with preemptive threads, there is a delay
17:31:11 <Chilli> sure, couple of ms range
17:31:29 <Igloo> Concurrent.yield is non-standard I assume too
17:32:07 <Chilli> the whole thread-story is non-standard, but without threads you can't do this anyway (even if GTK+ would support multi-threading)
17:33:06 <Igloo> Hmmm, true. I guess I'll just put it off some more for now  :-)
17:33:33 <Chilli> ok, but it is really easy to do using this technique
17:33:56 <Igloo> But not nice
17:37:11 <Igloo> Hmmm, any idea what ParSt is?
17:37:59 <Chilli> parallel list comprehensions, a non-standard extension
17:38:24 <Chilli> [x + y | x <- xs | y <- ys] == [x + y | (z, y) <- zip xs ys]
17:38:31 <Chilli> z = x
17:38:53 <Igloo> OK, ta
17:41:51 <Heffalump> what is [x + y + z | x <- xs, y <- ys | z <- zs] ?
17:42:16 <dark> You're asking about precedence?
17:43:26 <Chilli> [x + y + z | (x, y) <- [(x, y) | x <- xs, y <- ys] | z <- zs]
17:52:02 <engstad> Btw, what back-end is ghc using?
17:52:29 <dark> gcc if you use -fvia-C, otherwise its own.
17:52:42 <dark> Well, I think it'll still use an assembler.
17:54:49 <Pseudonym> dark: A lot of the monad transformers have instance declarations already.
17:55:12 <dark> Pseudonym: Even if you stack them?
17:55:15 <Pseudonym> For example, all monad transformers support liftIO, which lifts to an IO monad if it's there.
17:55:21 <Pseudonym> Yes.
17:55:26 <Pseudonym> For example:
17:55:26 <dark> Cool :)
17:55:41 <Pseudonym> instance MonadState m => MonadState (FooTrans m) where
17:55:45 <Pseudonym>   ask = lift . ask
17:55:46 <Pseudonym> etc
17:56:09 <Pseudonym> Some of the fun is working out what instance declarations make sense.
17:57:28 <dark> Hmm, sounds like I should be doing that with my RandT.
17:57:52 <dark> I put it on top of State, and then I get annoyed at using lift $ modify all the time :)
18:01:35 <engstad> Hmm, here's a challenge for your bright minds... Given four-tuples of symbols (String), and a list of transformations, FourTuple String -> FourTuple String, and binary operations FourTuple String -> FourTuple String -> FourTuple String, determine the least
18:01:36 <dark> Funny thing is that RandT is a wrapper around StateT itself, so it's easy to get confused, and the type ends up being like a StateT State monad.
18:02:02 <engstad> amount of steps to produce a given output from a given input.
18:02:17 <dark> This is Mastermind, right? :-)
18:02:26 <engstad> Almost. :-)
18:03:01 <dark> Or one of those language games, go from "fnord" to "ewoks" via "faust"
18:03:01 <engstad> Example: prot3w (a,b,c,d) = (c,a,b,d)
18:03:29 <engstad>       pextuw (_,_,a,b) (_,_,c,d) = (a,b,c,d)
18:04:33 <engstad> And a couple of other operations (unary and binary).
18:04:53 <dark> And you have to find the shortest path?
18:04:56 <engstad> Yes.
18:05:08 <engstad> Well, the shortest number of instructions.
18:05:33 <engstad> The instructions are wide (128-bit) operations "munging" 32-bit fields.
18:06:01 <engstad> So, "prot3w" is parallel rotate three words. 
18:06:26 <dark> Sounds like a job for GNU Superopt :-)
18:06:32 <engstad> superopt?
18:06:50 <dark> It's a tool for finding short instruction sequences for certain functions, via exhaustive search.
18:07:09 <dark> It helps when you're porting C compilers to strange new architectures.
18:07:28 <engstad> Ah. Interesting.
18:07:34 <dark> For example, the eternal "compare two numbers and convert result to 0 or 1" problem.
18:07:52 <dark> Superopt found some sequences that were shorter than what the architecture designers thought were possible :)
18:08:01 <dark> (With a VAX, though, so that's cheating)
18:08:06 <engstad> Hehe...
18:08:11 <engstad> I'll check it out.
18:08:33 <engstad> But, one should still be able to solve this problem in Haskell.
18:08:45 <dark> Yeah, but is exhaustive search acceptable?
18:08:52 <engstad> Sure.
18:09:39 <engstad> It should be a fun task for students. (And I can make use of the result.)
18:10:11 <engstad> I wonder if you could reason about the transformations.
18:10:23 <dark> This reminds me of someone who ran lcc's optimizer in reverse :)  He fed it a specific program, and it found which opcode definitions would give the shortest code.  (opcodes were constrained a bit, of course)
18:10:52 <dark> It was used for embedded stuff, where making a custom processor was cheaper than adding ram.
18:11:15 <dark> s/ram/memory/
18:11:45 <dark> engstad: I think it might be more fun to reason about transformations, but that it would also make it less suitable as a student exercise.
18:11:59 <dark> hmm...
18:12:18 <engstad> Perhaps..
18:12:22 <dark> I think that at least such reasoning could be used to prune the search.
18:13:06 <dark> Hmm, maybe not.
18:13:15 <dark> Just about any transformation can be useful in a side path :)
18:13:30 <dark> Since you have binary operators, I assume the transformations don't have to be applied in sequence.
18:14:45 <dark> Are all of them rearrangements, or do they use other operations like addition too?
18:14:56 <engstad> No, they are all just rearrangements.
18:15:08 <engstad> It would be cool to extend it though. 
18:16:14 <engstad> There are 64-bit transforms: (a,b,_,_) (c,d,_,_) -> (a,b,c,d) could be seen as (a',_) (b',_) -> (a',b'), where a' and b' are 64 bit.
18:16:37 <engstad> And there are also 16-bit transforms. 
18:16:45 <engstad> And 8-bit transforms.
18:17:03 <engstad> But, for me only the 32-bit ones are interesting.
18:18:51 <dark> I think an exhaustive search could quickly grow out of hand :)
18:38:45 <Pseudonym> engstad: I think dynamic programming is your friend.
18:38:59 <Pseudonym> Does it count if you share subtrees?
18:39:59 <Pseudonym> Oh, he's gone.
18:45:37 <dark> I think I wouldn't try to construct trees, but pretend it's an RTL.
18:48:52 <dark> Operands would be the results of previous instructions, by instruction number.  A nicely constrained set :)
18:50:58 <Pseudonym> I think the representation doesn't matter.
18:52:24 <Pseudonym> Effectively you do a breadth-first search from the initial state.
18:52:41 <Pseudonym> Store the cheapest way to get a certain string.
18:53:07 <Pseudonym> Hmm.
18:54:04 <dark> There's only 256 permutations :)
18:54:17 <dark> However, with binary operators, it can be important to have more than one of them available.
18:55:15 <Pseudonym> Are there only 256 permutations?
18:55:20 <dark> Hmm, I guess a binary operator would just add the cost of its operands.  Except that one operand could be produced in the process of constructing the other.
18:55:35 <Pseudonym> Binary operations could decide what transform to make based on the string arguments.
18:55:36 <dark> Well, he said there were only rearrangements of 4-tuples.
18:56:03 <Pseudonym> op (a,b,c,d) = if a = "" then (a,c,b,d) else (d,c,b a)
18:56:07 <Pseudonym> That's a rearrangement.
18:56:11 <Pseudonym> Of sorts.
18:56:17 <dark> Hmm.
18:56:50 <dark> There's still only 256 possible results, though.
18:57:07 <dark> So a table storing the cheapest way to get to each would be feasible.
18:57:13 <Pseudonym> True.
18:57:20 <Pseudonym> Oh!
18:57:22 <Pseudonym> Duh.
18:57:34 <Pseudonym> Are you allowed to invert the ops?
18:57:44 <dark> I don't know. 
18:57:53 <Pseudonym> If so, the solution is very easy.
18:57:54 <dark> Probably not, I get the impression these ops are part of the machine.
18:58:11 <dark> Some of them also throw away information.
18:58:19 <Pseudonym> I don't think that matters.
18:58:32 <Pseudonym> If you can invert them, it's easy.
18:59:16 <Pseudonym> It's really cheeky, though.
18:59:50 <Pseudonym> Oh, hang on.
18:59:52 <dark> Well I don't see what you're thinking of :)
19:00:00 <Pseudonym> No.  My algorithm could get stuck in an infinite loop.
19:00:04 <Pseudonym> That would be bad.
19:00:45 <Pseudonym> What I was thinking of is this: You set up an array.  One element (the initial one) is set specially to hold a "no operations required" value.
19:01:15 <Pseudonym> In the others you put a function call which finds what states you could go from to get to this state.
19:01:20 <Pseudonym> By inverting the ops.
19:01:47 <Pseudonym> It then looks up the array to find the cheapest way to compute those states.
19:02:08 <Pseudonym> Then all you need to do is look up the array element corresponding to the final state and lazy evaluation will do the rest.
19:04:15 <dark> I think you can avoid the inversion by going from the final value to the initial value.
19:04:30 <Pseudonym> Yes, but I was being trickier.
19:04:38 <Pseudonym> Letting lazy evaluation do the hard work for you.
19:04:58 <Pseudonym> I have some code which illustrates what I mean.
19:05:17 <Pseudonym> It's on the wiki which doesn't help much.
19:06:39 <Pseudonym> If you have a look here:
19:06:41 <Pseudonym> http://haskell.org/wiki/wiki?edit=MemoisingCafs&rev=1.11
19:06:48 <Pseudonym> Go to the wonderous example.
19:22:48 <dark> Hmm, sounds like a useful technique for my disassembler :)
19:23:12 <Pseudonym> It depends on being able to index states easily.
19:23:21 <Pseudonym> And being able to enumerate them in advance.
19:23:47 <dark> The most natural way to represent the disassembler is as a list of pattern-matching functions, where a scanning function picks the first one that matches and runs its corresponding action.
19:23:59 * Pseudonym nods
19:24:06 <Pseudonym> Greedy algorithm.
19:24:07 <dark> I worried about the expense of that, though.
19:24:31 <dark> but there's only 256 possible starting bytes, and constructing an array that partially evaluates based on that would speed it up :)
19:24:47 <Pseudonym> Right.
19:24:53 <Pseudonym> I think most disassemblers do that.
19:25:01 <Pseudonym> Have a full table for the first byte.
19:25:05 <Pseudonym> Certainly for x86.
19:25:23 <dark> Indeed, but in Haskell I didn't want to pollute the presentation with that kind of optimization :)
19:25:24 <Pseudonym> For the Sparc it's not so smart.
19:25:34 <Pseudonym> Even less smart for the IA64.
19:25:52 <dark> The sparc always has 4-byte instructions, right?
19:25:57 <Pseudonym> Yes.
19:26:11 <dark> Extracting an opcode pattern from that shouldn't be hard :)
19:26:21 <dark> It needn't be the first byte if you already know the length of the instruction.
19:26:23 <Pseudonym> The only tricky part is watching for delay slots.
19:27:42 <Pseudonym> Oh, cute feature I discovered on the IA64.
19:27:51 <Pseudonym> Every register is duplicated.
19:28:02 <Pseudonym> One bank is for normal code, the other is for interrupts.
19:28:12 <Pseudonym> So you don't have to save all your registers to get useful work done.
19:28:40 <dark> Cool :)
19:28:59 <dark> And interrupts are also the way to drop into kernel mode?
19:29:10 <Pseudonym> Erm...
19:29:26 <dark> I'm thinking of efficient system calls here :)
19:29:38 <dark> On x86 that's done with a software interrupt.
19:30:02 <Pseudonym> Well, it shouldn't be.
19:30:26 <Pseudonym> On K7/P4 there's sysenter
19:30:31 <Pseudonym> Or...
19:30:35 <dark> I think it's because interrupts already did all the state-saving stuff and already invoked privileged mode (to deal with hardware), so system calls were easy to tack on.
19:30:40 <Pseudonym> One of them is Athlon-specific and the other is P4-specific.
19:30:54 <dark> I'll bet that "sysenter" is just an interrupt with wallpaper over it :)
19:30:54 <Pseudonym> Yes, and it was easier than to set up a call gate.
19:31:00 <Pseudonym> No it isn't.
19:31:23 <Pseudonym> It doesn't do any stack operations (apart from switching to the ring-0 stack).
19:31:40 <dark> Ah, so register rescue is left to the callee?
19:31:43 <Pseudonym> It dumps the return address in a register.
19:31:49 <Pseudonym> No.
19:32:13 <Pseudonym> The ABI guarantees that some registers are clobbered across calls.
19:32:16 <Pseudonym> You can use them.
19:32:19 <dark> Aha...
19:32:36 <dark> Yeah, I see.  Using the instruction is under control of the caller, so there's less need to be careful.
19:32:42 <Pseudonym> Right.
19:33:27 <Pseudonym> OK, it looks like you do enter with a fault.
19:33:54 <Pseudonym> The IA64 is much more careful about distinguishing between interrupts, faults and exceptions.
19:36:24 <dark> Last year I considered getting one :)
19:36:35 <Pseudonym> We have one here.
19:36:39 <dark> The actual processor was affordable, but it was only compatible with expensive machines.
19:36:41 <Pseudonym> We're asking HP for a second.
19:36:50 <Pseudonym> They're actually not that good.
19:37:05 <dark> Yeah... I've wanted one for years, but the reason I didn't get one was partly disappointment.
19:37:17 <dark> I'd love to hack on a compiler for them, though.
19:37:23 <Pseudonym> SMP scalability is great, so you could go (in theory) to 16 or more CPUs and it wouldn't choke like the Pentiums do.
19:37:26 <dark> But only if I own one :)  I'm possessive that way.
19:37:30 <Pseudonym> But each CPU is quite slow.
19:37:44 <dark> I like HP's approach to installing memory.
19:37:54 <Pseudonym> WHat's that?
19:38:23 <dark> Lots of slots, so lots of interleaving, smallish units so that the price per kilobyte stays low.
19:38:34 * Pseudonym nods
19:38:40 <Pseudonym> That's a good thing.
19:38:49 <dark> So, 32 256kB chips instead of 4 ultra-expensive GB chips.
19:38:56 <dark> Hmm, my math is off :)
19:39:05 <Pseudonym> I get what you mean.
19:39:34 <dark> I had to search far to find a PC board that had even 4 slots :(
19:39:41 <Pseudonym> Yes.  There's some nice stuff in the IA64, but I suspect that EPIC is fundamentally flawed.
19:39:55 <Pseudonym> Asynchronous RISC will most likely beat the pants off it in the long run.
19:40:09 <dark> Hmm...
19:40:17 <dark> Only if it rediscovers the R in RISC, I think :-)
19:40:44 <Pseudonym> I don't think so.
19:41:11 <Pseudonym> A good asynchronous design, plus a smart compiler, will mean that the non-R instructions will only take as long as you're prepared to wait for them.
19:41:20 <dark> Hmm.
19:41:32 <dark> Won't the "good asynchronous design" part be much more difficult though? :)
19:41:35 <Pseudonym> You start a multiply instruction, then you do some stuff, then you get the result later.
19:41:51 <Pseudonym> And when you demand the result, that's when you wait (if you have to).
19:42:05 <Pseudonym> Uh, true. :-)
19:42:23 <Pseudonym> I'm a scientist, not a chip designer!
19:42:40 <Pseudonym> Sorry, wrong quote.
19:42:41 * Igloo mutters about silly CVS lag
19:42:46 <Pseudonym> I'm a doctor, not a chip designer!
19:42:48 <Pseudonym> That's more like it.
19:43:11 <dark> Actually, I'm being inconsistent here :)  I've also claimed that RISC's main problem is that memory bandwidth has become the bottleneck, so code density is important again.
19:43:52 <dark> Igloo: What a good thing that I'm working on a fast version control tool :-)
19:44:01 <Pseudonym> I disagree on that one.  Instruction cache prediction is very easy.
19:44:15 <Igloo> dark: This is sysadmin induced lag, however  :-)
19:44:25 * Igloo wonders which tool, anyway
19:44:27 <Pseudonym> dark's tool fixes that too
19:44:44 <Pseudonym> If you specify --sysadmin-lart
19:44:57 <Igloo> Pseudonym: Does it also solve the halting problem and show that P = (or /=) NP?
19:45:05 <dark> Igloo: I call it "harc" :)  It'll be backend-compatible with Tom Lord's "arch", but faster.  (Speed and scalability are arch's main problems, I quite like its namespace design)
19:45:06 <Pseudonym> Next version.
19:45:25 <Igloo> Ah - in what language are you writing it?
19:45:30 <dark> Haskell, of course :-)
19:45:42 <Igloo> Cool  :-)
19:45:56 <dark> Haskell may be hard to tune sometimes, but beating shell scripts is not difficult :-)
19:46:06 <Pseudonym> You didn't expect him to admit it was PL/I on this channel, did you?
19:46:38 <dark> I think I'll be able to publish version 0.1 in a week or two.  It won't do anything more interesting than "get" (~= checkout), but it will do it very quickly :)
19:47:15 <Igloo> Have you heard of apache?  :-)
19:47:23 <dark> Er, yeah?
19:47:42 <Igloo> n/m, poor attempt at humour
19:47:55 <Igloo> Apache also being very good at serving get requests
19:48:05 <dark> Ah :)  But this is a client, you see.
19:48:36 <dark> And the combined efforts of the human race have so far been able to produce a web client that doesn't suck.  We might be up against one of Nature's limits.
19:48:45 <dark> s/able/unable, sheesh, I spoil my own quotes.
19:49:15 <Igloo> wget doesn't really suck
19:49:30 <Igloo> (admittedly I haven't looked at the code)
19:49:38 <dark> (One of arch's claims to fame is that you can serve an archive with ordinary FTP.  Someone then noticed that FTP sucks and added some other protocols :)
19:50:06 <dark> Yeah, the suckage is in web _browsers_ I guess.
19:50:19 <dark> Maybe browsing is simply not meant to be a human activity.  We're omnivores.
19:51:35 <Pseudonym> Hypertext theorists will tell you that web browsing as we currently know it is like interacting with an assembler.
19:51:54 <Pseudonym> It's still very low-level.
19:52:04 <dark> Anyway, Haskell itself already solves the halting problem... lazily :)  Problem is, you never know how long you'll have to wait to get the answer.  I hope that'll be fixed in Haskell2.
19:52:34 <Pseudonym> Yes.  I can solve the halting problem, and it takes zero time if I don't require the answer.
19:52:49 <dark> See?  Some things are just easy.
19:53:53 <dark> I don't know if hypertext theory is still relevant :)  What used to be a hypertext web has been coopted into a remote application server.
19:54:13 <Pseudonym> True.
19:54:54 <dark> I'm as guilty of it as anyone, I pay my bills via my bank's web interface.
19:55:08 <Pseudonym> I don't.  I use the phone.
19:55:14 <Pseudonym> I still talk to a machine, of course.
19:55:48 <Pseudonym> Every time I want to talk to a human they spend a lot of time telling me how much they value my call while they ignore it.
19:56:02 <dark> They value it so much, they want to hold on to it a bit longer :)
19:56:40 <dark> "... press 2 if you're so desperate that you're willing to buy something just for the chance to speak to a human being"
19:57:30 <dark> Heh, this reminds me of one of my favourite quotes from Megahal (one of those conversation simulators):  "I have talked to machines, and they are all more intelligent than you!"
19:58:37 <dark> I obviously need to go to bed soon :)
23:27:31 <bronaugh> hmm.
23:27:45 <bronaugh> trying to get a handle on writing stuff in haskell.
23:28:10 <bronaugh> how would you do something really dumb like 'hello world'
23:28:13 <bronaugh> using the hugs interpreter?
23:28:32 <bronaugh> (and yes, I know, IO may be implemented using side effects, yadda yadda.
23:28:32 <bronaugh> )
23:29:37 <bronaugh> hmm ok, so you use show.
