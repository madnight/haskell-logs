04:56:00 <Heffalump> what does LoganACM mean?
06:40:24 <Marvin--> hmm, is there no standard function for "pipelining" monadic functions?
06:40:39 <ibid> pipelining?
06:40:57 <Marvin--> something like :: [a -> m a] -> a -> m a
06:41:13 <Marvin--> foo [] r = return r
06:41:18 <Heffalump> how about sequence (map (flip ($)))
06:41:20 <Heffalump> or similar
06:41:20 <Marvin--> foo (m:ms) r = m r >>= foo ms
06:41:26 <andersca> looks like the list monad :)
06:41:49 <ibid> i'd try something with fold and >>=
06:41:49 <Heffalump> actually, with the type you give it's not at all clear what the final a should be
06:41:57 <Heffalump> I'd expect [a -> m a] -> a -> m [a]
06:42:34 <Marvin--> Heffalump: well, with the definition  foo (m:ms) r = m r >>= foo ms  I hope it's clear what I want :)
06:42:46 <Heffalump> oh, right, yeah
06:42:47 <Heffalump> sorry
06:42:53 <Heffalump> you need some kind of fold then
06:44:01 <Marvin--> ah well, I'll just go with this definition
06:44:16 <Marvin--> odd though, feels like I wouldn't be the first to want this kind of thing
06:44:58 <Heffalump> foldr (flip (>>=))
06:45:02 <Heffalump> is nearly but not quite what you want
06:45:24 <Heffalump> I think
06:45:37 <Heffalump> or possibly you want foldl (>>=)
06:47:34 <Marvin--> foldl might be it
06:47:58 * Heffalump too lazy to work it out :-)
06:48:21 <Marvin--> foo ms r = foldl (>>=) (return r) ms
06:48:33 <andersca> interesting
06:48:53 <Marvin--> I suppose you could use foldr (=<<) too
06:49:20 <Marvin--> no, that's give reverse order
06:49:22 <andersca> wow, there's a =<< ?
06:50:38 <Marvin--> f =<< x = x >>= f, not that interesting :-)
06:51:11 <Heffalump> so it's just flip (>>=)
06:51:26 <Marvin--> yup
06:51:56 <andersca> ah
07:13:01 <andersca> so
07:13:04 <andersca> what does forall mean?
07:15:00 <ibid> for all
07:15:05 <Marvin--> all quantifier over types
07:15:16 <ibid> universal :-)
07:18:52 <Marvin--> whatever
07:19:32 <andersca> I got it when writing :t 2 in ghci
07:22:23 <Marvin--> yup, 2 has the type forall t . Num t => t
07:22:57 <Marvin--> when you write functions and say the type is a -> b, the forall:s are implicit. the "real" type is forall a b . a -> b
07:24:47 <Marvin--> I had a look at the implementation of Data.Dynamic.. the unsafeCoerce stuff was a bit scary ;)
07:25:04 <andersca> ah
07:32:52 <ludde> on an exam, when making a type system, would both those be okay to specify that we add a variable to the environment:   G("x", TInt)   or   G(x : int)
07:33:24 <ibid> depends on what you've been taught
07:33:43 <Marvin--> ludde: I can't speak for Marcin of course, and he'll be doing the marking, but I'd accept both
07:33:59 <ludde> Marvin--: thanks
07:43:20 <shapr> hiya
07:43:21 <shapr> what's up?
07:44:26 <Marvin--> hey shapr
07:45:44 <shapr> hi Marvin, how's life?
07:45:52 <Marvin--> hrrm, maybe I should use arrows instead of monads for this pipelining thingy
07:45:54 <shapr> finished correcting your papers?
07:46:07 <shapr> if you mean the webserver pipeline, I think arrows would be better.
07:46:18 <Marvin--> shapr: no I've got lots of stuff to do
07:46:30 <Marvin--> shapr: I've corrected most of the things I've gotten *so far* but the next deadline is on Monday *sigh*
07:46:46 <shapr> sounds like higher education means "more work, less pay" ;-)
07:47:49 <Marvin--> hmm, basically, I *am* already using Kleisli arrows here
07:48:16 * shapr still isn't sure what one of those is..
07:48:30 <shapr> for the webserver pipeline, lots of static info could be available.
07:49:08 <Marvin--> yeah... HWS uses lots of IORefs and stuff, I'd be happier with a state monad
07:49:32 <Marvin--> I suppose you could throw in some implicit parameters too to make it nicely incompatible with everything :-9
07:49:33 <shapr> yah, HWS also explicitly passes the configuration around in "conf"
07:49:42 <Marvin--> ?conf :-)
07:49:48 <shapr> well, a Config monad might be simpler
07:49:52 <Marvin--> yeah :)
07:50:01 <Marvin--> but implicit parameters are cool ;)
07:50:06 <shapr> I haven't used them yet
07:51:18 * shapr swears at HaXml
07:51:18 <Marvin--> and a Kleisli arrow is just Monad m => a -> m b
07:51:54 <shapr> Hughes talks about them in the Arrows paper, but I need to read more about them to understand what's going on there.
07:52:02 <shapr> I'm missing a lot of math background.
07:52:34 <shapr> my formal education gets as far as one cs101 course, and one business calculus course.
07:54:11 <shapr> I wish HaXml were in ghc in such a way that building and installing a new version would replace the old version.
07:54:11 <Marvin--> eh, what is the tilde in ~(a,b)?
07:54:16 <shapr> that would make my life simpler.
07:54:30 <shapr> um... I think that's a lazy/strict operator, but I forget exactly what
07:54:40 * shapr looks in books
07:55:31 <Marvin--> I thought ! was used for specifying strictness?
07:56:01 <shapr> I'm pretty sure that $! is the opposite of $
07:56:15 <shapr> the tilde isn't mentioned in Hudak or Thompson
07:56:49 <ibid> ! is used for strictness in defining data constructors
07:56:59 <shapr> is the ~ the opposite?
07:57:11 <ibid> ~ is used for nonstrictness in patterns
07:57:28 * shapr tries to figure out what that's good for
07:58:36 <ibid> for example, foo@(~(bar:baz)) binds foo to the whole and bar nonstrictly to the head and baz nonstrictly to the tail
07:59:16 <ibid> compare to foo@(bar:baz), where bar and baz are bound strictly
07:59:18 <shapr> does that mean "bind only when someone first uses bar or baz" ?
07:59:23 <ibid> no
07:59:29 <ibid> it means, bind nonstrictly
07:59:34 <ibid> it is bound at that point
07:59:56 <ibid> but they may get to be bound to bottom
08:00:16 <ibid> strict binding to bottom causes an immediate error message
08:00:44 <shapr> oh, I think I understand that.
08:00:49 <ibid> with nonstrict binding to bottom, nothing bad happens unless you try to use the value
08:01:00 <ibid> but yeah, you were close
08:01:29 <ibid> shapr: it's convenient in situations like these:
08:02:00 <Marvin--> ah, cool
08:02:18 <ibid> let rv@(~(Just v)) = f in if isNothing rv then 0 else v
08:02:55 <ibid> so, if f is Nothing, v is bound nonstrictly to bottom
08:03:13 <ibid> and since it is not used, the expression evaluates to 0
08:03:33 * shapr thinks about that
08:03:51 <ibid> of course, you could use case expression and not need the tilde at all
08:05:15 <ibid> note that let rv = ... is equivalent to let ~rv = ..., ~ is implied for the pattern as a whole
08:07:11 * shapr blinks
08:07:55 <Marvin--> can you say let !(Just x) = lookup ...?
08:08:10 <ibid> ! is not used in patterns afaik
08:08:17 <ibid> you want to force an error?
08:08:30 <ibid> just say _@(Just x) = lookup ir something
08:08:38 <ibid> s/ir/or/
08:08:41 <Igloo> What's the point in that?
08:08:54 <ibid> Igloo: forces strict binding of x
08:09:03 <ibid> if you want to do that...
08:09:09 <ibid> i see no reason to
08:09:21 <Igloo> How?
08:09:26 <ibid> how?
08:09:30 <Igloo> Hang on
08:09:59 <Marvin--> ibid: yeah, true, if I know it won't be Nothing, I might as well say Just x and then use x, which would make absolutely no difference
08:10:21 <ibid> yes :-)
08:10:21 <Igloo> OK, @ isn't allowed in things bound by let...can you give me an example of some code that demonstrates what you mean?
08:10:37 <ibid> Igloo: not allowed?
08:10:47 <Igloo> Prelude> let _@(Just x) = Nothing in 5
08:10:47 <Igloo> ERROR - Syntax error in declaration (unexpected `@')
08:10:53 <ibid> that's news to me
08:11:04 <ibid> but then again i almost never use let
08:11:14 <ibid> it is allowed in where
08:11:27 <Marvin--> yay, we found a difference between let and where ;)
08:11:49 <shapr> that was discussed on one of the mailing lists recently
08:11:56 <ibid> Prelude> let y@(Just x) = Just 3 in x
08:11:56 <ibid> 3
08:12:06 <shapr> that where and let have differences
08:12:09 <Igloo> hugs doesn't allow it in either
08:12:10 <ibid> yes it's allowed in let, but you can't use the wildcard there
08:12:16 <Marvin--> oh
08:12:22 <Marvin--> true
08:12:25 <Igloo> Oh, it might be the _, actually
08:12:25 <ibid> empirically speaking :_)
08:12:33 <Marvin--> ibid: :)
08:12:42 <ibid> not checked the report :-)
08:12:45 <shapr> I think the consensus was to make them all match up
08:12:51 <Igloo> Right, it is
08:12:54 <Igloo> But:
08:12:55 <Igloo> Main> let y@(Just x) = Nothing in 5
08:12:55 <Igloo> 5
08:13:02 <ibid> strange
08:13:10 <Igloo> So I still don't see why you think y@ should make a difference
08:13:25 <ibid> looks like a bug in your implementation
08:13:31 <ibid> it definitely should force an error
08:13:37 <ibid> ghci gives me:
08:13:37 <ibid> Prelude> let y@(Just x) = Nothing in x
08:13:37 <ibid> *** Exception: <interactive>:1: Irrefutable pattern failed for pattern (y@(Data.Maybe.Just x))
08:13:46 <ibid> ahh
08:13:49 <Igloo> That's in x, though
08:13:54 <ibid> hmmm
08:13:56 <Marvin--> ibid: duhh? x /= 5 :)
08:14:02 <Igloo> You'd get the same error without the y@
08:14:02 <ibid> yes, noticed myself
08:14:30 <Marvin--> What does the "irrefutable" part mean?
08:14:32 <ibid> strange
08:14:50 <ibid> Marvin--: the implicit ~ i presume
08:15:08 <dark> ibid: Isn't that the other way around?  ~ would make it refutable.
08:15:28 <dark> Oh, wait.  I have my english the wrong way around :)
08:15:30 <ibid> no
08:15:38 * ibid goes read the report
08:17:21 <dark> let y@(Just x) = Nothing in y gives an interesting error.
08:19:01 <ibid> let {y::Maybe Int; y@(Just x) = Nothing} in y
08:20:02 <dark> Prelude Data.Maybe> let y@(Just x) = Nothing in isNothing y
08:20:04 <dark> *** Exception: <interactive>:1: Irrefutable pattern failed for pattern (y@(Data.Maybe.Just x))
08:20:20 <dark> I don't understand that one; why would (isNothing y) trigger the pattern?
08:20:46 <ibid> the inner pattern is refutable?
08:21:30 <dark> Hmm, so y isn't bound unless its whole pattern matches?
08:22:09 <ibid> Prelude> let y@(~(Just x)) = Nothing in isNothing y
08:22:10 <ibid> True
08:22:23 <dark> Heh.
08:22:38 <dark> Now, would it be Evil to use such constructs in real code?
08:22:51 <dark> I generally find Maybe types a pain to deal with.
08:23:04 <dark> Except when I can use mapMaybe :-)
08:23:21 <Marvin--> it's okay with do notation
08:23:33 <dark> Marvin: You mean the Maybe monad?
08:23:47 <ibid> dark: which constructs?
08:23:48 <dark> It gets very confusing when mixed with IO :-)
08:24:00 <dark> ibid: Patterns like y@(~(Just x))
08:24:05 <ibid> i use them all the time
08:24:27 <dark> ibid: That says nothing about its evilness :)
08:24:33 <ibid> see for example this: (looking up...)
08:24:47 <ibid> http://www.mit.jyu.fi/antkaij/opetus/okp2002/demo/demo5/Translator.hs
08:24:51 <Marvin--> dark: what's the difference between the "Maybe Monad" and Maybe?
08:25:04 <ibid> bah, not that
08:25:32 <ibid> yes, that
08:25:34 <ibid> argh :-)
08:25:43 <dark> Marvin: Well, nothing... there's just a Monad Maybe instance, so you can use do notation with it.
08:26:24 <dark> Marvin: I find it confusing in functions that also use IO.
08:27:37 <dark> ibid: Hmm I would have wrapped that in a case statement :)
08:27:54 <ibid> there is no case statement in haskell
08:27:59 <Heffalump> there is!
08:28:01 <ibid> but i do not like the case expression
08:28:03 <Marvin--> dark: that may be true
08:28:05 <ibid> Heffalump: which is it?
08:28:15 <Marvin--> there's a statement in haskell? :)
08:28:24 <ibid> what Marvin-- said :-)
08:28:28 <Heffalump> yes, things you put inside a do are statements.
08:28:42 <Heffalump> and you can put a case inside a do
08:28:45 <Marvin--> no, things you put inside a do is syntactic sugar for a special type of expressions
08:28:54 <ibid> true
08:29:00 <ibid> do { stmts }
08:29:01 * Heffalump decides to just concede the point to avoid a long pedantic argument :-)
08:29:07 <dark> Syntactic sugar doesn't stop them from being statements.
08:29:07 <Marvin--> Heffalump: ;)
08:29:16 <ibid> the report says they are stmts :-)
08:29:27 <ibid> so they are not statemants but stmts :_)
08:29:35 <Marvin--> hah
08:29:51 <Marvin--> I prefer to think of it as the do notation emulates statements
08:30:11 * Marvin-- gets frustrated with tcp and bsd sockets
08:30:18 <ibid> well, in that case the let notation emulates a let expression :-)
08:30:34 <Marvin--> ibid: yes?
08:30:47 <Marvin--> What does the listen() backlog *really* mean?
08:30:58 <dark> Calling things "syntactic sugar" is just a way of pretending it's not part of the language, even though it is :)
08:31:13 <ludde> Marvin--: how many connections that can be in the listen queue i think
08:31:15 <Marvin--> it can't simply be unaccepted connected sockets
08:31:19 <dark> Marvin: If a process doesn't accept() connections as fast as they come in, the kernel queues them for later accepts.  The listen backlog is the max length of that queue.
08:31:27 <dark> Marvin: If more come in, they're simply dropped.
08:31:31 <ibid> Marvin--: i was just demonstrating the strangeness of your argument. haskell is essentially emulating a programming language, as it is syntactic sugar to the core
08:31:52 <Marvin--> that's my understanding of it too, so why can I still connect three telnets to a program that does listen(backlog=1)
08:31:57 <Marvin--> ibid: yeah, true
08:32:09 <dark> Marvin: The program doesn't accept?
08:32:48 <Marvin--> dark: the "program" is an interactive python session, so I decide myself when I accept
08:33:30 <dark> Hmm... there might be a lower limit on the backlog too.
08:33:38 <Marvin--> so it would seem
08:33:38 <Erwin> Note that often there is a minimum, so if you say listen(sock,1) it'll be 3-4 or so
08:34:20 <Marvin--> too bad this man page doesn't document that
08:35:44 <dark> It might depend on the protocol.
08:35:51 <dark> Hmm, might depend on whether you have SYN cookies enabled, too.
08:36:16 <liiwi> mmmm. syncookies
08:36:54 <liiwi> with chocolate RST chips
08:36:54 <Marvin--> dark: that should only affect non-complete connects
08:46:44 * Marvin-- patches RuntimeLoader.hs to use exceptions
08:47:10 <shapr> yay
08:48:26 * Marvin-- likes the 'when' function :-)
08:49:29 <Marvin--> ptr@(~(Ptr addr)) <- c_lookupSymbol ...
08:49:36 <Marvin--> when (ptr == nullPtr) (ioError (...))
08:52:15 <dark> I abbreviated that to throwIf :)
08:52:49 <dark> I think the FFI modules have a throwIfNull somewhere.
08:53:34 <Marvin--> throwErrnoIfNull
08:53:45 <dark> I like playing with names in Haskell.  I have a "blithely" function for running IO actions while ignoring errors.  I also have "bite" and "chomp" list operations.
08:54:03 <Marvin--> heh
08:54:21 <Marvin--> where's throwIf defined?
08:55:11 <dark> Marvin: I defined it myself in a utility module because I couldn't find it in a standard library (I remembered seeing such a function, I guess I didn't think of looking for throwErrno*)
08:55:48 <Marvin--> yeah I've defined it myelf, but only in the context of a MonadError...
08:56:01 <Marvin--> and for IO you're supposed to use ioError instead of throw, so...
08:56:20 <dark> Yeah, maybe I should rename my throwIf to be consistent with that.
08:56:34 <dark> It's a bit silly to have a throwIf function that doesn't throw :-)
08:56:51 <Marvin--> :P
08:56:57 <Marvin--> mine used throwError
08:57:46 <dark> What's throwError?
08:58:14 <dark> Oh, from MonadError :)
08:59:06 <dark> Hmm, there's an instance instance MonadError IOError IO, so that should work, right?
08:59:11 <dark> In an IO context, I mean.
08:59:26 <Marvin--> true
08:59:51 <Marvin--> but in this case, throwErrnoIfNull is cuter :P
09:00:01 <dark> If you _have_ an errno :)
09:00:05 <Marvin--> *cough*
09:00:27 <dark> Actually my complaint with the throwErrno functions is that they generate IOErrors without filenames.
09:00:34 <Marvin--> hmm, wait, dlsym probably doesn't set errno
09:00:42 <dark> So at the top I get messages like "harc: does not exist" and no explanation :)
09:01:17 <dark> I made a wrapper for System.Directory that adds filenames to errors it throws.
09:01:44 <dark> Hmm, maybe I should write a patch for System.Directory and try to get it accepted :)
09:02:25 <Marvin--> heh
09:02:26 <shapr> silly question, does deforestation deal with finding the largest common branches in a parse tree?
09:02:45 <dark> Marvin: That's when I ran into the rename problem, though.  Which filename to report?  How to report both?
09:03:11 <dark> A does-not-exist error could refer to the source name or to part of the destination path.
09:04:35 <dark> I wonder if it's worthwhile to stat the source name to see which filename should be reported :)
09:05:11 <Marvin--> hrrm, interesting.. The course I'm assisting in next period... I'm the only student assistant it seems, all the other assistants are grad students or something
09:05:41 <Heffalump> shapr: that's not what deforestation does
09:05:58 <shapr> hm, ok
09:06:09 <Heffalump> deforestation finds the case where one function is producing a data structure and another is consuming it, and merges the two together
09:06:12 <shapr> are there common algorithms for finding the largest common branches in a tree?
09:06:24 <Heffalump> yes, common subexpression elimination
09:06:35 <shapr> is there haskell source for doing that?
09:06:38 * shapr googles
09:07:08 <dark> Section 7.7.3 of the GHC users guide says something about deforestation.
09:07:35 <dark> Heffalump: Do you know if GHC does that on its own even if it doesn't have RULES to guide it?
09:07:47 <liiwi> deforestation leads into erosion
09:07:49 <shapr> I'd like to find the largest common chunks of a bunch of html pages, try to pull out includes
09:07:56 <Heffalump> dark: errm, I'm not certain
09:08:06 <shapr> hi pesco, what's up?
09:08:07 <Heffalump> I think it has foldr-build rules built in somewhere, or in its prelude
09:08:11 <Heffalump> so effectively, yes
09:08:16 <pesco> hey shapr. nothing much.
09:08:19 <dark> Heffalump: This might be a clue for optimizing my astar function further :)
09:09:22 <dark> Heffalump: It has two mutually recursive helpers, one of them builds a list and the other consumes it... heap profiling showed a lot of list-building activity.
09:11:18 <Heffalump> well, if you write your list-building in terms of build and your list-consuming in terms of foldr you should get a nice speedup :-)
09:12:39 <dark> GHC has a list of "good consumers" and "good producers" to use :)
09:13:07 <dark> Hmm, I probably described my situation wrong.  The first function builds a list and passes it as an argument to the second.  The second recurses over the list, and calls the first function again when it runs out.
09:13:19 <dark> This is not the usual producer and consumer relationship, right?
09:15:19 <Heffalump> why do you have the second one call the first one again, instead of just producing a huge lazy list?
09:16:35 <dark> The rest of the list depends on what the second function does.  The two functions pass a data structure back and forth.  The first function decides what to do next (that's the list), and the second function looks at the results and puts them in the data structure.  Then it calls the first for a new decision.
09:16:54 <shapr> I really wish I could put a main function in any module
09:16:58 <Heffalump> hmm, right
09:17:02 <Heffalump> shapr: you can, can't you?
09:17:19 <shapr> ones that aren't module Main?
09:17:20 <dark> GHC complains if you try to use --main on a module that isn't called Main.
09:17:38 <Heffalump> oh, right
09:17:48 <Heffalump> you can put a main function anywhere, it just doesn't help :-)
09:17:55 <dark> shapr: I bet you want it for the same reason I do... module tests.
09:18:04 <shapr> yup, exactly
09:18:15 <shapr> I'm writing HUnit tests
09:18:44 <shapr> maybe I should just learn how to use Makefiles and put the tests in there.
09:18:53 <dark> I did Makefile evilness to get it to work.
09:19:05 <shapr> tell me more :-)
09:19:18 <shapr> is it in the source I downloaded?
09:19:19 * shapr looks
09:19:40 <dark> shapr: Yeah, it is :)
09:19:42 <shapr> aha
09:20:10 <dark> It doesn't work as well as I want to, though.  GHC refuses to call the output anything but Main.hi and Main.o, so I have to recompile every time I run the tests.
09:20:47 <dark> On the other hand GHC doesn't like multiple -odir and -hidir arguments so I can't put the compiled tests each in their own directories.
09:21:03 <dark> (At least, not without recompiling most of the main program for every test)
09:21:07 <shapr> that sucks :-(
09:21:48 <dark> And I have to cheat, the module that's called Test/Search.hs starts with "module Main" :)
09:22:12 <dark> I could probably fix that by autogenerating a stub Main module that imports the module I want and calls its main function.
09:22:27 <dark> But since I only had two tests so far, I haven't bothered :)
09:23:01 <Marvin--> yep, no errno, damn
09:23:12 <Marvin--> Fail: failed
09:23:12 <Marvin--> Action: foo?
09:23:12 <Marvin--> Reason: Success
09:23:18 <dark> Marvin--: If you wished you could set errno and then call throwErrno :)
09:23:25 <Marvin--> dark: urgh
09:23:44 <dark> But yeah, I've seen a lot of "error: success" messages from programs that don't check if they have an errno :)
09:24:12 <dark> A common mistake is to try to print something before using errno.
09:24:13 <shapr> hi ski
09:24:21 <ski> hi shapr
09:24:24 <Marvin--> yah
09:24:47 <Marvin--> oh well, ptr@(~(Ptr addr)) <- c_lookupSymbol  is cooler :P
09:26:04 <dark> For some values of "cooler" :)
09:26:50 <dark> shapr: Notice how I had to use NOTINLINE pragmas in some of the test code to prevent the compiler itself from running my algorithm :)
09:26:52 <Marvin--> the value "I just recently learned this" ;)
09:27:40 <dark> At some point I wondered why compiling the tests took half an hour...
09:27:48 <shapr> dark: interesting
09:27:57 <shapr> yah, it takes quite some time here
09:29:47 <dark> I managed to get gen_cave down to about 2.5 seconds but that's still too slow, especially since I plan to add features... I'd love to speed up astar some more.  Knowing about deforestation will probably help :)
09:32:54 * shapr reads about Common Subexpression Elimination for GHC by Olaf Chitil
09:33:08 <Heffalump> dark: surely the compiler wouldn't have known enough input to actually run your algorithm?
09:33:28 <shapr> ghc does surprisingly nifty things
09:33:32 <dark> Heffalump: It does in the test module, I feed it with a known dataset.
09:33:37 <Heffalump> dark: ah, ok
09:33:43 <Heffalump> and you're trying to use this for benchmarking?
09:33:50 <shapr> why is ghc hard to port to other CPUs?
09:33:54 <dark> Heffalump: I could have read the test data from a file, but that would mean parsing :)
09:33:59 <shapr> from this paper it seems to output C...
09:34:14 <shapr> and since GHC is self-hosting...
09:34:19 <Heffalump> shapr: I think some of the low-level linking is a bit sick
09:34:24 <Heffalump> dark: :-)
09:34:27 <dark> Heffalump: Yeah, profiling and testing both.  In normal use I give it random data, so I needed fixed data for repeatable tests.
09:35:15 <dark> Some of the documentation notes that GHC "steals" some registers from gcc.  I guess this means it's architecture-dependent C code.
09:35:47 <shapr> oh
09:36:37 <dark> Heffalump: There's also a practical problem, if ghc tries to inline the test code and run the whole algorithm, it takes a very long time to compile :)  The generated code is quite a bit faster than ghc's inlining code.
09:36:49 <Heffalump> :-)
09:37:03 <Heffalump> I thought GHC had more intelligent time bounds on compilation than that
09:37:17 <dark> shapr: This is probably an improvement, the versions of ghc I played with at the university actualy used gcc to generate assembler code, then munged the assembler code before assembling and linking.
09:37:35 <dark> Heffalump: Should I submit a bugreport or something?
09:37:44 <Heffalump> dark: you could ask on ghc-users I guess
09:38:07 <Heffalump> I'm only guessing, but it does sound like over-enthusiastic behaviour to run an entire algorithm if that takes a long time.
09:38:11 <shapr> yikes, sounds like ghc has gotten more portable.
09:38:48 <dark> Heffalump: This might be an extreme case, the pathfinding algorithm might look like a yummy inlining candidate at every step.
09:39:14 <dark> Heffalump: This might be a case of extensive constant folding rather than true inlining :)
09:39:54 <Heffalump> heh
09:40:12 <Heffalump> unless your entire algorithm is one function it must be doing inlining too
09:49:08 <shapr> cool, nofib has lzw compression code
09:51:03 <dark> Patented by Unisys until 2003 :-)
09:51:19 <dark> But I'm off to a party now...
10:11:04 <shapr> I have a silly question...
10:11:12 <shapr> what's -1 ^ 0 ?
10:11:31 <ski> shouldn't it be 1 ?
10:12:06 * shapr is confused
10:12:11 <Heffalump> it should be 1, yes
10:12:17 <shapr> what do you get from -1 ^ 0 in ghci?
10:12:19 <Heffalump> (anything except 0) ^ 0 is 1
10:12:36 <Heffalump> Prelude> (-1) ^ 0
10:12:36 <Heffalump> 1
10:12:39 <ski> oh, you have to type "(-1) ^ 0"
10:12:42 <ski> yes
10:12:47 <Heffalump> Prelude> - 1^0
10:12:47 <Heffalump> 1
10:13:10 <Heffalump> Prelude> -1 ^ 0
10:13:10 <Heffalump> 1
10:13:20 <shapr> are you using ghc5.04.1 ?
10:13:27 <ski> hugs : Prelude> -1 ^ 0
10:13:49 <shapr> Prelude> -1 ^ 0
10:13:49 <shapr> -1
10:13:52 <Heffalump> 5.02.2
10:14:07 <ski> oh, i forgot : -1
10:14:21 <shapr> isn't that wrong?
10:15:30 <ludde> can I rewrite:
10:15:31 <ludde>   doit (l:ls) = do listitem;l;doit ls
10:15:31 <ludde>   doit _ = return ()
10:15:32 <ludde> in some way?
10:15:42 <ski> shapr : what is wrong ?
10:15:58 <shapr> I'm getting -1
10:16:01 <shapr> heffalump is getting 1
10:16:07 <ski> ghci : Prelude> -1 ^ 0  ==> -1
10:16:09 * Heffalump has a different version of GHC
10:16:22 <ski> ghci : Prelude> (-1) ^ 0 ==> 1
10:16:28 <shapr> ohhhhh
10:16:40 <shapr> thanks ski :-)
10:16:54 <ski> shapr : -1 ^ 0  seems to be parsed as -(1 ^ 0)  :)
10:17:26 <shapr> very confusing
10:17:50 <shapr> well, that fixed lots of errors
10:17:51 <shapr> yay
10:18:18 <Jii> yay for error-fixing
10:18:24 <shapr> hi Jii, how's life?
10:18:37 <Jii> my brain hurts
10:18:44 <Jii> a bit only, though
10:18:45 <shapr> whyfor?
10:19:11 <Jii> physically, that is
10:19:16 <shapr> oh
10:19:17 <Jii> donno why ;-)
10:19:22 <ski> ludde : doit = foldr (\l a -> do listitem; l; a) (return ())   ?
10:19:34 <Jii> have you been playing with haskell web server?
10:19:56 <ludde> ski: ok, hmm
10:20:02 <shapr> not so much, Marvin-- is getting school credit for writing a plugin API for it, so I'm leaving it to him.
10:20:22 <shapr> I'll be very happy to hack on it once he's got credit.
10:21:25 <shapr> what have you been up to?
10:22:39 <Jii> thinking about re-learning emacs
10:22:58 <shapr> I like emacs
10:23:00 <ski> ludde : or  doit = foldr (>>) (return ()) . map (listitem >>)  perhaps ?
10:23:08 <shapr> I'd like emacs that used Haskell even better :-)
10:24:52 <Jii> i didn't even know about C-w in incremental search, or C-M-l, or even M-/, I feel ashamed ;-)
10:25:16 <shapr> M-/ is one of the greatest things about emacs
10:25:25 <shapr> especially once you bind that to hippie-expand
10:26:04 <shapr> when I run my unit tests, I get "*** Exception: Banana.hs:103: Non-exhaustive patterns in function dispatchDecode"
10:26:15 <shapr> how can I figure out what's going on?
10:26:25 <shapr> dispatchDecode x       = error $ "hit error pattern with input: " ++ (show x)
10:26:26 <shapr> that doesn't catch it
10:26:41 <shapr> dispatchDecode s@_     = error $ "hit _ with input: " ++ (show s)
10:26:42 <shapr> nor does that
10:29:42 <ski> what other lines has dispatchDecode ? (are they huge or can you show them)
10:29:54 <ski> seems weird though
10:30:00 <shapr> dispatchDecode (length,x:xs)
10:30:07 <shapr> and then a bunch of guards
10:30:18 <shapr> and the guards end with     | otherwise        = error "oops, fell off dispatchDecode"
10:30:54 <ski> you have a dispatchDecode (length,[  ]) pattern i guess
10:31:09 <ski> (or perhaps you don't need one)
10:32:20 <shapr> hm
10:32:25 <shapr> no
10:32:32 <shapr> I don't have that pattern
10:32:46 <ski> and you don't want it ?
10:32:48 <shapr> would the last line catch that anyway?
10:33:04 <ski> it should, i believe
10:33:13 <ibid> shapr: no, the guards are executed only if the pattern matches
10:33:35 <shapr> I have an otherwise in the guards, and I have a dispatchDecode x
10:33:51 <ibid> yes that should do it
10:34:02 <shapr> hmm
10:34:12 <ski> so why doesn't the catch-all pattern work ?
10:34:15 <shapr> I don't know.
10:34:19 <ski> hm
10:34:26 <ibid> would have to see the whole code
10:34:42 <shapr> well, I'll go over it one more time, I'm sure it's user error.
10:36:41 <Jii> that's why it's good to show the code for other people, they'll probably notice the error right away ;-)
10:36:50 <shapr> true
10:40:35 * shapr finds the problem
10:43:43 <ski> so what was the problem ?
10:44:11 <shapr> user error
10:44:43 <shapr> I don't know why it reported that error, but the actual problem was that I was trying to call a typeclass method on something that isn't an instance of that typeclass
10:44:45 <shapr> very weird.
10:47:23 <ski> yes
11:01:52 <shapr> actually, it's even stranger than that...
11:02:02 <ski> oh ?
11:02:10 <shapr> there is an instance in Banana.hs, but not in Test_Banana.hs, which imports Banana
11:02:53 * shapr cleans out all the .o and .hi files
11:08:32 <shapr> it works when compiled, but not when interpreted.
11:08:48 * shapr doesn't understand why
11:08:54 <ski> weird
11:12:51 <shapr> http://kungens.kemi.fi/~shae/wtf.txt
11:13:19 <shapr> if I load Banana, and then use :a to add Test_Banana, then my HUnit tests work.
11:13:33 <shapr> if I load Test_Banana and then use :a to add Banana, I get the error.
11:13:54 <shapr> that's very confusing.
11:34:25 * shapr runs off to play counterstrike, bbl
14:15:44 <shapr> yay, John Hughes sent me a new version of QuickCheck
14:16:11 <ski> the one with support for ST/IO ?
14:16:31 <shapr> I think so
14:16:45 <shapr> he said the problem is that there are *two* new versions of QuickCheck
14:17:01 <ski> oh, i didn't know that
14:17:11 <shapr> both he and Claessen have been adding features to the old version, and need to merge their code.
14:17:23 <ski> heh :)
14:17:51 <shapr> he sent me his version that has "the monadic combinators described at PLI"
14:18:03 <ski> which are ?
14:18:25 * shapr reads
14:18:26 <ski> (do they use monadic combinators in Scheme ?)
14:18:35 <shapr> they can...
14:18:42 * ski associates PLI with DrScheme
14:18:43 <shapr> I saw an example of monadic IO in scheme recently
14:19:15 <shapr> his monad code looks almost too simple
14:19:26 <ski> I've seen some by oleg@pobox.com on comp.lang.{scheme|functional} IIRC
14:19:36 <shapr> yah, oleg does good stuff
14:19:50 <ski> I've noticed that.
14:20:14 * shapr reads QuickCheckM.hs
14:20:41 <ski> (Or perhaps it was Christopher Browne, I seem to confuse them together sometimes)
14:21:34 * shapr doesn't really understand all of this code
14:21:55 <ski> Coarbitrary ? or some new stuff ?
14:22:10 <shapr> it does have coarbitrary
14:23:10 <ski> but do you understand coarbitrary. I don't think i do very much.
14:23:21 <shapr> no, I don't :-)
14:23:35 <shapr> I read over the new paper, but it didn't stick
14:23:39 <liiwi> shapr: counterstrike on linux?
14:23:53 <shapr> liiwi: sure, works for me
14:23:59 <liiwi> whine?
14:24:02 <liiwi> erm, wine.
14:24:06 <shapr> winex
14:24:19 <shapr> cvs checkout from winex.sf.net, build and install
14:24:20 <shapr> tada
14:24:22 <ski> (i.e. i sort of can follow it somewhat if someone explains it to me, but i don't really understand (grok) it, and i wouldn't have thought of makeing something like that myself)
14:24:39 <liiwi> shapr: hrm, think I'll stick with q3 and tc.
14:24:43 <shapr> ok
14:24:55 <ski> liiwi : tc ?
14:25:41 * shapr reads the QuickCheckST paper
14:26:06 <liiwi> ski: truecombat.com
14:26:25 <shapr> looks to me like QuickCheck subsumes Design By Contract
14:26:29 <shapr> somewhat
14:27:24 <shapr> mm, higher level specification combinators
14:27:42 <shapr> model-based specification of imperative ADTs
14:27:45 <shapr> what does that mean? :-)
14:28:21 <shapr> what does universally quantified mean?
14:29:11 <ibid> in what context?
14:29:56 <shapr> "properties are implicitly universally quantified over their arguments, so this property states the associativity of integer addition"
14:30:01 <ibid> in logic, in the statement "for all x, if x = 4 then x > 0", the variable x is universally ("all") quantified
14:30:21 <shapr> ohh
14:30:24 <shapr> ok
14:30:28 <ibid> the other quantification in logic is existential: "there exists an x such that if x = 4 then x > 0"
14:30:35 <shapr> oh
14:30:41 <shapr> "all of", or "one of"
14:30:43 <ibid> the meanings in other branches of things should be similar
14:30:52 <ibid> no, for all and there exists
14:31:12 <ibid> all of and one of are descriptors, not quantifiers
14:31:19 <shapr> hm
14:31:24 <shapr> well, thanks :-)
14:32:00 <ibid> the difference is, quantifiers make assertions, descriptors make things
14:32:11 <shapr> ok
14:32:12 <shapr> cool
14:32:32 <ibid> but all of and for all are certainly linked (they are both universal)
14:32:44 <ibid> and similarly one of and there exists (existential)
14:32:51 <ski> mm
14:33:01 <shapr> sounds like a whole branch of knowledge I don't know yet
14:33:32 <ibid> and your quote sounds like the logic usage
14:33:34 <ski> wasn't all that obvious ?  (just teasing ;)
14:33:44 <shapr> of course it was ;-)
14:34:09 <ibid> meaning: if there is a free variable x in a property, then prepend an implicit "for all x" to it
14:34:36 <ibid> so, "x + y = y + x" is interpreted as "for all x and for all y, x + y = y + x"
14:34:50 <ski> "for all" and "there exists" is also linked to the (modal) operators "neccesary" and "possible"
14:35:02 * ibid knows nothing of modality :-)
14:35:10 <shapr> right, that's what I was saying in the first place
14:35:22 <shapr> "all of" or "one of" meaning "necessary" or "possible"
14:35:41 <ski> implicitely yes, in much the same way as variables in Prolog are implicitely universaly quantified over a clause
14:35:44 <shapr> there exists means there's at least one, though you may not find it
14:35:54 <ibid> but i'm taking a course on measure theory and integral theory, and i'm fascinated by the quantifier "almost everyhwere" :-)
14:35:55 <shapr> for all means all of these are that way
14:36:14 <shapr> I haven't approached Prolog yet...
14:36:24 <ski> ibid : modal logic and it siblings (temporal,deontic, etc) are very interesting
14:36:30 <ibid> for all x. p also means that there does not exist an x such that not p
14:36:34 <ibid> ski: i'm sure :-)
14:37:02 <shapr> I feel less geeky when you guys talk about stuff like this :-)
14:37:14 <ibid> i have a vague memory that a finn invented deontic logic. he invented some logic, of that i am sure, but i'm not sure which
14:37:23 <ibid> (georg henrik von wright)
14:37:39 <ski> a finn ?
14:37:44 <ibid> yes
14:37:59 <ski> who's that ?
14:38:14 <ibid> 00:37 < ibid> (georg henrik von wright)
14:38:27 <ibid> you mean who's von wright?
14:38:28 <ski> so georg henrik von wright = a finn ?
14:38:35 <daniel> hi
14:38:36 <ibid> he's a finn, yes
14:38:39 <ski> no, who's "a finn" ?
14:38:41 <shapr> hi daniel
14:38:41 <ski> ah
14:38:46 <ibid> i am a finn. too
14:38:50 <shapr> I am not a finn.
14:38:51 <ski> you mean he's from finland.
14:38:54 <shapr> but I live in Finland.
14:39:12 <ibid> finnish people are finns
14:39:15 <shapr> actually, I'm moving to sweden.
14:39:19 <shapr> in about a week.
14:39:28 <shapr> so I'll be offline for some amount of time.
14:39:34 <ibid> (of course, a finn might not speak finnish as her mother tongue)
14:39:36 * ski though "a finn" was the person name initial and surname of some logician/something ....
14:39:38 <ibid> sad to see you go
14:39:43 <ibid> ski: hehe
14:39:54 <shapr> well, I'm moving 400km or so... not very far.
14:39:58 <ski> daniel : hi
14:40:07 <ibid> you know von wright?
14:40:09 <shapr> daniel: do you need some Haskell help?
14:40:27 <daniel> hehe, no, because i just started...
14:40:37 <daniel> i thought it would be helpful if i join...
14:40:44 <ski> ibid : me know von wright ?
14:40:44 <daniel> s/would/could
14:40:51 <ibid> ski: yes
14:40:54 <shapr> are you learning Haskell at school?
14:41:17 <shapr> hm, mkPortNumber turned into something else, but I don't remember what...
14:41:18 <daniel> no, not at all.
14:41:41 <daniel> i was just talking about programming languages with a friend and he mentioned haskell
14:41:50 <shapr> Haskell is very nifty.
14:41:57 <shapr> I enjoy using it.
14:42:02 <daniel> and i wanted to have a look at it since i don't know any functional programming language.
14:42:10 <ski> ibid : i dont know very much about him. i vagually (spelling?) seem to remember that he had some connection to Wittgenstein or something ...
14:42:18 <shapr> it's a big jump to go from procedural to functional, but it's great fun jumping.
14:42:23 <shapr> vaguely
14:42:33 <ibid> ski: vaguely :_)
14:42:34 <daniel> but, as i allready know C++ very well... it's quiet hard! :)
14:42:36 <ski> shapr : thanks
14:42:44 <daniel> and pascal..
14:42:45 <ski> ibid : thanks :)
14:42:49 <shapr> daniel: I jumped from Python to Haskell ...
14:43:15 <daniel> i don't know, where he gets this token from.. in the qsort example from the quickstart: the elts_lt_x
14:43:17 <ibid> ski: yes, he was wittgenstein's student, and is one of the people who manage his written works (publish them posthumously etc)
14:43:21 <shapr> took me about a year to get comfortable in Haskell (I have a real job, could have been shorter), but it's very much worth it.
14:43:26 <daniel> theres no definition... dunno, what the compilers thinks, it is.
14:43:37 <shapr> daniel: have you read the Haskell tutorial?
14:43:42 <shapr> I can suggest a good one, if you like.
14:43:52 <daniel> i'm reading www.haskell.org/aboutHaskell.html
14:44:00 <daniel> shapr: would be nice
14:44:07 <ski> daniel : I sortof jumped from BASIC and C and Java to Haskell. Personally, I had very little problem adapting and learning the new paradigm
14:44:33 <daniel> mh.. i'm mainly programming oop.
14:44:33 <shapr> ski: you're just cooler than I am ;-)
14:44:36 <Erwin> daniel: the elts_lt_x are "locals" defined below.
14:44:42 <shapr> hi erwin!
14:44:45 <shapr> wassup?
14:44:46 <ibid> from basic to pascal to c to c++ to scheme to haskell ... (ignoring some other languages:-)
14:44:48 <ski> ibid : you mean von wright is still alive ?
14:44:59 <daniel> ah... the 'where' means 'where' :)
14:45:06 <shapr> I went from basic to java to python to haskell
14:45:10 <ibid> ski: yes 
14:45:35 <ibid> ski: http://www.kirjasto.sci.fi/gwright.htm
14:45:36 <shapr> I've learned bits of elisp, scheme, sql, javascript, etc, but can't claim fluency in them.
14:45:42 <Erwin> Yeah, you can also use let ... in which defines the expressions first but using where is nicer, sort of top-down
14:46:15 <ski> shapr : what ? i'm cooler than thou art ? how can that be ? I don't feel very cool ;-)
14:46:29 <Erwin> Note that because Haskell uses lazy evaluation nothing gets evaluated until actually used.
14:46:44 <Erwin> Hmm, does concatenating two lists ++ evaluate them actually?
14:46:46 <ibid> unless you force evaluation :-)
14:46:54 <ibid> Erwin: not necessarily
14:46:57 * shapr grins
14:47:25 <daniel> evaluate = parse/compile ?
14:47:34 <ibid> daniel: no
14:47:42 <ibid> daniel: evaluate = execute
14:47:44 * shapr tries to fix the Echo.hs server/client sample from the Programming Languages Shootout
14:47:55 <ibid> daniel: evaluate = execute and return the result to caller
14:48:22 <daniel> ah.. i understand.
14:48:23 <ski> ibid : ok, i though he was dead. shows how little i know about him. loaned a book about/by (?) him for some time ago. didn't have time reading it until it was due back though :(
14:49:00 <shapr> whoa, hal has changed his web page.3
14:49:03 <ibid> Erwin: i believe ++ creates a something (whaddya call it, a thunk?) that contains the instructions for performing this concatenation
14:49:09 <shapr> where did YAHT go to?
14:49:16 <shapr> man, Hal is a lot younger than I am :-)
14:49:19 <ski> (ski has also dabbled a little with 6502 and 68000 assembler ...)
14:49:36 <shapr> ok, suddenly I'm curious... I bet I'm the oldest newbie here :-)
14:49:45 <daniel> is it better to start with hugs or should i take a compiler?
14:49:49 <ibid> Erwin: when the first element of the concatenation is forced, the something is executed until it produces the first element. the continuation is saved as a something that is stored as the tail of the list...
14:49:58 <shapr> daniel: installed both hugs and ghc to start with
14:50:13 <shapr> it's informative to try your programs in both.
14:50:14 <ibid> daniel: i started with hugs, but you can use ghc, which has an interactive version much like hugs, called ghci
14:50:46 <daniel> but i don't understand.... just typed 'qsort [] = []' like in the example, hit enter and got an error
14:50:48 <Erwin> ibid: Hmm. It's interesting to think then excatly at what point will each part of the qsort expression get evaluated.
14:50:54 <ibid> yes
14:51:09 <Erwin> daniel: Yes, unfortunately hugs/ghc doesn't allow real interactive evaluation like Python which I found annoying
14:51:16 <Erwin> daniel: the best way is to use emacs and its haskell modes
14:51:21 <shapr> yah, emacs
14:51:24 <daniel> no no no :)
14:51:33 <ibid> real interaction?
14:51:34 <Erwin> daniel: then you can write a .hs file and press a keystroke to evaluate it in a haskell buffer you have running
14:51:46 <ibid> you can use let in ghci...
14:51:53 <shapr> ibid: real interaction means you can type *everything* in the interpreter
14:51:59 * daniel is a hardcore vim'ler :)
14:52:00 <ski> daniel : i haven't used ghc very much yet, just some at school. though i really ought to install it correctly sometime soon. time ..
14:52:01 <shapr> including pattern matches, etc
14:52:08 <Erwin> ibid: Sorry, I'm used to Python where you an do everything in the interactive interpreter :)
14:52:17 <ibid> shapr: you can do that in ghci i think
14:52:28 <ibid> Erwin: why can't you in ghci?
14:52:30 <shapr> in fact, there's no real difference between typing the code in manually and loading a file when it comes to Python
14:52:31 <daniel> can i write a makefile for the haskell source?
14:52:37 <shapr> daniel: yes, you can.
14:52:43 <daniel> thats nice
14:52:46 <daniel> then i'll go with vim
14:52:57 <Heffalump> don't do that!
14:52:59 <ibid> shapr: ahh, but that's because a definition is a statement in python :-)
14:53:00 <shapr> ok, whatever works best for you :-)
14:53:06 <shapr> Heffalump: eh?
14:53:12 <Heffalump> oh, you're a hardcore vim'er. OK then :-)
14:53:17 <shapr> afair, Igloo is a vim + haskell user also
14:53:23 <daniel> Heffalump: i won't get familiar with emacs since i already know vim...
14:53:25 <Heffalump> yes, he might even appear soon
14:53:39 <Erwin> daniel: well, with emacs you can evaluate your .hs file, define the functions and then switch to the *haskell* buffer and call them and see what results they give, which is nice
14:54:17 <shapr> daniel: http://www.isi.edu/~hdaume/htut/
14:54:26 <daniel> thanks
14:54:29 <shapr> sure
14:54:45 <shapr> hi Logan, what's up?
14:54:50 <ski> Erwin : i haven't used that feature very much, because of some strange ansi (?) problems here at school
14:54:57 <Heffalump> oh, maybe he won't, he's talking to someone about monads IRL
14:55:11 <shapr> hey Logan, you had some Haskell source you wrote that I wanted to read... I couldn't find it on your homepage..
14:55:20 <shapr> actually, I can't remember which source it was at the moment....
14:55:30 <shapr> Igloo talking about monads? unheard of!
14:55:41 * shapr envisions tribes of monadic grad students roaming the campus
14:55:52 * ski lol
14:57:43 <shapr> hm, SockAddrInet ?
15:00:00 <daniel> this ghc is quiet large...
15:00:03 <shapr> aha
15:00:09 <shapr> yah, it's big
15:00:13 <shapr> are you using Linux?
15:00:15 <ski> mm
15:00:21 <daniel> yes
15:00:23 <shapr> Socket.PortNumber
15:00:25 <shapr> which linux distro?
15:00:29 <daniel> gentoo
15:00:42 <shapr> oh, I know a coupla people who use that.
15:01:05 <daniel> it's a very nice distro.
15:01:07 * ski haven't heard of gentoo before
15:01:14 <daniel> perfect for lazy people like me
15:01:36 <ibid> lazy? even installs take days...
15:01:37 <ski> perfect for a lazy language like haskell ?  :)
15:01:50 <ibid> haskell is not lazy, it is non-strict
15:01:56 <ibid> haskell implementations may be lazy
15:02:22 <ski> ibid : but isn't lazy == call-by-need ?
15:02:31 <ibid> ski: yes
15:02:39 <ibid> ski: but lazy != non-strict
15:02:47 <ski> ibid : i know that
15:02:49 <ski>  ski: but lazy != non-strict
15:02:54 <daniel> ibid: but once it's installed, the user only has to type a few chars for installing anything.
15:02:56 <ibid> ski: laziness is a way to implement non-strict
15:03:05 <ski> (ignore last line)
15:03:15 <ibid> daniel: that's true of debian, too, and debian is easy to install... compared to gentoo
15:03:28 <daniel> ibid: but debian is not as 'clean' as gentoo, imho.
15:03:58 <ibid> can't comment on that, never seen gentoo :-)
15:03:59 <shapr> how so?
15:04:15 <ibid> i'm personally reasonably satisfied with debian
15:04:20 <shapr> yah, I use debian.
15:04:32 <ski> ibid : but isn't there several variants of non-strict. (i guess i'll have to say that i haven't yet got completely on top of all these call-by-X and related ..)
15:04:37 <daniel> most people who not use SuSE use debian, i think.
15:04:53 <ibid> daniel: lots of people use red hat
15:04:54 <daniel> seen a few with redhat and some with mandrake, but most use debian or SuSE.
15:04:54 <shapr> from what I hear, RedHat is way more popular than anything else.
15:05:04 <daniel> ibid: never came accross one. :)
15:05:16 <ibid> most people use either red hat or debian. suse is rare here :)
15:05:25 <daniel> where do you come from?
15:05:32 <ibid> jyu.fi :-)
15:05:36 <daniel> in usa redhat is big, i think.
15:05:47 <ibid> the computing centre uses red hat almost exclusively
15:05:49 <ibid> no suse
15:05:51 <ibid> some debian
15:06:00 <ibid> the same for my department
15:06:13 <daniel> never seen redhat, but it's not self-compiling afaik and that makes it useless for me.
15:06:15 <ibid> (exclusively of gnu distros...)
15:06:19 <Erwin> Most OPN users break down and install Debian after a while of being told how to apt-get this and apt-get that
15:06:25 <ibid> hehe
15:07:07 <ibid> personally, i'm waiting for gnu/hurd to stabilize
15:07:39 <daniel> gentoo is a bit hurd-like, i think. but dunno hurd.
15:07:47 <daniel> just heard it...
15:07:48 <ibid> cannot be
15:07:55 <ibid> gentoo is linux, cannot be hurd-like
15:08:04 <ibid> the hurd is a kernel
15:08:13 <daniel> yeah, i said '-like'
15:08:18 <ibid> i'd just switch to debian gnu/hurd
15:08:27 <daniel> such as gentoo has small parts of *bsd
15:08:29 <ibid> daniel: doesn't save your behind :_)
15:08:39 <daniel> mh?
15:08:53 <ibid> currently debian is the preferred gnu/hurd distro
15:10:12 <daniel> mh ghc is still installing. :(
15:10:31 <ibid> apt-get install ghc5 and you'd already be there :-)
15:10:36 <Heffalump> redhat is self-compiling, btw
15:10:41 <ibid> anyway, i'm off to reading liza marklund
15:10:44 <ibid> bbl
15:10:45 <daniel> i'm already installing
15:10:48 <daniel> emerge ghc :P
15:10:56 <daniel> cu ibid 
15:12:33 <ibid> hm, i can't use gentoo.  it ignores gnu ;-)
15:12:45 * ibid is really going to be off ... soon
15:12:53 * shapr tries to figure out network things
15:13:17 <daniel> mh a question: where is haskell used?
15:13:30 <shapr> I use it here. :-)
15:13:40 <shapr> Xylinx Lava Hardware design and verification language
15:13:58 <shapr> there's a list of things on the Haskell homepage
15:14:06 <shapr> GHC is written in Haskell
15:14:07 * ibid is using haskell in my msc thesis
15:14:13 <daniel> :)
15:14:19 <shapr> yah, I'll be using Haskell in my thesis, if I ever have one.
15:14:32 <shapr> actually, I'll probably use Haskell2
15:14:40 <shapr> rather than Haskell98
15:14:41 <ibid> to build a beginning of a formal methods toolset (mostly the automated reasoning stuff...)
15:14:43 * daniel just wants to have a look on functional programming
15:14:52 <daniel> but indeed im a huge fan of oop and C++.
15:15:02 <shapr> I like to write everyday useful code in Haskell
15:15:23 <shapr> daniel: do you have hugs or ghc installed and running?
15:16:27 <Heffalump> don't hold your breath for Haskell 2 :-)
15:16:29 <daniel> hugs
15:16:36 <daniel> ghc is installing
15:16:45 <daniel> oh shit... error while making it. :(
15:16:52 <ibid> apt-get install ghc5 and you'd already be there :-)
15:16:54 <shapr> Heffalump: same for my thesis :-)
15:17:10 <daniel> ibid: sorry but... shut up :)
15:17:19 * ibid is just teasing...
15:17:29 <ibid> but yeah, i should really go and read some liza marklund
15:17:42 * ibid just got a brand new copy of "prime time"
15:17:50 <shapr> what's "prime time" ?
15:17:56 * shapr doesn't know marklund
15:18:06 * ski neither
15:18:23 <ibid> it's a book
15:18:27 <ibid> by liza marklund :-)
15:18:33 <ibid> dunno if there is an english translation
15:19:14 <ibid> http://www.lizamarklund.net/books.html#primetime
15:20:04 <shapr> hi dark
15:20:07 <shapr> how was the party?
15:20:18 <Marvin--> meh, man do I suck at Cluedo
15:20:31 <dark> It was nice, but I don't really know because I spent all of it talking with liw :)
15:20:38 <shapr> ibid: looks like a neat book
15:20:47 <shapr> oh cool, liw was there?
15:20:53 <shapr> was it a #debian-fi party?
15:21:14 <dark> It was a birthday party of one of his friends :)  (And mine, of course)
15:21:26 <dark> Er, I don't mean my birthday...
15:21:52 <shapr> right
15:21:55 <shapr> I got it :-)
15:21:57 <dark> Okay :)
15:22:57 <dark> Unfortunately I couldn't entice him to Haskell, he's deeply embedded in Python :)
15:23:14 <shapr> who is it?
15:23:19 <shapr> if you don't mind me asking...
15:23:24 <shapr> I'm a great fan of Python myself.
15:23:35 <shapr> I just don't think Haskell and Python are exclusive
15:23:39 <liiwi> yes, twin is quite sold to python atm.
15:23:44 <dark> Who is what?
15:23:48 <shapr> liiwi: were you at the party also?
15:23:57 <shapr> hi seth
15:23:58 <liiwi> njet
15:24:29 <shapr> sethk: hey, I found Haskell source for LZW in the nofib test suite.
15:25:14 <Igloo> !
15:25:20 <shapr> ?
15:25:30 * Igloo goes off hunting!
15:25:42 <daniel> hi Igloo 
15:25:44 <daniel> cu Igloo 
15:25:59 <Igloo> Hi
15:26:16 <shapr> what are you hunting?
15:26:19 <shapr> oh well
15:26:33 <Igloo> Haskell source for LZW
15:26:42 <shapr> oh
15:26:54 <shapr> want the full path inside fptools ?
15:27:10 <Igloo> Only if it starts http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/nofib/
15:27:18 <shapr> if you find the compress and compress2 directories, it's in there
15:27:44 * Igloo finds it, ta
15:28:11 <shapr> ok
15:28:13 <shapr> hi dblack
15:28:26 <dblack> hi shapr
15:28:29 <shapr> how's the LotY stuff going?
15:28:31 <dark> That reminds me, I looked up the expiration times of the Unisys LZW patent.  Apparently it's July 2003 in the US and (possibly) July 2004 in Europe.
15:28:50 <dblack> shapr: ok, though slow... (at least for me)
15:28:57 <shapr> dblack: have any questions?
15:29:08 * dblack has been organizing the ruby conference and hasn't had much time for haskell
15:29:25 <dblack> shapr: yeah, how do i get 40 hours in the day? :-)
15:29:29 <daniel> the ghc source is broken...
15:29:32 <daniel> shit :(
15:29:59 <shapr> I can't give you more time :-)
15:31:08 <dark> dblack: Moving to a different planet should do it.
15:31:26 <dark> One that doesn't turn as fast.
15:33:04 <shapr> I think I could cut down the size of this Echo.hs
15:33:08 * shapr tries
15:34:11 <dark> Echo.hs?
15:34:19 <dark> Sounds like it ought to be a very simple module :-)(
15:34:23 <shapr> it should be...
15:34:33 <shapr> but I haven't used the Network module in GHC yet
15:34:52 <shapr> and this is code for an older version of GHC, so I'm trying to update it
15:37:49 <shapr> hmm
15:41:55 <shapr> dark: how much finnish have you learned? how long have you been in .fi?
15:42:12 <shapr> hi Verbophobe
15:42:18 <Verbophobe> Hello.
15:42:24 <shapr> new to Haskell? looking for help?
15:42:42 <Verbophobe> I am new, but I'm not looking for help just yet.
15:42:58 <shapr> ok, do you already have an url to a tutorial?
15:43:06 <dark> shapr: Just enough to get by in stores and restaurants :)  I've been here for 2 years.
15:43:21 <shapr> ok, so I don't have to feel like a complete language ditz, whew :-)
15:43:24 <Verbophobe> Yes, yes...  Thanks for asking...
15:43:44 <shapr> Verbophobe: well, feel free to ask if you have any questions.
15:43:52 * shapr goes back to figuring out the network stuff
15:44:55 <Verbophobe> Well, I'm currently in a manic-depressive state due to this (haskell unrelated) GUI app I'm writing that's seriously fucking up...  I'm this close to commiting suicide.
15:45:16 <Verbophobe> So hey.
15:45:19 <Verbophobe> How was your day?
15:45:31 <Verbophobe> Or, if you're not in my time zone, how is it going to be?
15:45:38 <dark> shapr: What language are you learning?
15:45:41 <Heffalump> my day is just ending
15:45:43 <dark> My day was excellent.
15:46:11 <Verbophobe> Good, good.  Any new developments on the whole "world-domination" front?
15:46:16 <sethk> Verbophobe:  What are you writing a GUI in?
15:46:18 <ski> my day was a little tiresome
15:46:22 <Verbophobe> GTK+ 2.0
15:46:49 <Verbophobe> I'm pretty good, GTK wise, but I'm trying to implement something that's actually making my goddamn X server crash.
15:46:49 <sethk> Verbophobe:  All the GUI languages are annoying, GTK isn't as bad as some others.
15:47:01 <Verbophobe> Yeah, that's why I chose it...
15:47:04 <sethk> Verbophobe:  Specifically?
15:47:14 <Verbophobe> What do you mean?
15:47:24 <sethk> Verbophobe:  What is crashing your X server?
15:47:38 <Verbophobe> If I knew, I wouldn't be complaining...
15:47:50 <Verbophobe> I think it has something to do with my WM.
15:47:57 <shapr> dark: I'm about to start learning swedish, but I've been doing a bad job of learning finnish for three years
15:48:02 <Verbophobe> But I'm not sure, since it's random...
15:48:07 <Verbophobe> Joy...
15:48:35 <sethk> Verbophobe:  Does it give you a core file?
15:48:54 <shapr> finnish is difficult.
15:49:36 <Verbophobe> Not even.  Actually, my kernel says "core dumped", but I can't find the core file.  Plus, running an Xnest in gdb reveals that it crashes when recursively calling a function a few million times.
15:49:55 <Verbophobe> sethk: We should continue this in PM.
15:50:24 <sethk> Verbophone:  OK, how do we do that?  Is PM a channel?
15:50:49 <Heffalump> private messages
15:50:53 <Heffalump> I guess
15:50:57 <Verbophobe> That's it...
15:51:05 <Verbophobe> That /query thing.
15:51:12 <Heffalump> (I had to think a bit to work that out :-)
15:52:12 <dark> shapr: Which language are you coming from?
15:52:34 <shapr> dark: american english
15:52:42 <shapr> I'm from Alabama :-)
15:53:03 <dark> shapr: I assumed from your name and location that you were a swedish-speaking finn :)
15:53:32 * shapr laughs
15:54:04 <dennisb> Verbophobe: if the X server is crashing it's not your fault but a bug in the X server, try your app on another computer with another graphics card
15:54:55 <Verbophobe> dennisb: Hmmm...  I don't really have access to other X servers right now...  Perhaps a windows one... I'll check it out.
15:55:31 <dennisb> I bet you use the binary only nvidia driver..
15:55:49 * shapr uses that driver
15:55:57 <shapr> that driver has some major flaws
15:55:58 <dennisb> it works most of the time
15:56:11 <shapr> the latest release is happier with SMP, yay
15:56:24 <Verbophobe> Hehe...  Actually, I'm on FreeBSD, with an ATI Radeon.
15:56:41 <Verbophobe> No DRM acceleration enabled, by the way...
15:57:54 <dark> My tolerance for bugs seems to vary over the years.  Currently it's fairly high, probably from playing Windows games on my girlfriend's computer.
15:58:20 <shapr> hey, you can play several popular win32 games on winex
15:58:24 <dark> It used to be way below human normal :-)
15:58:33 <liiwi> I thought drm was working on frisbee these days with radeon
15:58:43 <shapr> I have a low tolerance for bugs, especially after using Java
15:58:52 <liiwi> I haven't played any games except on linux in years
15:58:58 <shapr> yay linux!
15:59:34 <Verbophobe> It is.  I just disabled it, because when your X server is crashing, you suddenly decided that an OpenGL screensaver isn't necessary.
15:59:38 <liiwi> nethack and tc keep me mostly happy still
15:59:48 <shapr> counterstrike and crack-attack for me
15:59:49 <liiwi> heh
15:59:54 <shapr> crack-attack is fun
16:00:02 <Verbophobe> Ever tried xevil?
16:00:10 <Verbophobe> I was addicted to that a while ago.
16:00:32 <Verbophobe> www.xevil.com
16:00:40 <shapr> thanks, I'll check it out.
16:00:44 <dark> I'm much happier playing non-free games on someone else's windows than installing non-free emulators on my linux :)
16:00:47 <liiwi> I need to play crossfire one of these days
16:01:30 <liiwi> I started maintaining the package and imagined that I'd have time to play it ..
16:02:22 <dark> Ooh, crossfire.  It contains my first free software patch :)
16:02:47 <dark> I also remembering grepping through /dev/hda3 in a desperate attempt to recover my dead character :)
16:02:53 <liiwi> heh
16:04:21 <liiwi> damn, there's new version again
16:04:37 <|Fo|Ns> hi
16:05:18 <shapr> hi
16:05:25 <ski> hi
16:06:32 <liiwi> hmm, sfs is just begging for haskell implementation
16:06:39 <shapr> sfs?
16:07:23 <liiwi> shapr: fs.net
16:08:44 * shapr looks
16:09:39 <liiwi> beware
16:10:12 <shapr> liiwi: neato
16:11:14 <liiwi> wow, out of 6 ftp sites that are supposed to carry new version of crossfire, two have no dns records, and four are either unreachable or not allowing logins
16:12:10 <shapr> hm
16:12:17 <shapr> sfs does look very cool
16:13:14 <dark> liiwi: You just don't belong to the elite crossfire initiates.
16:16:19 <liiwi> dark: well, with some bouncing around, I got to the second mirror, and it does not have the new version yet, which was released on september 15th.
16:16:35 <liiwi> so I shall use some spells to get it.
16:19:12 <liiwi> shapr: and you can just apt-get install it.
16:19:46 <ski> i've got to ask : what's apt-get ?
16:20:11 <shapr> it's how you install and remove programs in Debian
16:20:27 <dark> Well, it's one way :)  But the currently the most convenient.
16:20:35 <shapr> aptitude is nice
16:20:39 <ski> ok
16:20:59 <shapr> "apt-get install sfs-server" would let me use sfs
16:21:16 <shapr> the spiffy part of apt-get is upgrading
16:21:50 <shapr> this box started out being Debian 2.1 I think, and is now 3.0
16:22:10 <shapr> no reinstallation required
16:22:24 * shapr upgrades his box once a day
16:22:50 <ski> oh
16:23:58 * shapr wishes haddock would output info docs for in-emacs browsing
16:24:10 <shapr> btw, hasktags is handy
16:24:20 <ski> well, i think i gotta go in a few minutes (has to listen to music ..)
16:24:30 <shapr> bye ski!
16:24:40 <ski> bye !
16:25:16 <dark> hasktags?
16:25:33 <shapr> makes a TAGS file for Haskell
16:25:43 <shapr> very handy for tracking through source from other people
16:26:00 <dark> Ah, I see.
16:26:08 <dark> I wonder if I could use it to find out which of my functions are unused.
16:26:27 <shapr> hIDE makes dependency graphs like that
16:26:52 <shapr> http://kungens.kemi.fi/~shae/hIDE.png
16:27:29 <shapr> I need to try to build that again.
16:41:25 <dark> shapr: The 'unused functions' display is cross-module?
16:41:47 <shapr> I'm not sure
16:42:00 <dark> ghc already warns me of unused functions within a module :)
16:42:05 <dark> But it doesn't warn about exported ones.
16:44:02 <dark> I'd like a list of exported functions that are not used by any other module.
16:45:00 <dark> Nope, hasktags doesn't do what I want.  I need some sort of xref tool :)
16:45:27 <shapr> I wonder if there's something in the hssource package
16:46:45 <shapr> if you can get the list of modules, and the functions exported, and the modules they import and functions used, you could just do a directed graph thing on it
16:50:49 * shapr finally gets the Echo server to compile
16:51:11 <dark> Or a simple filter, actually :)  If a function isn't used directly then it doesn't need to be exported.
16:52:21 <shapr> the lo-tek method being "change all modules to export nothing; fix compile error; repeat"
16:52:38 <dark> That sounds like work :)
16:52:43 <shapr> yes it does :-)
16:53:09 <dark> I didn't know there was so much stuff in haskell-src.  Maybe I'll write a hsunused tool :)
16:53:22 <dark> But then I'll have to get my homepage into shape so I can put it somewhere.
17:02:22 <shapr> cool, it works.
17:02:55 <shapr> making threaded socket servers in Haskell is a lot easier than I expected.
17:05:48 * shapr feel the glow of accomplishment
17:06:13 <shapr> well, I'll take that glow and inflict it on nearby counterstrike players.
17:50:48 <daniel> good night
