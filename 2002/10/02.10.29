03:19:29 <Segora> hi
04:01:41 <dark> Hmm, sometimes I do want to pattern-match constructors as (_ x) :-)
04:02:26 <dark> I have three very similar cases now.
04:12:03 <Igloo> If you make them records you can have a commonly named accessor
04:19:12 <dark> Yeah but I can't think of a name :)  The datatype looks like this:
04:19:15 <dark> data Change a = Create a | Change a a | Destroy a
04:19:30 <dark> (It's for recording the difference between two lists)
04:20:20 <dark> The cases for handling them are all similar but just different enough that I can't extract a common pattern.
04:20:56 <Igloo> "thing"?  :-)
04:21:00 <dark> Heh :)
04:21:16 <cleverdra> diff [1,2] [2,3,4] = [Change 2, Change 3, Create 4] or? [Destroy 1, Create 3, Create 4]
04:22:25 <dark> [Destroy 1, Change 2 2, Create 3, Create 4]
04:22:26 <Igloo> Both are valid, but the second is probably better
04:22:51 <dark> It's not very interesting with numbers :)  I use it with (key, value) pairs where they keys are compared and the values recorded.
04:22:51 <Igloo> Oh, I see, you mean in Dark's case
04:23:06 <cleverdra> Well, the first ignores the second part of Change
04:23:57 <dark> I used to have a "Leave a" constructor for changes that change nothing, but it turned out to be just extra work.
04:24:00 <cleverdra> dark - do you mean Change 1 2 ?
04:24:26 <dark> cleverdra: No...
04:24:29 <dark> A more proper example is:
04:25:23 <dark> diff [('a', 3), ('b', 4)] [('b', 2), ('c', 5)] = [Destroy 3, Change 4 2, Create 5]
04:26:41 <dark> I guess I could have old_thing and new_thing accessors :-)
04:28:11 <cleverdra> (oldThing/newThing older/newer)
04:28:44 <dark> Nah, I don't like halfCapNames.
04:29:45 <cleverdra> hm, OK.  I despise underbar_names, myself.
04:30:17 <dark> cleverdra: One day we shall have to duel to the death :-)
04:30:35 <cleverdra> dark =)  What do you think of dashed-names ?
04:30:54 <dark> They're nicer than underbar_names.
04:31:06 <dark> I can't use them in Haskell, though?
04:31:12 <cleverdra> Ah!  Then I don't have to kill you.
04:31:18 <cleverdra> No, you can't use them in Haskell.
04:31:41 <dark> I never understood why language definitions are always geared to parsing code withoutanyspaces.
04:32:52 <dark> It's not _that_ hard to write "x - 1", and it frees up "x-1" as an identifier and allows "-1" without any confusion.
04:33:00 <cleverdra> dark - or why it's so important to allow a*2+3 over (a * 2 + 3) that names (ala Forth or, to a lesser degree, Lisp) must be limited.
04:33:46 * cleverdra assumes that all this can be blamed on Fortran, somehow.
04:34:30 <dark> cleverdra: Probably.  I think it's the path Fortran -> linker implementation -> assembler syntax -> C design -> immortality
04:34:58 <dark> C didn't allow any characters in its identifiers that assemblers didn't accept in labels.
04:35:07 <dark> Hmm, but Pascal is older than C and did the same thing.
04:35:46 <dark> cleverdra: Ah, but I see you're thinking of the spacelessness now :)
04:38:02 <cleverdra> actually, I wonder if some of the spacelessness comes from paper-programming; I find it to write and read pencilled code when whitespace between elements isn't too significant.
04:38:09 * dark proposes for Haskell 2: allow odd? as identifier and +FM as operator.
04:38:10 <cleverdra> easier, I find it.
04:38:31 <cleverdra> yay
04:38:46 <Heffalump> dark: ?
04:39:25 * cleverdra notes that Ruby, mostly as restrictive as most languages about identifier-characters, also allows foo? (for but not restricted to predicates) and bar! (for but not restricted to destructive variants of non-destructive functions)
04:39:35 <dark> Heffalump: In long, require spaces between identifiers, and use this newfound freedom to allow a greater range of characters in names and operators.  Distinction is still made based on the first character.
04:39:45 <dark> Then we can get rid of evilness like "addToFM"
04:40:15 <Igloo> What would you replace addToFM with?
04:40:29 <dark> cleverdra: Whereas haskell allows the oh-so-useful Int# :-)
04:40:38 <dark> Or is that in itself a ghc extension?
04:40:41 <Igloo> Haskell doesn't allow Int#
04:41:06 <dark> Igloo: Hmm, you're right, plusFM would become +FM.  I'm not sure about addToFM.
04:41:27 <cleverdra> >FM
04:41:33 <cleverdra> "to FM"
04:41:33 <dark> It can't be :FM because that would be a constructor :)
04:42:25 <Heffalump> well, you could always define nicer looking operators
04:43:00 <dark> Heffalump: The operator namespace seems particularly limited, though.  And it quickly becomes cryptic if only symbols are allowed.
04:43:24 <Heffalump> you can use ` ` though
04:43:39 <dark> I don't consider `plusFM` much of an improvement :-)
04:44:04 <Heffalump> ok, but with suitable use of type classes (possibly MPTCs) you can probably make nicer names
04:44:26 <dark> Yeah, I guess with Haskell 2 there's scope for doing that.
04:44:53 <cleverdra> MPTCs?
04:45:46 <dark> Hmm, the character range for operators could be greatly extended if we can use unicode.
04:45:50 <Heffalump> multi-parameter type classes
04:45:54 <dark> I'm sure there's some suitable ones for map and filter :-)
04:47:33 <dark> cleverdra: Perhaps even addToFM -> +1FM
04:47:50 <dark> If letters are allowed, why not numbers? :)
04:48:58 <Heffalump> ick!
04:49:08 <Heffalump> +1FM just looks horrible, IMO
04:49:24 <dark> Okay, +eFM, for "element"?
04:49:35 <Heffalump> still.
04:49:46 <dark> I guess the FM tag needs to go, and have a typeclass for container types instead.
04:49:56 <Heffalump> Never mind Haskell, my brain parses things mostly ignoring spaces around operators.
04:50:33 <dark> Even in a spaceful context?  foo +eFM bar
04:50:51 <Heffalump> yes.
04:50:53 <cleverdra> Your brain does that because of languages like Haskell, Heffalump.
04:51:07 <Heffalump> my brain does that because I learnt arithmetic when very young
04:51:12 <dark> Scheme is the answer.
04:51:15 <Heffalump> and algebra
04:52:22 * Heffalump disappears
04:52:38 <dark> But in algebra, "xy" is generally two identifiers.
04:52:44 <dark> Plus an implied operator :)
04:53:00 <dark> I wonder if there are languages where identifiers can be only one char long.  APL?
04:53:15 <cleverdra> (Scheme is certainly the answer when you've a program that should deal with huge user-editable data structures that mix various data types and code.  Has anyone tried this using another language's syntax?)
04:53:47 <cleverdra> dark - what languages have identifiers that *can't* be only one char long?
04:54:09 <cleverdra> dark - oh, sorry, I see what you mean.
04:54:22 <dark> LEVEL I BASIC is one :)
04:54:46 <dark> But it didn't take advantage of that when parsing, I think.
04:55:41 <dark> cleverdra: I'm sure people have tried it using another language's syntax.
04:55:45 <dark> cleverdra: Example: XML :-)
04:56:48 <cleverdra> dark - with other-than s-expressions, yes; I've tried it using Erlang-syntax.
04:56:52 * cleverdra shudders.
04:57:39 <cleverdra> XML might not be bad, actually.
04:59:44 <cleverdra> (only if I supplied an editor, though)
05:00:28 <dark> <functiondef><typedecl><type>a</type><type>b</type><type>a</type></typedecl><cases><pattern><patternarg>x</patternarg><wildcard/</pattern><identifier>x</identifier></cases></functiondef>
05:00:40 <dark> Add indentation to taste, and you have the definition for "const" :-)
05:01:08 <dark> Oh, I forgot to wrap the identifier in an "expressoin"
05:01:12 <dark> s/oi/io/
05:01:42 <dark> Oh, and the whole pattern, expression pair should be in a case element.
05:02:24 <dark> But notice how you don't need -> markers between the argument types :)
05:04:23 <cleverdra> <level> name="Simple level" data={["#####","#@$.#","#####"]} <rules> <rule> from="@$." to=" @*" after={deltaScore 1; message "Congratulations!"} </rule> <rule> from="@ " to=" @" </rule> </rules> </level>
05:05:05 <cleverdra> That's more what I meant =)
05:07:27 <dark> Surely those should be <name>Simple level</name> elements :)
05:07:43 <dark> Or <level name="Simple level"> if you're desperate.
05:07:53 <dark> I can see you have roguelike games on the mind :)
05:08:12 <cleverdra> Well, this is inspired from Sokoban.
05:08:53 <dark> Hmm, it shouldn't be hard to write a Scheme interpreter in Haskell :)
05:09:51 <cleverdra> That's probably what I'll do =)  but I'd prefer to have all of Haskell available to me in the rules.
05:11:30 <dark> So the data is going to be compiled in?
05:12:32 <dark> Speaking of compiling in, I noticed that my executable is already over a megabyte even though it doesn't do much yet.  Is this normal?  Can anything be done about it?
05:14:12 <cleverdra> ldd it; is curses being linked statically or dynamically?
05:14:30 <Igloo> Does strip help?
05:15:14 <dark> cleverdra: This is a different program :)
05:15:20 <dark> It's the version control tool.
05:16:39 <dark> Hold on, I'm recompiling...
05:18:13 <dark> Strip reduces it from 1.5 MB to 0.9 MB
05:19:07 <dark> It's dynamically linked with libgmp, libc, libm, and libdl.
05:19:31 <cleverdra> I was just thinking that it would be neat if Haskell modules could be silently dynamically-linked, as with C libraries.
05:19:35 <dark> I link with -package posix -package network
05:20:11 <dark> cleverdra: I think there's too much inlining going on to make stable interfaces :)
05:20:37 <dark> I guess the bulk of the executable is library modules, in fact.
05:20:38 <cleverdra> Yes, it would hurt efficiency.
05:21:18 <dark> cleverdra: Hmm, might be interesting to analyze a set of Haskell programs, to see how much of the library they could share despite the inlining.
05:21:40 <dark> Hm, but...
05:21:45 <cleverdra> Is unused code compiled into the binary?
05:21:51 <dark> I think executables wouldn't even agree on the binary representation of various types.
05:22:09 <dark> cleverdra: I think the libraries are all compiled with function-sections, so the linker should get rid of unused functions.  But user modules aren't.
05:22:19 <dark> Then again, I hope I'm using all of my own functions, otherwise I should get rid of them :)
05:24:07 <dark> I have a version history of this program, maybe I can graph the growth of executable size to see if I should be worried :-)
05:26:00 <dark> Hmm, more useful might be to compare source size to object size for each module, to find the biggest hogs :)
05:37:11 <dark> Heh, all I have found is that small modules that inline a lot of code get big object files.
06:09:25 <dark> hmm, the size jumped from 600k to 1M when I added -package network.
06:15:54 <Igloo> Are the two stripped sizes the same?
06:17:52 <dark> No, 200k difference.
06:18:06 <dark> Of course some of that will be due to the code I added that makes use of the network package :)
06:18:14 <dark> But it's the most significant size jump in the series.
06:18:25 <dark> (I compiled all the versions in my archive)
06:19:33 <dark> I guess I'll resume worrying about this when the program is ready for release :)
06:19:46 <dark> I could always make my own library containing only the functions I use.
06:21:44 <dark> (I'm currently a bit unhappy about mixing the PosixIO and Handle models in one program)
06:29:44 <Igloo> Ah, I thought you were testeing just adding a package to see what difference that made
07:34:25 <jadrian> hi
08:25:49 <hdaume> hi all
09:19:26 <Blizz> I have a question about Maybe. I have a function which looks up a certain value from a key-value pair. I can assume the find will always result in a 'hit'. Well the find returns a value of 'Maybe a' so to get rid of the Maybe I use a case . (case foo of Just a = a) but I have the feeling this isn't the nicest way to do it, or is it? 
09:20:09 <hdaume> fromJust?
09:20:46 <Blizz> hdaume I'll have to look this one up ;)
09:20:56 <hdaume> Maybe.fromJust :: Maybe a -> a
09:21:01 <hdaume> raises an error on Nothing
09:21:11 * cleverdra imagines that fromJust x = case x of Just a -> a
09:21:22 <hdaume> cleverdra: more or less ;)
09:21:38 <Blizz> fromJust (Just a)      = a
09:21:38 <Blizz> fromJust Nothing       = error "Maybe.fromJust: Nothing"
09:21:39 <cleverdra> fromJust (Just x) = x -- better =)
09:21:54 <Blizz> hehe. 
09:22:24 <Blizz> hdaume: this will do thnx
09:24:55 <hdaume> Blizz: you can also use fromMaybe :: a -> Maybe a -> a where the first param is used in the case of Nothing
11:17:20 <dark> boring (from, to) = from == to
11:17:26 <dark> Haskell is so expressive :-)
11:17:44 <ayrnieu> boring = (==)
11:17:58 <dark> ayrnieu: No, it has to unpack the tuple.
11:17:59 <ayrnieu> 1 `boring` 2 => False =)
11:18:10 <ayrnieu> dark - there's a function for that
11:18:19 <dark> uncurry?
11:18:38 <ayrnieu> boring = (==) . uncurry -- or curry; I forget which does what.
11:18:43 <dark> boring = uncurry (==), perhaps
11:18:56 <ayrnieu> oh, yes, it'd be yours.
11:19:15 <dark> I think my original definition better shows why it's boring, though :)
11:19:19 <creature> I'm trying to load a very simple file so I can do my Haskell assignment, only I get "Undefined type constructor "Picture"". How do I solve this?
11:20:06 <dark> creature: Is Picture supposed to be defined in the file you're loading, or in some other module?
11:20:09 <ayrnieu> creature - possibly, you are using Picture as a type constructor without defining it as such.
11:20:27 <ayrnieu> creature - where and how do you define Picture ?
11:20:56 <creature> dark - I think Picture is supposed to be defined automatically for me somewhere else.
11:21:02 <creature> I don't have to define it, anyway.
11:21:14 <creature> I get the feeling it might be one of the things in Prelude.
11:21:28 <creature> Ooh, hang on, I've got an exercise somewhere that called another file to be able to use it.
11:21:33 <creature> Let me see if I can dig that out.
11:22:30 <dark> Not prelude, but maybe in ObjectIO.Graphics.UI somethere.  Sorry, I have to run now :)
11:22:41 <creature> no worries, thanks.
11:22:58 <creature> How do I specify in a Haskell file that it should load another one?
11:23:30 <Heffalump> import Foo
11:23:45 <Heffalump> just after the "module Bar where" line
11:23:57 <creature> What module bar where line?
11:24:03 <creature> Remember I'm very new to Haskell. :)
11:24:54 <Heffalump> you should put one at the top of your file
11:24:59 <Heffalump> make Bar the same as the name of the file
11:24:59 <ayrnieu> creature - module Bar where ... definitions ... -- is a simple definition of a module.
11:25:07 <Heffalump> so bar.lhs would have module Bar where at the top
11:25:23 <creature> What's the l in the file extension do?
11:25:57 <Heffalump> means that you have to have "> " at the beginning of each line of code
11:26:06 <ayrnieu> creature - .lhs is literate Haskell; contents are by default non-code, and code must be specified (with TeX tags or '>' at the beginning of lines)
11:26:10 <Heffalump> (and things without that "> " are treated as non-code, which is useful)
11:26:30 <Heffalump> if you have bar.hs then just every line is code (but ones starting "-- " are comments)
11:26:40 <creature> OK, right.
11:27:18 <creature> So I want to start my file with "module bar where". Then do "import Pictures.hs" ?
11:29:09 <ayrnieu> No .hs
11:29:50 <creature> Ah, right. I was wondering why it was erroring. 
11:31:52 <creature> Fantastic, it's working now, thanks.
12:12:13 <creature> Would someone give me a hint on how to build a function that builds a square of size n?
12:15:14 <ayrnieu> square x = x*x
12:16:09 <creature> Yep, I see that, but I don't think it's really relevant. 
12:16:22 <creature> I have building blocks, of size 1.
12:16:30 <creature> These are white squares, and black squares. 
12:16:35 <creature> However, this is done in ascii graphics.
12:16:53 <creature> so a white square is really ["..",".."] and a black square is really ["##","##"]
12:17:11 <creature> I also have functions like sideBySide, and above.
12:19:09 <creature> Any ideas? 
12:43:39 <BlizzNL> This is rather a math question than a haskell one, but since they are very much related (and I know some of you know this) I'll ask you guys ;) : What is the result of the union operator on the sets {1, 2, 3} diff {2, 3, 4}. Is it {1} or {1,4} ?
12:43:57 <ayrnieu> square x c = take x $ square' where square' = take x $ repeat c : square'
12:44:11 <ayrnieu> square 2 '.'; square 2 '#'
12:44:32 <ayrnieu> take x (repeat c) : square'
12:45:09 <ayrnieu> blizz - you say 'union of sets' and then you say 'diff', so I don't know what you are asking.
12:45:55 <BlizzNL> ayrnieu: sorry I meant difference
12:46:25 <ayrnieu> OK.  I don't know what 'difference' means, then =)  Is it the union minus the intersection?
12:46:44 <ayrnieu> If so, {1,4} is the difference.
12:47:13 <creature> ayrnieu - cheers for the code, but 1. I don't understand it, and 2. I'd prefer hints, rather than solutions, as I am getting marks on it.
12:47:33 <BlizzNL> ayrnieu: I also think it is. thnx
12:47:54 <ayrnieu> creature - OK.  Hints: understand lazily-evaluated- and infinite- lists; look up 'take' and 'repeat'
12:48:12 <creature> I think I'm meant to do this with iteration, to be honest ayrnieu.
12:48:23 <ayrnieu> creature - you really, really shouldn't -- but OK.
12:48:40 <creature> I've got a function that builds a line of length n.
12:49:06 <ayrnieu> OK.  What's the problem?
12:49:29 <creature> I can't see how I can use that to build a square using iteration and only 1 argument.
12:49:47 <BlizzNL> creature: what is the argument?
12:49:55 <creature> 1 Integer.
12:50:10 <creature> I can post the code online, if you like.
12:50:11 <BlizzNL> yeah great but what is the 'meaning'
12:50:26 <Marvin--> BlizzNL: A\B = { x \in A | x \not\in B }
12:50:27 <ayrnieu> foo 0 = []
12:52:03 <BlizzNL> creature: you can of course if the height and width are the same length
12:52:09 <creature> Take a look at www.alexpounds.com/assessment3.hs and www.alexpounds.com/Pictures.hs
12:52:18 <creature> Those are the functions I have to play with, and what I've done so far.
12:53:33 <creature> What's irritating is that once I get this bit done, everything else falls into place. 
12:54:24 <ayrnieu> creature - by 'iteration' you mean 'recursion', right?
12:54:39 <creature> Yes, my bad, sorry.
12:54:53 <creature> I've just been reading up on ArrayLists and the Iterator stuff in Java.
12:55:10 <creature> I imagine a bit of cross-pollination was on the go.
12:55:32 <ayrnieu> creature - you should read the Little Schemer :-/  or look at it inductively.  You have two cases: you are asked to produce a square of length zero, and you are asked to produce a square of length n.
12:56:50 <creature> ayrnieu - I'll keep an eye out for the book.
12:57:07 <creature> I just can't see what I need to do on each successive iteration to get what I need, as it were .
12:57:19 <creature> Well, I kind-of can, but not well enough to implement it.
12:57:29 <creature> recursion step, even.
12:58:41 <ayrnieu> stars 0 = []
12:58:52 <ayrnieu> stars n = '*' : stars (n-1)
13:02:18 <creature> ayrnieu - well, I've got something like that with my wLine.
13:02:33 <creature> It's how to do the correct number of (above) steps I really don't see.
13:02:45 <ayrnieu> 'correct number'?
13:03:58 <creature> Well, if I had a square of side 3, I'd want to do above twice, each with wLine 3.
13:04:19 <creature> If I had a square of side 4, I'd want to do above 3 times, each with wLine 4.
13:04:26 <creature> Hang on, had an idea.
13:04:51 <ayrnieu> creature - 'the above'?
13:04:57 <creature> No, no I didn't.
13:05:03 <ayrnieu> creature - you seem to be suffering from a one-off error.
13:05:06 <creature> Did you take a look at the source files I posted above? 
13:05:47 <ayrnieu> No.
13:05:57 <creature> Would you mind?
13:06:09 <creature> In particular, the Pictures.hs one.
13:08:34 <creature> Argh, this is getting me down now.
13:08:42 <creature> I'm sure I'm missing something ridiculously easy.
13:14:19 <creature> Ping?
13:14:48 <nde> Pong?
13:14:50 <ayrnieu> I'm here, but I'm busy.
13:14:53 <Heffalump> PONG!
13:14:55 <creature> Ah, no worries.
13:14:58 <Heffalump> but I'm about to have dinner
13:15:00 <creature> Everything went quiet, that's all.
13:15:19 <Heffalump> stars n = map (const '*') [1..n]
13:15:41 <ayrnieu> stars n = take n $ repeat '*'
13:15:46 <Heffalump> stars n = replicate n '*'
13:16:02 <ayrnieu> 'replicate' is new to me.
13:16:11 <Heffalump> it does what you just said with take and repeat
13:16:17 <Heffalump> (it's in the Prelude)
13:16:25 <creature> All of this looks to me to be a re-implementation of my wLine function.
13:16:39 <creature> I can build a line of length n.
13:16:43 <Heffalump> oh yes, I was just showing off neat ways of doing stars
13:16:43 <creature> I need a way to stick one on top of the other.
13:16:48 <Heffalump> not saying you should use it
13:16:59 <ayrnieu> creature - I don't understand how you can know how to build a list of length n and simultaneously not know how to build a list of length n.
13:17:18 <ayrnieu> creature - the only difference is that one is [Char] and one is [[Char]]
13:17:24 <creature> ayrnieu - probably because we haven't been taught about lists. 
13:17:33 <creature> We're dealing with pictures, which aren't really pictures.
13:17:42 <creature> What I know I know from my own study.
13:17:51 <ayrnieu> creature - hm.
13:17:59 <creature> All of this would probably be a lot more evident if you were to look at the haskell files. 
13:18:11 <ayrnieu> box n = replicate n wLine
13:18:18 <creature> Take a look at www.alexpounds.com/assessment3.hs and www.alexpounds.com/Pictures.hs
13:20:04 <dark> creature: Do you need a solid square or a hollow one?
13:20:31 <creature> Solid.
13:20:41 <creature> As I say, I think I'm meant to be doing this by stacking white lines on top of one another.
13:21:28 <dark> creature: Well you have an "above" function :)
13:21:52 <creature> dark - yep. But I can't really see how to get it to do the correct amount of "above's". 
13:22:03 <dark> creature: There's two ways you could make a square recursively.
13:22:05 <creature> And when I try, I end up with too short wLines and build triangles by accident.
13:22:10 <dark> creature: (Well, thousands of ways, but...)
13:22:37 <dark> creature: The first is to start with a small square and keep making bigger squares.
13:22:58 <dark> creature: The second is to start with a rectangle and keep making it taller until it's just as high as it is wide.
13:23:24 <dark> creature: I think the second approach will be easier, but you'll need a helper function for making rectangles.
13:23:50 <dark> creature: So my hint is to first make a function that takes tallness and wideness arguments and makes a rectangle.
13:23:59 <dark> creature: And then use that to make a square.
13:24:28 <creature> I don't think I know enough to do that.
13:24:55 <dark> creature: You've already made a function that takes two arguments, bwLine :)
13:25:22 <creature> yeah, but I'm left with the problem of how to make it do a relevant amount of above's to build a high rectangle.
13:25:41 <creature> I'm going to go and make a herbal tea, I'm not expressing myself well here. BRB.
13:30:00 <creature> There, T infusing.
13:30:03 <creature> Tea, even.
13:31:03 <dark> creature: I think the right kind of "above" handling is already in your bTriangle function.
13:32:51 <creature> Yes, but I don't see how to make it so that my wLine is constant length.
13:33:17 <dark> creature: wRectangle should be a function that takes two arguments, length and height.
13:33:45 <creature> With you so far.
13:34:29 <dark> So it starts like this:
13:34:52 <dark> wRectangle width height | height == 1 =
13:35:11 <creature> wLine width, yes? 
13:35:17 <dark> Yes :)
13:35:24 <dark> So that's a really short rectangle.
13:35:35 <dark> How would you make one that's one unit taller?
13:36:04 <creature> above (wLine width) (wLine width)
13:36:42 <creature> or, I suppose, above(wLine width) (wRectangle(n-1))
13:36:51 <dark> Right, almost :)
13:37:01 <dark> Your wRectangle call isn't right.
13:37:18 <creature> or, I suppose, above(wLine width) (wRectangle width (n-1) )
13:37:46 <creature> or, I suppose, above(wLine width) (wRectangle width (height-1) )
13:37:54 <dark> Heh :)
13:38:19 <dark> This looks right to me.
13:39:05 <dark> This is a general way to keep values constant while you recurse: just keep passing them along when you make the recursive call.
13:39:32 <creature> Remember when I said I was missing something really easy? 
13:39:35 <creature> I think that was it. 
13:40:32 <dark> Okay :)
13:41:24 <dark> But if you intend to answer question 4 by superimposing bTriangle on wSquare, I don't think it will work.  superimpose expects pictures to be of the same size.
13:41:48 <dark> I think pictures are supposed to be rectangular.
13:41:55 <creature> Yes, I was wondering why that didn't work.
13:42:20 <creature> All of a sudden, I think I see why bwLine could be useful.
13:42:29 <dark> :)
13:43:31 <dark> I think you can fairly easily modify wRectangle to be a building block for the triangle-in-square function.  I have no idea what to call it, though.
13:45:36 <creature> I was going to write a bwLineFixedLength that takes 2 parameters - length of black, and total length.
13:46:13 <creature> then use something wRectangle-like to use it.
13:47:14 <dark> Right, that would work.
13:54:52 <dark> creature: By the way, this realization that you have a function like "wSquare size" and you actually need a two-argument function for recursion is pretty common.  If you're stuck, it helps to try a helper function.  This leads to a lot of functions called "loop" or "f" in real code :-)
13:55:25 <creature> Heh.
13:55:43 <creature> And I am having trouble, as it happens.
13:56:07 <creature> I've got a lovely bwLineFixed, but can't really see how to use it. Although I kind of can.
13:56:10 <creature> Hold on, let me fiddle more.
13:58:03 <creature> Ooh, I'm close.
14:04:26 <creature> Woohoo! 
14:04:27 <creature> Got it. 
14:04:58 <dark> Great :)
14:06:10 <creature> Thanks for your help, that was really great. 
14:06:40 <dark> No problem, I like helping :)
14:07:24 <creature> There's another Q coming up, depending on how well my brain is working. :)
14:08:08 <dark> Question 5, A function to read an MPEG of Star Wars IV: A New Hope, and display an ASCII art animation of it?
14:08:38 <creature> Heh, nah. 
14:08:46 <dark> There actually is such an animation, btw :)
14:08:52 <dark> Someone had _really_ a lot of spare time.
14:09:22 <creature> Challenge question (which means there's no marks for it), is to build an England flag (black cross in a white square) in a square of size n.
14:09:28 <creature> Let me have a think before telling me this.
14:22:15 <creature> I would be inclined to generate a square that starts with a black line, and is then wrapped in white ones. 
14:22:24 <creature> Then rotate it by 90 degrees, and superimpose the two.
14:22:54 <Heffalump> how is a black cross in a white square an England flag?
14:23:36 <creature> Well, it should really be red, and in a rectangle, but we're dealing with ascii here. 
14:23:36 <dash> cross of st george
14:23:49 <creature> And the challenge question reads as follows: 
14:23:51 <Heffalump> dash: I know that, it was the colours and shape I was objecting to :-)
14:24:10 <dash> hah
14:24:14 <creature> "Write a function to build an England flag, a black horizontal/vertical cross on a white background, in a square of size n"
14:26:07 <dark> Yeah, that doesn't look like an England flag at all :)
14:26:33 <Marvin--> heh
14:27:29 <creature> Can I get a function to return 2 arguments? 
14:27:42 <creature> I suppose a list would be it, really, wouldn't it.
14:27:57 <Marvin--> use a tuple?
14:28:13 <creature> We haven't done them, so I'll stay clear.
14:28:32 <creature> Incidentally, are there any functions in Prelude to say whether a number is odd or even?
14:28:53 <dark> creature: There doesn't seem to be a rotation function in Picture.
14:29:00 <Marvin--> wtf is up with this... the files for the assignment are given in a .tar file, the graphics implementation is for Xlib but the assignment description is a .doc?!
14:29:05 <dark> creature: The normal way to return 2 arguments is to return a 2-tuple, as (a, b)
14:29:09 <creature> There's a rotate function, and a flipV and flipH
14:29:21 <dark> creature: A list is generally overkill, and it requires that the elements be the same type.
14:29:43 <dark> Yes but the rotate function rotates through 180 degrees, and it sounds like you need 90 :)
14:30:34 <creature> I might have a rotate90 somewhere. Let me check.
14:30:50 <dark> creature: Oh I missed some of the conversation, sorry for the repeats.
14:31:18 <dark> There are functions "odd" and "even" in the Prelude, if I recall correctly.
14:32:07 <creature> D'oh at no odd & even.
14:32:14 <creature> Err, D'oh at no rotate90, even.
14:33:10 <creature> How easy would a rotate90 be to write?
14:33:41 <Heffalump> not trivial, but not too hard
14:34:01 <Heffalump> I think I could probably do it in one line, but I'm not certain
14:34:34 <Heffalump> oh, no I couldn't
14:34:46 <dark> I just did it in one line :)  But it requires a Picture-operating function that's not in the Pictures module, and I think that would be outside the scope of the assignment.
14:35:38 <creature> dark - I think it would be OK for you to give me the rotate90 function, as this part isn't marked.
14:35:50 <v1c> hello
14:35:54 <dark> (That is, you'd have to operate on the Picture as a [[Char]], instead of pretending that it's just a Picture)
14:36:40 <v1c> sorry for butting in but i just have a quick q
14:36:50 <Marvin--> v1c: but on
14:37:09 <v1c> dark sounded like he was trying to explain something to someone
14:37:22 <creature> Anyway, introduce me to tuples. I want to return 2 things. First up, how do I declare my function so it returns them?
14:37:25 <Marvin--> well, there are more people here than dark ;)
14:37:36 <Marvin--> creature: ... -> (a, b)
14:37:40 <creature> v1c - dark & I are playing with pictures. I can handle 2 conversations at once, so fire away with your Q. :)
14:37:49 <creature> Marvin-- I don't need to give them a type? 
14:37:56 <Heffalump> (a,b) is the type
14:38:12 <Heffalump> (if a and b are types)
14:38:19 <creature> Ah, got you.
14:38:34 <v1c> ok well my is, is there a way to drop certain elements out of a list
14:38:41 <v1c> oh wait
14:38:46 <Marvin--> v1c: sure.. you can use filter, for example
14:38:53 <v1c> on 2nd thought i could just use tail head init and so on
14:39:38 <Heffalump> it depends if you want to drop them by position or by the properties of the elements
14:39:54 <v1c> filter...hmmm...it would be pretty messy with strings wouldn't it
14:40:02 <Heffalump> what are you trying to do?
14:40:03 <v1c> yea position
14:40:15 <dark> Okay, the rotate90 function you probably can't use :)
14:40:16 <Heffalump> then you want things like tail, head, init, take, drop etc
14:40:20 <dark> rotate90 = flipV . transpose
14:40:25 <v1c> so i think head and tail fucntions should
14:40:28 <v1c> yea
14:40:39 <Heffalump> transpose isn't a library function, is it?
14:40:44 <dark> creature: transpose is in Data.List.  On a Picture it reflects through a diagonal mirror.
14:40:45 <v1c> nope
14:40:52 <v1c> transpose is in list
14:40:59 <Heffalump> oh, right
14:41:08 <Heffalump> so it is
14:41:09 <v1c> ok thanks
14:41:15 <dark> Yeah it's also in Haskell98 standard List module.
14:41:18 * v1c is going back to coding
14:41:21 <creature> dark - of type Picture :: Picture?
14:41:25 <dark> I'm very used to GHC's module :)
14:41:31 <dark> creature: Picture -> Picture
14:41:39 <dark> creature: Well its actual type is [[a]] -> [[a]] :)
14:41:44 <dark> creature: And Picture is a [[Char]]
14:41:44 <creature> That's what I meant. :)
14:42:10 <creature> undefined variable "transpose"
14:42:15 <creature> So what do I need to import?
14:42:15 <dark> But I think you're supposed to pretend Picture only has the operations defined in Pictures.hs
14:42:21 <dark> creature: import List
14:42:55 <dark> Heffalump: Was yours also flipV . transpose?
14:43:06 <dark> creature: Have you learned about the "." operator already?
14:43:09 <Heffalump> dark: no, it involved defining transpose in one line
14:43:16 <creature> dark - nope.
14:43:26 <Heffalump> which I then decided would need at least two lines
14:43:39 <dark> creature: Well, my definition is equivalent to rotate90 pic = flipV (transpose pic)
14:43:58 <creature> dark - I think I'm going to use it, if I can. As I've said where it's from, and as I'm not getting marked on this bit, I don't mind.
14:44:01 <dark> creature: In general (f . g) x is f (g x)
14:44:46 <dark> creature: It's usually spoken as "after" :)  So "rotate90 is flipV after transpose"
14:45:22 <creature> Ah, right. That makes sense.
14:46:02 <creature> "Instance of fractional int required for definition of strips" <-- Eh?
14:46:09 <dark> Interesting.
14:46:18 <dark> Are you using / somewhere?
14:46:23 <creature> I think this is because I'm trying to use 0.5*
14:46:34 <creature> But it should always give an integer as a result, if my maths is OK.
14:46:39 <dark> For integers you need to use `div` or `quot`
14:46:51 <creature> Ah, right. With the backquotes? 
14:46:57 <creature> But I'm multiplying! 
14:47:08 <dark> Multiplying by 0.5, means dividing by 2 :)
14:47:14 <creature> Yeah, I know.
14:47:25 <dark> 4 `div` 2 is the same thing as div 4 2.  The backquotes mean that div is used as an operand.
14:47:33 <dark> Er, I mean, as an operator.
14:47:44 <creature> Oh yes, I remember now. 
14:47:48 <creature> It's so I can use it as infix notation.
14:47:52 <dark> Right.
14:47:52 <creature> Least that's what the lecturer said.
14:50:07 <dark> Haskell expects both sides of the * to have the same type, and it has already decided that "0.5" must be some kind of fractional type, so x must also be fractional. 
14:50:52 <dark> (I never memorized the kinds of numbers in Haskell, so I might have the terms wrong)
14:55:54 <Igloo> It'll be something like Fractional a => a rather than a type
14:57:28 <creature> Sorry, network problems. 
14:57:36 <creature> And incidentally, grr@people who restart my box for no reason and without permission!
14:58:00 <dark> "If it's off, leave it off.  If it's on, leave it on (except when it's on fire)"
14:58:08 <creature> Precisely. 
14:58:17 <creature> Now my iptables doesn't seem to be letting through my DHCP renew packets. 
14:59:18 * Marvin-- ponders writing a breakout game in haskell just to taunt his poor brother who's doing it in C++ as an assignment
14:59:26 <Heffalump> hehe
14:59:37 <Marvin--> is hopengl any good? ;)
15:03:01 <creature> How do I work with tuples, then? 
15:03:24 <creature> Let's say I want to use the first bit in an (a,b) tuple. How do I do that?
15:03:34 <Heffalump> fst
15:03:41 <dark> fst (a, b) = a
15:03:57 <dark> Another way is to use pattern matching when calling the function:
15:04:05 <dark> let (a, b) = foo in ...
15:04:18 <dark> Oh, you might not have had "let" yet in the course :)
15:05:17 <creature> No, we haven't.
15:05:22 <creature> How do I get the last?
15:05:25 <dark> snd
15:06:13 <dark> It might be helpful to print out the Standard Prelude and keep it next to your computer :)
15:07:43 <Marvin--> what, don't everybody have a copy of the Report under their pillows?
15:07:52 <dark> Marvin: I don't have a working printer :)
15:08:04 <Marvin--> dark: neither do I, but the university has :)
15:08:09 <Heffalump> creature: have you had where clauses?
15:08:17 <Marvin--> hmm, pygame or hopengl
15:08:33 <Marvin--> in Debian, hopengl seems to be b0rken, while pygame works great
15:10:45 <creature> heffalump - yep.
15:11:02 <Heffalump> creature: you can use them to split up the bits of a tuple too
15:11:07 <Heffalump> where (a,b) = foo
15:11:13 <Heffalump> morning Chilli
15:11:18 <Chilli> Moin Heffalump
15:16:11 <creature> If I do "fst (strips n)" where strips n returns a tuple, it should return a, yes? 
15:16:38 <Pseudonym> What's a?
15:16:48 <creature> The first element in my tuple.
15:16:51 <Heffalump> yes
15:16:56 <creature> strips n should returns (a,b)
15:16:59 <Heffalump> (you don't have to call them a and b, btw :-)
15:17:02 <creature> I haven't. 
15:17:11 <Pseudonym> Yes.  Of course it only works for pairs.
15:17:15 <creature> I declared them as (Int, Int).
15:17:38 <Pseudonym> Not for general tuples.
15:18:12 <engstad> greets.
15:18:36 <engstad> I have a question, given:
15:18:43 <engstad> type Answer = Value
15:18:43 <engstad> type K a = (a -> Answer) -> Answer
15:18:43 <engstad> callccK :: ((a -> K b) -> K a) -> K a
15:18:43 <engstad> callccK h =
15:18:43 <engstad>     \c -> let k a = \d -> c a in h k c 
15:18:56 <Pseudonym> Yup.
15:19:02 <dash> zow. looks like you're doing the fun stuff :)
15:19:04 <engstad> How do I understand this code? I mean, what's going on?
15:19:16 <Pseudonym> Oh, you are the lucky one, aren't you.
15:19:18 <dash> engstad: where's it from?
15:19:20 <Pseudonym> Do you know what it does?
15:19:26 * Pseudonym does
15:19:29 <Pseudonym> I just want to know if you do.
15:19:47 <engstad> It's from "The essence of functional programming" by Phillip Wadler.
15:19:54 <Pseudonym> http://haskell.org/wiki/wiki?MonadicContinuationPassingStyle
15:20:04 <Pseudonym> That might help.
15:20:27 <engstad> I know what it "does", I just don't grok it.
15:20:31 <Pseudonym> h.
15:20:32 <Pseudonym> Ah
15:21:02 <Pseudonym> callccK f calls a function f, supplying a continuation as an argument to f.
15:21:02 <engstad> Like, if someone asked me, make a callcc function in Haskell, I would say "huh"? U crazy?
15:21:03 <Heffalump> passes continuations, hope that helps
15:21:27 <Pseudonym> That continuation, when called, basically returns to the callee of callccK.
15:22:24 <Pseudonym> callccK h = \c -> let k a = \d -> c a in h k c
15:22:28 <Pseudonym> First off, the \c part.
15:22:34 <Pseudonym> That should be obvious if you understand CPS.
15:22:38 <engstad> That's the function to call when done, right.
15:22:42 <Pseudonym> Right.
15:22:48 <Pseudonym> Now the right hand side.
15:22:49 <Pseudonym> h k c
15:23:14 <engstad> Hmmm, big question...
15:23:16 <Pseudonym> That calls h, supplying an argument k (yet to be grok'd), and the continuation c.
15:23:30 <engstad> Ok. 
15:23:41 <Pseudonym> So it's like calling h except you supply another argument.
15:23:50 <engstad> *nod*
15:24:01 <Pseudonym> That argument is k where k a = \d -> c a
15:24:09 <engstad> So, h is a function with two arguments, both of them continuations?
15:24:14 <Pseudonym> Yes.
15:24:26 <Pseudonym> The second one is the callee continuation.
15:24:36 <Pseudonym> That is, the continuation passed by whoever called callccK.
15:24:53 <Pseudonym> The other one is a continuation that can be called "inline".
15:25:09 <Pseudonym> It takes a continuation, d, which it discards, in favour of calling c instead.
15:25:23 <Pseudonym> So effectively it culls subsequent combinations, returning to the caller.
15:25:37 <Pseudonym> Sorry, it culls subsequent _computations_.
15:26:01 <Pseudonym> If you look in the wiki page, there's an example of use.
15:27:01 <engstad> Okey, so I don't grok the k function yet.
15:27:06 <creature> dark - cheers for that rotate90 function.
15:27:09 <Pseudonym> Do you understand what it's for?
15:27:11 <Pseudonym> How to use it?
15:27:14 <creature> Just finished writing an englandFlag function. :)
15:27:38 <engstad> No, and also how come it is not: let k a = \_ -> c a in
15:27:44 <Marvin--> creature: with black or red cross? ;)
15:27:51 <dark> creature: Remember to add "Britannia waives the rules" under it :)
15:27:52 <creature> With black cross.
15:27:59 <Pseudonym> engstad: Well the reason it's not that I dunno.  It's equivalent.
15:28:05 <creature> Heh. I'll add it as a comment.
15:28:07 <engstad> *nod*
15:28:31 <engstad> k is the "inline" function?
15:28:33 <creature> dark - any idea about how to do it recursively, though? :)
15:28:38 <Pseudonym> engstad: Er... not quite.
15:28:43 <engstad> hmm...
15:28:51 <Pseudonym> engstad: Have a look at the wiki page.  Look at the final example.
15:29:00 <engstad> Okey, 
15:29:12 <Marvin--> dark: that was just a tad backward ;)
15:29:22 <dark> creature: How to make the flag recursively, or rotate90 recursively?
15:29:42 <creature> How to make the flag recursively.
15:29:52 <creature> As it is, I look at n, and decide what widths to make my strips. 
15:30:07 <engstad> Pseudonym: the divide :: Integer -> Integer -> IO () example?
15:30:07 <creature> Then I use some above functions and wRectangle and bRectangle to make the relevant square.
15:30:16 <Pseudonym> engstad: That's the one.
15:30:18 <creature> Then rotate one, and stick it on the other using superimpose.
15:30:20 * Marvin-- wonders why pygame doesn't do what he wants
15:30:22 <creature> And very nicely it works, too.
15:31:29 <Pseudonym> engstad: You see that divid takes a continuation as an argument.
15:31:53 <Pseudonym> engstad: Calling it (as in the call to esc) basically exits divid early.
15:32:06 <engstad> Where's runContinuation defined?
15:32:17 <Pseudonym> engstad: In the body of the newtype.
15:32:30 <Pseudonym> engstad: It's a record accessor.
15:32:32 <engstad> Oh, I see. :-) Forgot about auto-accessors.
15:33:29 <Pseudonym> I love netsplit.
15:33:36 <creature> Always fun.
15:35:47 <engstad> Pseudo: Okey, so k is a fast-out function?
15:36:22 <engstad> Pseudo: Hmm, no.. *sigh*
15:36:32 <Pseudonym> Sort of.
15:37:14 <Pseudonym> That's what it's used for here.
15:37:31 <creature> wb dark, and everyone else.
15:37:40 <Pseudonym> It's kind of like setjmp() and longjmp() in C, only it's type safe and sane.
15:37:42 <dark> creature: Hmm, there's another way too.
15:37:42 <dark> creature: The flag has two kinds of lines: ones that are all black, and one that just have a black center (the vertical line)
15:37:42 <dark> creature: First you get a chunk of the second kind of line, then some of the first kind of line, then another chunk of the second kind of line.
15:37:42 <dark> creature: You could make a non-recursive function that just puts those chunks "above" each other, and then recursive functions for making each of the chunks.  (The top and bottom chunks will be the same)
15:37:42 <dark> creature: Let me know if you got all that, there seem to have been some irc splits in the meantime.
15:38:03 <Pseudonym> callcc is kind of like setjmp() and calling the continuation is kind of like longjmp()
15:38:21 <creature> I think I got everything from "There's another way too" to "netsplits".
15:39:08 <dark> creature: Did you get the first way? :)
15:39:29 <creature> Nope, don't think so
15:39:53 <dark> [repeat] Basically, you need a function that constructs one line of the flag, given the line number and the flag size.
15:40:08 <dark> [repeat] The rest is similar to the triangle-in-square thing.
15:41:00 <creature> I think I like my current way better.
15:41:06 <dark> Which is that?
15:41:39 <creature> Hang on, I'll post the code online.
15:43:09 <creature> Take a look at www.alexpounds.com/assessment3.hs
15:43:22 <engstad> pseudo: Thanks, but I think I'll have to devour this in my own pace... :-)
15:43:59 <Pseudonym> engstad: No problem.
15:44:08 <Pseudonym> engstad: I don't know how much that helped.
15:44:20 <Pseudonym> engstad: Like most things, the best way to grok it is to play with it.
15:48:40 <dark> creature: By using techniques similar to buildSquare (two of them, one horizontal, one vertical), you could do it non-recursively :)
15:49:28 <creature> You mean it's recursive right now? 
15:49:40 <dark> Er, no :)
15:49:46 <dark> But it's using transpose!
15:50:22 <creature> Yeah, but I quite like that. 
15:50:28 <dark> Okay :)
15:54:59 <creature> Why is it complaining about an unexpected ; when I have no ; anywhere? 
15:56:00 <Heffalump> oh dear.
15:56:04 <Heffalump> layout problems.
15:56:13 <Heffalump> look at the last program line before the non-existent ;
15:56:15 <Heffalump> and check the indentation
15:56:33 <creature> I just indented something, it works now.
15:57:02 <Heffalump> that error was the single most frequent thing I got when I demonstrated at practicals
15:57:31 <dark> Heffalump: Strange, I only get layout problems when I try to mix "where" and "do".
15:57:49 <dark> Well, at first I had to adjust my indentation style for if-then-else :)
15:57:50 <Heffalump> dark: but you're an experienced coder
15:58:09 <Heffalump> oh, and it's mainly a Hugs problem, ghci has better error reporting, i think
15:58:39 <Pseudonym> I only get layout problems when I search & replace nowadays.
15:58:43 <Heffalump> when I say "demonstrated at practicals", I mean "was helping ickle first years fix their problems", not "was writing code myself"
15:58:54 <dark> Yeah I got that :)
15:59:22 <Pseudonym> I use Miranda layout, though, which I believe was a little more strict than Haskell layout.
15:59:27 <Marvin--> Heffalump: thing is, when you go more advanced, you don't understand ghci's error messages, they're too "real" ;)
15:59:43 <Heffalump> hehe
16:00:07 <Marvin--> First time I got a "kind" error I was going "wha...?"
16:00:43 <dark> Heh.
16:01:04 <dark> Yeah some of ghc's error messages make me stare at confusion, and then ignore them and look at the code instead :)
16:01:04 <dark> s/at/at them in/
16:01:16 <creature> dark - that's what nailed me, btw - an if-then-else.
16:01:34 <Pseudonym> The worst ones I find are those which don't give you a location to look at smaller than a function.
16:01:38 <Marvin--> dark: yeah, I usually look at the line number, and ignore the rest :P
16:01:50 <Marvin--> yeah that's a problem
16:01:56 <Pseudonym> Mostly type errors involving quantified types escaping their quantification.
16:02:15 <dark> Well, especially when they give an exact line number which is miles off.
16:02:34 <dark> Pseudonym: Those can be solved by deleting type signatures, right? :-)
16:02:42 <Pseudonym> Yeah, that's it.
16:03:03 <Pseudonym> Especially if you turn off the monomorphism restriction.
16:03:15 <dark> I don't think I've run into that yet.
16:04:28 <Chilli> Consider bad error messages to be bugs
16:04:55 <Marvin--> the best part is when ghci complains of a type, you comment out the type, and ghci gives it the same type
16:05:14 <Chilli> and send an email to glasgow-haskell-bugs@haskell.org citing the error message and what message you would have preferred (ie what you think would have been a clearer message)
16:05:33 <dark> Chilli: This requires me to understand it first, right? :)
16:06:10 <Chilli> If you manage to remove the problem in your program that triggers the error message, you must have some idea of was wrong in your program
16:06:20 <Chilli> (if you don't do random debugging :-)
16:06:47 <creature> Anyway, that's my Haskell done for another week.
16:06:54 <creature> Thanks for all the help, Dark - much appreciated.
16:07:52 * Marvin-- ponders on what "local escape functions" could do to improve the HWS code
16:08:10 <Heffalump> a what?
16:08:30 <Heffalump> chilli: hmm, how about genetic debugging?
16:08:30 <Marvin--> oh, just looking at that page on monadic continuation-style passing
16:09:02 <Pseudonym> Chilli: I do semi-random debugging, actually.
16:09:09 <dark> creature: Do you do any Haskell programming for fun?
16:09:18 <Pseudonym> I replace parts of the code at random with undefined until the message goes away.
16:09:20 <creature> dark - well, I did the challenge exercise.
16:09:20 <Marvin--> HWS has way too many functions with do ... case foo of { Nothing -> return (..); Just x -> do .... case bar of ...  }}
16:09:29 <creature> And as that's not marked, nor required, it was for fun.
16:09:36 <Pseudonym> OK, it's not completely random, but that's still my general approach.
16:09:42 <dark> creature: Ah yeah :)
16:09:58 <Marvin--> gotta love it when the last line of a function is '}}}'
16:10:09 <Marvin--> looks like vim folding markers
16:10:18 <Pseudonym> Besides, in the example I'm thinking of, fixing the type error triggered a compiler panic.
16:10:24 <dark> Marvin: Hmm I never use {} on my cases.
16:10:33 <Pseudonym> The error message was much more comforting by comparison.
16:10:36 <dark> Heh.
16:10:56 <Marvin--> dark: well, unless you want the function to grow diagonally, you have to throw away the layout rule
16:10:57 <dark> Marvin: I learned some easier ways of dealing with Maybe types :)
16:12:03 <dark> Marvin: I write a firstJustM once, which runs elements from an [IO (Maybe a)] until one of them is Just.
16:12:15 <dark> Marvin: That de-diagonalized a fairly huge function :)
16:12:37 <Heffalump> Marvin--: have you read the various papers advocating continuation-based CGI programming?
16:12:46 <Marvin--> Heffalump: nope, sounds interesting
16:12:54 <dark> Marvin: Also I use exceptions a lot...
16:13:06 <Heffalump> e.g. Peter Thiemann at the Haskell Workshop (IIRC)
16:13:25 <Heffalump> or some stuff from Matthias Felleisen and others
16:14:24 <Chilli> Pseudonym: hmm, I do this only in really weird situations
16:14:24 <Marvin--> Heffalump: wash stuff?
16:16:34 <dark> Pseudonym: It should be possible to automate this undefining process :-)
16:16:45 <Heffalump> Marvin--: that's Peter Thiemann's stuff, yeah
16:17:05 <dash> felleisen does haskell stuff now?
16:17:09 <dash> thought he was a schemer
16:18:26 <Heffalump> Felleisen doesn't do it in Haskell
16:18:36 <Heffalump> (he spends his entire life being rude about Haskell, AFAICT...)
16:18:49 <dash> ah good
16:19:34 <hdaume> does anyone know what felleisen's gripe with haskell (and the FP community en large) is?
16:19:36 <Marvin--> wasn't ludde using wash in his afp project?
16:19:47 <hdaume> he made a lot of snide remarks at the summer school...
16:20:00 <dash> hdaume: more than "static typing is a waste of time"?
16:20:07 <hdaume> dash: yes
16:20:15 <dash> hm.
16:20:32 <hdaume> dash: something like "my university got scheme spread across the world in universities and the the FP community single handedly destroyed that"
16:20:33 <Heffalump> he seems to think that the statically typed functional languages destroyed the opportunity Lisp/Scheme had to take over the world.
16:20:41 <dash> hdaume: ah, ok, he's a schemer
16:20:50 <creature> Oh, someone here recommended "The craft of functional programming" book to me the other day.
16:20:57 <dash> Heffalump: Nah, Symbolics and LMI did that.
16:20:59 <creature> Turns out the author is a member of staff at my Uni.
16:21:03 <Heffalump> I was reluctant to ask him why because I didn't think I wanted to hear most of the answer.
16:21:07 <Marvin--> maybe some sort of  handleMaybe :: Maybe a -> b -> (a -> b) -> b  function could clean up HWS quite a bit
16:21:10 <Heffalump> creature: that's partly why we recommended it :-)
16:21:25 <creature> Heffalump - heh.
16:21:27 <Heffalump> well, it's certainly why I made a comment about that
16:21:32 <Marvin--> I like that book a lot
16:21:36 <dash> not to worry; there's still plenty of time for lisp to take over the world
16:21:45 <dash> just as soon as we bury common lisp and scheme
16:21:58 <Marvin--> I tried reading his notes on type theory, and realized he's a constructivist *rolls eyes upward*
16:22:40 <dash> what's a constructivist?
16:23:07 <creature> And do you need a permit to be one?
16:23:51 <dash> for that matter, what's type theory
16:24:05 <Marvin--> constructivists don't hold RAA to be valid
16:24:10 <dash> what's RAA?
16:24:10 <hdaume> RAA?  :)
16:24:11 <Marvin--> (proof by contradiction)
16:24:15 <hdaume> oooh yeah
16:24:32 <Marvin--> which I find stupid and silly, but maybe that's just because of my mathematical background
16:24:38 <Pseudonym> Chilli: The code I was writing was really weird.
16:24:40 <Heffalump> reduction ad absurdum
16:24:44 <hdaume> what do you expect, though.  i mean, type theory was basically borne of category theory...
16:24:52 <dash> oh
16:24:54 <Pseudonym> Chilli: It was an intermediate step of a formal derivation,
16:24:55 <Marvin--> I know! :/
16:25:04 <dash> ok, so not a programming issue
16:25:21 <Heffalump> can you give an example of a proof that requires RAA?
16:25:34 <Marvin--> no, but it's damned convenient to use
16:26:16 <Pseudonym> Marvin: I missed somwething.  What was handleMaybe for?
16:26:51 <Marvin--> Pseudonym: oh, handleMaybe Nothing f g = f; handleMaybe (Just z) f g = g z
16:27:00 <Pseudonym> Yes, but what would it clean up?
16:27:24 <hdaume> Heffalump: if you really want i can give an example of something which shows why RAA might be invalid
16:27:29 <Marvin--> Pseudonym: instead of nesting case expressions and using { to be able to write the code "vertically"
16:27:41 <Chilli> hdaume: Matthias Felleisen is actually a nice guy
16:27:45 <creature> Anyway, I'm off.
16:27:50 <creature> Thanks again for the help, guys.
16:27:59 <Marvin--> Chilli: as long as he's not talking about haskell?
16:28:07 <Pseudonym> Marvin: MonadNegate is your friend.  Or it would be if it was in the hierarchical libraries.
16:28:09 <Heffalump> hdaume: I might ask you about it some other time
16:28:10 <hdaume> Chilli: he seemed it; just also seemed a bit peeved :)
16:28:14 <Chilli> he only has this habit of formulating many of his remarks in a way that can put some people off
16:28:15 <Heffalump> I think bed calls
16:28:16 <Marvin--> Pseudonym: hmm, don't know that one
16:28:22 <Chilli> Heffalump: night
16:28:23 <Pseudonym> I know. :-)
16:28:25 <Pseudonym> Night.
16:28:44 <Pseudonym> Basically, MonadNegate supports the following operations:
16:28:57 <Marvin--> huh, google doesn't find anything on 'MonadNegate'
16:28:59 <Pseudonym> mtrue = return ()
16:29:05 <Pseudonym> mfalse = fail "err"
16:29:11 <Marvin--> which means that in my world it doesn't exist ;)
16:29:17 <Pseudonym> mnot (return a) = mfalse
16:29:21 <Pseudonym> mnot (mfalse) = mtrue
16:29:35 <Pseudonym> mifPred (return a) t e = t a
16:29:39 <Pseudonym> mifPred (mfalse) t e = e
16:29:50 <Pseudonym> Basically, the mifPred operation is your handleMaybe.
16:29:58 <Marvin--> yeah
16:30:09 <Pseudonym> Only it's a full monad.
16:30:15 <Pseudonym> Including a monad transformer version.
16:30:48 <Marvin--> the reason I wanted the arguments in that order is that I usually want to short-curcuit on a Nothing, so I can write code like this:
16:30:56 <Marvin--> foo x = do
16:30:56 <Marvin-->     handleMaybe x (return 42) $ \x -> do
16:30:56 <Marvin-->     return (x+1)
16:31:20 <Pseudonym> Right.
16:31:23 <Marvin--> the shadowing of x makes this a bit weird-looking, but you get the point
16:31:42 <Pseudonym> In fact you don't need the Maybe type at all.
16:31:51 <Pseudonym> For that matter, you don't need any data constructors.
16:32:00 <Marvin--> instead of:
16:32:03 <Marvin--> foo x = do
16:32:03 <Marvin-->     case x of {
16:32:03 <Marvin-->       Nothing -> return 42;
16:32:03 <Marvin-->       Just x -> do
16:32:03 <Marvin-->     return (x+1)
16:32:04 <Marvin-->     }
16:32:08 <Marvin--> which is how HWS does it
16:32:10 <Pseudonym> type Maybe a = forall b. (a -> b) -> b -> b
16:32:23 <Pseudonym> just x = \j n -> j x
16:32:26 <Pseudonym> nothing = \j n -> n
16:32:35 <Pseudonym> handleMaybe = id
16:32:48 <Marvin--> this is lambda calculus instead ;)
16:32:52 <Pseudonym> Yes. :-)
16:33:40 <Pseudonym> http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/hfl/hfl/mtl/
16:33:43 <Pseudonym> That's where to find it.
16:33:46 <Pseudonym> If you care.
16:34:08 <Pseudonym> I've gotten a lot of mileage out of the transformer version.
16:34:45 <Marvin--> cute
16:35:30 <Pseudonym> Maybe rather than "handleMaybe" you should call it "unless", which is very Perl.
16:35:50 <Marvin--> well, yeah, but Control.Monad already defines unless
16:35:56 <Pseudonym> True.
16:36:06 <Marvin--> handleMaybe was just a working name :)
16:37:28 <Marvin--> man, I really need to go to bed
16:37:30 <Marvin--> bleh
16:37:34 <Pseudonym> Yes, go to bed.
17:32:46 <dark> swap (a, b) = (b, a)
17:32:50 <dark> I wonder why that's not standard.
17:34:04 <Pseudonym> Probably because (\(a,b) -> (b,a)) is more general.
17:34:24 <Pseudonym> As in, the technique applies to longer tuples too.
17:34:28 <dark> More general in what way?
17:34:32 <dark> Oh, I see :)
17:35:00 <Pseudonym> While I won't second-guess the standards people, there are diminishing returns here.
17:35:18 <Pseudonym> Possibly fst and snd wouldn't have ended up in Haskell either, if Miranda had lambda expressions.
17:35:30 <Igloo> wrap x = [x] (or box) is one I keep on wishing for
17:35:43 <Pseudonym> Oh, that one's easy.
17:35:48 * Igloo is 90% sure it does
17:35:51 <dark> (:[]) ?
17:35:56 <Pseudonym> Exactly.
17:36:05 <dark> Looks like a smiley with a headache :)
17:36:08 <Igloo> But wrap is much nicer to read
17:36:10 <Pseudonym> Or return x in the context of the [] monad.
17:36:28 <dark> Igloo: First time I saw it, I had to hunt for the definition to figure out what it meant :)
17:36:42 <Igloo> Saw which?
17:36:48 <Pseudonym> I'm curious what you would use wrap for.
17:36:51 <dark> Igloo: "map wrap"
17:37:04 <dark> Pseudonym: It's used by mergesort in GHC's Data.List
17:37:04 <Igloo> But you could say the same about map, foldr, fst, ...
17:37:09 <Pseudonym> aH, RIGHT.
17:37:22 * Pseudonym will take (:[]) or (\x -> [x]) any time.
17:37:33 <Igloo> I think I use it quite often
17:37:40 * Pseudonym TURNS OFF THE CAPS LOck key
17:37:45 <dark> Igloo: Might be idiosyncratic :)  I've never had a need for it.
17:38:09 <Igloo> GHC's Data.List might be a bad example because I might be responsible for it  :-)
17:38:11 <dark> My favourite candidate for standardization is sortWith:
17:38:12 <dark> sortWith f = sortBy (\x y -> compare (f x) (f y))
17:38:26 <Pseudonym> "wrap" sounds like namespace pollution to me
17:38:36 <Pseudonym> I can think of a lot of functions which I might like to call "wrap".
17:38:37 <dark> I need something like that fairly often, and inlining it means repeating the f.
17:39:09 <Pseudonym> sortWith looks good to me
17:39:18 <Pseudonym> Even better if you can get it to work on partial orderings.
17:40:28 <Igloo> Ah, yes, my lexer uses    wrap <$> lexer_for_a_acharacter    to produce a lexer for a string all over the place
17:40:30 <dark> Pseudonym: What kind of partial orderings?
17:41:12 <dark> Pseudonym: I tried using them before, and was told that sorting with them required comparing every element to every other element :)  It seemed to make sense, too.
17:50:51 <dark> Heh.  I was annoyed and upset when a pattern-match failed even though I had proved it can't happen.  Then I realized that I had written down the proof in half a page of comments, but had forgotten to implement its preconditions :)
17:51:33 <Igloo> If you use ghc -Wall it will warn you about unmatched patterns
17:51:54 <dark> Igloo: This was in a let expression
17:51:59 <Igloo> The universe is conspiring against me. I think I'll go to bed.
17:52:02 <Igloo> Ha
17:52:06 <Igloo> IM Ah
17:52:31 <dark> It was a (Just x) pattern, from a lookupFM which wasn't supposed to fail.
17:53:07 <dark> I guess sound software engineering practice would tell me to check it anyway :)
18:52:33 <Pseudonym> dark: It doesn't quire require comparing every element to every other element.
18:52:40 <Pseudonym> If a < b and b < c then a < c
18:53:45 <Pseudonym> Oh, he's gone.
20:09:34 <engstad> Pseudo: I get it now! :-)
20:11:03 <engstad> callcc h = \c -> let k a = \d -> c a in h k c
20:11:08 <Pseudonym> Yay!
20:11:18 <Pseudonym> Useful, innit?
20:11:43 <Pseudonym> I submitted #haskell to the communities report.
20:11:48 <Pseudonym> Just in case nobody else did.
20:12:06 <Pseudonym> Expect an influx of the three academics somewhere in Sweden who actually read the report soon.
20:13:20 <engstad> I.e.: h is a function taking two arguments, one is the "fast out" continuation and the second is the regular continuation. However, they're both essentially the same, except that the second one doesnt care about any change in how it carries on results thro
20:13:26 <engstad> through the chain of calls. 
20:13:30 <Pseudonym> Right.
20:13:38 <Pseudonym> It's damn handy.
20:13:47 <Pseudonym> Because you can do deep returns from several functions deep.
20:13:53 <engstad> Yes.
20:13:58 <Pseudonym> Poor man's exceptions.
20:14:29 <engstad> I think it took me longer to understand because I didn't realize that the type K a "adds an argument".
20:14:35 <Pseudonym> Ah.
20:14:57 <engstad> So, from the type ((a -> K b) -> K a) -> K a
20:15:13 <engstad> it is not obvious that callcc takes three arguments...
20:15:40 <engstad> of course K a = (a -> Answer) -> Answer.
20:15:46 <Pseudonym> Yes.
20:16:21 <Pseudonym> Incidentally, as I mentioned earlier, you can do Haskell without constructors thanks to quantified types.
20:16:36 <Pseudonym> The continuation type K is actually the CPS version of data K a = K a
20:16:39 <engstad> Withough constructors?
20:16:43 <Pseudonym> Right.
20:17:03 <Pseudonym> Consider this:
20:17:06 <engstad> You can do CPS without constructors, you mean?
20:17:16 <Pseudonym> I mean you can do all of Haskell without constructors.
20:17:26 <engstad> As a reduction?
20:17:30 <Pseudonym> Right.
20:17:35 <engstad> Oh, ok, I see.
20:17:52 <Pseudonym> data K a = K a transforms to type K a = forall b. (a -> b) -> b
20:18:06 <engstad> *nod*
20:18:16 <Pseudonym> data (a,b) = (a,b) transforms to type (a,b) = forall c. (a -> b -> c) -> c
20:18:18 <Pseudonym> and so on.
20:18:20 <engstad> Ah, yes, of course, i see it now.
20:19:07 <Pseudonym> You didn't catch it earlier, but I plugged one of my own monads earlier.
20:19:27 <Pseudonym> The Maybe type is like: type Maybe a = forall b. (a -> b) -> b -> b
20:19:45 <Pseudonym> The one I mentioned was like a Maybe monad transformer.
20:19:59 <engstad> Are you writing a paper on it?
20:20:05 <Pseudonym> No.
20:20:12 <engstad> You should! :-)
20:20:26 <Pseudonym> However, I am investigating writing a paper on a general way to derive monad transformers that's a little easier than John Hughes' method.
20:20:48 <Pseudonym> I think it's pretty close to automatic, too.
20:21:02 <Pseudonym> You write the axioms, you get the monad transformer implementation out the other end.
20:21:22 <engstad> Sounds very interesting. :-)
20:22:35 <engstad> Hmm, I have to rush home... but I'll log in when I get there.
20:22:43 <engstad> Take care.
20:22:43 <Pseudonym> No prob.
21:07:16 <Pseudonym> AARGH
21:07:30 <Pseudonym> This bloody compiler panic is driving me nuts.
21:07:49 <Pseudonym> I think it's the combination of newtype + records + quantified types.
21:29:58 <Chilli> Pseudonym: what panic?
21:30:34 <Pseudonym> I submitted it to glasgow-haskell-bugs.
21:31:00 <Pseudonym> If you have something like this:
21:31:39 <Pseudonym> newtype Foo a = Foo { mkFoo :: forall b. (forall c. something with b and c) something with a and b }
21:31:49 <Pseudonym> newtype Foo a = Foo { mkFoo :: forall b. (forall c. something with b and c) -> something with a and b }
21:32:09 <Pseudonym> Hang on.
21:32:16 <Pseudonym> OK, concrete example.
21:33:56 <Pseudonym> newtype Foo a = Foo { mkFoo :: forall b. (a -> Foo a -> b) -> b -> b }
21:34:09 <Pseudonym> Basically, pulling that apart causes a panic.
21:35:16 <Pseudonym> For example:
21:35:23 <Pseudonym> foo :: Foo a -> a
21:35:33 <Pseudonym> foo m = mkFoo m (\a _ -> a) undefined
21:36:22 <Pseudonym> I found a workaround.
21:36:31 <Pseudonym> If you use data instead of newtype it works.
22:22:41 <engstad> Greets.
22:27:17 <Pseudonym> G'day.
22:29:47 <Pseudonym> Night everyone.  Gotta go home.  I'm cooking tonight. :-)
