00:25:00 <ludde> is there any way to make an instance declaration which will allow me to function-apply an argument to a string? (as if the string was a function)
00:27:14 <Pseudonym> You mean you want to execute a string?
00:28:29 <ludde> no..
00:28:41 <ludde> I want to be able to write ("my string" argument)
00:28:50 <Pseudonym> Which should do what?
00:29:07 <Pseudonym> Oh, like operator() in C?
00:29:12 <ludde> yeah
00:29:15 <ludde> i guess
00:29:16 <Pseudonym> No.
00:29:24 <Pseudonym> Best you can do is use an operator.
00:29:29 <ludde> okay
00:29:40 <Pseudonym> "my string" %% argument
00:29:42 <Pseudonym> Or something.
00:30:00 <ludde> yes
00:30:05 <ludde> hmm
00:30:11 <ludde> if I make a data constructor
00:30:20 <ludde> data MyData = A String | B String
00:30:23 <ludde> would it be possible to do then?
00:30:36 <ludde> A "hej" argument
00:30:41 <ludde> err
00:30:45 <Pseudonym> (A String) foo
00:30:46 <ludde> hmm
00:30:48 <Pseudonym> Nope.
00:30:51 <ludde> ok
00:31:01 <Pseudonym> Can I ask why you want to do this?
00:31:31 <ludde> It looks neater with ("name" arguments) than ("name" %= arguments)
00:31:44 <ludde> i'm making a cgi script library
00:31:49 <Pseudonym> OK
00:32:07 <ludde> so for button events, ("name" arguments) specifies that the routine "name" should be invoked with the arguments arguments whenever the button is clicked
00:33:11 <Pseudonym> Personally I find (event "name" arguments) no less neat, but no arguing over taste, I guess.
00:33:23 <ludde> how do you mean?
00:33:30 <Pseudonym> Use a real function.
00:33:38 <ludde> you mean i should have (event "name" arguments) instead of ("name" %= arguments)
00:33:52 <Pseudonym> I'm not going to tell you what you "should" have. :-)
00:33:54 <ludde> yeah
00:33:57 <Pseudonym> I find it no less neat.
00:33:57 <ludde> but is that what you mean
00:34:01 <Pseudonym> Yes.
00:34:03 <ludde> "no less neat"
00:34:08 <ludde> ?
00:34:16 <Pseudonym> It looks fine to me.
00:34:18 <ludde> okay
00:34:29 <Pseudonym> But I'm not using your library.  (Yet, anyway.)
00:34:35 <ludde> heh
00:35:11 <ludde> how do I specify that %= should be bound almost as tightly as function application?
00:35:16 <ludde> precendence
00:35:32 <ludde> or hmm
00:35:37 <ludde> yeah i guess it should
00:35:42 <Pseudonym> Well, you first lookup the Haskell report to see how tight function application actually is.
00:35:46 <Heffalump> infixl 9 %=
00:35:50 <Heffalump> IIRC
00:35:53 <Pseudonym> Yes.
00:35:55 <ludde> thanks
00:35:58 <Heffalump> or infix or infixr
00:36:07 <Pseudonym> Probably infix
00:36:10 <ludde> infix is probably better, since it shouldn't be associative
00:36:23 * Pseudonym nods
00:37:49 <Pseudonym> lambdabot: @listchans
00:37:51 <lambdabot> I am on these channels: ["#haskell"]
00:39:12 <Pseudonym> lambdabot: @listmodules
00:39:14 <lambdabot> I have the following modules installed: ["hello_module"]
00:40:35 <Heffalump> is lambdabot a modular IRC client?
00:40:40 <Heffalump> s/client/bot/
00:40:55 <Pseudonym> Sort of.
00:41:00 <Pseudonym> It's not very modular.
00:41:06 <Pseudonym> lambdabot: Can you do anything?
00:41:07 <lambdabot> Sorry, I'm not a very smart bot yet.
00:41:11 <Heffalump> :-)
00:41:27 <Pseudonym> Naturally it's in Haskell.
00:42:11 <Heffalump> did you write a Haskell RFC 1459 library then?
00:42:19 <Pseudonym> Of sort.
00:42:22 <Pseudonym> Of sorts.
00:43:19 <Heffalump> IWW "of sorts"?
00:43:30 <Pseudonym> It's not hugely complete.
00:43:35 <Pseudonym> Well, the RFC 1459 bit is.
00:43:51 <Pseudonym> No CTCP/DCC/anything fancy.
00:44:11 <lambdabot> I am too fancy.
00:44:16 <Pseudonym> lambdabot: Shut up.
00:44:18 <lambdabot> Sorry, I'm not a very smart bot yet.
00:44:22 <Heffalump> lol
00:44:55 * Heffalump suspects quite a few people might want such a library
00:45:04 <Pseudonym> Very possibly.
00:45:17 <Pseudonym> I'll let people have it when it's a bit more complete.
00:45:48 <ludde>     htmlcode = case (lookup "cont" pp) of
00:45:48 <ludde>       Nothing -> errmsg
00:45:48 <ludde>       Just cont -> handlecont cont
00:45:48 <ludde>     handlecont cont = case maybeRead (base64Decode cont) of
00:45:48 <ludde>       Nothing -> errmsg
00:45:49 <ludde>       Just xx -> handlebec xx     
00:45:51 <ludde>     handlebec bec = case lookupbec bec pp of     
00:45:53 <ludde>       Nothing -> errmsg
00:45:55 <ludde>       Just cl -> handleclosure cl
00:46:02 <ludde> is there any way to reduce the number of case statements in patterns like this?
00:46:27 <Heffalump> use the monad
00:46:41 <Heffalump> do handlecont and handlebec need to be intermediate functions?
00:46:48 <ludde> no
00:46:57 <ludde> they're just there since i want to reduce the indention depth
00:46:58 <Heffalump> htmlcode = do cont <- lookup "cont" pp
00:47:12 <Heffalump>               xx <- maybeRead (base64Decode cont)
00:47:15 <ludde> will hat work even though htmlcode is of type HtmlCode () monad ?
00:47:34 <Heffalump>                cl <- lookupbec bec pp
00:47:52 <Heffalump> s/bec/xx/
00:48:01 <Heffalump> yes
00:48:07 <ludde> is that all of it?
00:48:11 <Heffalump> the do notation I quoted is exactly identical
00:48:17 <ludde> what happened to "errmsg" ?
00:48:20 <Heffalump> oops.
00:48:24 * Heffalump thinks
00:48:31 <Heffalump> oh yes
00:48:37 <Heffalump> around the outside, you need a case
00:48:41 <ludde> okay
00:48:46 <Heffalump> if the result of the do is a Nothing, then call errmsg
00:48:52 <Heffalump> otherwise call handleclosure
00:48:53 <ludde> so htmlcode is of type Maybe HtmlCode right now?
00:49:01 <Pseudonym> Another option, plugging my own code here, is Control.Monad.Negate.
00:49:17 <Pseudonym> It's like a Maybe transformer.
00:49:33 <Heffalump> is it the monad transformer that introduces Maybe?
00:49:46 <Pseudonym> It's not implemented with Maybe.
00:49:49 * Heffalump doesn't necessarily see any need for a monad transformer here, but that somewhat depends on the entire context
00:50:04 <Heffalump> well, a Maybe-style success/failure
00:50:20 <Pseudonym> Not in this example, no.
00:50:26 <Heffalump> ok
00:50:40 * Heffalump --> read Haddock docs
00:51:17 <Pseudonym> It's Negate because you can do mnot (fail "error") == return ()
00:51:29 <Pseudonym> And mnot (return ()) = fail "error"
00:51:35 <Pseudonym> For some value of "error".
00:52:05 <Heffalump> DYM == in the second line?
00:52:10 <Pseudonym> Yes.
00:52:17 <Heffalump> and where can I find docs for it
00:52:18 <Heffalump> ?
00:52:25 <Heffalump> (if anywhere)
00:52:25 <Pseudonym> Er...
00:52:38 * Heffalump was assuming it was actually in the hierarchical libraries, but it doesn't seem to be
00:52:51 <Pseudonym> No.  I'll be submitting it RSN.
00:53:07 <Heffalump> does it actually satisfy the monad laws, btw?
00:53:11 <Pseudonym> Yes.
00:53:39 <Heffalump> apart from strictness presumably, no monads satisfy the laws in the presence of seq, IIRC :-)
00:53:40 <Pseudonym> http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/hfl/hfl/mtl/
00:53:54 <Pseudonym> Well quite. :-)
00:53:56 <Pseudonym> Actually...
00:53:59 <ChilliX> Heffalump: finished sleeping?
00:54:00 <Pseudonym> No, I can think of one.
00:54:07 <Pseudonym> data MonadUnit a = ()
00:54:13 <Pseudonym> return a = ()
00:54:21 <Pseudonym> m >>= k = ()
00:54:23 <Pseudonym> And so on.
00:54:35 <Pseudonym> Er... that's not quite right, but you get what I mean.
00:55:30 <Heffalump> chillix: yeah :(
00:55:40 <Heffalump> heh :-)
00:55:58 * Heffalump decides he's not awake enough to understand the code for Negate and goes to shower
00:56:04 <Pseudonym> :-)
00:56:27 <Pseudonym> It's not as bad as Logic.
00:56:33 <Pseudonym> Logic programming with soft cut.
00:56:46 * Pseudonym isn't sure why he bothered
00:59:59 <Pseudonym> ANyway.
01:00:05 <Pseudonym> Night everyone.  Have a good weekend./
01:00:13 <Pseudonym> Must go home.
01:13:29 <ludde> i have data InputField = InputField ControlID
01:13:36 <ludde> how do I make show/read instances for it?
01:15:27 <Heffalump> what's ControlID?
01:15:32 <ludde> that's just an Int
01:15:49 <Heffalump> you can probably just do deriving Read, Show then
01:15:50 <ludde> I want to make my own show instance
01:15:54 <Heffalump> ah, ok
01:16:13 <Heffalump> just write whatever functions the Show class wants then
01:16:17 <ludde> hmm
01:16:43 <ludde> instance Show InputField where
01:16:43 <ludde>   show (InputField n) = "@@" ++ show n
01:18:07 <ludde> shouldn't this work:
01:18:07 <ludde> instance Read InputField where
01:18:07 <ludde>   read s = undefined
01:18:26 <ludde> I get Variable not in scope: `read'
01:18:54 <Marvin--> you have to define readsPrec
01:19:09 <ludde> hmm
01:19:14 <andersca> hey Marvin--
01:19:30 <Marvin--> morning
01:20:26 <Heffalump> if you're using the latest GHC only, I think there's a new Read class based on parser combinators you should look at
01:21:29 <ludde> Heffalump: ok
01:22:48 <Marvin--> Koen's ReadP?
01:22:58 <Heffalump> yeah
01:23:08 <Heffalump> (is that actually in a release yet?)
01:23:21 <Marvin--> the documentation is in 5.04 anyway :P
01:23:27 <Heffalump> right :-)
01:23:36 * Heffalump disappears workwards
01:26:55 * Marvin-- mutters about nobody answering his question on ghc-users
01:44:35 <ludde> is three some way to speed up the compilation with ghc?
01:54:50 <ludde>   h <- openFile fname ReadMode
01:54:50 <ludde>   s <- hGetContents h
01:54:50 <ludde>   hClose h
01:54:56 <ludde> why doesn't this read anything?
01:56:02 <Marvin--> because hGetContents uses unsafeInterleaveIO
01:56:09 <ludde> hmm
01:56:24 <ludde> so hClose will close the handle which hGetContents wants to use :(
01:56:28 <Heffalump> I thought hClose did the right thing, and only half-closed the descriptor?
01:56:28 <ludde> sigh
01:56:45 <Marvin--> Heffalump: hmm, point
01:56:48 <ludde> how would I read the contents of a file then?
01:56:55 <ludde> hGetContents hdl returns the list of characters corresponding to the unread portion of the channel or file managed by hdl, which is made semi-closed. 
01:56:55 * Heffalump not sure
01:57:00 <Heffalump> ohh.
01:57:03 <Heffalump> in which case don't do the hClose
01:57:08 <ludde> oh
01:57:16 <Marvin--> yeah, the handle is already made semi-closed
01:57:25 <Marvin--> which means it'll be closed automatically when GC'ed
01:57:31 <Marvin--> or rather, when finished reading
01:57:51 * Heffalump disappears somewhere in a hurry
01:58:31 <ludde> Marvin--: but how do I do if I both need to write AND read from the same file
01:58:40 <ludde> Marvin--: in that case i will get an error which says that the file is locked
01:58:54 <ludde> because read hasn't read the whole file, before I start writing to it
01:59:05 <ludde> hGetContents hasn't read the whole file
01:59:35 <Marvin--> You have to force the evaluation somehow
01:59:41 <Marvin--> Maybe seq does what you want
02:00:37 <Marvin--> ARGH
02:00:39 <Marvin--> GRRRRRRRRR
02:00:48 <Marvin--> So THAT was why it didn't work
02:00:52 <Marvin--> fuck fuck fuck
02:01:16 <Marvin--> ghc happily optimized away code that worked and replaced it with code that didn't
02:01:33 <ludde> how did you notice that?
02:01:38 <Marvin--> I didn't
02:01:43 <Marvin--> someone replied on ghc-users
02:01:47 <ludde> oh, haha
02:01:52 <ludde> can i get a url?
02:01:57 <ludde> stupid ghc :(
02:02:08 <Marvin--> I wasn't talking about reading and writing
02:02:13 <Marvin--> I was talking of Data.Dynamic
02:02:18 <ludde> i know
02:02:18 <ludde> but i want to read what they said
02:02:28 <ludde> compiler bugs are interesting
02:02:36 <Marvin--> The archive is linked to from www.haskell.org/ghc
02:08:28 <Marvin--> Hmm, eta reduction doesn't apply in do notation?
02:18:00 <ludde> is there some way to make an if statement inside a monad, without having to have an else clause?
02:19:46 <Marvin--> Use the when function
02:20:03 <Marvin--> when e m = if e then m else return ()
02:23:48 <Marvin--> argh, heisenbugs
02:46:31 <ludde> ok
02:48:35 <ludde> http://grosse.mdstud.chalmers.se:20123/kossa
02:56:38 <Marvin--> coo' :)
02:59:12 <ludde> Marvin--: what does your AFP project do? Dynamic loading of haskell code?
03:01:13 <Marvin--> yeah, I'm extending Simon Marlow's web server to add an apache-like layer of plugins
03:01:35 <ludde> okay
03:01:52 <ludde> where can i read about dynamic loading of haskell code w/ GHC?
03:03:09 <Marvin--> ask o3 ;)
03:03:16 <Marvin--> http://www.algorithm.com.au/wiki/hacking/haskell.ghc_runtime_loading
03:03:45 <andersca> wow
03:03:46 <andersca> that's cool
03:32:25 <Marvin-->   sendHeaders resp'
03:32:26 <Marvin-->   when send_body $ bracket
03:32:26 <Marvin-->       (openFile path ReadMode)
03:32:26 <Marvin-->       hClose
03:32:26 <Marvin-->       (\fileH -> squirt fileH h >> hFlush h)
03:32:31 <Marvin--> how's that for HaskPerl?
03:39:34 <Marvin--> Response.hs:372: Variable not in scope: `--+++'
03:39:34 <Marvin--> dammit ;)
03:43:40 <BlizzNL> I am reading this paper about monads and substitution, but it keeps ranting about 'unification algorihms'. Can someone tell what that is?
03:44:24 <Marvin--> in the context of types?
03:44:50 <BlizzNL> Marvin--: yes
03:45:39 <Marvin--> since Haskell has type inference it builds up a huge type equation system and then uses a unification algorithm to solve it
03:46:29 <BlizzNL> Marvin--: thnx
03:46:36 <Marvin--> e.g. from the expression  (a == b)  we can draw the conclusions that a and b are of the same type, and that type is in class Eq
03:47:06 <Marvin--> or rather, those constraints are added to the equation system
03:47:14 <andersca> scary stuff :)
03:47:28 <andersca> doesn't it first check (a ==) and then apply it to b?
03:47:50 <BlizzNL> Marvin--: Any advised reads on the subject?
03:55:11 <Marvin--> andersca: I don't know the details
03:55:23 <Marvin--> BlizzNL: Typing Haskell in Haskell (by Mark P Jones iirc)
03:55:28 <ibid> any book that discusses automated reasoning discusses unification (in the context of ar, but it's similar)
03:55:47 <Marvin--> yep, Mark P Jones
04:01:08 <ludde> how do I compare two strings case-insensetively?
04:01:25 <Marvin--> map Char.toLower or something?
04:01:36 <ludde> there's no direct way?
04:01:46 <Marvin--> not that I know of
05:13:55 <Marvin--> YAY, the core works!
05:15:01 <andersca> woo
05:15:05 <andersca> cool stuff
05:15:15 <Marvin--> http://193.11.232.159:2080/index.html <- self-hosted
05:15:35 <Marvin--> now I just need to write some plugins too ;)
05:15:42 <Marvin--> and *cough* clean up the code
05:17:14 <Marvin--> I need a dirindex plugin and a userdir plugin at the very least
05:17:48 <andersca> and mod_python
05:18:05 <Marvin--> no? :)
05:18:23 <Marvin--> a mod_haskell would be cool though
05:18:52 <andersca> yes
05:18:52 <Marvin--> http://193.11.232.159:2080/hws.diff <- the runHooks/hook functions are pure voodoo
05:52:53 <Heffalump> Marvin--: you're aware people have done mod_haskell stuff already (using hugs)?
05:53:52 <Heffalump> they were planning on working on GHC but got stopped by the dynamic loading problem (the last I heard)
05:55:06 * Heffalump reads the GHC problem and goes ick
05:56:12 <ibid> hmph
05:56:54 <ibid> what's "desugar" in GHC and why is it taking so long?
05:57:46 <ibid> (i have a function Int# -> Int# defined using a huge number of pattern-matching cases)
06:00:15 <Heffalump> turns Haskell into Core syntax
06:00:31 <Heffalump> I dunno why it would take a huge amount of time on such a function, though
06:02:49 <ibid> it appears using case instead does not help
06:03:45 <ibid> this is a generated file, maybe i can directly generate core syntax?
06:06:29 <Heffalump> yes, you can now
06:06:33 <Heffalump> I can't remember precisely how
06:07:23 <BlizzNL> I studied some papers by wadler and jones the last few days and monads are clearer to me now, but the thing that is still very vague to me is combining different monads like WriteMonad and StateMonad etc. to satisfy the contraints of some function. Anyone who can point me to some paper on this subject?
06:07:54 <ibid> Heffalump: any pointers where to look for it, or keywords?
06:08:13 <Heffalump> external core syntax
06:08:17 <Heffalump> or something like that
06:08:33 <Heffalump> blizznl: wdym by constraints of some function?
06:08:40 <Heffalump> did you look at monad transformers?
06:08:50 <Heffalump> (the Jones et al paper on Modular Interpreters etc)
06:11:45 <Igloo> Is it -ddump-simpl?
06:12:40 <BlizzNL> Heffalump: Well I don't know if describes it well enough, but let me explain the context. I read a very intersting paper by Mark Jones on constructor classes and it treats monads and in the final part it shows a very nice type inference system. I want to make this example working by 1) 'porting' it to Haskell 98 (it;s a quite old paper) and 2)Make it work by "create a monad to satisfy the constraints" of the main function in his inference system. H
06:12:54 <Heffalump> blizznl: title of the paper?
06:13:44 <BlizzNL> Heffalump: "Functional Programming with Overloading and Higher-Order Polymorphism" by Mark P Jones
06:15:24 <Marvin--> Heffalump: yes I know
06:16:16 <Heffalump> blizznl: right. have a look at the Modular Interpreters and Monad Transformers paper
06:16:34 <BlizzNL> Heffalump: I will thnx
06:17:49 <Heffalump> blizznl: oh, he's already talking about monad transformers in that paper too, actually
06:17:55 <Heffalump> I think you can just implement what he describes.
06:18:43 <BlizzNL> Heffalump: Yes I noticed that, but I was looking for a 'second opinion' because he is pushing it through in only a few pages.
06:22:45 <Heffalump> try that other paper, then
06:23:04 <BlizzNL> Heffalump: I am ;)
06:33:59 <ibid> generating core and reading that in did the trick...
06:34:35 <Heffalump> cool.
06:35:55 <ibid> now the compilation time is about 18 seconds
06:36:09 <ibid> when it previously wouldn't finish within 20 minutes...
06:39:26 <ibid> -O takes time though
06:50:48 <dark> Sometimes I wish do-notation had an ifM syntax that takes a monadic condition.
06:51:21 <dark> I could write such a function but then I can't have "then" and "else" syntax to go with it :)
06:51:50 <Igloo> Yes you can
06:52:29 <dark> I hope you'll not propose perversity like elseM = $
06:52:30 <Igloo> ifM :: Monad m => m Bool -> () -> m a -> () -> m b; thenM = (); elseM = ()
06:52:40 <dark> Ooh :)
06:53:38 <dark> Hmm, this does mean parentheses around the condition and the then branch, right?
06:53:41 <Igloo> Or you could make them real types to forc them to be there, be the right way round etc
06:54:03 <Igloo> Yeah, but I don't think you can fix that  :-(
06:54:12 <dark> elseM = $ might do it :)
06:54:20 <dark> Don't know what to do with thenM though.
06:54:41 <Igloo> If you mean that as a definition you'd need `elseM`
06:54:49 <dark> Oh, right.  elseM = ($)
06:54:55 <dark> Oh, I see what you mean.  Usage.
06:55:07 <Igloo> thenM could be the same
06:55:57 <dark> Somehow it doesn't seem like a win :)
06:56:33 <dark> Especially if it stops working if the then branch contains a $ itself.
06:56:45 <Igloo> Is this where I get glared at for suggesting sed?  :-)
06:56:59 <Igloo> Yeah
06:59:02 <dark> I'm not about to do any preprocessing on my pretty Haskell code :)
06:59:23 <dark> Just out of curiosity, does anyone use editor macros for switching then and else branches?
06:59:45 <Igloo> I don't do it very often
07:00:21 <dark> Then it's just me, I guess.  I often glare at if-then-else, switching the branches around to see which way looks better.
07:00:44 <dark> Maybe I need to get myself a refactoring browser for Haskell :)
07:00:54 <Igloo> :-)
07:01:27 <Igloo> In general I think I am using isFoo rather than == so I have the guard not having a "not" which defines the order
07:01:28 <dark> Hmm, it might be more difficult to write such a beast for Haskell than for Java.  Haskell has so much flexibility in layout.
07:01:40 <Igloo> Or just use guarded definitions a lot of the time
07:02:53 <dark> Igloo: I've been known to change the sense of my guard functions in order to have the then and else branches the right way around :-)
07:03:08 <Igloo> lol
07:03:20 <dark> changing "valid_char" to "invalid_char" for example.
07:03:30 <dark> Of course these are usually local functions :)
07:04:43 <Heffalump> hmm, if you have an endif construct, it should be possible to do if then else in a type-safe way such that the then and else can be swapped
07:05:15 <dark> Are you talking about an if-else-then sequence?  That's not quite what I mean :)
07:05:21 <Heffalump> if' :: Condition -> IfBody a -> a
07:05:27 <Heffalump> ah, ok :-)
07:05:32 <Heffalump> it'd be cool though
07:05:38 <Heffalump> endif' :: IfBody a
07:05:47 <Heffalump> endif' = (Nothing, Nothing)
07:06:06 <Heffalump> then' :: a -> IfBody a -> IfBody a
07:06:17 <Heffalump> then' foo (Nothing,elseP) = (Just foo,else P)
07:06:18 <Heffalump> etc
07:11:16 <dark> Heffalump: Took me a while but I see how it works now :)
07:12:27 <Heffalump> depending on whether you were inside the appropriate monad or not if could either insist on having then and else parts or just fail
07:14:44 <dark> Hmm, you could cheat with the SPECIALIZE pragma to make the else part optional iff the return type is (Monad m) => m ()
07:15:14 <Heffalump> I was more thinking of having two different ifs :-)
07:15:20 <dark> Bah! :)
07:15:32 <Heffalump> oh, and I think some tricks with type classes could make it possible to check for then and else parts statically
07:15:41 <Heffalump> (using a rather more complicated type signature than above)
07:17:48 <dark> Is it normal to develop an urge to write one's own standard library?
07:18:04 <Heffalump> it seems to be
07:29:07 <Marvin--> yay, time to mark assignments again :/
07:53:26 <dark> Hmm, if I have a pattern in a list comprehension, such as: Just re <- lookup cl rules, is it an error if the pattern fails, or is the element just skipped?
07:53:48 <Marvin--> skipped
07:54:36 <dark> Ok, great :)
07:55:00 <dark> Hmm, this might make me use more list comprehensions, if it makes Maybe types easier to deal with :)
07:55:12 <Marvin--> hehe
07:55:19 <Marvin--> the extended guards are way cool too
07:55:20 <|Fo|Ns> hi
07:56:38 <|Fo|Ns> does anybody know if is there a translator of Haskell with a XML backend?
07:57:09 <|Fo|Ns> I thought I show it on the internet months ago, but Im unable to find it
07:58:00 <|Fo|Ns> saw
08:00:53 <shapr> goood morning!
08:01:09 <shapr> hey, I was thinking about unit testing GHC
08:01:18 <Marvin--> shapr: the Core "plugin" works :D
08:01:28 <shapr> I think it would be more sensible to use QuickCheck and dc for math
08:01:35 <shapr> marvin: yay! that's great!
08:01:40 <Marvin--> shapr: http://193.11.232.159:2080/index.html <- self-hosted ;)
08:01:47 <shapr> awesome!
08:02:06 <shapr> shouldn't it say HWS-0.2 at the bottom? ;-)
08:02:07 <Marvin--> gonna mark some assignments, have dinner, and then fiddle with a dirindex, a userdir and a cgi plugin
08:02:12 <Marvin--> it probably should
08:02:20 <Marvin--> or HWS-WP 0.0.0.1
08:02:28 <dark> Hmm, maybe Text.Regex needs a "fastmatch" option for when you just need to know if it matches or not.  I think the way it uses IO now makes it do all the work of matching substrings even if you don't need them.
08:02:48 <Marvin--> it uses IO?
08:02:49 <Igloo> Oh, I thought Koen was at Glasgow
08:03:16 <Marvin--> Igloo: Koen is in Göteborg ;)
08:03:32 <Igloo> Well, I know that *now*  :-)
08:03:43 <Marvin--> haha
08:04:02 <Igloo> Shouldn't he have a \" somewhere?
08:04:09 <Heffalump> if anywhere you should have thought he was at York
08:04:23 <Igloo> Oh, yes, that's what I meant  :-)
08:04:28 <Heffalump> lol
08:04:34 * Igloo always confuses Glasgow, York and Nottingham up
08:04:37 <Marvin--> \" what/where?
08:04:39 <Heffalump> as you do
08:05:02 <shapr> I think he means umlaut
08:05:02 <Heffalump> his web page doesn't have any accents in his name
08:05:04 <Marvin--> oh
08:05:04 <Igloo> Either K\"oen or Ko\"en for the TeX meaning of \"
08:05:12 <Marvin--> no, Koen's Dutch
08:05:14 * Igloo could be wrong
08:05:15 <shapr> right
08:05:19 <shapr> he's from the lowlands
08:05:42 <Marvin--> but he's probably been in Sweden quite some time, his Swedish is better than his English :)
08:06:00 <Heffalump> since '97
08:06:02 <shapr> one technical name of Dutch is "Low German" referring to the fact that so much of the land should actually be underwater.
08:06:43 * shapr considers writing a syntax highlighting plugin for HWS-WP
08:07:21 <shapr> is Koen permanently employed at chalmers? or is he doing post-doc or something?
08:07:43 <Marvin--> dunno
08:07:58 <dark> Marvin: (Regex) Yeah, it uses IO because it uses the libc regex functions.
08:08:20 <dark> The Text.Regex module then uses unsafePerformIO to hide that.
08:08:45 <dark> Hmm, does unsafePerformIO make the IO computatin lazy?
08:09:01 <Marvin--> oh
08:09:08 <Marvin--> dark: no, that's what unsafeInterleaveIO does afaik
08:10:40 <Marvin--> shapr: I hope he stays though, I'm going to ask him to be my supervisor for my MSc
08:11:28 <shapr> cool :-)
08:11:53 <shapr> if I get really lucky, maybe I'll get to take classes at chalmers.
08:12:03 <shapr> I wonder if they offer distant learning classes.
08:12:12 <shapr> or maybe that's just #haskell ;)
08:13:40 <Marvin--> I wonder how they other projects are doing
08:13:40 <shapr> oh, I was thinking about using QuickCheck to test GHC
08:13:59 <Marvin--> Someone was going to implement a programmable gnutella client
08:14:01 <shapr> I wonder if I could write an Arbitrary instance for Haskell code
08:14:14 <Heffalump> what would you compare it against?
08:14:45 <Marvin--> shapr: I suppose you could instantiate the datatype for the core language
08:15:21 <shapr> Heffalump: I was thinking of trying to crash GHC
08:15:42 <Heffalump> so your test would be compile code `seq` True ?
08:15:52 <shapr> at least the first layer
08:16:07 <shapr> math tests could be done with outside references, such as dc
08:16:32 <shapr> assert that this code returns equal results in GHC and this external calculator program
08:16:42 <Heffalump> only if you limited the generated code to doing arithmetic
08:16:56 <shapr> yah, I'm trying to figure out a good way to test Haskell itself
08:16:56 <Heffalump> and you'd have to implement the Haskell report specification of arithmetic in dc
08:17:07 <Heffalump> checking against hugs might be cool, though
08:17:13 <shapr> that's a good idea
08:17:41 <shapr> I think the best idea would be to make a literate version of the Haskell Report, and include QuickCheck tests for every bit of documentation
08:17:51 <shapr> then you could run the Report itself against Hugs or GHC
08:17:54 <dark> And nhc?
08:17:58 <shapr> right, that too
08:18:40 <Heffalump> yeah, that'd be nice
08:18:59 <shapr> the U of Washington wrote a random Java generator and ran it against jvm1.1 in the early days of Java
08:19:06 <shapr> they found something like 1500 bugs
08:19:06 <Heffalump> hehe
08:19:46 <shapr> since I'm able to find bugs at a rate of once a month while doing fun programming, maybe a random Haskell code generator could find lots more.
08:22:57 <shapr> Heffalump: any other ideas for random testing?
08:26:56 <shapr> hi hal
08:26:58 <hdaume> hey
08:27:03 <hdaume> how do you run irc in emacs?
08:27:20 <shapr> I use erc.sf.net
08:27:34 <hdaume> k
08:27:37 <shapr> much of it was written by delYsid
08:28:21 <Igloo> What does that stand for, Emacs Relay Chat? Is Emacs a multi user environment now? Wouldn't surprise me  :-)
08:28:42 <shapr> emacs has been a multi-user environment for years
08:28:49 <shapr> it's still not multi-threaded though
08:29:02 <Igloo> IWW?
08:29:24 <shapr> I've writte about it before..
08:29:27 * shapr gets url
08:29:38 <shapr> http://c2.com/cgi-bin/wiki?VirtualPairProgramming
08:29:45 <shapr> in short, emacs has M-x make-frame-on-display
08:29:51 <shapr> which is very useful, though not very secure
08:30:07 <shapr> Luke Gorrie wrote shbuf, which lets you sync buffers though an erlang server process
08:30:22 <shapr> (he recently rewrote it in pure elisp when gnu emacs got server sockets)
08:30:30 <Igloo> Ah
08:30:35 <hdaume> shapr: that's the most incredible thing i've ever heard.  is there a "move-frame-to-display" or something like that?
08:30:44 * shapr could go on in much more detail
08:30:57 <shapr> that's pretty much what make-frame-on-display does
08:31:13 <shapr> emacs and make-frame still isn't as cool as Self and Kansas though
08:31:24 * shapr is a collaborative environments geek
08:31:43 <shapr> speaking of which, I had an idea for teaching Haskell on irc
08:32:25 <shapr> if you attach a ghci process to an irc process, then whatever you type on the channel is input to that process
08:32:45 <shapr> if you also add "/dcc file" to work like ":load file"
08:32:46 <Marvin--> eek
08:32:53 <shapr> then you can really collaboratively teach Haskell
08:32:58 <shapr> marvin: yes, I've thought of that too :-)
08:33:13 <shapr> user-mode-linux is the best solution I've come up with
08:33:25 <|Fo|Ns> is there a way to instace a class using deriving, of a type you imported from another module?
08:33:25 <Igloo> DoS potential, though - both deliberate and accidental  :-)
08:33:51 <shapr> Igloo: yah, it's not perfect..
08:34:13 <Marvin--> nothing is perfect :)
08:34:14 <shapr> but it would still dramatically improve our ability to share Haskell experience on #haskell
08:34:54 <Igloo> You could do it fairly sanely if you had a dedicated machine to run it on
08:35:08 <shapr> I do have some spare machines here
08:35:30 <shapr> hal: screen can also let users share the same program
08:35:40 <shapr> you can fake it with tee, though I forget how
08:36:02 <shapr> Self is still the best I've seen
08:36:15 <hdaume> cool
08:36:20 <shapr> I got to use it once from Seattle to San Francisco, Self is just amazing
08:37:13 <shapr> fons: haskell to XML?
08:37:22 <dark> I'd have security nightmares with such a setup :)
08:37:40 <shapr> dark: well, come up with a better setup ;-)
08:37:44 <liiwi> self?
08:37:51 <shapr> security is the opposite of user-friendlyness
08:38:05 <rogon> +(Pal-Kristian Engstad)
08:38:11 <dark> I'd say that getting your computer taken over is not very friendly to the user :)
08:38:12 <rogon> #haskell   dblack    H   ~dblack@ool-18bfb8d1.dyn.optonline.net (dblack)
08:38:12 * liiwi squishes shapr securely
08:38:21 <shapr> liiwi: sun research did Self, it was a better Smalltalk than Smalltalk
08:38:39 <shapr> it was prototype based rather than object oriented
08:39:16 <rogon> Wasn't there an attempt to make proper OO in haskell?
08:39:28 <shapr> much like smalltalk, each instance could have an on-screen representation.. and multiple users could play with the on-screen objects at the same time
08:40:21 <dark> One way to make the setup more secure would be to use a dedicated, restricted account for it on the student side.
08:40:56 <dark> Another was would be to arrange to show the code and have it confirmed before executing anything.  Since it's Haskell, it should be obvious if anything bad is going on :)
08:41:32 <rogon> I'm sorry, what is the issue about security?
08:41:39 <shapr> rogon: there's O'Haskell
08:42:17 <shapr> fons: I think deriving only works in the original instancing statement, but I could be wrong
08:42:30 <dark> rogon: teaching setup where the teacher and student share a ghci process on the student's machine.
08:44:09 <rogon> And what's the risk then?
08:45:15 <dark> rogon: The risk is in the ghci process being fed Bad Code.
08:46:01 <rogon> But, if the ghci process is running on the students machine, who cares?
08:46:10 <dark> *cough* The student might care.
08:47:10 <Marvin--> haha
08:47:22 <rogon> ;-)
08:47:28 <dark> This is obviously a culture clash :)
08:47:57 <rogon> If the student can't trust his own teacher, then what's going on??
08:48:13 <shapr> I was thinking more of teaching random people on irc
08:48:22 <rogon> Oh, I see. :-)
08:48:54 <Marvin--> I think it's easier to say "type that into ghci" ;)
08:49:01 <shapr> sometimes it is...
08:49:03 <shapr> sometimes not
08:49:11 <shapr> teaching HaXml would be a pain
08:49:22 <shapr> but less pain with a #ghci channel
08:52:06 <dark> rogon: Teacher and student might disagree on the meaning of "harmless trick" :)  Also, if this is just an X display connection, it's easily hijacked.  And thirdly, the teacher might be checking email at hotmail while teaching...
08:52:27 <shapr> yah
08:52:46 <Marvin--> yay, hotmail viruses that take over your ghci process
08:52:47 <shapr> so, assuming you don't get screwed by one of the participants, this sounds like a great idea
08:52:53 * shapr laughs
08:53:36 <dark> Marvin: My threat model includes "well-funded government agency that can't invade Finland for political reasons wants to discredit me" :-)
08:53:36 <Marvin--> sounds like a Big But ;)
08:54:11 <dark> Writing a hotmail virus in Haskell might be feasible for that...
08:54:12 <Marvin--> dark: that wouldn't be a Swedish agency at least, I can't think of a single government agnecy that's well-funded :)
08:54:46 <dark> NL has been selling off government agencies so that's not a problem either :)
08:56:26 <dark> Anyway, at a university, your biggest security threat is usually the other students :)
08:56:35 <Marvin--> yup
08:57:05 <Marvin--> the policy of the student network here is "please don't hack us, yes we know it's easy, but please don't"
09:00:15 <dark> Marvin: The story is that at BSD, students were shown in their first week how to break and crash the system, so that they wouldn't have to experiment :)
09:00:39 <Marvin--> :)
09:01:28 <shapr> that's a neat trick
09:02:07 <Igloo> ITYM Berkley  :-)
09:02:26 <Igloo> Or Berkeley rather
09:02:39 <Heffalump> lol
09:03:17 <Marvin--> whoops, gprolog crashed and burned
09:05:35 * Marvin-- fires up squeak and cries
09:28:20 <shapr> hi ski!
09:28:47 <ski> hi shapr !
09:31:22 <shapr> what's up?
09:31:42 <shapr> hey ski, do you know anything about arrows?
09:31:52 <shapr> I think I understand them, but I want to talk to someone who knows more
09:33:10 * Marvin-- mutters
09:33:18 <Marvin--> SICStus should be renamed to SIC-stus
09:34:10 <ski> shapr : i'm currently talking to another person, and yes I know something about arrows
09:34:17 <ski> Marvin-- : why ?
09:34:27 <Marvin--> the user interface sucks
09:34:32 <shapr> ski: well, I won't distract you then :-)
09:34:36 <Marvin--> or maybe it's just the incompetent installation we have at university
09:34:44 * shapr decides to go off and play counterstrike for awhile! yay!
10:03:26 <ludde> hello
10:03:33 <ibid> hello
10:04:36 <ski> hello
10:06:10 <hdaume> hello
10:13:41 * dark dances around his shiny or_maybe function.
10:13:51 <Heffalump> wossit do?
10:14:07 <dark> m1 `or_maybe` m2 will return the first of m1 and m2 that's Just, or else Nothing.
10:14:31 <Heffalump> doesn't something already exist to do that?
10:14:42 <dark> Heffalump: I thought there would be, but I can't find it :)
10:14:44 <Heffalump> heh
10:14:55 <Heffalump> mplus?
10:15:00 <dark> There's catMaybes which takes a list, but it strips the Maybeness.
10:15:43 <dark> mplus?  There's a Monad Maybe, but not a MonadPlus Maybe.  I think.
10:15:49 <Heffalump> there is
10:16:00 <Heffalump> it's a very obvious instance of MonadPlus
10:16:22 <dark> Oh, it's in Control.Monad instead of Data.Maybe :)
10:16:33 <ludde> ski: does your name come from the S K and I combinators?
10:19:06 <dark> Okay, so is there a replacement for my guard_maybe?  (Bool -> a -> Maybe a)
10:20:24 <jadrian> hello
10:20:31 <dark> I feel a bit silly with a 3-line module :)
10:20:57 <Heffalump> what's it do?
10:21:04 <jadrian> hi dark, hi Heffalump
10:21:09 <Heffalump> hi jadrian
10:21:27 <Heffalump> guard_maybe True a = Just a, guard_maybe False a = Nothing ?
10:22:13 <jadrian> do you know if I can have STRefs to unboxed types?
10:22:15 <dark> Heffalump: Yep
10:22:26 <dark> Heffalump: Pretty common pattern in my code.
10:22:55 <Heffalump> guard_maybe b v = guard b >> Just v, I think
10:22:58 <jadrian> I was just playing around trying to do an imperative factorial function in haskell, so I used STRefs, but no I wanted to use #Ints...
10:22:58 <Heffalump> but that probably doesn't help
10:23:04 <jadrian> opss
10:23:07 <jadrian> Int#
10:23:21 <Heffalump> jadrian: sorry, dunno
10:23:22 <jadrian> but it's not working
10:23:25 <Heffalump> have you tried?
10:23:27 <Heffalump> ah.
10:23:31 <jadrian> yeap ;)
10:23:36 <jadrian> I get this error
10:23:52 <jadrian> Couldn't match `#' against `*'
10:23:52 <jadrian>         Expected kind: #
10:23:52 <jadrian>         Inferred kind: *
10:23:52 <jadrian>     When checking kinds in `STRef s Int#'
10:23:52 <jadrian>     In the type: forall s. Int# -> ST s (STRef s Int#)
10:23:53 <jadrian>     While checking the type signature for `fact'
10:24:16 <Heffalump> and if you replace Int# by Int it works?
10:24:29 <jadrian> yeap
10:24:38 <jadrian> all I had in the body was:  x = newSTRef x
10:24:43 <ski> ludde : yes
10:24:53 <ludde> ski: cool :)
10:25:14 <Heffalump> sounds like you can't do it then
10:25:19 <Heffalump> I didn't realise boxing affected kinds
10:25:26 <jadrian> me neither
10:25:48 <jadrian> I know there are some Unboxed arrays, but I find it silly to use a length 1 array
10:25:50 <jadrian> :)
10:29:23 <dark> Now that I think about it, it makes sense that an unboxed type would be a different kind.
10:29:36 <dark> It's sort of one kind less than * :-)
10:29:58 <Heffalump> yeah
10:30:13 <ski> less ?
10:32:27 <dark> ski: If you think of boxing as a type operator, you could say that # is to * as * is to * -> *
10:32:46 <ski> hmm
10:32:52 <dark> So an Int is something like a Boxed Int#
10:32:53 <Heffalump> I don't buy that
10:33:14 <dark> Heffalump: It's not for sale :-)
10:33:16 <ski> then Boxed :: # -> *  eh ?
10:33:44 <ski> perhaps, in a very vague, loose sense ..
10:34:00 <ski> (ITYM (->) and not * -> *)
10:34:29 <dark> Hmm...
10:35:19 <dark> No, Boxed :: # -> * makes more sense to me :)
10:35:36 <Heffalump> hmm, I suppose actually.
10:41:42 <ski> Sort of like  Record :: row -> *  and  Variant :: row -> *  :)
10:42:43 <jadrian> hmmm yeah taht makes sense... but I still can't see when exactly should I use unboxed types
10:43:22 <jadrian> it seems to me like in many situation where you want your types to be unboxed, you'd want to make updates inplace right?
10:43:31 <jadrian> destructive updates
10:44:06 <jadrian> but how can I have destructive updates if I'm not allowed to define STRefs to unboxed types
10:46:01 <Heffalump> might the contents of STRefs be unboxed anyway?
11:06:00 <ludde> ski: what's your afp project about?
12:14:19 <engstad> Imagine you have different sets of commodities. Each commodity can be transferred to different vehicles depending on the vehicle types. Commodities can be bought, sold and produced. Commodities can be used to produce other commodities (in factories). 
12:14:38 <engstad> What data structure would you use in haskell to describe this?
12:25:33 <Marvin--> o3?
12:32:46 <hdaume> grrr...i want to say something like "import Prelude ([],(:))" or "import Prelude ([](..))" or something like that but neither works...help?
12:43:40 <Marvin--> /usr/lib/ghc-5.04/HSlang.o: unknown symbol `__stginit_Ix'
12:43:40 <Marvin--> eep
12:44:34 <ski> hdaume : i though hugs allowed at least (:) to be imported, but perhaps that was a previous version ..
12:45:32 <hdaume> hrm...well it need to be in ghc anyway ;)
12:45:43 <hdaume> it says Prelude doesn't export (:)
12:45:54 <ski> seems like ghci doesn't like it either ..
12:45:57 <ski> yes
13:09:51 <Marvin--> it takes *forever* to link hws-wp :)
13:11:33 <ludde> ski: what AFP project are you doing?
13:12:59 <Marvin--> ouch, ouch ouch ouch
13:13:15 <Heffalump> marvin?
13:13:32 <Marvin--> I thought I could do without implementing sub-requests, but I don't think I can
13:13:40 <ludde> ski: you're not listed on the booking page :(
13:43:29 <dark> hmm, is there some generic to-string class that I should be using instead of Show?  Show seems geared towards human-readable output, and I just need to convert between String and a newtype.
13:44:25 <dark> If I define show (Tag x) as anything other than x, my program will break :)
13:47:33 <Marvin--> whoa
13:47:40 <Marvin--> adding sub-requests was a piece of cake
13:47:51 <dark> The power of Haskell :-)
13:48:17 <Marvin--> as in, I moved 'handleRequest' from Main.hs to PluginAPI.hs and called it directly from the plugin, and that was *it* ;)
13:48:33 <ludde> Marvin--: how many lines of code is your AFP project?
13:48:40 <Marvin--> I now have a plugin that turns /foo/bar/ -> /foo/bar/index.html
13:49:05 <Marvin--> ludde: err... hard to count, since I haven't started from scratch... I'm basing it on an existing web server
13:49:11 <Marvin--> ludde: but I have some huge diffs if you want to see ;)
13:49:23 <ludde> hmm, it's ok.
13:58:11 <Verbophobe> Mornin'
14:00:10 <dark> Greetings
14:03:42 <Marvin--> http://193.11.232.159:2080/DirPlugin.hs
14:03:51 <Marvin--> incredibly little code
14:04:47 <dark> I learned only yesterday that you could pattern-match records that way :)
14:05:14 <hdaume> cool!
14:05:20 <Marvin--> there are very few things you *cannot* do with records ;)
14:06:07 <Marvin--> records are very nifty
14:06:50 <dark> The one thing I ran into that I cannot do, is pass an element-setting function as a parameter.
14:07:12 <Marvin--> huh?
14:07:19 <Marvin--> sorry, that must've come out as greek on my end
14:07:24 <dark> In the foo { bar = gnu } syntax, bar is literal.
14:07:35 <Marvin--> ah, yeah
14:07:45 <Marvin--> since it's a pattern match ;)
14:08:08 <dark> This made my transformWorld function harder :)  I needed to write a setter for every element.
14:08:29 <Marvin--> you might as well ask for (_ 3) to match Just 3
14:08:42 <hdaume> anyone know if there's an option to ghc to make it inline *nothing*?
14:09:04 <Marvin--> I gotta write more plugins :D
14:09:13 <dark> language negotiation!
14:09:44 <Marvin--> I was thinking AutoIndex
14:09:47 <Marvin--> and UserDir
14:09:55 <Marvin--> doh! i missed Fight Club on TV
14:09:55 <andersca> deflate!
14:10:07 <Marvin--> perhaps a Speling plugin ;)
14:10:18 <dark> Accept-Language: hs;q=1.0, c;q=0.6, ml;q=0.5
14:21:06 <Marvin--> ugh, come to think of it, I *won't* implement an autoindex plugin, too much work
14:23:03 <dark> What's "autoindex" anyway?
14:28:00 <Marvin--> If there's no DirectoryIndex file (e.g. "index.html"), mod_autoindex generates an index over the files in the directory
14:51:29 <Marvin--> whoa, this is so cool that it's scary
14:53:46 <cleverdra> What is it?
14:54:22 <Marvin--> http://193.11.232.159:2080/
14:55:05 <cleverdra> is this o3?
14:55:53 <Marvin--> I've used o3's module, yes
14:57:09 <cleverdra> This page is by someone other than o3, then?
14:58:05 <Marvin--> yes, me
14:58:13 <cleverdra> Oh, OK.
14:59:52 <Marvin--> I just added the userdir plugin and I was happily shocked that it interacted with the dir plugin exactly as it should :)
15:01:30 <Marvin--> userdir's uri-trans handler expands /~user to a directory, if there's an index.html in it, the dir plugin's content handler will launch a sub-request with that index.html as URI
15:04:29 <andersca> so where's the userdir code?
15:04:48 <andersca> found it :)
15:05:23 <andersca> wow
15:05:25 <andersca> scary stuff :)
15:07:22 <Marvin--> not really
15:07:39 <Marvin--> well, all the IO error stuff is, I suppose :)
15:07:54 <cleverdra> andersca - did you mean scary-cool?
15:31:08 * Marvin-- yawns
15:31:11 <Marvin--> maybe it's time to sleep
15:31:53 <jadrian> hey
15:32:00 <clausen> gday jadrian
15:32:52 <jadrian> hi clausen
15:34:11 <clausen> jadrian: have you heard of caixa mágica?
15:34:17 <jadrian> clausen: yeap :)
15:47:01 <ski> g'd night all
16:09:34 <hdaume> any sml folk in here?
16:12:07 <Heffalump> me
16:14:05 <hdaume> nm, i figured it out...i may ask you something later tho ;)
16:14:58 <dark> Marvin: autoindex is probably not as much work as it is inelegant :)  Lots of hardcoded HTML.  Maybe it would be more fun to do a DAV module.
16:29:03 <hdaume> Heffalump: what's the sml version of ++?
16:30:28 <cleverdra> In O'Caml, the C operator ++ isn't possible.
16:30:46 <hdaume> i mean haskell's ++ ;)
16:31:01 * hdaume wonders: why would i be thinking about C?
16:31:05 <cleverdra> Oh, OK =)  List.something_or_other
16:31:29 <hdaume> @
16:31:33 <Heffalump> ^
16:31:44 <Heffalump> or @, sorry
16:31:44 <hdaume> ^ is for strings, is it not?
16:31:47 <Heffalump> yeah
16:31:50 <cleverdra> yes, it's @
16:31:50 <Heffalump> I keep forgetting they're not lists.
16:31:55 <hdaume> :)
16:32:02 <Heffalump> or rather, I end up having to translate ++ in two different ways
16:33:40 * cleverdra supposes that strings will tend to become lists as i18n becomes more invasive.
16:39:49 <Heffalump> cleverdra: why?
16:42:17 <Igloo> I thought one of the problems with internationalisation in Haskell was that strings *aren't* lists of Chars any more
16:42:30 <cleverdra> Heffalump - I don't know enough about i18n to give a precise answer; I know that in Gauche, a Scheme where all strings are defaultly considered under a (decided at compile-time) format such as JIS-mumble or UTF-8, traditional algorithms based on the implicit belief that strings are flat arrays of characters are *horribly inefficient*.
16:43:25 <Pseudonym> It depends what the algorithms are.
16:43:28 <cleverdra> Heffalump - for instance, building a string of n-characters and then filling the zeroth character, the first character, etc, is efficient in most other schemes.
16:43:51 <cleverdra> Sorry, I didn't mean to imply that all algorithms are so inefficient.
16:45:14 <Pseudonym> Our customers want to do things like find all the words in a Unicode string.
16:46:00 <cleverdra> Heffalump - there are other situations where strings-as-lists is useful, such as when you're looking for ANSI color codes and the like in a string; it's easy to pass each character to a state machine, and you only need (x:xs) for that.
16:46:02 <Pseudonym> Or regular expression searching, which is a pain when you have combining characters.
16:47:02 <Pseudonym> Strings-as-lists work well in principle, except for extracting substrings, where you sometimes want to share part of the superstring.
16:54:40 <cleverdra> (#Haskell is an engine that generates conversation.  (What is its fuel?)  (What starts it?)  (What stops it?)  (What else does it generate?))
16:54:56 <cleverdra> (Sorry for that.)
16:55:07 <Pseudonym> It generates sequent calculus and category theory.
16:55:41 <cleverdra> Psuedonym - what are 'combining characters'?  Something to do with Arabic writing?
16:56:06 <Pseudonym> I don't know much about Arabic Unicode.
16:56:36 <Pseudonym> One example is an accent codepoint, like diaresis/umlaut/whatever you call it.
16:57:20 <Pseudonym> The codepoint 'a' followed by "umlaut" is equivalent to the single codepoint "a with umlaut".
16:58:43 <Pseudonym> I think (I'm not sure) that in Hebrew, vowel marks are combining characters, and I have a vague recollection that Arabic works that way too.
16:59:29 <cleverdra> How do you deal with that in regular expressions, then?
16:59:43 <Pseudonym> You canonicalise the string first.
17:00:13 <cleverdra> Both strings?
17:00:14 <Pseudonym> Or, rather, since the user presumably formulates both the string and the regex, you require them to ensure that both are canonicalised.
17:01:05 <cleverdra> OK.
17:01:30 <Pseudonym> The unicode spec has an algorithm for canonicalisation.
17:02:43 <Pseudonym> Once again, though, regular expression searching in principle works by starting at the start ofthe string and heading for the end a character at a time.
17:03:48 <hdaume> Heffalump: do you know what the equivaled of something like '\x0a' in SML is?  #"\x0a" doesn't work....
17:04:20 <Heffalump> sorry, no
17:04:25 <Heffalump> never had to do that
17:05:08 <cleverdra> O'Caml likes '\nnn' where nnn is an octal numeral.
17:07:31 <dark> Speaking of i18n, does anyone know a good way to support multiple locales in one program?  I would like to avoid passing locale parameters around to every function that displays text.
17:08:57 <dark> Once again I want Stream classes instead of Handles :-)
17:09:32 <cleverdra> locale = unsafePerformIO newEmptyMutVar -- perhaps
17:10:11 <dark> I'd also like to hook into gettext, but that means using printf style messages instead of expressions using ++ and show.
17:10:44 <dark> They don't have to be _very_ printf-like, I think.  Perhaps a string that uses %1, %2, etc to refer to arguments in an accompanying list.
17:11:17 <dark> Oh well, I'll start worrying about it when the first person who wants to translate my program comes along :)
17:14:31 <hdaume> ok i'm going home...everyone have a nice weekend
17:38:02 * Pseudonym sighs
17:38:15 <Pseudonym> My favourite type error, I think.
17:38:27 <Pseudonym>     Inferred type is less polymorphic than expected
17:38:28 <Pseudonym>         Quantified type variable `b' escapes
17:38:38 <Pseudonym> With no clue as to where the error might be.
17:39:42 <Igloo> :-)
17:40:06 <Pseudonym> Of course I'm deep in the middle of lambda spaghetti.
17:40:39 <dark> Maybe this is a message from the labmda gods to unspaghetti your code :)
17:40:53 <Pseudonym> Perhaps.
17:41:00 * Igloo thinks about looking at c2hs
17:41:04 <Pseudonym> Thing is, I'm in the middle of a long derivation.
17:41:26 <Pseudonym> This is an intermediate form and I want to know it's well-typed before I proceed.
17:45:32 <Pseudonym> Ah, I left out an apostrophe.
17:45:36 <Pseudonym> That'll do it any time.
