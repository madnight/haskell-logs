01:13:35 <ludde> how do I show that any number >= (n-1)*n can be written as p*(n+1)+q*n
01:52:09 <ludde> Show that (n-1)*n-1 cannot be written as p*n+q*(n+1), p>=0 and q>=0 for any value of n.
02:40:40 <Marvin--> Uhm
02:42:28 <ludde> i found a solution :)
02:43:12 <BlizzNL> ludde: for what?
02:43:39 <ludde> BlizzNL: I question I asked before you joined
02:47:11 <BlizzNL> ludde: ahh ;)
02:51:59 <Marvin--> argh
02:52:06 * Marvin-- fixes Yet Another bug in HWS
02:59:12 <Marvin--> -show (defaultType conf) +defaultType conf
02:59:23 <Marvin--> pretty dumb to do show on a string before sending it over a socket
02:59:38 <Marvin--> galeon says 'Heeey, this file has content type "text/plain" what the heck should I do with it?'
03:52:59 <Marvin--> damn
03:54:56 * Marvin-- needs cyclic imports
03:55:38 <Marvin--> a server monad feels very tempting
03:57:05 <Marvin--> a handler function takes a Config as argument, but the Config should include a list of the plugins
03:57:06 <Marvin--> hmm
05:57:35 <BlizzNL> Can I summarize a functor by saying: some type is a functor if a generic version of map exists based on its constructor?
05:59:46 <Heffalump> yes
05:59:47 <dark> Seems inaccurate.  I've seen lots of almost-functors here that didn't really work :)
06:03:15 <BlizzNL> thnx great. I needed to know beceause I'm reading 'Functional Programming with Overloading and Higher-Order Polymorphism' by Mark P. Jones
06:19:02 <dark> Is there a way to disable or intercept the command-line +RTS processing?
06:29:15 <Heffalump> if you find one, let me know
06:32:56 <ludde> +RTS? run time stack?
06:33:35 <Heffalump> run time system
06:33:58 <Heffalump> a GHC-compiled program will always intercept options placed between +RTS and -RTS on the command-line to configure the GHC runtime system
06:35:50 <Marvin--> argh
06:36:04 <Marvin--> how the fuck am I supposed to make a state monad interact with the block/unblock ickiness
06:36:17 <Igloo> Why do you want to (re RTS)?
08:01:57 <BlizzNL> I am reading some Functor and Monad theory but am encountering some dificulties. Can someone tell me what's wrong with this:
08:02:06 <BlizzNL> data State s a = ST (s -> (a, s))
08:02:06 <BlizzNL> instance Monad (State s) where 
08:02:06 <BlizzNL>     return x    = ST (\s -> (x, s))
08:02:06 <BlizzNL>     (>>=) m f   = ST (\s -> let ST m'   = m 
08:02:06 <BlizzNL>                                 (x, s1) = m' 
08:02:06 <BlizzNL>                                 s ST f' = f x 
08:02:08 <BlizzNL>                                 (y, s2) = f' s1 
08:02:10 <BlizzNL>                             in (y, s2)
08:13:59 * shapr bounces
08:14:21 <BlizzNL> shapr: what does shapr bounces mean?
08:15:16 <shapr> like jumping up and down happily
08:15:28 <shapr> do you jump when you're happy?
08:19:14 <BlizzNL> shapr: hehe no I use to grin when I'm happy ;)
08:28:16 <shapr> BlizzNL: have you figured out monads yet?
08:29:30 <BlizzNL> :e
08:29:49 * BlizzNL : sorry that command was for hugs ;)
08:29:51 <shapr> :l
08:30:06 <shapr> :l /home/shae/src/haskell/Spiffy.hs
08:30:31 <BlizzNL> shapr: which editor do you use for haskell?
08:30:37 <shapr> I'm using ERC 2.93 $Revision: 1.303 $ with XEmacs 21.4 (patch 8) "Honest Recruiter" XEmacs Lucid!
08:30:50 <shapr> XEmacs is my irc client...
08:31:22 <BlizzNL> shapr: with syntax highlighting and such?
08:31:26 <shapr> yup, that too
08:31:30 <shapr> you wanna see?
08:31:42 <BlizzNL> shapr: how?
08:32:30 <shapr> http://kungens.kemi.fi/~shae/src/haskell/GKSuffixTree.html
08:32:37 <shapr> emacs also has M-x htmlize-buffer
08:32:49 <shapr> which saves the source as text, and with html colors :-)
08:32:51 <shapr> neat, eh?
08:32:58 <BlizzNL> shapr: very cool!
08:33:35 <shapr> emacs does more than any other editor I've seen, but emacs has its own downsides.
08:33:58 <BlizzNL> shapr: I am 'migrating' to linux. And I am not really into the available tools yet.. thats why I asked
08:34:07 <shapr> I'd be happy to help you
08:34:17 <shapr> anything I can help you with right now?
08:34:28 <shapr> I've been using linux for several years
08:34:41 <shapr> though only two years ago did I get rid of windows entirely
08:35:22 <BlizzNL> shapr: No not really. I am having troubles with my soundcard (via onboard) but I'll have to wait untill they release RH8 drivers
08:35:42 * BlizzNL has to eat..
08:35:45 <shapr> what kind of card?
08:36:56 <shapr> hi hal
08:37:02 <hdaume> hi ;)
08:37:06 <shapr> have you had time to look at the arrows paper?
08:37:33 <hdaume> no...i have a midterm today and was studying (a bit) last night
08:37:54 <shapr> good reason to study :-)
08:38:00 <shapr> are you a grad student?
08:38:01 <dark> Studying, isn't that like cheating?  I thought you were supposed to just know how to do the problems.
08:38:07 * shapr grins
08:38:29 <hdaume> yeah, i am.
08:38:40 <hdaume> dark: it's algorithms, so your statement is more or less correct
08:38:44 <shapr> I wonder if there's some relationship between Arrows and Monad Transformers
08:38:59 <shapr> I think studying is an NP complete problem
08:39:13 * hdaume thinks it's undecidable
08:39:18 <dark> "I want to know everything.  I want to understand everything, and put it all together and see what it means."
08:39:19 * shapr laughs
08:39:25 <shapr> dark: me too!!
08:39:28 <shapr> where's that a quote from?
08:39:45 <dark> shapr: Xenocide, by Orson Scott Card.  The reply was "Excellent project.  It will look good on your resume."
08:39:47 <shapr> hi nerdlor_
08:39:51 * shapr grins
08:40:03 <shapr> ah, I haven't read Xenocide since it was published
08:40:08 <nerdlor_> caught me?
08:40:11 <shapr> I am reading book three of ender's shadow
08:40:24 <shapr> nerdlor_: just saying hi :-)
08:40:35 <nerdlor_> howdy!
08:40:38 <dark> Hmm it might have been from Speaker for the Dead.  I always forget the boundary between those two.
08:40:54 <shapr> don't think you've said much here, thought I'd try to bring you into the conversations....
08:41:05 <dark> Anyway, I'm currently rereading all my books about Morgaine :)  (Cherryh)
08:41:23 <shapr> nerdlor_: do you use Haskell?
08:41:44 <nerdlor_> yes, i 've been interested in it for awhile
08:41:52 <nerdlor_> trying to get some haskell hacking time in
08:42:09 <shapr> what kind of stuff do you do with Haskell?
08:42:34 <nerdlor_> well, i'm interested in parsers,
08:42:41 <nerdlor_> so when i saw parsec for the first time, i nearly fell over
08:42:51 <shapr> parsec is cool
08:42:54 <nerdlor_> you write the parser *in the grammar*, or pretty close
08:43:27 <nerdlor_> so latey, a littlle pet project has been designing a little toy language
08:43:41 <nerdlor_> for specifying entities and their relationships to each other,
08:43:44 <shapr> using parsec?
08:43:45 <nerdlor_> to emit SQL
08:43:48 <nerdlor_> yep
08:43:59 <nerdlor_> i mean, parsec for parsing
08:44:05 <shapr> neat idea
08:44:15 <shapr> there's parsing beyond monads
08:44:21 <nerdlor_> putting together an ER model, and then functions to map that model to a SQL table schema
08:44:27 <shapr> the Arrow based LL(1) parsers are even spiffier
08:44:35 <nerdlor_> i'm not sure i can get *beyond* monads
08:44:38 <nerdlor_> don't know about arrow
08:44:46 <shapr> have you read about monads?
08:45:00 <nerdlor_> monads are strange to me: i seem to get these brief, 5 second glimpses of understanding and enlightenment,
08:45:06 <nerdlor_> and then it goes away and i'm all confused again
08:45:09 <shapr> only recently did I realize that monads are like objects, just a useful abstraction that's defined by a few properties
08:45:27 <nerdlor_> i've done some reading
08:45:29 <shapr> yah, same thing happened with me
08:45:45 <shapr> then I read Hughes "Generalizing Monads to Arrows" paper three times in a row
08:45:46 <nerdlor_> just recently the meijer and graham paper (?) parsing monad combinators (?)
08:45:52 <shapr> yah, that's a good one
08:45:56 <nerdlor_> it takes a while for it to sink in
08:46:00 <shapr> got me started using Parsec :-)
08:46:17 <nerdlor_> yep! i'll have a look at arrow
08:46:34 <shapr> anyone know where I'm most likely to get answers about arrow questions?
08:46:39 <nerdlor_> my toy language's grammar is very simple -- definitely LL(1)
08:46:40 <shapr> maybe I should try c.l.f
08:47:11 <shapr> can your toy language emit SQL yet?
08:47:22 <nerdlor_> well, not yet
08:47:30 <nerdlor_> the parser's mostly done
08:47:32 <hdaume> shapr: John?
08:47:39 <nerdlor_> now it's time to map ER model to table schema
08:47:49 <shapr> I've thought about a ParaSQL that takes sql92 and emits spiffier db-specific stuff, like stored procedures or more efficient SQL
08:47:50 <nerdlor_> which has a couple of interesting twists
08:47:54 <shapr> hdaume: probably so
08:48:10 <hdaume> your best be is probably posting on the mailing list...i dunno
08:48:16 <nerdlor_> shapr: cool
08:48:50 <shapr> I'll try that
08:50:02 * nerdlor_ goes out to forage for food in the frozen Canadian wastes...
08:51:59 <dark> shapr: ParaSQL would already be useful if it took sql92 and emitted db-specific code that doesn't break :)  They're all incompatible.
08:52:33 <dark> So... what's the connection between Haskell and arctic environments?
08:52:59 * shapr doesn't know
08:53:14 <shapr> I couldn't even think of a smartass remark to connect them
08:53:30 <dark> I didn't mean it as a straight line :)  There just seems to be a correlation.
08:53:37 <shapr> yah, I agree
08:53:44 <shapr> neat idea
08:59:13 <dark> Hmm, I wonder if dropping -O from the makefile will change the time complexity, or just the constant factor.
08:59:21 <dark> I'm getting bored waiting for compilation :)
08:59:38 <dark> But I don't want to get the wrong idea about which parts of my program are fast or slow.
08:59:58 <hdaume> dark: accoring to SPJ and SimM, they only use -O for final compilations and not for development.  i've found it rarely makes a huge difference.
09:01:37 <dark> Wow, dropping -O makes it lots faster.
09:01:48 <hdaume> yup
09:01:51 <dark> I got into the habit of keeping -O in my makefile when I started with smaller projects :)
09:02:53 <hdaume> yeah, i did too
09:03:07 <hdaume> Pseudonym: new TTrie has been committed
09:03:15 <shapr> oh, he is here
09:04:04 <hdaume> bbiab
09:18:10 * BlizzNL is back from his dinner
09:18:26 <BlizzNL> shapr: its a VIA VT8233 onboard
09:18:46 <dark> Hmm, sounds like mine.
09:20:01 * dark writes a recursive_remove function and shivers.
09:20:06 <BlizzNL> dark: could be. It works for RH up to 7.3 but the 8.0 driver have not been released yet
09:20:55 <dark> "works for"?  I haven't had any trouble with it except that I needed alsa for the sound.
09:21:43 <BlizzNL> dark: ahh you use alsa. Yes i tried that too, but I had problems compiling the alsa-lib. very strange.
09:22:38 <shapr> I use alsa
09:22:40 <dark> alsa-lib?
09:22:47 <shapr> it is a bit of a pain to compile, but I got it working
09:23:07 <dark> I compiled alsa-modules for my kernel, then installed the alsa packages and killed their init script.
09:23:47 <dark> Instead I do my own "aslactl restore" from modules.conf
09:24:08 <dark> This is because I want to reboot with sound in a *known* state, not whatever-I-shutdown-with :)
09:24:16 <BlizzNL> dark: yes. the website stated I needed the driver, a library and some utils. spread over 3 different files. which have to be build in sequence. But I have probs with the lib
09:24:59 <hdaume> since we're talking about rh compat, anyone here running RH on an nforce motherboard?
09:25:12 * shapr is using debian
09:25:20 <hdaume> shapr: on nforce?
09:25:22 <shapr> nah
09:25:28 <dark> BlizzNL: I guess I never had to worry about that :)
09:25:31 <shapr> how do you like the nforce mobo?
09:25:37 * hdaume can't get xwindows to work :(
09:25:41 <hdaume> i really like it, in windows ;)
09:25:49 <BlizzNL> dark: you'd be grateful;)
09:25:49 <shapr> heh
09:26:00 <shapr> hal: using nv or nvidia X driver?
09:26:22 <hdaume> shapr: right
09:26:27 <shapr> either?
09:26:37 <shapr> I'm using a GeForce 4 MX 400 here
09:26:47 <shapr> so I can help you get nvidia binary drivers working for X
09:27:13 <hdaume> well, nvidia has nforce rpms available from their web page...i've installd those but they don't seem to help
09:27:17 <BlizzNL> But I don't like to repeat questions but the question i asked 2 hours or something ago is still bugging. Can anyone help me with that?
09:27:25 <shapr> what's the question?
09:27:47 <hdaume> part of the problem is that since the ethernet is part of the mb, withoput nforce drivs running, i can't get on the net, which means i have to constantly reboot in windows
09:27:52 <shapr> hal: what's the error in /var/log/XFree86.0.log ?
09:28:01 <shapr> whoa, extreme suckage
09:28:29 <shapr> what kind of ethernet chipset is it using?
09:28:31 <BlizzNL> shapr: it's kinda long so check the log. It's VERY recognizable ;)
09:28:33 <shapr> custom nvidia?
09:28:42 <hdaume> shapr: i don't remember...it's been a while since i tried.  i believe it was something about being unable to set the display mode
09:28:53 <shapr> hm
09:29:12 <BlizzNL> shapr: 08:02:06
09:29:24 <shapr> hal: feel free to send me the logfile
09:29:35 <hdaume> okay...perhaps when i get home i'll do so ;)
09:29:54 <hdaume> i might try just doing a clean install of 7.3 and start over
09:29:55 <shapr> I'll see if I can divine the problem
09:30:18 * shapr looks in the channel logs
09:31:18 <shapr> oh, monad troubles
09:31:33 <BlizzNL> shapr: i think I have it.. forgot a damn )
09:32:21 <shapr> ah, damns are always handy. swearing is a necessary part of programming.
09:32:24 * shapr grins
09:32:39 <dark> Hmm, I never use swearing.
09:32:44 <shapr> really?
09:32:56 <BlizzNL> shapr: I like to swear at my code to show who is in charge ;)
09:32:58 <dark> Not for programming, anyway :)
09:33:01 <shapr> ohh
09:33:04 <shapr> what do you swear at?
09:33:19 <BlizzNL> :e
09:33:20 <shapr> I swear at my code to try to beat it back into shape.
09:33:29 <shapr> the only two things I swear at are code and counterstrike
09:33:48 <dark> I don't remember what I swear at :)
09:34:27 <dark> I tend to swear back at people who swear at me, but that's just part of my tit-for-tat strategy.
09:34:38 <dark> Inanimate objects get the benefit of the doubt.
09:36:03 <shapr> swearing at my code is somewhat related to autoflagellation I think
09:37:33 <dark> Would exclamations like "Gahrahrargh" count as swearing?  They're not really _at_ anything.
09:38:00 <shapr> hmm
09:38:10 <shapr> they do serve the same function
09:38:46 <dark> They express dissatisfaction without really pointing blame at anything :)
09:58:00 <dark> Run-to-store time :)  I'm addicted to chocolate milk.  Can't program without it.
10:25:13 <dark> One thing I like about Haskell is how easily I can make a function like with_tempdir.
10:28:17 <hdaume> dark: i can't tell if you're being sarcastic or not ;)
10:28:31 <dark> I'm not :)  Imagine doing something like it in C.
10:28:57 <hdaume> okay.  you just seemed to have gone through such hell recently with tmp files ;)
10:29:02 <dark> create_tempdir was difficult to make, but once I have it, with_tempdir does something that's out of reach for most languages.
10:29:17 <hdaume> true
10:30:26 <dark> And creating a temp directory is much easier than a temp file :)  (Doing it _properly_, that is)
10:30:42 <hdaume> shapr: how do you use irc from emacs?
10:32:49 <dark> hdaume: You take the _blue_ pill :-)
10:33:00 <hdaume> ;)
10:35:14 * hdaume really wants to be able to selectively import/export instances
10:43:46 <dark> The syntax for it shouldn't be hard, just the class and type name.
10:44:27 <dark> The problem would be with backwards compatibility :)
10:46:06 <hdaume> well, you could do something like "module M (exports) hiding ((Eq a => Eq [a])) where" or something...
10:46:20 <hdaume> so by default everything gets exported (instance-wise)
10:56:13 <dark> I don't think you even need the context there.  I don't think you can have different instances for Eq []
10:56:56 <dark> So: import Prelude hiding (Eq [])
10:57:00 <hdaume> well, if you have -fallow-{undecidable/overlapping}-instances, you can ;)
10:57:41 <dark> Hmm, the problem here is: every other module you import will re-export that instance.  You would have to hide it everywhere.
10:58:29 <hdaume> well, really what i want is just hiding on exports, not imports, so that doesn't worry me much ;)
10:59:41 <dark> I'll bet that -fallow-overlapping-instances was invented as a workaround for the problem of hiding instances :)
10:59:58 <hdaume> or there could be some rule like: if A exports instance I, B imports A and re-exports I; then, if your module C imports A hiding I and also imports B, I is implicitly hidden in B, too
11:00:17 <hdaume> so, basically you'd only have to hide it from the original module
11:00:42 <hdaume> though, that wouldn't really work because in the std libs, things are defined in like GHC.List and then imported into the prelude...
11:01:22 <engstad> Greets.
11:01:26 <hdaume> overlapping-instances solves some problems, but i want that the compiler wouldn't be able to use instances to do context reduction, which obviously that won't handle
11:01:28 <hdaume> hi engstad
11:01:46 <engstad> So, ocaml won again, huh? (icfp).
11:02:57 <engstad> Listen, I was thinking (because I like Haskell better), would it be possible to _enforce_ strictness in the language, i.e., make Strict Haskell?
11:03:11 <hdaume> sure
11:03:59 <engstad> But, without the strictness annotations.
11:04:51 <hdaume> sure
11:05:30 <dark> I remember that someone is working on Eager Haskell, would that be it?
11:06:06 <hdaume> that's not the same thing
11:07:12 <engstad> Or perhaps we should improve the strictness analysis instead... ;-)
11:08:24 <dark> I think there are some language rules that could be tweaked to give more freedom to strictness analysis.
11:08:41 <dark> The trick of rewriting lets to cases shouldn't be needed in a proper language :)
11:08:43 <hdaume> a poor-man's attempt would simply to introduce a core2core pass which changes all lets to cases and all datatypes to strict datatypes ;)
11:09:37 <dark> You might need a new Prelude, too.
11:09:43 <hdaume> certainly
11:09:47 <hdaume> you'd want to do it to everything
11:10:38 <dark> I don't mean just recompile the Prelude :)  Parts of it might rely on laziness.
11:10:55 <dark> And some of its functions don't make sense if everything is strict.
11:12:15 <dark> Hmm.  I wonder if the compiler could give advice: "If you make this argument strict, I could make the function much faster!"
11:13:31 <hdaume> there used to be a ghc flag -fstrict-all (or -fall-strict; i can't remember) which i think just told the strictness analysis to assume everything was strict.  it's defunct now and will probably break your code.
11:14:05 <toadx> that would be extra cool if it delievered the message in shakespearean english
11:15:13 <toadx> "thine code is a milk-livered reeky coxcomb"
11:21:20 * hdaume is off to the gym then his midterm....ttyl
11:37:48 <|Fo|Ns> hi
11:42:16 <tez> hi
11:54:21 <shapr> hdaume: http://erc.sf.net/ that's irc from inside emacs
11:56:41 <shapr> toadx: when do you create the new locale... en_shakespeare
12:35:11 <BlizzNL> anyone who read 'Functional Programming with Overloading and Higher-Order Polymorphism by Mark P Jones' and actually worked along with the examples ?
12:42:19 <|Fo|Ns> hi
12:42:51 <obraun> hi
13:05:57 * shapr reads http://www.cs.fit.edu/~satkin/monads.html
13:06:36 <liiwi> moooooonads
13:06:45 <shapr> m00nads
13:07:00 <liiwi> moon-ads
13:07:03 <shapr>          (__) 
13:07:03 <shapr>          (oo) 
13:07:03 <shapr>    /------\/ 
13:07:03 <shapr>   / |    ||   
13:07:03 <shapr>  *  /\---/\ 
13:07:04 <shapr>     ~~   ~~
13:07:06 * shapr spams
13:07:15 <lament> gonads?
13:07:23 <shapr> hi lament
13:07:35 <lament> hi!
13:07:47 <shapr> gonads are from a whole 'nother part of life
13:09:18 <shapr> lament: you learning Haskell?
13:09:27 <lament> Yes.
13:09:38 <shapr> how do you like it so far?
13:09:47 <shapr> lament == lilo ?
13:10:16 <lament> It's mind-blowing :)
13:10:17 <lament> no.
13:10:21 <shapr> ok
13:10:25 <Marvin--> "And here we have an example of a Haskell programmer. Listen! It's their mating call... (mooooonaaads)"
13:10:29 * shapr laughs
13:10:31 <shapr> hi Marvin!
13:10:35 <Marvin--> hi :)
13:10:38 <shapr> wassup?
13:10:43 <shapr> still having fun with HWS?
13:10:58 <Marvin--> if "fun" is what you want to call it ;)
13:11:00 <dark> The documentation for Text.Regex.mkRegexWithOpts seems seriously off.
13:11:04 <Marvin--> I'm trying to finish the coding today so I can work on the report
13:11:08 <shapr> yay
13:11:29 <shapr> Marvin: you could have changed it all to .lhs with embedded LaTeX
13:11:33 <Marvin--> hookOne :: (HWSPlugin -> Maybe HandlerFunc) -> RequestCode -> HandlerFunc
13:11:40 <Marvin--> how's that for a confusing type?
13:11:43 <shapr> wow, neat
13:11:47 <shapr> makes sense actually
13:11:55 <Marvin--> oops, sorry, ResponseCode
13:12:10 <Marvin--> nah, I don't want to have all the code in the report
13:12:15 <shapr> might not make sense if I didn't know about Apache plugins and RunTimeLoader.hs
13:12:51 <Marvin--> First I was going to have a Phase datatype, but then I just realized that the Phase is simply the record members in a plugin ;)
13:13:15 <shapr> ?
13:13:20 <shapr> record members?
13:13:52 <Marvin--> data HWSPlugin = HWSPlugin { ... pTransHandler :: Maybe HandlerFunc, pAccessHandler :: Maybe HandlerFunc ... }
13:14:35 <shapr> ohh
13:14:37 <shapr> cool
13:14:40 <Marvin--> so I can call  hookOne pTransHandler RC_InternalServerError ...
13:15:01 <Marvin--> `Maybe HandlerFunc' screams "function pointer that can be NULL" but who cares ;)
13:15:34 * shapr grins
13:16:04 <Marvin--> damn bad timing, the debian-desktop project just started and I really want to contribute to it, but I don't have the tiiime
13:16:12 <Marvin--> and I have a lot on my d-i todo too
13:16:58 <shapr> d-i?
13:17:06 <Marvin--> debian-installer
13:17:45 <Marvin--> let handlers = [ hf | Just hf <- map f plugins ]
13:17:46 <Marvin--> hrrm
13:21:03 * shapr likes autoderiving Show
13:21:35 <BlizzNL> Can someone tell me what instance code is generated by : "data MyType x = MyCons x deriving Show" ?
13:27:50 <Igloo> An instance of Show identical to that of x except with "MyCons " printed before it and parentheses added if necessary. Why?
13:29:04 <BlizzNL> Igloo: educational purpose, I want to know what is going on..
13:31:46 * Marvin-- does some pointless^H^H^H^hfree programming
13:32:21 <Heffalump> :-)
13:32:40 <Heffalump> I'll tell Richard Bird you said that!
13:33:08 <Marvin--> sheesh, everybody say it
13:33:19 <Heffalump> well, so do I :-)
13:33:42 <Marvin--> actually, this is not really pointfree, but I'm über-generalizing
13:33:52 <Marvin--> hook :: (HWSPlugin -> Maybe HandlerFunc) -> Maybe ResponseCode -> HandlerFunc
13:36:15 <Marvin--> result <- runHooks [ hook pURITransHandler (Just RC_InternalServerError), hook pAccessHandler Nothing, ... ]
13:36:57 <Marvin--> runHooks [] = id
13:37:01 <Marvin--> okay, so that's pretty point-free ;=)
13:54:23 * BlizzNL left #redhat because it could not stand a take-over.
14:19:02 <Marvin--> whoa
14:19:08 <Marvin--> these are some big error messages
14:29:50 <Marvin--> torture?
14:29:58 <Marvin--> are you marking assignments too? ;)
14:31:11 <hdaume> no, algorithms midterm ;)
14:31:20 <tez> Is anyone familiar with Erlang?
14:31:23 <hdaume> it was actually rather trivial
14:31:43 <Marvin--> tez: somewhat
14:32:08 <tez> I was just wondering if it's a strongly-typed language.
14:32:31 <Marvin--> nope
14:32:38 <tez> Cheers.
14:32:52 <Marvin--> or, well, it may be strongly typed, but it's not statically typed
14:32:59 <Marvin--> I don't remember if it's strong or weak
15:07:51 <hdaume> anyone know how to use perl's split where the character to split on is a tab?  split("\t",$_) doesn't seem to work...
15:11:08 <clausen> #perl ?
15:11:23 <clausen> #haskell is the last place I'd expect an answer :p
15:11:47 <hdaume> *grin* i tried there, but no one seems to like me ;)
15:11:51 * Heffalump probably writes more perl than haskell
15:12:04 <dark> filter (not comment) $ map (dropWhile isSpace) $ lines contents
15:12:08 <dark> I love Haskell :)
15:12:15 <Heffalump> will just splitting on whitespace do, btw?
15:12:52 <hdaume> i got it ;)
15:13:21 <Marvin--> dark: you should see my code for the hws-wp plugin machinery, it's starting to look neat, a bit combinator-ish
15:14:00 <dark> I think it's split /\t/ rather than split "\t"
15:14:17 <dark> Marvin: My code is starting to look more and more imperative-ish :)
15:14:46 <dark>   exists <- doesFileExist tmfile
15:14:46 <dark>   if not exists
15:14:48 <dark> blah blah
15:15:40 <Marvin--> dark: heh, some of the hws code uses  case foo of { some_error -> return (); not_error -> do .... case bar of { ... ;)
15:18:10 <dark> Marvin: One of my functions has this "leaning tree" style of if-then-else, some of them nested four deep.  So far I haven't found a sane way to make it prettier.
15:18:29 <dark> Sometimes I miss C's "instant return" operator :)
15:20:01 <hdaume> dark: yeah.  i usually do something ugly like:
15:20:05 <hdaume>    do ...
15:20:17 <hdaume>      if foo then return bar else do
15:20:21 <hdaume>      the rest of the stuff
15:31:44 <dark> hdaume: I'm not confident enough of my grasp of the layout rules to do that :)
15:32:59 <dark> Ooh, I used foldl!
15:34:18 <hdaume> anyone remember off the top of their heads the command to force a GC?
15:34:40 <Heffalump> performgc, with some appropriate capitalisation, IIRC
15:34:53 * hdaume looks in the index
15:35:04 <hdaume> which doesn't have it ;)
15:35:18 <hdaume> Heffalump: you remember which module?
15:36:01 <Heffalump> IOExts?
15:36:09 * Heffalump guessing fairly wildly here, really
15:37:02 <hdaume> System.Mem.performGC :)
15:39:40 <Heffalump> ahh.
15:39:48 <Heffalump> must have moved when the hierarchical libraries were introduced
15:50:28 <Marvin--> AAAAAAAAAAARGH
15:51:06 <Marvin--> How can fromDynamic (toDyn foo) fail!?
15:54:19 <Heffalump> because of the types
15:54:32 <Heffalump> fromDynamic (toDyn (foo :: String)) :: Integer is bound to fail
15:54:36 <Marvin--> well yes
15:54:59 <Marvin--> but foo is :: HWSPlugin and the thing I'm assining fromDynamic ... to is Maybe HWSPlugin
15:55:09 <Marvin--> oh well, *recompiling all the files to be on the safe side*
15:55:18 <Marvin--> nope, didn't help
15:55:24 <Heffalump> hmm...
15:55:31 <Heffalump> you're sure about the types?
15:55:40 <Marvin--> in one file,  plugin = toDyn $ HWSPlugin { ... }
15:55:42 <Heffalump> is the Typeable instance for HWSPlugin sensible?
15:55:58 <Marvin--> in another  let Just p = fromDynamic plugin
15:56:03 <Marvin--> I hope so
15:56:16 <Marvin--> typeOf p = mkAppTy (mkTyCon "PluginAPI.HWSPluginV1") []
15:56:53 <Marvin--> heck I haven't even started using dynamic loading yet, I'm trying to make the core "plugin" work ;)
15:58:09 <Heffalump> heh
15:58:55 <Marvin--> so this should just be a regular import
15:59:01 <Marvin--> import qualified Core
15:59:06 <Marvin--> let Just coreP = (fromDynamic Core.plugin :: Maybe HWSPlugin)
15:59:14 <Marvin--> or how hard does :: bind?
16:00:51 <Heffalump> I'm not really sure how tightly it binds. Less than ' ', I'm fairly sure.
16:02:51 <Marvin--> so maybe my typeable thingy isn't good enough
16:03:06 <Marvin--> but I think I tested it before
16:05:00 <Heffalump> they're definitely both using the same instance of Typeable?
16:05:40 <Marvin--> I should hope so, they're importing the same file!
16:06:01 <Heffalump> and you've forced rebuilds everywhere to be sure of this?
16:06:11 <Marvin--> yep, removed every .o and .hi
16:06:42 <Marvin--> wow wow wow, wait a sec
16:06:58 <Marvin--> hmm, yeah, ok, make clean did remove the .hi files
16:07:08 <Heffalump> can you get the TypeRep out of a Dynamic?
16:08:00 <Heffalump> I can't see any way to, unless Show does that by making a string
16:08:11 <Heffalump> (I can't really see what else the Show instance for Dynamic could do)
16:08:33 <Marvin--> show on a Dynamic does how on the typerep
16:08:44 <Heffalump> check that at both ends, then
16:08:45 <Marvin--> loading up Core.hs in ghci works fine
16:08:59 <Heffalump> and at the end that's receiving the value, do a show on another Dynamic made from a HWSPlugin locally
16:09:10 <Marvin--> *Core> fromDynamic plugin :: Maybe HWSPlugin
16:09:10 <Marvin--> Just <HWS Plugin core, 1.0>
16:11:02 <Marvin--> print Core.plugin
16:11:02 <Marvin--> print $ toDyn $ HWSPlugin "" "" Nothing Nothing Nothing Nothing Nothing Nothing [] Nothing
16:11:04 <Marvin--> (is what I did)
16:11:09 <Marvin--> they print the same thing
16:11:23 <Marvin--> <<PluginAPI.HWSPluginV1>>
16:11:24 <Marvin--> <<PluginAPI.HWSPluginV1>>
16:11:33 <Heffalump> but that's in a situation where fromDynamic works...
16:11:44 <Heffalump> you need to test it in the same situation that fromDynamic doesn't
16:12:08 <Marvin--> that's what I get when printing two Dynamic:s on the "receiving" end
16:12:16 <Heffalump> ah, ok
16:12:26 <Marvin--> print Core.plugin
16:12:26 <Marvin--> let coreP = (fromDyn Core.plugin (error "WTF"))
16:12:29 <Marvin--> is what I do
16:12:42 <Marvin--> <<PluginAPI.HWSPluginV1>>
16:12:43 <Marvin--> Fail: WTF
16:12:44 <Marvin--> is what I get ;)
16:12:50 <Heffalump> heh
16:13:09 <Heffalump> you have the print $ toDyn $ ... in the same do block too?
16:13:35 <Marvin--> yes
16:13:47 <Heffalump> fromDyn does have sane semantics, right?
16:14:10 <Marvin--> I've tested with both fromDyn and fromDynamic
16:14:13 <Heffalump> right
16:15:16 <Marvin--> and even when I do:
16:15:28 <Marvin--> let dynp = toDyn $ HWSPlugin "" "" Nothing Nothing Nothing Nothing Nothing Nothing [] Nothing
16:15:28 <Marvin--> print dynp
16:15:28 <Marvin--> let p2pHeh = fromDyn dynp (error "1") :: HWSPlugin
16:15:28 <Marvin--> print p2pHeh
16:15:31 <Marvin--> it prints:
16:15:37 <Marvin--> <<PluginAPI.HWSPluginV1>>
16:15:37 <Marvin--> Fail: 1
16:15:49 <Heffalump> so even locally it breaks? eep.
16:15:56 <Heffalump> at least that should be easier to debug
16:16:24 <Heffalump> and can't be fucked up by dynamic loading etc
16:16:41 <Marvin--> there isn't any "don't use this in IO"-silliness is there?
16:16:55 <Heffalump> I should hope not
16:17:01 <Heffalump> since everything you do is ultimately in IO
16:17:15 <Marvin--> exactly
16:17:16 <Heffalump> and cos of referential transparency, could be arbitrarily close to being in IO
16:18:05 <dark> Heh, I wish I could use ++ in patterns.
16:18:19 <dark> Match on ("exclude " ++ xs)
16:19:20 <Heffalump> dark: yeah, would be nice
16:19:26 <Marvin--> use prolog instead ;)
16:19:30 <Heffalump> in that case there's a nice direct translation to existing syntax, too
16:19:52 <Marvin--> isn't that pretty much what Views is supposed to be?
16:20:27 <Heffalump> well, in the sense that they might make ++ a constructor in the correct view, I guess so
16:20:55 <dark> Yeah I don't need general support, just for an explicit prefix :)
16:20:56 <Marvin--> http://193.11.232.159:8080/Foo.hs
16:21:01 <Marvin--> Am I doing anything wrong?
16:21:19 <dark> I could use isPrefixOf, but then I have to do tricks to drop exactly that many characters from the string before processing.
16:21:25 <Marvin--> I compiled and ran that file, and it fails too :)
16:21:27 <dark> Not nice if I'd like to have a long list of these, one per line.
16:21:33 <Heffalump> hmm..
16:21:46 <dark> Bah, I'll just make a long list of these, and process that list :-)
16:21:59 <Heffalump> Marvin--: command line to compile it?
16:22:07 <Heffalump> (to save me working out the list of packages)
16:22:09 <Marvin--> Heffalump: just ghc Foo.hs
16:22:18 <Marvin--> ./a.out
16:22:20 <Heffalump> 'k
16:22:33 <Heffalump> fails for me too
16:22:41 <Marvin--> argh, time for a mail to ghc-users I think
16:22:47 <Marvin--> my first ;)
16:23:06 <Marvin--> gonna try one more theory first
16:23:54 <Marvin--> nope
16:23:58 * Marvin-- mails
16:27:44 <Marvin--> and now we wait :)
16:29:30 <hdaume> marvin-- has lost his ghc-users virginity ;)
16:30:05 <Marvin--> hdaume: can I leave the corner now? ;)
16:34:44 <hdaume> i suppose
16:37:41 <Pseudonym> G'day.
16:42:43 * Pseudonym scrolls back over 16 hours of IRC log
16:49:10 <Marvin--> time to sleep
16:49:25 * Pseudonym is just about awake
16:51:23 <Pseudonym> hdaume: Thanks for committing that.
16:51:30 <Pseudonym> Finally got to that part. :-)
16:55:02 * Heffalump gets home
16:55:18 <dark> I love my "chomp" function.
16:55:28 <dark> fix_dir = (chomp '/' dir) ++ "/"
16:55:43 <Heffalump> clearly a perl programmer at heart...
16:55:51 <Pseudonym> Definitely.
16:55:58 <dark> Well that's why I named it "chomp", yeah :)
16:56:04 <dark> I also have "bite" which eats from the front.
16:56:07 <Pseudonym> I assumpe chomp x = dropWhile (/=x) ?
16:56:13 <Pseudonym> Oh, I see.
16:56:17 <Pseudonym> It drops from the last one.
16:56:22 <dark> Pseudonym: No, chomp drops up to 1 character from the _end_
16:56:28 <Pseudonym> Yes, like in Perl.
16:56:36 <Pseudonym> Nice.
16:56:39 <dark> strip_quotes = chomp '"' . bite '"'
16:56:41 <dblack> dark: what's wrong with ruby's chomp?
16:56:56 <dark> dblack: What's ruby's chomp?
16:57:07 <dblack> the chomp method in ruby
16:57:12 <Pseudonym> I have one objection to Perl's chomp.  Lines are terminated differently on different platforms.
16:57:33 <dark> Pseudonym: Perl's chomp isn't platform-dependent about it?
16:57:36 <dblack>  ruby -e "puts 'abc'.chomp 'c'"
16:57:36 <dblack> ab
16:57:36 <Heffalump> doesn't it DTRT for the platform you're on?
16:57:43 <Pseudonym> The magic of deciding which is which based on the platform is okay for Perl, but I suspect it's not pretty for Haskell.
16:57:55 <Heffalump> ah, yes
16:57:56 <dark> dblack: Looks like it does the same thing.
16:57:59 <Pseudonym> You want to be able to chomp "\r\n" if you want to.
16:58:03 <dblack> groan
16:58:04 <dblack> sorry
16:58:05 <Pseudonym> Not in Perl, arguably.
16:58:05 <dark> dblack: But not very useful if I'm programming in Haskell :)
16:58:08 <dblack> i'm in the wrong window
16:58:11 <dblack> dark: sorry :-)
16:58:58 <dark> Pseudonym: Yeah, I don't actually have a function for chomping a sublist.
16:59:06 <dark> dropPrefix and dropSuffix, I guess.
16:59:26 <Pseudonym> But your chomp is nice nonetheless.
16:59:52 <dark> I sort of like C's policy that end of line is always \n, regardless of platform.
17:00:06 <dark> Of course it creates problems in estimating the length of files.
17:01:00 <Pseudonym> Text processing is basically irrevocably messy.
17:01:18 <Pseudonym> Between line length protocols, character sets and so on, the thing is to avoid it where possible.
17:01:20 <dark> Unicode could have solved that, but decided to add three more line terminators instead :)
17:01:24 <Pseudonym> :-)
17:01:46 <Pseudonym> Naturally this is why I hack text databases for a living.
17:02:04 <dark> I think Unicode should have stayed away from formatting codes entirely, and concentrated on being a character set.  We have a sufficiency of markup languages for doing the formatting :)
17:02:50 <dark> But, at this point, I think it's going to be Unicode or nothing.  "Sometimes, when you fill a vacuum, it still sucks."
17:02:53 <Pseudonym> Grrr.  What's the magic in build.mk for building ghci?
17:03:11 <Pseudonym> dark: Basically, yes.
17:03:17 <Igloo> Compile with the version you are building
17:03:28 <Pseudonym> Ah.
17:03:30 <Pseudonym> Makes sense.
17:06:24 * Pseudonym fires off a parallel build
17:07:11 <Pseudonym> I normally don't care, but I hit a bug and I want to make sure it's not fixed before reporting.
17:07:49 <Pseudonym> Ha ha.
17:10:07 <Pseudonym> make clean tries to delete files called "core".
17:10:18 <Pseudonym> Trouble is, there's a directory called that.
17:10:26 <Pseudonym> Never noticed that before.
17:27:41 <dark> Hmm, it would be nice to have a version of newtype that does preserve instances.
17:27:48 <dark> Just to get the benefit of typechecking.
17:34:31 <Heffalump> YM that automatically copies instances?
17:34:38 <Heffalump> well, makes the obvious derived one
17:35:02 <Heffalump> hmm.
17:38:20 <Pseudonym> There might be situations where you want different instances.
17:39:00 <Pseudonym> For example: newtype ListChar = ListChar [Char]
17:39:08 <Pseudonym> I might want to Show that as a list rather than as a String.
17:39:34 <Pseudonym> So at the very least you'd want to control it.
17:40:11 <Pseudonym> Perhaps extend the "deriving" keyword might work.
17:40:51 <Pseudonym> newtype MyIO a = MyIO (IO a) deriving (Monad, MonadIO)
17:41:38 <Heffalump> I think dark wants a different newtype for certain circumstances
17:41:46 <Heffalump> where he really just wants a type synonym, but with strong typechecking
17:42:19 <Heffalump> I thought about extending the deriving keyword, but I think the way tools like Drift extend the deriving keyword would conflict with that
17:42:19 <Pseudonym> Yes.
17:42:46 <Pseudonym> The thing is, I'm not so sure that those circumstances are everyone's circumstances.
17:43:03 <Pseudonym> In general, I want some inherited and some not.
17:43:17 <Pseudonym> One particularly useful case for this is:
17:43:30 <Pseudonym> class Foo a where { some methods }
17:43:50 <Pseudonym> newtype FOO = forall a. (Foo a) => FOO a  deriving (Foo)
17:44:03 <Pseudonym> Or maybe I really want Object Haskell here.
17:44:05 * Heffalump reckons two new "deriving" keywords are wanted
17:44:21 <Heffalump> "derivingfrombase Monad"
17:44:25 <Heffalump> and "derivingallfrombase"
17:44:32 <Heffalump> (or whatever)
17:44:52 <Heffalump> probably what you really want is a whole little language to put after the deriving keyword to explain what you want
17:45:09 <Pseudonym> At which point you might as well be using the big language.
17:45:16 <Heffalump> which big language?
17:45:20 <Pseudonym> Haskell. :-)
17:45:27 <Heffalump> no, it's sort of meta-code
17:45:39 <Heffalump> like the type class language, sort of
17:45:49 <Pseudonym> I want typeclass synonyms.
17:46:05 <Pseudonym> I have so much code that looks like this:
17:46:29 <Pseudonym> foo :: (Class1 a, Class2 a b, Monad m a) => blah -> blah -> blah
17:46:45 <Pseudonym> bar :: (Class1 a, Class2 a b, Monad m a) => baz -> baz
17:46:47 <Pseudonym> And so on.
17:46:58 <Heffalump> can't you just do
17:47:14 <Pseudonym> The constraints are sometimes longer than the type declarations themselves.
17:47:20 <Heffalump> class Class1 a, Class2 a b, Monad m a => MyS m a b where
17:47:23 <Heffalump> and then no functions
17:47:28 <Pseudonym> Not quite.
17:47:29 <Heffalump> and then
17:47:30 <Pseudonym> You need this:
17:47:39 <Heffalump> instance Class1 a, Class2 a b, Monad m a => MyS m a b where
17:47:43 <Pseudonym> Right.
17:47:44 <Pseudonym> I do that.
17:47:50 <Pseudonym> But they're undecidable instances.
17:47:54 <Heffalump> ah :(
17:48:10 <Pseudonym> Lucky I can do -fallow-undecidable-instances.
17:48:13 <Heffalump> presumably they're not if you just use SPTCs?
17:48:23 <Pseudonym> Probably not.
17:48:34 <Heffalump> well, I'd hope not, since that looks like it would be Haskell 98 then :-)
17:48:39 <Pseudonym> :-)
17:49:04 <Heffalump> is it still undecidable if you put some fundeps in?
17:49:21 <Pseudonym> So either I want undecidable instances to be ruled decidable under certain circumstances, or I want typeclass synonyms.
17:49:21 <Pseudonym> Possibly.
17:49:29 <Heffalump> cos it seems to me that the undecidability is coming from your MPTCs in the first instance
17:49:35 <Pseudonym> I usually don't want to constraing these things further, though.
17:49:45 <Heffalump> so if they have fundeps, then you should be able to lift those to the "synonym"
17:49:56 <Pseudonym> True.
17:50:00 <Heffalump> and if they don't, then your code is probably doomed to having undecidable instances anyway
17:50:40 * Heffalump shouldn't be awake, I have to give a tutorial at 10am
17:50:44 <Heffalump> (and it's nearly 2am now)
17:50:51 <Pseudonym> Ah.  Yes, sleep.
17:50:54 <Pseudonym> What's the tutorial on?
17:51:02 <Heffalump> Programming Languages
17:51:15 <Heffalump> fairly basic, beginning-of-the-course stuff
17:51:18 * Pseudonym nods
17:51:27 <Pseudonym> Should be easy to do on not enough sleep, then.
17:51:55 <Heffalump> yeah
17:51:58 <Heffalump> I just need to make sure I do wake up
17:52:07 <Pseudonym> Drink a large glass of water before bed.
17:52:19 <Pseudonym> A really large one.
17:52:22 <Heffalump> I'm not very good at that, since I don't generally need to get in to work at any particular time
17:52:25 <Pseudonym> I promise you'll get up.
17:52:25 <Heffalump> oh?
17:52:27 <Heffalump> oh, right :-)
17:52:29 <Heffalump> cunning.
17:52:33 <Pseudonym> Indeed.
17:52:43 <dark> Heh, I've done that.
17:52:53 <Pseudonym> Another possibility is to put chocolate covered coffee beans beside your alarm clock.
17:53:11 <Heffalump> I wouldn't wake up enough to eat them
17:53:14 <dark> Pseudonym: I'd eat those before sleeping, it would be a disaster.
17:53:18 <Heffalump> lol
17:53:21 <Pseudonym> You need to put those right beside the snooze button.
17:53:31 <Pseudonym> Yes, good point dark.
17:53:42 <Heffalump> my brain is *very* well trained at turning off my alarm clock whilst almost completely asleep
17:54:02 <Heffalump> anyway
17:54:05 * Heffalump heads bedwards
17:54:05 <Pseudonym> Try the water, then.
17:54:06 <Heffalump> night all
17:54:09 <Pseudonym> Night.
17:54:11 <Heffalump> will do :-)
18:14:06 <tez> Yes!  I've cleaned my out my inbox!
18:15:24 <tez> Now the only thing that needs sorting out is every other aspect of my life.
18:16:31 <Pseudonym> If only life had its own procmail.
18:16:46 <tez> "proclife"
18:17:06 <tez> The filters might be a bitch to set up though.
18:17:27 * Igloo finishes the cool graphicsy bit of my website and is getting desparately short of things to do before I have to write the actual text
18:17:39 <tez> lol
18:17:51 * Pseudonym laughs
18:17:57 <Pseudonym> I have no excuse.
18:18:02 * Pseudonym is married to a graphic designer
18:18:09 <Pseudonym> I don't get to do the graphics on my web site.
18:18:21 * Igloo is quite proud of http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/Haskell2LaTeX/8.png
18:18:29 <tez> So you're the Content Designer?
18:18:39 <Pseudonym> I wouldn't be proud of that URL if I were you.
18:18:42 <Igloo> But I don't think I want to know the graphic designers opinion  :-)
18:18:58 <Pseudonym> Oh, nice image though.
18:19:21 <Igloo> A bit big given it really wants to be inline, but hey  :-)
18:19:26 <Igloo> Thanks
18:19:41 <Pseudonym> If you shrink that down by a factor of two, the jaggies should go away.
18:19:53 <Pseudonym> And it should still be readable.
18:20:44 <tez> You seem to have an unusually high repect for quicksort...
18:21:11 <Igloo> HDYM, Tez?
18:21:31 <tez> Oh wait, that's just that one picture.  Nevermind.
18:21:47 <Igloo> Ermmm, OK  :-)
18:22:10 <tez> Oege is your supervisor?
18:22:15 <Igloo> Yup
18:22:16 <tez> He was my tutor :-)
18:22:18 * Heffalump fails to sleep
18:22:27 <Heffalump> tez: we've heard stories about you :-)
18:22:28 <Igloo> Oh, how long ago?
18:22:32 <Igloo> Have we?
18:22:36 <tez> Heffalump: What?!?
18:22:44 <Heffalump> tez: well, you didn't exactly do a lot of work...
18:23:19 <tez> Alright, I confess.
18:23:32 <tez> Is that the only "story"?
18:24:01 <Heffalump> it's the only thing I heard about you from Oege
18:24:30 <tez> Nothing too damning then :-)
18:24:31 <Heffalump> it was you and someone else that tried to run l0phtcrack in SSTCR too, wasn't it?
18:24:42 <Pseudonym> Heffalump, I suggest reading the Hughes arrow paper.
18:24:46 <Pseudonym> You'll be asleep in no time.
18:24:48 <Heffalump> lol
18:24:51 <Heffalump> I've read it before :-)
18:24:54 <Heffalump> I quite enjoyed it
18:25:10 <Pseudonym> Oh, even better.  Read the pretty printing library paper.
18:25:20 <Pseudonym> Now THAT'S long.
18:25:39 * Heffalump (partly) couldn't sleep for thinking about things he should do, so is doing some of them
18:25:55 <Igloo> I often make that mistake. Then I go to bed at 4am.
18:26:12 <Igloo> See also: The aforementioned image  :-)
18:26:19 <Heffalump> :-)
18:26:32 <Heffalump> Pseudonym: what do you have against the URL, btw?
18:27:01 <Pseudonym> Well, let me put it this way: If it weren't for cut 'n paste, I wouldn't have bothered.
18:27:19 <Pseudonym> In fact it's not as bad as it first looked.
18:27:24 <Heffalump> don't you do that with all URLs, though?
18:27:30 <Pseudonym> The bad line breaking made it look worse than it was.
18:27:44 <Heffalump> ah, irssi broke it nicely
18:27:54 * Igloo doesn't think many people will go straight there anyway
18:32:30 * shapr can't sleep
18:33:22 <Heffalump> want to write me a web system for recording information about tutorials? :-)
18:33:35 <shapr> Heffalump: Fle3 ?
18:33:53 <shapr> http://fle3.uiah.fi/
18:33:54 <Heffalump> that looks like complete overkill
18:34:13 <Heffalump> I just want to keep a record of when I do tutorials, who was there, how good their work was, and how the tutorial went
18:34:16 <shapr> ohh
18:34:35 <shapr> I thought you wanted to give tutorials via a browser
18:34:37 <Heffalump> mostly several bits of freeform text, that I can later group appropriately for writing reports or just checking on progress
18:34:40 <Heffalump> nono :-)
18:34:50 <Heffalump> that'd be far too modern for Oxford (and actually a silly idea IMO)
18:35:02 <shapr> you could use a wikiwiki
18:35:04 <shapr> that's what I would do
18:35:17 <shapr> I used emacs-wiki at the moment
18:35:19 <Heffalump> that wouldn't allow me to collate stuff automatically later
18:35:31 <shapr> what do you mean by collate?
18:35:38 <Pseudonym> shapr: Have you ported ghc to emacs yet?
18:35:48 <shapr> Pseudonym: no, but I want to port emacs to ghc
18:36:02 <shapr> Hemacs, by the power of Playskool!
18:36:03 <Pseudonym> Wouldn't Paul Graham love that.
18:36:10 <Heffalump> as in, have a page that says "tell me how all the tutorials in this subject for this person went"
18:36:18 <Pseudonym> Haskell finally reaches the maintainability of Lisp.
18:36:23 <shapr> Heffalump: you could do that
18:36:39 <shapr> as long as you used StudlyCaps for the people's names, and then you clicked on the title of their page.
18:36:48 <shapr> that's how you get reverse references in a wikiwiki
18:37:19 <shapr> well, it's not really want you want
18:37:19 <shapr> hmm
18:37:29 <Pseudonym> You actually have time to report on individual students for your tutorials?
18:37:42 <Heffalump> Pseudonym: there's only 1 or 2 in each tutorial
18:37:48 <Heffalump> maybe 3 sometimes
18:37:51 <Pseudonym> Oh, fair enough.
18:37:55 <Pseudonym> I regularly had 20.
18:37:59 <shapr> I'd like to have a tutorial.
18:38:01 <Heffalump> the Oxford tutorial system is quite manpower-intensive :-)
18:38:06 <Heffalump> Pseudonym: we call that a class
18:38:07 <Pseudonym> I see that.
18:38:08 * shapr signs up for one of Heffalump's tutorials
18:38:27 <Pseudonym> In Australia, we have classes of 500 and tutorials of 20.
18:38:36 <Heffalump> 500 would be a lecture
18:38:40 <Pseudonym> For first years, anyway.
18:38:46 <shapr> I've heard that Oxford's nearly one-on-one system is both expensive and productive
18:39:06 <Heffalump> shapr: I give tutorials in roughly the same way I explain things on here, when I get into explaining-mode
18:39:09 <Pseudonym> I think it's also college-intensive, though, right?
18:39:17 <Heffalump> shapr: it's certainly expensive, and it's probably productive
18:39:27 <Heffalump> Pseudonym: wdym by that?
18:39:28 <shapr> Heffalump: extraspiffy :-) I'd very much enjoy your tutorials then.
18:39:53 <Heffalump> shapr: my point was more that you've already either had or seen something very similar to one anyway
18:40:04 <Pseudonym> OK, let me ask: Who runs the lectures, classes and tutorials respectively?
18:40:21 <Heffalump> hmm, now it gets complicated.
18:40:30 <Heffalump> lectures are run by university lecturers.
18:40:36 <Pseudonym> Right.
18:40:50 <shapr> Oxford sounds like a "learners teach each other" kind of system
18:40:54 <Heffalump> classes are run by anyone the department can find to do it (usually postdocs or grad students or departmental lecturers)
18:41:15 <Pseudonym> With you so far.
18:41:32 <Heffalump> tutorials are run primarily by fellows, but also by college lecturers or anyone else that can be found to do them
18:41:41 <Pseudonym> Who organises them?
18:41:54 <Heffalump> lectures and classes are organised by the department
18:42:04 <Heffalump> tutorials by the college (usually by the fellow in that college)
18:42:11 <Pseudonym> Are all students part of a college?
18:42:14 <Heffalump> all fellows are also university lecturers
18:42:18 <Heffalump> yes
18:42:26 <Pseudonym> Right.  Different here.
18:42:27 <tez> Wht's the difference between a college fellow and a college lecturer?
18:42:39 <Heffalump> Oege is a college fellow, I'm a college lecturer
18:42:45 <tez> Ah
18:42:54 <Pseudonym> Colleges here are a cross between Oxford colleges and US dorms.
18:42:55 <Heffalump> (at Somerville, only from this year)
18:42:59 <Pseudonym> You don't have to be in a college.
18:43:50 <Heffalump> being a college lecturer is generally only a (very) part-time job - college lecturers are usually either postdocs or departmental lecturers too
18:43:57 <Pseudonym> College fellows here do diddly squat.  They're eminent alumni who turn up for a dinner once a year.
18:44:06 <Heffalump> confusingly though, only university lecturers actually give lectures
18:44:23 <shapr> are your tutorials as interactive as irc chats?
18:44:33 <Heffalump> in theory
18:44:43 <Heffalump> it's sometimes hard to stop the student just sitting there not saying much
18:44:54 <Heffalump> I tend to throw in random questions to keep them awake
18:44:59 <Pseudonym> It would be easier in a class of 3 or so, I would think.
18:45:06 <Heffalump> yes, definitely
18:45:07 * shapr was never good at being quiet and receptive in class
18:45:12 <Pseudonym> That was my average class size as a college tutor.
18:45:28 <Heffalump> I'll be giving classes for functional programming from next week, either two classes of 6 or one of 12
18:45:28 <Pseudonym> As a university tutor (taking what you would call "classes") it was harder.
18:45:33 * Igloo was never good at being noisy
18:45:38 <Heffalump> I intend to ask random people to answer questions to keep them awake
18:45:41 <Heffalump> igloo: in tutes?
18:45:47 <Igloo> In classes
18:45:50 <Igloo> And more so in lectures
18:46:03 <Heffalump> well, it's not really expected in lectures
18:46:15 <Heffalump> in classes it'd be nice if it happens, but it's usually hard to make it do so
18:46:18 <shapr> I used to irritate my teachers so much they would throw chalk at me.
18:46:28 <Heffalump> I've only ever managed to make functional programming classes even vaguely interactive
18:46:50 <shapr> do the students plead referential transparency?
18:47:12 <Heffalump> actually, I think the fact that functional programs are built up in small blocks is one of the major reasons I can make them interactive
18:47:22 <Heffalump> because I actually can just sort of guide them into doing the right thing
18:47:39 <Pseudonym> I find lab classes much more fun for teaching functional programming.
18:47:56 <Heffalump> I would if ours didn't use hugs
18:48:07 <Heffalump> I used to spend all my time helping people with layout errors
18:48:11 <shapr> why can't you use GHC?
18:48:15 <tez> Heffalump: I remember you marking one of my practicals :-)
18:48:24 <shapr> emacs + ghc would let you do Network stuff in lab
18:48:29 <Pseudonym> Well last time I taught a lab class we used Miranda.
18:48:29 <Heffalump> the last time I demonstrated in them was 2 years ago, at which point ghci didn't really exist
18:48:39 <Pseudonym> This was some time ago.
18:48:49 <Heffalump> tez: IIRC you just turned up with it to be marked, rather than wanting help, though :-)
18:49:14 <shapr> the #haskell world feels very small and well connected :-)
18:49:23 <Heffalump> hehe
18:49:29 <Heffalump> it is rather incestuous
18:49:45 <tez> Yorke doesn't ever hang out here, does he?
18:49:49 <Heffalump> there's the Chalmers cabal, the Oxford cabal, the UNSW cabal
18:49:55 <Heffalump> Yorck? no.
18:50:03 <tez> Oops, that's the spelling.
18:50:09 * shapr hopes to join the Chalmers cabal at some point
18:50:34 <Heffalump> oh, and the shapr cabal, though we haven't seen delYsid for a while :-)
18:50:37 * shapr grins
18:50:40 <Pseudonym> There's a developing Melbourne cabal, actually.
18:50:47 <Pseudonym> Mostly Bernie Pope.
18:50:49 <shapr> maybe just the irc cabal ;-)
18:50:59 <shapr> we're the metacabal
18:51:12 * Pseudonym tutored Bernie Pope once, actually
18:52:36 <Pseudonym> Oh, on #haskell.
18:52:48 <Pseudonym> The Melbourne group on #haskell is just me and clausen.
18:52:50 <shapr> I really am convinced that commercial software could dramatically improve its quality by using Haskell and QuickCheck
18:53:17 <shapr> and I have no problems telling that to people that I know.
18:53:39 <Heffalump> I think you somewhat overestimate the usability of Haskell for many tasks.
18:53:42 <Pseudonym> Haskell software could dramatically improve its quality if we had coverage testing tools.
18:53:51 <Heffalump> hmm, yes
18:54:12 <shapr> maybe I'm overestimating... I won't know till I try.
18:54:31 <shapr> it's true that debugging Haskell is nearly impossible
18:54:42 <Heffalump> actually, debugging Haskell isn't too bad
18:54:48 <shapr> but I rarely need debugging, since I do unit-test-first aka test-driven-development
18:54:51 <Heffalump> trace is good
18:55:10 <Pseudonym> One problem I have with QuickCheck is modularity.
18:55:21 <shapr> what areas/ways do you think Haskell usability falls short?
18:55:36 <Pseudonym> I've found I need to expose hidden interfaces in order to make something work with QuickCheck.
18:55:43 <Heffalump> well, the tools aren't robust enough
18:55:55 <Heffalump> Pseudonym: can't you put the internal tests inside the module?
18:56:03 <Heffalump> surely the external tests shouldn't need to use hidden interfaces
18:56:30 <Pseudonym> I can, but a) I can't switch them off for production code, and b) I still need some way to run them from QuickCheck.
18:56:46 <Pseudonym> i.e. I still need to expose "runInternalTests".
18:56:53 <Pseudonym> Or whatever.
18:57:29 <shapr> I've seen a paper on debug Monads
18:58:03 <shapr> though it's effectively "if DEBUG"
18:58:18 <Pseudonym> I've written a simple one for printf-style debugging.
18:58:44 <Pseudonym> It's damn easy.  You just instance MonadIO for an identity-style monad.
18:58:49 <shapr> Heff: any examples of not robust enough?
18:58:51 <Heffalump> Pseudonym: can't you just run the quickcheck script on the module itself?
18:59:00 <Heffalump> shapr: the compiler bug you ran into with WASH-CGI
18:59:10 <Pseudonym> Heffalump: You need to expose properties.
18:59:12 <Heffalump> I've run into some similar ones off and on too
18:59:27 <Heffalump> Pseudonym: oh, ok <thinks> oh, of course you would </thinks>
18:59:34 <shapr> that's a good point
18:59:41 <shapr> GHC needs unit tests
18:59:45 <Pseudonym> Yes.
19:00:03 <shapr> I found an inet_ntoa bug when I patched HWS
19:00:14 <shapr> that one's also fixed in 5.04.2
19:00:20 <Heffalump> oh, and space leaks are a real killer for large-scale Haskell programming
19:00:27 <shapr> Arrows can fix that ;-)
19:00:38 <shapr> I've been rereading that paper again.
19:00:42 <Heffalump> how??
19:00:56 <Pseudonym> People don't use strict constructors enough.
19:01:02 <shapr> Arrows make dependence on input explicit
19:01:13 <Heffalump> hmmm.
19:01:22 <Heffalump> Pseudonym: that's not the only cause, though
19:01:26 <Pseudonym> I'm with Chris Okasaki on this one.  In data structure programming, you shouldn't use lazy evaluation unless you mean to.
19:01:30 <Pseudonym> Oh, absolutely.
19:01:36 <Heffalump> if it was the GHC team wouldn't have spent huge amounts of time tracking down space leaks
19:01:37 <shapr> at least for the parsers, that lets you know when to dump, and when to save, input for further code
19:01:54 <Heffalump> the other major problem with Haskell is that it's *difficult*
19:02:01 <shapr> yes, that's true.
19:02:10 <shapr> but...
19:02:20 <shapr> you sure get a lot of power when you figure it out.
19:02:28 <Heffalump> the majority of programmers simply aren't good enough to cope with it, I suspect, even if training methods are changed from the ground up
19:02:28 <Pseudonym> Similar to C++ in many respects.
19:02:35 <Pseudonym> C++ programming is difficult, too.
19:02:41 <Pseudonym> In precisely the same ways.
19:02:41 * shapr hasn't tried C++
19:03:02 <Heffalump> Haskell does have the advantage that you can have the good people do the complicated bits (e.g. programming the combinator library) and have the less good people do the less complicated bits
19:03:04 <Pseudonym> There's a big difference though: Lots of people have written different kinds of C++ programs, so there's engineering experience.
19:03:22 <shapr> yah, I've noticed that lack in Haskell
19:03:34 <shapr> for example, I'm thinking about Arrow Transformers....
19:03:36 <Heffalump> well, that's something that could be overcome by it being used more
19:03:44 <Heffalump> as could the lack of libraries for Haskell
19:03:55 <dark> The hierarchical module namespace should help a lot there.
19:04:03 <dark> With library availability, I mean.
19:04:07 <Pseudonym> Haskell doesn't have a lot of engineering experience, and the little that we do have is written by academics with research quotas to fill, not engineers interested in raising a new generation of programmers.
19:04:13 <shapr> so I think I'm going about this the right way... I'm trying to write commercial apps in Haskell.
19:04:30 <dark> I'm writing freeware apps in Haskell for a similar purpose :)
19:04:59 <Pseudonym> I've also noticed that there's an undercurrent in the Haskell community which seems _against_ engineering experience.
19:05:06 <Pseudonym> You say "design patterns" and people run screaming.
19:05:11 <shapr> really?
19:05:15 <shapr> there's a design patterns paper
19:05:20 <shapr> gives some neat Haskell tricks.
19:05:23 <Pseudonym> Strafunski?
19:05:27 <shapr> yup, that's it
19:05:38 * Heffalump went to a talk by Ralf Laemmel about that kind of thing
19:05:45 <shapr> Pseudonym, you wrote some of the neat engineering experience wiki pages
19:05:45 <Pseudonym> Yes, but Strafunski isn't standard Haskell.
19:05:52 <Pseudonym> Thanks. :_)
19:05:53 <Heffalump> twas nice, but it did seem a bit ad-hoc
19:05:58 <shapr> which I wish would get fixed :-/
19:06:03 <Pseudonym> Me too.
19:06:06 <shapr> dam that wiki breaking, I want to learn that stuff!
19:06:06 <Pseudonym> I have more to write.
19:06:23 <Pseudonym> This was all gained on writing my own medium-sized project, too.
19:06:29 <dark> Oh, the reason I came back to the channel: is there _any_ way to tell if a filename is a symbolic link?  Both PosixFiles from hslibs and GHC.Posix seem to omit that check.
19:06:40 <Pseudonym> Which unfortunately is currently sitting on a hard drive which is not plugged into a machine at the moment.
19:06:45 <shapr> dark, it's 5am here, you should be asleep :-)
19:06:59 <dark> shapr: Same to you :)
19:07:08 * shapr is being hypocritical, it's true
19:07:23 <Pseudonym> What is best for shapr may not be best for dark and vice versa.
19:07:33 <shapr> that's true
19:07:51 <shapr> I couldn't sleep... monad transformers chasing each other around in my dreams
19:08:09 <dark> I didn't even consider sleep yet, this is my normal schedule now :)
19:08:33 <shapr> my woman gets unhappy when she doesn't see me before noon.
19:08:43 <Pseudonym> Your woman is a morning person?
19:08:46 <dark> My woman can come look at me while I sleep if she likes :-)
19:08:55 <shapr> hah
19:09:04 <shapr> yes, my woman is a 7:30am kind of person
19:09:09 <Pseudonym> Now there's a recipe for disaster.
19:09:20 <shapr> sometimes I make coffee for her before I go to bed.
19:09:30 <dark> Anyway, why are symlinks being discriminated against?
19:09:41 <Pseudonym> I'm an afternoon person but my woman is a night person.
19:09:51 <Pseudonym> I get up at 10am, she gets up around 3pm.
19:10:04 <shapr> very sensible.
19:10:06 <dark> I suppose I could decide it's a symlink if it's not any of the other types.
19:10:10 <shapr> 3pm, that is
19:11:34 <shapr> it looks to me like Haskell is on the verge of becoming commercially viable
19:11:42 <shapr> stuff like unit tests would really help
19:11:48 <Heffalump> dark: there's no lstat equivalent in the libraries?
19:12:53 <Pseudonym> I wish the guys at Galois Connections had more time to write about what they find.
19:14:14 <dark> Heffalump: GHC.Posix exports the raw C one, but it's not much use without a way to check the mode.
19:14:24 * Igloo thinks about putting #haskell in my contact section  :-)
19:14:26 <Heffalump> ah
19:14:44 <Heffalump> igloo: or "/msg on OxIRC" :-)
19:15:59 <Pseudonym> shapr: The suggestion was made a little while ago to put a #haskell entry in the communities report.
19:16:07 <Heffalump> that is happening, isn't it?
19:16:15 <Pseudonym> Is someone doing it?
19:17:01 <dark> Oh, cool!  readlink is in Network.BSD.  It's a symlink if that works, I guess.
19:17:50 <Heffalump> isn't that also true if lstat works?
19:18:41 <dark> Heffalump: No, lstat works like stat on non-symlinks.
19:18:52 <shapr> I like the idea of #haskell communities entry
19:19:08 <shapr> I don't know if anyone is doing it
19:19:41 <Heffalump> dark: ah, ok
19:19:49 <dark> is_lnk <- catch (readlink >>= \_ -> return True) (\_ -> return False)
19:19:51 <dark> Evil.
19:20:07 <Heffalump> all cos symlinkness isn't in the modes Haskell understands?
19:20:11 <shapr> was there a message on haskell or cafe about the #haskell entry?
19:20:37 <dark> Heffalump: Yup.
19:21:11 <Igloo> I'm sure there was an easier way than that
19:22:12 * shapr thinks about relevant #haskell info
19:23:20 * shapr is tempted to do a hostile takeover of the HaskellWiki
19:23:49 <shapr> hi Chilli
19:24:02 <Pseudonym> G'day.
19:24:19 <Igloo> Oh, I remember, I patched GHC
19:24:30 <shapr> yah, easier :-)
19:24:36 * shapr grinss
19:24:41 <ChilliX> re
19:24:48 <Igloo> I have a feeling the BSD stuff wasn't there at that point
19:25:39 <Heffalump> hmm, so you claim patching GHC is easier than dark's is_lnk? :-)
19:26:01 * Igloo finishes my webpage with 35 mins left to hang up washing, brush teeth and go to bed
19:26:40 * Igloo waves to chilli and goes to do so
19:26:50 <ChilliX> cu Igloo
19:27:00 <Pseudonym> Night.
19:27:18 <shapr> g'night Igloo
19:28:11 * shapr needs to read the Yampa paper
19:28:41 * shapr tries to sleep again
19:31:32 <Pseudonym> Lunch for me.
19:31:52 <dark> Hmm, I have an list [IO (Maybe a)], and I'd like to return the first Maybe a that's not Nothing.
19:32:19 <dark> I would like to not evaluate the elements after that, because they're expensive IO.
19:32:54 <dark> I don't know enough about laziness to know if I can just take the head of catMaybes . sequence
19:33:16 <Heffalump> I'm pretty certain you can't
19:33:41 <Heffalump> because the laziness of sequence will depend on the laziness of bind, and in IO it's not lazy
19:33:46 <Heffalump> (unless I'm really confused)
19:36:56 <dark> Right... sequence is a foldr, so I can't get the first element without evaluating all of the list.
19:37:22 <Heffalump> well, you could if bind was lazy
19:38:26 <dark> But I could use foldl to make this work, right?
19:38:55 <Heffalump> umm
19:39:00 <Heffalump> I was just trying to work out if that's the case
19:39:39 <Heffalump> I think not, cos foldl is fundamentally unlazy, even if the thing you're folding with is lazy
19:39:56 <Heffalump> foldl f e (x:xs) = foldl f (f e x) xs { or something v. similar }
19:40:10 <Heffalump> so you won't get /any/ result until you get to the end of the list
19:40:37 <Heffalump> foldr f e (x:xs) = f x (foldr f e xs), so you get a result before getting to the end of the list if f is lazy in its second argument
19:47:33 <dark> foldr (\a r -> maybe r Just a) Nothing attempts
19:47:41 <dark> Haven't compiled it yet :)
19:48:56 <dark> Hmm, no, it looks wrong :)  I need a return somewhere in there.
19:50:58 <Heffalump> getfirst :: [IO (Maybe a)] -> IO (Maybe a)
19:51:06 <Heffalump> getfirst [] = return Nothing
19:51:12 <Heffalump> getfirst (x:xs) = do v <- x
19:51:26 <Heffalump>                      case v of
19:51:37 <Heffalump>                       Just e -> return (Just e)
19:51:46 <Heffalump>                       Nothing -> getfirst xs
19:51:52 <Heffalump> ok, so that's an obvious foldr
19:52:24 <dark> While you did that, I was tinkering with:
19:52:32 <dark> foldr (\a r -> a >>= return . maybe r Just) Nothing attempts
19:53:08 <Heffalump> I think if you have (return Nothing) instead of Nothing it might work
19:53:19 <Heffalump> oh, no
19:53:44 <dark> a is the head action, r is the result of the tail.  So r is a Maybe, not an IO.
19:54:01 <dark> *scratch*
19:54:06 <Heffalump> no, r needs to be an IO (Maybe a)
19:54:14 <Heffalump> cos the final result needs to be an IO (Maybe a)
19:54:18 <Heffalump> you can't escape IO that easily :-)
19:54:27 <dark> Heh :)
19:55:13 <Heffalump> foldr (\a r -> a >>= maybe r (return . Just)) (return Nothing)
19:55:23 <Heffalump> has the right type and looks right to me
19:55:50 <dark> Cool :)
19:56:05 <dark> Now the question is, would it be better to write it out as a function anyway :)
19:56:06 <Heffalump> I'm still not 100% certain about sequence not working, though
19:56:12 <dark> Other people might have to read this.
19:56:14 <Heffalump> have you actually checked?
19:56:16 <Heffalump> heh
19:56:36 <dark> Heffalump: I didn't check, but I'm fairly sure you're right about it.  Otherwise sequence_ couldn't work.
19:56:53 <dark> Because IO implements >> as just >>= \_ ->
19:57:30 <Heffalump> hmm.
19:57:41 <Heffalump> but any monad can implement >> that way
19:58:35 <dark> Hmm.
19:59:10 <Heffalump> anyway, bed, since I intend to be up in 4 hours or so
20:01:41 <dark> It doesn't seem to be lazy.
20:01:57 <dark>   test <- sequence $ replicate 10 $ putStrLn "foo"
20:01:57 <dark>   putStrLn (show (take 5 test))
20:02:01 <dark> This prints 10 foos
20:02:26 <dark> And then [(),(),(),(),()]
20:05:32 <Heffalump> right.
20:05:46 <Heffalump> so that implies catMaybes . sequence definitely isn't what you want
20:06:57 * Heffalump really --> bed
20:07:02 <dark> Sleep well :)
20:18:17 <ChilliX> as Heffalump said, IO is a strict monad
20:18:27 <ChilliX> this is why you see 10 foos
20:20:01 <dark> I wrote out a recursive definition instead :)
20:20:14 <dark> I ended up calling it firstJustM, but I'm not very happy with that name.
20:21:57 <ChilliX> I think, in fact, writing you own recursive def is the most reasonable thing to do
20:22:52 <ChilliX> reason being that all the precanned ops like fold always traverse the whole list
20:22:52 <ChilliX> so, you would need a case distinction in folding function, which would make it quite ugly
20:27:06 <dark> Hmm, right.  The folding version would still run the (return . Just) computation for every element in the list.
20:27:12 <dark> Even if the first one worked.
20:29:34 <dark> Anyway, with firstJustM my function is a lot nicer :)  Instead of a precariously nested pile of if-then-else and do, it's a series of try_foo function definitions followed by firstJustM.  Much flatter.
20:32:48 <ChilliX> :t dark
20:32:56 <ChilliX> oops
20:34:43 <dark> You were asking ghci for my type? :)
20:35:27 <ChilliX> well, I think I just had some random neurons firing in my brain
20:35:59 <ChilliX> kind of two threads in my brain being mixed up
20:36:14 <ChilliX> one ran the discussion with you and the other did Haskell stuff
20:36:20 <dark> I sometimes have that.  I'm coding, my mind wanders, and when I look back there's the weirdest stuff in my editor buffer.
20:36:21 <ChilliX> you saw the result...
20:37:15 <dark> Once there was even a proof of P=NP, but I misclicked and accidentally didn't save it.
20:37:17 <ChilliX> I am happy to hear that it is not only my brain, which is screwed up ;)
20:37:28 <ChilliX> What a pity!
20:38:01 <ChilliX> But at least *you* now know that P=NP; even if you can convince the rest of us.
20:38:08 <dark> Heh :)
20:38:13 <ChilliX> can = can't
20:39:21 <dark> I shall use this knowledge to further my quest for World Domination!
20:40:04 <ChilliX> hehehe
20:45:13 <Pseudonym> For Haskell 2, some work needs to be done on the Maybe type, I think.
20:45:34 <Pseudonym> We have all these monad interfaces now that Maybe conforms to.
20:46:19 <Pseudonym> Plus, Maybe is overused in return values where Monad fail would make more sense.
20:46:21 <dark> Hmm my morning cron jobs just fired.  This is a sign that I should go to bed :)
20:46:26 <Pseudonym> :-)
20:46:51 <dark> Pseudonym: It's also underused sometimes :)  getEnv should return Maybe String instead of throwing an exception.
20:47:34 <Pseudonym> Does getEnv use IO?
20:47:37 <dark> Yeah.
20:47:41 <Pseudonym> In that case:
20:47:53 <Pseudonym> getEnv :: (MonadIO m) => String -> m String
20:48:09 <Pseudonym> You get the best of both worlds that way.
20:48:10 <dark> How would you use it?
20:48:35 <Pseudonym> Well, you could just call it in an IO context and it would throw error.
20:48:46 <Pseudonym> Or you could use a monad transformer around IO if you want to catch the error.
20:49:31 <dark> Actually... what I would usually want is a getEnvDefault function :)
20:49:40 <dark> tmpdir <- getEnvDefault "/tmp" "TMPDIR"
20:50:26 <ChilliX> yeah, that's useful
20:50:46 <Pseudonym> Or you could make a generic one.
20:51:01 <dark> Pseudonym: A generic defaulting function?
20:51:06 <Pseudonym> ioDefault :: (MonadIO m) => m a -> a -> IO a
20:51:28 <Pseudonym> Uhm...
20:51:36 <dark> io specific because catch is IO?
20:51:37 <Pseudonym> No, you need to use a monad where fails are catchable.
20:51:46 <Pseudonym> Actually, that would be a useful interface.
20:52:02 <dark> I think the IO return type does that.
20:52:03 <Pseudonym> MonadCatch
20:52:13 <dark> Or, you'd want to be able to stay in m?
20:53:13 <dark> Pseudonym: You said "interface" instead of "class".  That's a sign of heretical Java thought processes :)
20:54:08 <Pseudonym> :-)
20:54:11 <dark> Actually I could use an IO-based defaulting function right now.
20:54:17 <dark> Maybe I'll define one and clean up some code :-)
20:54:23 <Pseudonym> No, interfaces are very Haskell.
20:54:31 <Pseudonym> Module interfaces, for example.
20:55:22 * Pseudonym loves typeclasses
20:55:37 <Pseudonym> I like being able to add interfaces to an object in places other than where the object is defined.
20:55:49 <dark> Yeah...
20:55:57 <dark> but sometimes I wish I could go back and make a function a class function.
20:56:07 <dark> Like "map" :-)  "fmap" is obviously a workaround.
20:56:19 <dark> I guess that would make it too difficult for the compiler.
20:56:41 <Pseudonym> Yes.
20:57:04 <Pseudonym> There's always module-based overloading.
20:57:19 <Pseudonym> I think in retrospect, having a standard Prelude was a mistake.
20:57:34 <dark> I was surprised that Functor didn't have a filter function.
20:57:47 <Pseudonym> There's a good reason for that.
20:57:58 <Pseudonym> The functor may not have a zero.
20:58:22 <dark> Hmm, I think GHC is very happy with having a standard Prelude, for some of its low-level transformations.
20:58:46 <Pseudonym> Yes, you're probably right there.
21:02:05 <dark> But maybe the standard prelude could have been much smaller :)
21:02:37 <dark> Hmm, no... it would still need Int and Integer and Ord and Eq to be useful.
21:02:44 <dark> And that pulls in a lot of stuff.
21:03:55 <dark> And maybe even IO, to keep the compiler sane.
21:04:30 <dark> On the other hand, it would be cool to be able to define a new IO monad.
21:04:43 <dark> I'm unhappy with the IOError type, for example :-)
21:05:27 <Pseudonym> DEFNITELY
21:05:38 <Pseudonym> IOError == wrong
