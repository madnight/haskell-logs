00:59:39 <BlizzNL> Is 'Monads for functional programming' by Wadler the best introductory read on monads?
01:00:42 <Chilli> depends what you want to do
01:01:17 <Chilli> SPJ's Tackling the Awkward Squad is very good when you want to now how to do IO, concurrency, exceptions, etc using monads
01:01:17 <Marvin--> I still hold that "Monads for the working haskell programmer" is a very good introduction
01:01:22 <Marvin--> at least for state monads
01:01:32 <Marvin--> yeah, that one's good too
01:01:46 <BlizzNL> Marvin--, Chilli: ok thnx
01:03:39 <Marvin--> Imperative functional programming is pretty good too
01:04:46 <BlizzNL> Marvin--: I am reading that one at the moment
01:27:11 * BlizzNL is back into the world of linux and wonders if there is a editor with haskel syntax for linux?
01:28:09 <Marvin--> you're kidding, right?
01:28:31 <Marvin--> both vim and emacs have excellent haskell support
01:29:32 <BlizzNL> Marvin--: I'm not that funny ;)
01:30:08 <Marvin--> maybe nedit does it too, I don't know
03:02:57 * shapr spills guarana extract on himself
03:03:02 <shapr> my pants are now awake.
03:09:58 <shapr> hoi! hoe gaat het met je?
03:10:11 <dark> Het gaat prima :)
03:10:38 <shapr> ik ben een buitenlander!
03:10:45 * shapr snickers
03:10:48 <dark> Heh.
03:10:52 <shapr> dutch is spiffy
03:11:02 <BlizzNL> haha cool
03:11:13 <BlizzNL> shapr: nog boerenkool gegeten?
03:11:16 <dark> I'v always liked how dutch divides the world into "the in-country" and "the out-country", as if they're just two places.
03:11:32 * Marvin-- mutters something about pindasaus
03:11:39 <BlizzNL> dark: what do you mean?
03:11:47 <dark> BlizzNL: "het buitenland"
03:11:56 <dark> BlizzNL: a term covering all of the world except for NL :)
03:11:56 <shapr> buitenlander meaning "out land" I tihnk
03:12:02 <shapr> right, uit land
03:12:13 <dark> shapr: "buiten" means "outside"
03:12:17 <shapr> BlizzNL: sadly, you've just heard all the dutch I know :-)
03:12:23 <BlizzNL> dark: ahh ok we do ;)
03:12:31 <shapr> well, except for kikke and some other stuff
03:13:00 <BlizzNL> I think 'gaaf' or 'vet' are the duds words for cool
03:13:12 <shapr> yah, gaaf
03:13:21 <dark> I thought 'vet' was outdated by now...
03:13:53 <shapr> I used to date this girl who would say "wat loek" and "guhveldig(sp?)" a lot
03:14:01 <shapr> she was from groningen
03:14:03 <dark> shapr: "wat leuk" perhaps?
03:14:19 <shapr> yah, that one
03:14:28 <shapr> :)
03:14:31 <dark> shapr: Groningen native, or Groningen student?
03:14:44 <shapr> I think she was an utrecht native and student at RuG
03:14:55 <BlizzNL> dark: yes I think it is
03:15:22 <BlizzNL> shapr: you mean 'wat leuk' and 'geweldig'
03:15:25 <shapr> aha
03:15:30 <shapr> yes, that sounds like it
03:15:34 <dark> shapr: Well those are the two most fun cities in NL :-)
03:15:43 <shapr> oh, cool...
03:16:03 <shapr> I've never been to .nl, I hope to spend some time there at some point.
03:16:06 <dark> Of course there are people from Amsterdam who pretend otherwise, but... they're from Amsterdam.
03:16:11 <shapr> hah
03:18:27 <shapr> there's a running joke on comp.lang.python that dutch is the secret language of Python programmers.
03:18:29 * Marvin-- has been to Amsterdam and Tilburg
03:18:43 <Marvin--> sorry, Tilburrcccchcchc
03:18:50 * shapr snickers
03:19:05 <Marvin--> <insert gagging noise here>
03:19:10 <shapr> the dutch "g" sound is my favorite
03:19:24 <shapr> I like to say "graag gedann" with lots of gutturals.
03:19:27 <dark> shapr: In the south it softens and becomes very sexy.
03:19:41 * dark goes to Limburg to meet girls.
03:19:53 <shapr> my fiancee spent several years in Leuven learning Flemish
03:19:59 <BlizzNL> shapr: its 'graag gedaan' which means 'you're welcome'
03:20:15 <shapr> yah, I know what it means, but it's so much fun to *say* it
03:20:23 <shapr> lots of "gggg"
03:20:38 <dark> BlizzNL: Actually it would be a pretty strange response to "Can I come in?" :)
03:20:53 <BlizzNL> shapr: flemish doesn't exist. It's definately dutch. 
03:21:15 <dark> Groningse grachtgravers graven graag gave grachten.
03:21:15 * shapr laughs
03:21:24 <BlizzNL> BlizzNL: in some contexts it is
03:21:24 * shapr blows a vocal cord trying to say that
03:21:36 <BlizzNL> dark : where are you from?
03:21:42 <dark> "A language is just a dialect with an army"
03:21:48 * shapr laughs
03:21:50 <shapr> cute quote
03:22:36 <dark> BlizzNL: It's hard to say :)  I'm Dutch, but I didn't spend my childhood there.
03:22:46 <shapr> where did you spend your childhood?
03:22:47 <dark> I went to the RuG though.
03:23:01 <shapr> rijks wheee
03:23:06 * shapr also like ij
03:23:12 * shapr has the middle name of "matijs"
03:23:17 <BlizzNL> dark: i see , but occupied in Finland
03:23:27 <dark> shapr: Indonesia, Oman, Texas :)  My father worked for Shell.
03:23:33 <shapr> spiffy!
03:23:55 <dark> BlizzNL: Yeah, I moved here to get a free software job and to meet girls.
03:24:07 <shapr> nice
03:24:15 <shapr> especially the girls
03:24:21 <BlizzNL> dark: why the Finnish girls are the best? ;)
03:24:21 <dark> shapr: There's a piece of water called Het IJ :)
03:24:57 <shapr> BlizzNL: have you been to Helsinki?
03:25:32 <BlizzNL> No've never been to any scandinavian country
03:25:35 <dark> BlizzNL: I don't know why, I think it's the saunas :)
03:25:45 <BlizzNL> dark : haha
03:26:04 * shapr snickers
03:27:19 <dark> Finnish people grow up without any delusions about what other people look like naked.  That must mean something.
03:27:34 <shapr> they're less repressed sexually
03:32:22 <shapr> Finnish women fit the US American idea of "blonde bombshell" rather well.
03:32:38 <shapr> strangely, dark-haired women are the beauty ideal here.
03:32:42 * shapr will never understand that
03:32:52 <dark> I don't see that many blond ones, actually.
03:33:03 <dark> But my definition of "blond" is known to be unusual :)
03:33:10 <shapr> albino? ;)
03:34:20 <dark> Not that far :)  But I don't consider hair to be blond if it's more brown than yellow.
03:35:08 <shapr> here in Tornio there is much blonde
03:35:12 * Marvin-- hates squeak
03:35:25 <shapr> what's bad about squeak?
03:35:36 <Marvin--> where do I start?
03:35:41 <shapr> I'd be happy to learn squeak if it would run as an emacs inferior process
03:35:50 <shapr> otherwise, it's not happening.
03:36:01 <Marvin--> I don't agree with IDEs that don't integrate with the rest of the world
03:36:11 <shapr> ok, that I agree with.
03:36:16 <shapr> that's my problem with squeak
03:36:26 <dark> Hmm, is there a simple way to get a random Int out of the standard IO gen?  I keep making random_int functions so that I can add a type signature.
03:36:28 <Marvin--> The *minimum* requirement I have on an IDE is that it exports to text files
03:36:37 <shapr> hi ChilliX
03:36:46 <ChilliX> Hi shapr
03:36:49 <shapr> how's life?
03:37:15 <Marvin--> The second thing that bothers me with squeak is the window-in-window GUI, that sucks bigtime. The third thing is that they have their own window management. I have configured my window manager for a reason, dammit
03:37:24 <shapr> yah, same here
03:37:26 * shapr prefers ion
03:37:40 <shapr> I like to use emacs inside ion
03:37:49 <shapr> squeak does not fit that usability profile
03:38:08 <Marvin--> squeak does not fit ANY usability profile in my world
03:38:22 <shapr> it's really cute
03:38:23 <Marvin--> is it possible at all to design classes in a top-down way?
03:38:29 <dark> So... don't use it :)
03:38:41 <Marvin--> dark: I have to! I'm correcting smalltalk assignments!
03:38:50 <shapr> I wish Self had been non-SPARC specific
03:38:51 <Marvin--> The "load project from file" is a *joke*
03:39:03 <shapr> I could have specialized in Self
03:39:18 <shapr> especially with the collaborative programming parts of it.
03:39:51 <shapr> smalltalk has an image problem
03:40:04 <dark> shapr: s/image/attitude/ :-)
03:40:26 <shapr> actually, that's a joke on Smalltalk Image files
03:40:48 <shapr> that's the problem marvin is having
03:40:53 <dark> shapr: By the way, what was the name of that data exchange language you were playing with?  The one that proudly isn't XML :)
03:40:59 <shapr> um
03:41:01 <shapr> YAML?
03:41:07 <dark> Yeah, that one :)
03:41:20 <shapr> it's like a typed whitespace significant XML
03:41:31 <dark> I need to promote it more, but that's hard without knowing the name :)
03:41:37 * shapr grins
03:41:37 <shapr> truly
03:46:44 * shapr tries to figure out how to resend stuff that's in his outbox
03:46:46 * BlizzNL just received a 90CM Tux as a gift because I subscribes to a dutch linux magazine! Damn I need to give up smoking.. pfft pfft
03:46:50 <shapr> any gnusers here?
03:47:00 <shapr> yay Tux!
03:53:22 * shapr discovers how to resend email from gnus
03:56:24 * dark kicks System.Directory for distinguishing between renameFile and renameDirectory.
03:56:41 * dark wanders over to the posix package.
03:56:41 <shapr> they're just talking abouth that kind of stuff on ghc-users
03:56:58 <dark> shapr: Hmm, maybe I should get off my ass and subscribe :)
03:57:24 <shapr> there's some fun stuff on the haskell mailing lists
03:59:28 <Marvin--> AAAAAAAAAAAAARGH
03:59:34 <shapr> marvin: having fun?
03:59:36 <dark> I'm tempted to get rid of my use of Handle entirely, and use the posix functions for everything.
03:59:43 <Marvin--> Wouldn't it be nice if squeak had *sorted* the file names in the open dialog?!
03:59:53 * Marvin-- sobs
04:00:07 <dark> Marvin: You missed a bunch of files?
04:01:05 <ludde> Marvin--: don't you like squeak's rotated windows capability? ;) does your window manager have that?
04:01:25 <Marvin--> dark: no, but I have plenty of dot-files in my home directory, do you think it's easy to find the right directory then?
04:05:55 <dark> sequence_ [ rename (from ++ "/" ++ f) (to ++ "/" ++ f) | f <- files ]
04:05:57 <dark> Evilness.
04:06:27 <dark> Looks better than mapM_ though :-)
04:06:37 <Marvin--> heh
04:13:23 <dark> Is there any way to make an operator that binds stronger than function application?
04:14:07 <ChilliX> no
04:14:28 <ChilliX> but you can use $ for function application that binds really weakly
04:16:55 <dark> Yeah but I think I'm overusing it :)  My code is littered with $'s
04:17:20 <Marvin--> mine too, people laugh at me ;)
04:17:33 <shapr> I use $ lots also
04:17:52 <Marvin--> I don't want my code to degenerate into Lots of Irritating Silly Parentheses
04:18:10 <shapr> yah, same here
04:20:20 <ChilliX> $ is good
04:20:23 <ChilliX> :-)
04:21:40 <ludde> heh, LISP :P
04:28:16 <Heffalump> . can help with that too
04:28:37 <dark> Heffalump: Usually, you need to add parentheses to use .
04:28:40 <dark> So that defeats the point :)
04:28:45 <shapr> oh hey
04:29:04 <shapr> have you guys read Okasaki's paper on removing parentheses *and* . *and* $ ?
04:30:00 <shapr> it's really a series of two papers, one on embedding postfix languages in Haskell, and one on flattening
04:30:21 <Heffalump> shapr: Chilli has, I'm sure :-)
04:30:30 <shapr> chilli has read everything ;-)
04:30:38 * Heffalump skimmed the paper and listened to his talk on it
04:30:49 <Heffalump> yeah, but Chilli was chair of the workshop the former was presented at :-)
04:31:34 <dark> Garh, I have a most unhaskellish problem: handles are being closed too early.
04:32:05 <ChilliX> shapr: it's a cute trick
04:32:13 <Marvin--> f . g . h $ x
04:32:20 <shapr> yah, especially for those who want to implement Joy in Haskell
04:32:26 <ludde> why not f $ g $ h x
04:32:55 <ludde> one character less
04:33:02 <Heffalump> :-)
04:33:47 --- topic: set to 'mo' nads than you || We put the Funk in Funktion || See logs @ http://tunes.org/~nef/logs/haskell/ || Gtk+HS  0.14.10 released http://www.cse.unsw.edu.au/~chak/haskell/gtk/ || ICFP is over <Erwin> Your mother asked you to write COM program? Who are you, Dilbert? || Ganesh's HaskPerl challenge: make Haskell look like line noise too!' by Heffalump
04:34:00 <shapr> oh, I read about debugging monads last night
04:34:54 <Marvin--> Heffalump: :)
04:35:11 * Heffalump --> talk
04:35:13 * Marvin-- introduces a monadic $_ operator
04:37:20 <Marvin--> "implicit haskell"
04:45:17 <shapr> I think a Joy embedded into Haskell would win the HaskPerl contest.
04:45:23 <shapr> or at least make the judges very ill
04:56:41 * dark proposes a scan of everyone's utility functions to figure out what would be good library additions.
04:56:53 * dark proposes that someone else does the work :-)
04:56:56 <shapr> yah, refactor the library
04:59:23 * Marvin-- read that as 'scam' first and thought it a bit weird
04:59:26 <dark> Aiye, now I have a problem that goes away if I turn tracing on.
04:59:40 <Marvin--> Observe is your friend
04:59:46 <shapr> what's that?
04:59:53 <dark> what shapr said
05:00:00 <Marvin--> data inspection that doesn't change the evaluation
05:00:08 <Marvin--> Debug.Observe or something
05:00:08 <o3> re
05:00:16 <shapr> hi Andre!
05:00:17 <shapr> wassup?
05:00:29 <o3> oooh, not too much
05:00:32 <shapr> marvin: hey, are you gonna make your hws cvs tree available somewhere?
05:00:43 * shapr wants to plaaay
05:00:57 <Marvin--> shapr: I'll put together a tarball during the weekend, I don't have time to fiddle too much
05:01:12 <shapr> yay
05:01:34 <shapr> you could stuff it into haskell-libs cvs tree
05:01:36 <shapr> or I could
05:01:54 <Marvin--> http://193.11.232.159:21398/ <- current status
05:02:21 <shapr> awesome, thanks :-)
05:02:34 <work_den> hello
05:02:46 <shapr> hiya
05:02:48 <Marvin--> shapr: nothing complete, but at least the two most important files ;)
05:02:58 <Marvin--> coffee.. now. me need coffee
05:03:04 <shapr> work_den == dennisb ?
05:03:06 <work_den> I told John at lunch today about this channel
05:03:09 <work_den> yes
05:03:13 <shapr> yay
05:03:23 <shapr> oh, cool, do you think he'll show up?
05:03:28 <work_den> Yes, I'll bring him here sometime
05:03:31 <shapr> you get to have lunch with John Hughes, cool =)
05:03:59 <work_den> He will probably not be here all the time, but he seemd interested
05:04:05 <shapr> I want to know if he's done anything with the idea of saving failing test cases in QuickCheck
05:04:10 <work_den> wanted to meet the practical programmers
05:04:16 <ludde> work_den: who are you?
05:04:21 <work_den> dennisb
05:04:25 <ludde> who is that? :)
05:04:31 <work_den> Dennis Björkund, at chalmers
05:04:42 <ludde> you're a doctorand student?
05:04:44 <work_den> yes
05:04:47 <ludde> aha
05:04:52 <shapr> he helped me lots when I was learning Haskell on this channel
05:05:10 <ludde> work_den: you could bring koen and josef here too :)
05:05:15 <shapr> heh
05:05:31 <work_den> ludde: maybe, I just compiled a new version of xchat here
05:05:37 <shapr> the only downside of irc is that it distracts from productive work sometimes
05:05:41 <ludde> oh, hehe :)
05:05:48 <work_den> that I know all too well
05:06:53 <work_den> xchat 1.8.10 seems to work after I disabled a lot of stuff. It didn't compile directly on this stupid old computer system we have
05:07:11 <shapr> I've always used debian packages
05:07:23 <shapr> this irc client is written in elisp though
05:07:30 <work_den> shapr: I'm sure he will be happy to tell you things about quickcheck
05:07:31 * shapr wants a Haskell irc client someday
05:07:33 <shapr> yay!
05:07:51 <work_den> this is a solaris system, and i'm just a user. No packages here
05:08:01 <shapr> oh, suckage
05:08:06 <Marvin--> work_den: dammit, what's wrong with my installation of xchat in the dum directory?
05:08:25 <work_den> Marvin--: i don't know. There wasn't one before :-)
05:08:50 <dark> I moved some `seq`s around and suddenly it works.  This does not inspire confidence :-)
05:08:54 <work_den> I sort of have had my own version for a long time. But now mine was so old I wanted to upgrade. Didn't know you had installed it
05:09:08 * shapr notices that sunfreeware.com doesn't have xchat packages
05:09:12 <work_den> dark: seq is a bit of magic
05:09:26 <dark> work_den: What I really want is a strict version of hGetContents
05:09:38 <Marvin--> work_den: "before" as in "two years ago" then
05:09:41 <work_den> dark: tell me about it, I hate how it works today
05:09:46 <dark> work_den: I did length contents `seq` contents and that didn't work right.  Now I have return (length contents `seq` contents) and it works :)
05:09:52 <work_den> Marvin--: might be something like that :-)
05:10:05 <dark> Oops, the first version was length contents `seq` return contents
05:10:26 <Marvin--> $ dumpkg info xchat
05:10:27 <Marvin--> xchat: 1.8.7
05:10:46 <Marvin--> guess I could upgrade that
05:11:11 <work_den> Marvin--: well, it's even better when it's installed there. I'm very happy about it and now I can delete mine.
05:12:05 <Marvin--> work_den: you know that all our software is in /users/mdstud/dum/usr/bin these days, right? not dum/bin
05:12:07 <work_den> dark: I can't understand why it did not work at the first try
05:12:22 <Marvin--> seq is icky
05:12:42 <work_den> Marvin--: I don't know much. I've stoped using the system and usually ssh to my machine at home to run programs
05:13:02 <Marvin--> work_den: amen, the computer system at MC sucks bigtime
05:13:36 <Marvin--> work_den: I've complained about there being both rcopt and mkII for a long time. Recently I've discovered a few more trees with other packaging systems
05:13:43 <Marvin--> Not to mention the messy /usr/pd tree
05:13:50 <dark> work_den: Well the non-working thing is that I try to close the handle later (if it's still open), and with the first version that closed it too early.  (The maybe-close is there because the caller doesn't know if the worker function closes the handle itself or not)
05:13:58 <work_den> Marvin--: maybe we should start a channel for that
05:14:10 <Marvin--> work_den: for whining about the computer system? :)
05:14:12 <work_den> so we can complain about it all day long
05:14:19 <Marvin--> yay, whine and complain
05:14:30 <Marvin--> actually, I've been thinking on starting #dum
05:14:50 <Marvin--> dunno where though
05:15:08 <Marvin--> OPN^H^H^Hfee^H^H^Hfreenode kinda sucks
05:17:12 <work_den> Hmm, why is the program not the same here as at home. Where is the query-button...
05:17:17 <shapr> you could just stick with irc.se.freenode.net
05:17:22 <shapr> that's what I do
05:17:35 <work_den> dark: I have a hard time to see where the first version of the seq fails
05:18:16 <work_den> I guess I have to expand the thing and understand IO-bind and so on to really get this
05:19:04 <dark> I think "return" might react differently to seq than other IO actions.
05:19:57 <work_den> dark: i'm not so sure about that
05:23:27 * Marvin-- watches the rain out the window *sigh*
05:23:58 <dark> work_den: My worry is that maybe I just affected the timing, and that it only seems to work right now.
05:24:14 <dark> work_den: I think I'll spend some time writing a strict version of hGetContents :-)
05:38:00 <work_den> dark: I tried the version with length xs `seq` return xs and it seems to work here
05:38:12 <work_den> are you sure it didn't work for you?
05:43:10 * shapr discovers ways of applying the Burstall-Darlington transformation system to Python code
05:45:58 <work_den> shapr: if you say A you have to say B. What is the Burstall-Darlington transformation?
05:46:42 <shapr> I read about it in the Rabhi&Lapalme book "Algorithms, a Purely Functional Approach"
05:46:49 <shapr> it's from the 80s I think...
05:46:59 <shapr> those two guys wrote a paper about it.
05:47:21 <shapr> it's really cute, you can use it to turn multi-pass algorithms into single pass, stuff like that.
05:49:19 <shapr> oh, yesterday I discovered that there's more than one way to transform a monad
05:49:20 <dark> work_den: Quite sure :)  However, I've changed the code enough by now that I probably can't reproduce the problem.  I have a strict hGetStr now.
05:49:32 <shapr> David Espinosa came up with stratified monad transformers
05:49:56 <shapr> haven't read the paper yet, but rumor has it Haskell's type system can't deal with stratified monad transformers
05:50:12 * work_den don't know too much about that
05:50:21 <work_den> but I'm interested
05:51:59 <o3> evening chilli
05:52:10 <Chilli> re o3
05:57:01 <dark> work_den: Hmm, I was probably mistaken about _what_ didn't work.  It fails with hGetStr in the same way.  So probably moving the `seq` made it lazier, and only the lazy version works for some reason.
05:57:22 <dark> Either that or I'm imagining patterns while it's failing randomly.
05:57:28 <dark> (I'm reading from a socket so there are timing issues)
05:58:05 <work_den> aha, I tried to read from a file and it didn't look like a problem at all. Work every time
06:27:25 * shapr was going to say something useful here... but forgot it.
07:23:34 * shapr bounces
07:23:39 * shapr writes Haskell code in Python
07:37:33 <dark> .hc files are somewhat hard to read.
07:38:06 <creature> Afternoon, all.
07:38:13 <Heffalump> hi
07:38:46 <creature> As part of a functional programming exercise, I've been asked the following, and can't see the best way to do it. Could someone give me a hint or two, please? The question is this: 
07:39:18 <creature> Define a function howManyOfFourDiffer :: Int -> Int -> Int -> Int -> Int that returns how many of its four arguments are different.
07:40:10 <creature> With what I know at the moment, I'd be tempted to tackle it with one very long guard, but I'm sure there's a better way.
07:43:19 <dark> howManyOfFourDiffer 1 1 2 2 should be 2?
07:43:34 <creature> Yep.
07:43:36 <dark> howManyOfFourDiffer 1 1 2 3, should that be 2 or 3?
07:43:41 <creature> That should be 3.
07:44:04 <creature> examples given are as follows, where hMOFD = howManyOfFourDiffer.
07:44:27 <creature> hMOFD 1 2 3 4 = 4 , hMOFD 1 2 2 2 = 2, hMOFD 2 3 3 2 = 2.
07:44:52 <creature> As I say, I'm not hunting a solution, merely a hint.
07:46:17 <dark> Well, I could give a hint toward the solution I would use, if keeping it simple is more important than efficiency.  I don't know if it would be a good solution :)
07:47:05 <creature> Simple is probably the best thing, given that this week 5 of the course. We're up to the point of using guards, the while keyword, and the occasional if-then-else. :)
07:47:21 <dark> while keyword?
07:47:32 <creature> Erm, where keyword.
07:47:42 <dark> Okay, you had me confused there :)
07:47:47 <creature> Yeah, me too. :)
07:48:14 <creature> The class convener mentioned I might be able to do it with recursion.
07:48:34 <creature> OK, so how would you attack it?
07:48:48 <dark> Well, I would put the arguments in a list, so that I can operate on them without distinguishing between them.  There's some handy functions for this sort of thing.
07:48:59 <dark> But that would probably end up using features you haven't had in the course yet :)
07:49:12 <creature> Ooh, I did something like that the other day. 
07:49:29 <creature> And no, we haven't "officially" done that. 
07:49:51 <creature> We had to write a function to convert case on characters, and I was swish and did a function to convert an entire string too. :)
07:49:52 <dark> Hmm... recursion...
07:50:17 <creature> I was trying to make it use a barrage of if statements to decrement a difference counter whenever it met an equal pair.
07:50:51 <dark> Yeah.  But you end up with a lot of "duplicate" code, right?
07:50:54 <creature> But hugs didn't like that much.
07:51:05 <creature> It seems far more strenuous than need be.
07:51:36 * shapr would use recursion
07:52:02 <dark> shapr: Yeah I think I see the solution the lecturer had in mind, but I don't know how to hint it :)
07:52:08 <shapr> nor do I
07:52:35 * dennisb thinks the function is strange
07:52:36 <creature> I think it's worthwhile pointing out that he told me that I wouldn't be expected to carry it out, as I'm not meant to know about recursion yet. :)
07:52:55 <dennisb> creature: then you should do lots of tests here
07:53:09 <dark> Well, there's one hint derived directly from "recursion": how would you use howManyOfFourAreDifferent to find out how many of *three* are different?
07:53:10 <shapr> yah, manual code :-)
07:53:47 <dark> Hmm, yeah, no lists, no recursion... I guess you're not supposed to come up with something elegant at all :)
07:54:14 <shapr> which is sad, since recursion + lists is where you start to get into sexy code
07:54:21 <creature> I take it I'll need more brackets to do this: 
07:54:34 <dark> Maybe this exercise is just to see if you can write lots of guards and keep them all straight.
07:54:34 <creature> | ( w == x == y == z)   = 0
07:54:39 <creature> As my first line of a guard, yes? 
07:55:04 <dennisb> it should work, why don't ju just test it!
07:55:16 <dennisb> bha, ju = you
07:55:19 <shapr> hi dennisb, how's life treating you?
07:55:34 <creature> I did, and it told me  "Ambiguous use of operator (==) with (==).
07:55:38 <dennisb> shapr: lots and lots of rain today. I think god is not happy about me
07:55:44 <dark> dennisb: That's mean, as far as I can tell it'll run but do the wrong thing :)
07:55:49 <shapr> because he's raining on you?
07:55:51 <dennisb> or happy with me parhaps
07:56:21 <shapr> ya know, we could just teach recursion...
07:56:46 <creature> I know a bit about recursion.
07:56:52 <dark> creature: I don't think Haskell has multi-way relational operators at all.  (w == x) == (y == z) would compare the results of the two sub-comparisons, instead of comparing all the numbers.
07:56:52 <creature> As my theory of programming isn't bad.
07:56:54 <shapr> maybe the course is designed to show how procedural code usually does it, and then show how recursion is so much more elegant?
07:56:58 <dennisb> shapr: yes, the rain is obviously a punishment
07:57:03 <creature> It's just my implementation sucks. :)
07:57:08 * shapr emails an umbrella to dennisb
07:57:22 <dark> shapr: That would be mean, the first example should be on the blackboard in that case :)
07:57:26 <creature> shap - I think the course is meant to contrast the object-orientated approach being taught with Java.
07:57:33 <dark> dennisb: Either that or you're the new Rain God.
07:57:46 <creature> dark - OK, so I'll attack it with a load of && in there too. :)
07:58:09 <dennisb> dark: I though his example was correct (as a first case)
07:58:31 <dark> Hmm didn't someone here write Haskell code for playing MasterMind?  This function could be implemented in terms of that :-)
07:58:35 <dennisb> but I was obiously confused
07:58:50 <dark> dennisb: Probably you have too many different languages on your mind :)
07:58:52 <dennisb> maybe my head leaked in water into my brain
07:59:40 <dark> creature: Are you allowed to also write a howManyOfThreeAreDifferent function, etc?
08:00:19 <creature> dark - yep.
08:00:31 <creature> I've got a feeling I did that about a week ago, hold on, I'll check.
08:00:42 <dennisb> creature: it's easy to see why the above does not work. == is an operator returns a boolean, 1 == 2 == 3 would then be False == 3
08:00:56 <dennisb> it can clearly not work
08:01:03 <creature> No, I didn't. 
08:01:23 <creature> dennisb - yep, I see that now. 
08:02:11 <dennisb> maybe you need to use lots of &&
08:02:19 <creature> Yep, I've done that.
08:02:30 <dennisb> ooh, it's going to be big and ugly .-)
08:02:30 <creature> This could get very laborious, I feel.
08:02:34 <creature> Yeah.
08:04:05 <creature> I think I'd rather someone taught me about recursion. :)
08:04:05 <dennisb> I think dark has the best solution, to write a howManyOfThreeAreDifferent
08:04:43 <creature> dennisb - OK, that's easy enough. But then how would you use it? 
08:04:46 <dennisb> if you get the solution with howManyOfThreeAreDifferent you are on your way to a recursive solution
08:04:47 <dark> Well, I think the *best* solution is the list-based one, it's one line :)
08:04:51 <creature> It seems to me that you'd need to consider all variables. 
08:05:06 <creature> It seems to me that you'd need to consider all variables in one big chunk, as it were.
08:05:44 <dennisb> dark: sure, lists are better
08:06:23 <creature> If I define the function as [Int] -> Int, would this expect to get a list of integers as its input and an output of a single integer? 
08:06:33 <tez> Yup
08:07:05 <dark> creature: Changing the type signature probably wouldn't be allowed as an answer though :)
08:07:18 <creature> dark - damn, you're right, forgot it gave me that. :)
08:08:03 <dennisb> creature: you have to figure out how to use howManyOfThreeAreDifferent to write howManyOfFourAreDifferent
08:08:14 <tez> But he can do the list version, then get his Int -> Int -> Int -> Int -> Int function to call the list version (or is that cheating?).
08:08:24 <dark> creature: That kind of question is typical of recursive solutions, by the way.
08:08:54 <dennisb> dark: which is why I liked your suggestion to write such a function
08:09:48 <dark> tez: It probably wouldn't be cheating, if he's allowed to write helper functions :)  But it does mean knowing how to turn the arguments into a list, which might not have been taught yet.
08:10:11 <creature> brb, implementing a howManyOfThreeDifferent
08:10:16 <dark> (not that it's difficult or anything, but it can be hard to get into the minds of teachers :)
08:14:15 <apm02> can you have a let in an "| otherwise =" statement ?
08:14:36 <creature> Argh, this is making my head hurt. 
08:14:42 * creature begins to take a dislike to guards.
08:14:59 <apm02> can you have a let in an " | otherwise = " statement ?
08:16:03 <apm02> because i am trying to have the result from an iterate be the return from an otherwise =
08:16:31 <apm02> so to make the iterate work, i need to have a let to make a partial function of my f() and its 1st arguement
08:16:43 <apm02> but i'm not sure how i can fit the let into this ?
08:18:34 <dennisb> sure you can use a let there
08:20:24 <creature> what should howManyOfThreeDiffer 1 2 1 return?
08:20:27 <creature> I'm really not sure.
08:21:13 <creature> To me, it should be 1.
08:21:24 <dark> Well it's an analogy with howManyOfFourDiffer
08:21:43 <dennisb> creature: what should howManyOfFourDiffer 1 2 3 1 return?
08:21:59 <creature> To my eyes, that should be 2.
08:22:39 <dennisb> but you said before: hMOFD 1 2 2 2 
08:22:39 <creature> If I have howManyOfFourDiffer w x y z, can't I take w as my base and then compare each term with that? 
08:22:43 <dennisb> = 2
08:22:47 <apm02> mmm
08:23:01 <creature> dennisb - yeah, that's where my understanding falls down.
08:23:14 <dennisb> then I think that 1 2 3 1 should return 3, there is 3 different numbers there
08:23:38 <creature> That's a bit clearer.
08:24:44 <apm02> dennisb: not getting syntax right here.. "let p1 = f 1 in (otherwise = iterate p1 2) is giving syntax errors
08:24:59 * creature goes to think about hMOTD some more.
08:25:15 <shapr> haskell message of the day?
08:25:29 <tez> lol
08:25:36 <dark> How many of our three topics are different? :)
08:26:34 <dennisb> apm02: you seem to have misunderstood a bit about haskell, ot I don't understand your example. What would you like that piece of code to do?
08:27:10 <apm02> i'd like it to return the result of (iterate p1 2)
08:27:15 * dennisb need a irc client that can fix my bad english. Please, can someone hack xchat to fix that
08:27:19 <apm02> when " | otherwise " is reached
08:27:38 <apm02> since f has 2 args, i use p1 which is a partial function
08:28:01 <dennisb> the otherwise seems to be in the wrong place here
08:28:30 <dennisb> you could write this expression: let p1 = f 1 in iterate p1 2
08:29:07 <shapr> hi hal!
08:29:18 <hdaume> hi
08:29:21 <shapr> what's up?
08:30:05 <dark> I'm going shopping now :)
08:30:23 <creature> dennisb - you know how we're interpreting the "how many differ" as being "how many numbers appear in the string"? 
08:30:33 <creature> So what do we return when they're all equal?
08:30:44 <dennisb> creature: I would guess 1
08:30:54 <creature> but none of them differ, though.
08:31:03 <dennisb> it's true
08:31:14 <dennisb> what does your assignment say?
08:31:15 <dark> Yeah but you said hMOFD 1 2 2 2 = 2, and none of the 2's differ from any other 2 :)
08:31:22 <creature> Yeah.
08:31:29 <creature> As I say, I have 3 examples. 
08:31:31 <dark> You should spank whoever wrote the assignment, defining a function with only a couple of examples like that.
08:31:39 <creature> hMOFD 1 2 3 4 = 4 , hMOFD 1 2 2 2 = 2, hMOFD 2 3 3 2 = 2.
08:31:49 <dark> creature: *grin* In that case, a three-line pattern-matching solution suggests itself.
08:31:55 <tez> lol
08:32:17 <tez> I think a better name is howManyUniqueNumbersFromFour
08:32:18 <dark> "But.. the assignment said *nothing* about hMOFD 1 2 3 *5*!"
08:32:20 <tez> :-)
08:32:51 <creature> Yeah, but it describes itself as "for instance", so I can't take it as the only inputs it's going to get given. :)
08:33:28 <apm02> dennisb: thanks, got the syntax right now :)
08:33:44 <creature> I think it could be a typo.
08:34:04 <creature> As the function is meant to "count how many of its four arguments are different."
08:34:14 <creature> And with hMOFD 1 2 2 2 only 1 is different.
08:34:39 <tez> (alterntively, the three 2's are different...)
08:34:47 <dennisb> creature: yes, just assume that 1111 should give 1
08:35:01 <tez> Yeah, that would seem consistent.
08:38:20 <hdaume> anyone know how to build packages with profiling?
08:40:49 <creature> Can I have a hint regarding using hMOTD in hMOFD, please? 
08:43:33 <dennisb> creature: how would you do it as a human being?
08:44:02 <creature> As a human being, I'd take this silly function and beat whoever wrote the exercise with it.
08:44:07 <dennisb> :-)
08:44:55 <dennisb> you have the numbers a b c d, and you use the function on three of them, hMOTD b c d, and get a number. What should the final number be?
08:45:38 <creature> You can't tell yet, as you haven't compared it to a.
08:45:47 <dennisb> true!
08:46:01 <dennisb> the result depends on a
08:46:14 <dennisb> and what cases are there?
08:46:20 <creature> I think I see now. 
08:46:32 <creature> I have to see if a = b, a = c, or a = d. 
08:46:40 <creature> And if it does, then the output is just the output from hMOTD . 
08:46:48 <creature> Otherwise, it's hMOTD + 1. 
08:46:49 <dennisb> I think you are on to something now!
08:46:52 <tez> yes!
08:46:56 <creature> Woohoo!
08:46:56 <tez> Looks good!
08:47:00 * creature implements.
08:47:55 <dennisb> then to implement howManyOfThreeDiffer you should of course use the new function howManyOfTwoDiffer!
08:48:25 <creature> I've done a howManyOfThreeDiffer already, although I don't like it. 
08:48:33 <creature> In Haskell, is there a way of aliasing things? 
08:48:43 <creature> So I can say that howManyOfFourDiffer = hMOTD? 
08:48:49 <creature> So I can say that howManyOfFourDiffer = hMOFD, even?  
08:48:50 <hdaume> just like that
08:49:05 <creature> So I can then do hMOFD 1 2 3 4 instead of typing everything out? 
08:49:47 <hdaume> yikes.  can someone try typing '(5+1) `mod` 0' into ghci -- it core dumps on me :)
08:50:31 <dennisb> Prelude> (5+1) `mod` 0
08:50:32 <dennisb> Aritmetiskt fel
08:50:38 <dennisb> (some swedish there)
08:50:51 <hdaume> did ghci quit or did it just report the error?
08:50:59 <dennisb> it quit
08:51:04 <creature> what's ghci? 
08:51:08 <creature> I'm up for trying this out too.
08:51:11 <dennisb> I guess it performed the division by zero
08:51:12 <hdaume> it's ghc's version of hugs
08:51:24 <hdaume> yikes.
08:51:36 <hdaume> tell me someone else has submitted this as a bug :)
08:52:01 <creature> You'll become known as "The Famous Perverse modulo-0 boy"!
08:52:06 <creature> I mean, mod 0. I ask you. :)
08:52:11 <tez> lol
08:52:17 <dennisb> hdaume: this is now your responsibility
08:52:20 <creature> . o O (And yes, I know it should catch this.)
08:52:20 <dennisb> :-)
08:53:16 <creature> Anyway, the good news is my hMOFD works. :D
08:53:30 <dennisb> hdaume: sounds like they just forgot to catch a signal
08:54:09 <dennisb> what should the result be?
08:54:25 <dennisb> creature: nice
08:55:22 <hdaume> dennisb: yeah, sure does.  well, i was hoping x `mod` 0 would just be x, but i don't really care, so long as it doesn't die.  0 would be reasonable.  error would also be reasonable, probably most reasonable.
08:56:28 <creature> imho error is the most reasonable.
08:56:32 <dennisb> hugs gives Program error: {primQrmInteger 6 0}, that's almost the same as segmentation fault anyway :-)
08:57:36 <ibid> there is a huge difference between a segfault and such an error
08:57:39 <creature> Anyway, as the challenge exercises (ie. for those of us who enjoy it, as they're not marked) I'm meant to start looking at recursion. Anyone care to break me in gently?
08:58:41 <dennisb> creature: write the same function but with type [Int] -> Int, that works with any number of elements.
08:58:51 <dennisb> ibid: I don't agree
08:59:04 * creature points to the "Gently" part of his above question and pouts. :)
08:59:18 <dennisb> creature: just a moment
08:59:35 <creature> I'll try on my own to begin with, don't worry.
09:00:20 <ibid> dennisb: segfault is the os signalling that the program is behaving unpredictably. that error is the program itself noticing a runtime error, preventing any erratic behaviour
09:00:31 <dennisb> ibid: if a compiled program dies with an error like that or with a signal for aritmitic error is not a big difference for me. In the intepretor it's a bigger difference and the interpretor should probably have a signal handler for that
09:00:56 <dennisb> well, it was not a really seg fault in this case
09:02:21 <hdaume> dennisb: but you can *catch* runtime errors; you can't catch segfaults
09:02:56 <ibid> you can catch segfaults
09:02:59 <dennisb> hdaume: yes, and this error is catchable, right
09:03:14 <ibid> just install the signal SIGSEGV handler
09:03:47 <hdaume> okay, but not in haskell...you have to do yucky stuff which should be done for you ;)
09:04:31 <dennisb> but would it be better if div/mod called error "Bad, bad user"?
09:04:46 <hdaume> yes, much much better
09:05:02 <dennisb> in ghci yes, in a compiled program no
09:05:23 <creature> ghci shouldn't segfault for a division by 0.
09:05:37 <creature> It should print an error message, and let you go on your merry way. 
09:06:05 <hdaume> dennisb: in a compiled program YES.  you can catch errors in the IO monad using Exception.catch!
09:06:20 <hdaume> how do you think ghci does it? :)
09:06:27 <dennisb> hmm, ok. Then it should be an error
09:06:35 <dennisb> i've never done that
09:06:39 <creature> Is this the best time to ask "What's a monad"? 
09:06:53 <hdaume> creature: probably not ;)
09:07:00 <hdaume> creature: it's basically a way of sequencing code
09:08:04 <creature> hdaume - I'm looking it up in the notes I've got for this course. 
09:08:10 <creature> What's the >>= function?
09:08:17 <dennisb> to understand recursion you should probably find some examples to look at, for example the length function
09:08:21 <Heffalump> that's the thing that does the sequencing
09:08:39 <hdaume> creature: you basically say "x >>= y" means "run x and pass the results to y"
09:08:40 <Heffalump> a >>= f takes the result of computation a and gives it as a parameter to f
09:09:10 <hdaume> i like to think of ">>=" as a pipe that you're pushing results through
09:09:14 <creature> As it says that "A monad consists of a type with (At least) two functions, return and >>=. Informally, a monad can be seen as performing some sorts of action before returning an object. The two monad functions respectively return a value without any action, and sequence two monadic operations".
09:10:24 <ludde> can you have monads in a language that isn't lazy?
09:10:25 <creature> OK, I think I get the idea of >>= now, and quite like it.
09:11:02 <hdaume> ludde: sure
09:11:28 <dennisb> creature: monads in itself is "simple", it's all the cool instances that makes it interesting
09:12:52 <creature> OK. Let's return to recursion.
09:13:02 <creature> You think I should have a look at the length function. Is that in Prelude?
09:14:31 <tez> The version in the Prelude isn't particularly readable unless you've come across the fold functions.
09:14:39 <dennisb> don't you habe something in the course material?
09:15:00 <creature> I was about to ask, wtf is foldl' meant to mean? :)
09:15:28 <Heffalump> foldl' is the strict version of foldl
09:15:34 <tez> You could try implementing a fibonacci function, as an introduction.
09:15:35 <dennisb> the one at http://www.haskell.org/onlinereport/standard-prelude.html is simple
09:15:43 <dennisb> Heffalump: great answere!
09:16:01 <creature> I think I could implement a fibonacci function.
09:16:10 <creature> I get the idea that recursion is a function calling itself.
09:17:15 <tez> Yes, most of the time.  There's also "mutual recursion", where a function f calls function g, but g also calls f.
09:18:11 <creature> Didn't I read somewhere that hugs doesn't like that? 
09:18:22 <tez> Doesn
09:18:26 <tez> Doesn't it?
09:18:41 <hdaume> creature: not mutually recursive *Modules*
09:18:53 <hdaume> creature: i.e., module M cannot import module N if N imports M
09:18:54 <creature> "Hugs implements almost all of the Haskell 98 standard, except for mutually recursive modules" says the manpage.
09:19:07 <creature> Ah, I see how this is not the same thing now. :)
09:22:22 <creature> What's wrong with this:
09:22:54 <creature> fibonacci :: Int -> Int
09:22:54 <creature> fibonacci n
09:22:54 <creature> 	| n == 0	= 1
09:22:54 <creature> 	| n > 0		= n + fibonacci(n-1)
09:23:56 <dark> Somehow that doesn't look like fibonacci to me.
09:24:03 <tez> That just looks like the sum of 1 to n, or something
09:24:04 <creature> Me neither.
09:24:06 <tez> lol
09:24:41 <creature> I'm new to this recursion stuff, OK? :)
09:25:06 <tez> Well, informally, how does one write out the fibonacci sequence?
09:25:36 <creature> Oh, I see where I've buggered up now. :)
09:27:24 <creature> There, got it. 
09:27:29 <creature> fibonacci :: Int -> Int
09:27:29 <creature> fibonacci n
09:27:29 <creature> 	| n == 0	= 1
09:27:29 <creature> 	| n == 1	= 1
09:27:29 <creature> 	| n > 0		= fibonacci(n-2) + fibonacci(n-1)
09:27:47 <dennisb> here is what the cool haskell programmer would you do: fib = 1:1:zipWith (+) fib (tail fib)
09:28:18 <ludde> fibonacci a b = b : (fibonacci b $ a+b)
09:28:31 <creature> I understand the "=" in both of those statements, and that's about it.
09:28:39 <creature> Oh, and fib's the name of your function, of course.
09:28:44 <creature> Beyond that, colour me clueless.
09:28:55 <dennisb> well, mine was not a function. It was the list of all the numbers
09:29:30 <ludde> hmm
09:29:31 <ludde> fibonacci a b = b : fibonacci b (a+b)
09:29:43 <creature> Is it a list comprehension?
09:29:51 <ludde> mine? no
09:29:57 <creature> no, dennisb 's/
09:30:16 <dennisb> creature: nope, its a recursive definition (it does not just work on functions)
09:30:37 <dennisb> but maybe you should save that example and look at it later in the course
09:30:43 <ludde> dennisb: hehe
09:30:44 <creature> OK, so how does it work?
09:31:03 <ludde> dennisb: is that O(N) or O(N^2) 
09:31:15 <dennisb> it should be o(n) 
09:31:21 <creature> What does tail do?
09:31:29 <ludde> dennisb: okay
09:31:34 <creature> As I think I can see how it works if tail does what I think it does.
09:31:36 <dennisb> removes the first element of a list
09:32:24 <dennisb> tail [1,2,3] ==> [2,3]
09:32:40 <creature> OK. and zipWith? 
09:32:53 <creature> I'm guessing that sticks a + in between 2 things, in this case.
09:32:57 <dennisb> yes
09:33:04 <creature> A bit like making a sandwich, as it were.
09:33:12 <Heffalump> ol
09:33:15 <Heffalump> s/^/l/
09:33:21 <dennisb> true, we should rename zipWith to sandwich,
09:34:04 <creature> But then you'd lose all manner of puns about getting caught in zips etc. 
09:34:07 <ludde> zipWith sounds almost like sandwich if you change the pronounciation slightly
09:34:28 <tez> while keeping your mouth closed
09:35:08 <ludde> :)
09:35:49 <creature> So what your definition does is say "The first 2 elements of this list are 1 and 1. Then, add fib to tail fib.
09:35:53 <creature> "
09:36:06 <creature> Although I don't quite see how that fib + (tail fib) works.
09:36:34 <dennisb> well, zipWith puts the + between each pair of elements in the lists fib and tail fib
09:36:56 <creature> Ah, I see, ish.
09:38:31 <creature> So how does Haskell react when you tell it to add 2 lists together? 
09:38:56 <creature> Say c = a + b where a = [1, 2, 3] and b = [5,10,15].
09:39:07 <tez> I think it might complain the [a] doesn't match Num a => a, or something.
09:40:14 <creature> Basically, I don't see how that fib (tail fib) bit works.
09:40:37 <dennisb> creature: the easiest is just to type in [1,2] + [3,4] and see what happens. It wont work. But zipWith (+) [1,2] [3,4] will
09:40:59 <dennisb> creature: that's the tricky recursive part
09:41:28 <dennisb> we just use fib at the same time as we create it, piece of cake
09:41:32 <ludde> how does the list monad work?
09:41:52 <Heffalump> ludde: think of it as non-deterministic computation
09:42:02 <ludde> Heffalump: I don't understand what that means :(
09:42:12 <ludde> how can a pure function be non-deterministic ?
09:42:34 <Heffalump> you can simulate a non-deterministic function by returning a "list of successes"
09:42:48 <hdaume> think of path finding.  you can have a deterministic algorithm by returning a single path or a non-deterministic algorithm which returns the set of all paths
09:42:59 <creature> Is there some way I can type that fib = etc. line into hugs and get some output? 
09:43:09 <creature> As when I try, it complains about an unexpected =.
09:43:15 <dennisb> creature: put it in a file and load it in
09:43:15 <ludde> okay, so for example a parser could return all ambigous parses
09:43:28 <ludde> ambiguous
09:43:42 <hdaume> let fib = etc. in fib 10
09:43:48 <hdaume> yeah
09:43:56 <creature> OK, I've just typed in "fib". 
09:43:58 <dennisb> creature: then you can do something like take 20 fib
09:44:02 <creature> It's now listing a *lot* of numbers. 
09:44:04 <creature> How do I stop it? 
09:44:08 <dennisb> ctrl-c
09:44:08 <hdaume> control c :)
09:45:25 <creature> That's really cool
09:45:26 <ludde> anyone has a quick example how i can use the list monad?
09:45:28 <creature> How accurate is it? 
09:45:40 <dennisb> creature: accurate?
09:45:44 <tez> Accurate?
09:46:04 <creature> I mean, what are the limits to it?
09:46:29 <creature> eg. in C, one can take an int up to 65,335 or something around that area, before it falls over.
09:46:41 <creature> 65536.
09:46:56 <hdaume> ludde: how about "[1::Int,2,3] >>= (return . (+1))"
09:47:09 <tez> I think there is an integer format (iirc, called Integer) which is effectively capped by system memory.
09:47:10 <dennisb> the type Integer in haskell have no limit (except memory size)
09:47:16 <ludde> que?
09:47:19 <ludde> :)
09:47:21 <dennisb> The type Int is usually 32 bits
09:47:43 <hdaume> ludde: [1,2,3] is a list of possible outcomes.  you're sending them through a computation which adds one.  this will result tin [2,3,4]
09:47:46 <creature> So if I left it to run and run, eventually the system would fall over and die?
09:47:52 <creature> This gets better by the second. :)
09:48:10 <dennisb> creature: no, it would probably go on for ever (almost)
09:48:13 <Heffalump> well, unless your system imposes resource limits on processes
09:48:37 <Heffalump> both time and memory usage would grow with the log of the number
09:48:54 <ludde> hdaume: could you explain return . (+1)
09:49:03 <ludde> oh
09:49:05 <ludde> never mind
09:49:54 <dennisb> it's nicer in do syntax
09:50:44 <creature> So a "take 5 fib" gives the first 5 elements of fib, yes? 
09:50:47 <Heffalump> yes
09:51:42 <hdaume> ludde: yeah, "do a <- [1,2,3]; return (a+1)"
09:51:52 <creature> Ooh.
09:51:57 <ludde> hdaume: yeah, i realized :)
09:52:01 <hdaume> okay
09:52:11 <creature> So what happens to haskell if you add a list with, say, 5 elements to a list of, say, 4 elements?
09:52:36 <creature> I'm sorry if I'm being incredibly dense re: my understanding of this.
09:52:47 <tez> creature: what, with zipWith?
09:52:48 <hdaume> creature: you can't "add lists"
09:53:04 <creature> tez - yes, with zipWith. Sorry.
09:53:17 <hdaume> it will cut out at the length of the shorter
09:53:19 <dennisb> creature: this is advanced stuff, so don't worry
09:53:48 <dennisb> it just depends on the definition of zipWith, if you use some other function to add them up something else might happen
09:54:02 <dennisb> zipWith is just a normal function that you can define your self
09:54:38 <creature> so the "take 5 fib" zipWith's [1,1,2,3,5] and [1,2,3,5] to yield [2,3,5,8]. 
09:55:18 <creature> It's beginning to fall into place now. :)
09:55:37 <dennisb> well, actually no
09:55:43 <creature> Well, no.
09:55:52 <creature> so the "take 6 fib" zipWith's [1,1,2,3,5] and [1,2,3,5] to yield [2,3,5,8]. 
09:55:56 <dennisb> fib is the infinite list and take 5 picks out the first 5 elements in that list
09:56:14 <creature> Yes, but I see how the definition works now!
09:56:21 <dennisb> but in some sence you are correct of course
09:56:34 <dennisb> yes
09:56:47 <creature> By cutting off the first element, adding the two lists always makes the resulting list begin with 2, so we stick the 1:1 on the front of it and all is right with the world.
09:57:28 <tez> hmm
09:57:57 <tez> Oh, yes.
09:58:06 <creature> I mean, I can see how it calls itself over and over to continue generating the list.
09:59:03 <creature> After a measly 45 minutes, I understand these 37 characters. 
09:59:05 <tez> But can you now do a hmofd function?
09:59:26 <creature> brb.
09:59:32 <tez> lol
10:00:16 <Heffalump> just goes to show that Haskell is an efficient language
10:01:04 <tez> What, in terms of (code length)/(time to comprehend) ?
10:01:13 <Heffalump> yes :-)
10:01:22 <creature> Back.
10:01:51 <Heffalump> or rather, (code length)/(ideas in code)
10:01:53 <creature> And no, I don't think I can now do a hmofd function using recursion.
10:02:20 <creature> Ooh, yes, maybe I can...
10:02:25 <tez> Oh.  Alright, maybe it would help if you did some recursive functions that work on lists.
10:03:08 <hdaume> Heffalump: i think that strongly depends on what you're writing code to do :)
10:03:08 <creature> Actually, I don't think I can, although I can see the principle behind it. 
10:03:44 <creature> Although it's kind-of blurry.
10:03:58 <creature> Sorry, I tend to talk in these strange, vague metaphors.
10:04:10 <tez> S'okay.
10:04:57 <creature> I should say, this is the only thing I've ever done with lists:
10:05:25 <creature> changeCaseString :: String -> String
10:05:25 <creature> changeCaseString x = [changeCaseChar y | y <- x]
10:05:36 <creature> That, and the recursive definition I've just been grappling with.
10:06:16 <dennisb> creature: it was not fair of me to show you that example, it does not have very much to do with normal recursive functions that you are supposed to start with..
10:06:38 <creature> dennisb - nah, get me understanding the difficult stuff and the easy stuff should fall into place. :)
10:07:32 <dennisb> in the heart of that example there is also the notion of lazy evaluation, in haskell things are calculated only when needed
10:08:03 <creature> So it doesn't have to sit and make fib up to begin with, hence it doesn't get stuck on an infinite loop, yes?
10:08:11 <dennisb> yes
10:08:14 <creature> when I say "make fib up", I should probably say "Generate".
10:08:18 <dennisb> something like that
10:09:01 <creature> OK, cool.
10:09:19 <tez> creature: In your own fibonacci definition, you had 2 base cases, and a general case.
10:09:32 <tez> You can do the sme thing with lists.
10:10:08 <dennisb> when you call "take 5 fib" it does not calculate the arguments before the call as in most other languages. If it would calculate the whole of fib before calling the function take it would take for ever
10:10:21 <dennisb> haskell is simply lazy
10:10:34 <shapr> like me!
10:10:53 <dennisb> like we all are!
10:11:02 <shapr> right!
10:11:03 <creature> Yay for laziness!
10:11:33 * creature decides to make a T shirt saying "Haskell is the reason I get up in the afternoon"
10:12:02 * shapr laughs
10:12:05 <shapr> that's a good T-shirt
10:12:13 <shapr> it's like the lazy evaluation lecture
10:12:20 <creature> shapr - take a look at www.alexpounds.com . 
10:12:30 <Igloo> Heh
10:12:31 <creature> Most of it's filler text, ie. bumpf, but the T shirt database is good.
10:12:44 <creature> One of my Grand Plans that I've been knocking around for a while is to print T shirts.
10:12:51 <creature> Far too pricey for me at the moment though.
10:13:03 <creature> damn my full-colour ambitions.
10:13:08 <shapr> I want one that says "what part of <the hindley-milner principal typing algorithm> don't you understand?"
10:13:41 <creature> Would I regret asking "What's the hindley-milner principal typing algorithm?"
10:14:04 <shapr> well
10:14:07 <shapr> um
10:14:14 <shapr> it's how Haskell does type inferencing
10:14:29 <Igloo> If you remove things like classes IIRC
10:14:30 * shapr dodges quickly
10:14:43 <shapr> hi Igloo!
10:14:55 * Igloo points to my "Heh" up there  :-)
10:16:12 * shapr grins
10:19:12 <creature> brb, phone.
10:19:32 <creature> back, for a bit.
10:19:39 <creature> My friend is at work, and has a queue to serve.
10:19:47 <creature> So he's going to serve, then call me back. 
10:19:48 * Igloo boggles at code running slower when I ask ghc to inline it
10:20:12 <shapr> creature: I know of some good Priority Queue implementations in Haskell.
10:20:30 <creature> shapr - if you drop me an email with the code to the hindley-milner algorithm, then I'll whack it on a T shirt when (if) I get them done.
10:20:39 <creature> The addy's on the site.
10:22:14 <creature> Is there a haskell implementation for the palmpilot? 
10:22:21 <creature> I'm googling now, but does anyone know of one?
10:22:26 <tez> I don't think so.
10:23:02 <shapr> afaik, the best thing you'll find is hugs for the sharp zaurus :-)
10:23:11 <creature> The zaurus rocks. 
10:23:13 <tez> Oh yes, I have heard of that one.
10:23:23 <tez> Zaurus... <drool>
10:23:25 <creature> One of the guys living next door to me is a 4th year student, just come back from working with Sun in the US.
10:23:40 <creature> He picked up a zaurus for something like 100 US$ at a trade show.
10:23:46 <creature> It's fantastic, it knocked my socks off.
10:23:52 <creature> Having a bash prompt on something that small is great.
10:24:10 <creature> Plus he had a neat little emulator on it, which means he could play day of the tentacle on it.
10:24:11 <tez> Yeah, I can't wait to hook one up to my wireless network!
10:24:15 <tez> lol
10:24:22 <shapr> winex runs day of the tentacle
10:24:36 <creature> I don't think it was winex.
10:24:41 <shapr> aww
10:24:58 <creature> Is there an emulator called "vile"?
10:25:11 <shapr> vile is lossy emacs
10:25:16 <shapr> but that's probably not what you mean
10:25:20 <creature> No.
10:25:26 <creature> I seem to recall it had a funny name along those lines.
10:25:38 * shapr dunno
10:25:51 * shapr tries to decide between monad transformers or counterstrike
10:26:28 <tez> Aren't you getting tired of CS?
10:26:44 <shapr> umm. no?
10:26:47 <shapr> should I?
10:26:56 <creature> Does CS run on Linux yet? 
10:27:00 <shapr> yah, of course.
10:27:04 <creature> Fantastic! 
10:27:07 <shapr> you think I have windows here or something? eww
10:27:16 <shapr> I get tired of CS when I kill everybody else.
10:27:17 <creature> What machine do you run it on?
10:27:20 <tez> CS has been around for a while.
10:27:21 <shapr> this machine
10:27:28 <shapr> dual Athlon MP 1800+
10:27:30 <creature> OK, what kind of spec is "this machine". 
10:27:37 <shapr> 512mb of ram
10:27:41 <creature> Don't you have to run CS through wine or suchlike?
10:27:41 <shapr> gf4 MX 400
10:27:45 <shapr> winex
10:27:54 <creature> is winex freely available?
10:27:59 <shapr> yup
10:28:01 <creature> free as in "no cost"?
10:28:03 <creature> Fantastic.
10:28:07 <shapr> libre also
10:28:14 <shapr> as well as gratis
10:28:39 <creature> When I get my new machine (Athlon 1800+, 256Mb ram, dunno about the video card) I'm gonna have to try this.
10:28:45 <creature> There's a lot of counterstrike on the internal network.
10:29:14 <shapr> if you want decent speed in Linux, nvidia is best.. even though their drivers flip out and die occasionally
10:29:18 <shapr> especially on SMP :-/
10:29:22 <creature> Yeah, I'm hopefully getting an nVidia.
10:29:35 <creature> I've been playing about with suppliers for about a month now, starting to get me down. 
10:29:37 <shapr> radeon driver are of greater sanity
10:30:07 <creature> I thought I had finally got a decent machine, but wanted it to bounce it off my encyclopaedia-like friend. Everyone else said they couldn't see any problems with it, and reckoned it was a decent machine.
10:30:20 <shapr> well, which chipset?
10:30:35 <creature> My friend comes back immediately with "That mobo won't do AGP acceleration under Linux, and the graphics card has only 1/2 the memory bandwidth of the DDR versions".
10:30:52 <shapr> hm, which card?
10:30:57 <creature> That's the quote.
10:31:34 <creature> He recommended the ECS K7S5A mobo, so I'm trying to get it with that in and a different graphics card.
10:31:39 <shapr> oh
10:31:50 <creature> You did get my /msg, yes?
10:31:51 <shapr> yah, you're  getting ripped if you get that graphics card
10:32:04 <shapr> I'd recommend buying at least a gf4 of some flavor
10:32:09 <creature> Yep.
10:32:20 <shapr> even the economy GF4 models are faster than the the high-end GF2 models
10:32:21 <dark> shapr: winex libre?  Then what's the dispute with wine?
10:32:25 <creature> Aforementioned friend suggests that they're quite cheap now, given that nVidia is about to roll out something new. 
10:32:42 <shapr> dark: winex is a fork of wine that adds directX support
10:32:55 <shapr> dark: but the only way you can get actual winex packages is to purchase commercial support
10:33:03 <shapr> otherwise you have to cvs checkout and build yourself.
10:33:13 <creature> Is it difficult? 
10:33:18 <shapr> on the good side, every cvs checkout I've done has worked flawlessly.
10:33:27 <creature> Hang on, can I do cvs checkout over http?
10:33:31 <dark> shapr: Ah, now I remember the debate on the debian lists :)  They basically said, the license allows you to package it for Debian, but if you do, we'll change the license.
10:33:51 <shapr> well, I can understand their problem ...
10:34:00 <creature> Y'see, I've got no contact with the outside world here in my uni bedroom. 
10:34:05 <shapr> they're trying to get people to pay $5 a month and yet remain OSS
10:34:14 <shapr> creature: s'okay, I'm in north finland.
10:34:14 <creature> I've got access to machines that do have access to the outside world, but not direct access myself.
10:34:20 <shapr> reindeer are not much for conversation
10:34:28 <shapr> well, proxy
10:34:33 <creature> shapr - I mean in internet terms, as you well know. :)
10:35:06 <creature> Anyway, I can come to cvs when I need it. 
10:35:07 <shapr> winex really is spiffy
10:35:14 <shapr> I'd subscribe if they'd take AmEx
10:36:05 <shapr> I hope they can keep making money
10:36:53 <creature> Incidentally, what reference work on Haskell would you recommend? 
10:36:57 * shapr decides to play CS for a bit before playing with monad transformers
10:37:04 <shapr> creature: I like the thompson book
10:37:13 <shapr> chilli prefers the Hudak book, and he teaches Haskell
10:37:13 <creature> Bearing in mind cost is a factor, given that 1 textbook is roughly 1 week's worth of shopping.
10:37:30 <Heffalump> the Thompson book is clearly appropriate for creature :-)
10:37:46 <creature> shapre - as in, "The craft of functional programming"?
10:37:48 <shapr> hudak book requires more math
10:37:53 <shapr> yop, that's the thompson book
10:38:21 <creature> I've got a copy of the notes from that book.
10:38:29 <creature> Which is a darn sight more reasonable.
10:38:32 <shapr> thompson book is better if you lack geometry (like me)
10:38:52 <creature> I've done A level maths, so (in theory) I should be able to handle most maths I encounter. 
10:38:56 <creature> Eventually, anyway. 
10:39:02 * shapr dunno what A levels means
10:39:11 <Heffalump> end of High School
10:39:13 <shapr> oh
10:39:15 <shapr> ok
10:39:24 <creature> A levels are the exams in the UK that basically end your secondary-school education.
10:39:25 * shapr needs to go through the hudak book anyway
10:39:53 <creature> brb, phone again.
10:39:56 <shapr> I still think monad transformers are the coolest things I've seen yet in software.
10:40:05 <shapr> well, combinator theory in general is
10:41:02 <shapr> combinators make me happy...
10:41:12 <shapr> I even dream about 'em :-)
10:55:41 <ludde> Marvin--: thanks :)
10:56:39 <Marvin--> ludde: I hope you didn't mind the short message
10:57:15 <ludde> Marvin--: no it's ok.
11:01:58 <Marvin--> ARRGRGH! Who's afp-60!? I'm going to kill them with my bare hands!
11:02:43 * Marvin-- wants l33t r00t access so he can slay some processes :/
11:03:26 <hdaume> Marvin--: why?
11:04:09 <Marvin-->  9869 afp-60     1   0    0   55M   13M cpu3  421:18 47.97% ghc-5.04
11:04:55 <hdaume> at least it's not like 1800M or something :)
11:05:12 <dark> Such violence for a handful of megabytes.
11:05:59 <Marvin--> it's not the memory usage, it's the hogging of a CPU for that long time
11:06:14 <dark> so... ghc is slow, fix it :-)
11:08:57 <dark> *sigh* I getting stuck.  I have a program that seems to randomly close handles while using them.  Most transactions go fine, but sometimes it closes a socket in between hGetBuf calls, or closes a file during a hPutStr call.
11:09:16 <Marvin--> but that's *seven hours*
11:09:33 <dark> I audited all my own uses of close functions and made them say stuff to stdout before acting.
11:10:40 <dark> The only other thing I can think of is the garbage collector getting confused and calling handleFinalizer too early.
11:17:57 <dark> I don't know how to debug this.
11:22:37 <dark> If I ltrace it it gets further than if I strace it.
11:25:10 <Marvin--> heisenbug?
11:32:27 <dark> Yeah, somewhat.  It's reproducable, but changes to the program seems to move the problem around randomly.
11:33:46 <creature> d/me returns.
11:33:48 <creature> Ack.
11:33:52 * creature returns.
11:34:02 <dark> I'm currently experimenting with adding performGC calls to suspect areas :)
11:34:53 <dark> And I have a new suspicion, that it's cause by calling socketToHandle but keeping the Socket around for its address information.
11:36:09 <creature> Out of curiousity, what do you guys use Haskell for? What are its strengths?
11:36:40 <creature> I'm learning it, I presume, as a way of teaching us functional programming ideas and concepts. But does it have anything it really excels at that would make me want to use it in the real world?
11:36:58 <ibid> some people like to write compilers in it :-)
11:37:01 <dark> Hmm, but Socket doesn't have a finalizer.
11:37:50 <creature> Are these people sane people? 
11:37:56 <dark> creature: Currently I have three haskell projects: a binary -> C decompiler, a roguelike game, and a revision control system.
11:38:07 <dark> creature: The sanity of programmers is always in question.
11:38:19 <creature> Ooh@roguelike. 
11:38:29 <creature> That sounds quite fun, actually.
11:38:39 <creature> dark - OK, so why are you using haskell for these things?
11:39:03 <dark> Anyway, so far I'm happy with Haskell for these tasks.  Level generation in the roguelike game is too slow, but if all else fails I can probably write some pieces in C.  Haskell <-> C integration is surprisingly easy.
11:39:23 <dark> creature: Mainly, because I've gotten fed up with all other languages I know :-)
11:39:26 <ibid> creature: haskell is actually quite nice for that :-)
11:40:40 <dark> creature: Haskell has the pleasant property that if a program compiles without warnings, it usually also does the right thing.
11:40:57 <dark> The main exception to this, so far, is the damn FTP module which I'm presently stuck with.
11:41:08 <creature> Yes, it seems to be quite picky about what it does and doesn't accept.
11:41:22 <dark> creature: It's not just picky, it also tends to guide me toward a fix :)
11:41:41 <creature> I've not done a great deal of programming, but before I met haskell I never had something not compile/interpret because of a layout problem.
11:42:57 <Marvin--> dark: are you sure you're just calling socketToHandle once?
11:42:57 <dark> Ah, that's different -- I don't see that as pickiness, just Haskell's version of getting all the braces in the right place.  C complains if you forget a semicolon :)
11:43:39 <dark> Marvin: _fairly_ sure :)  But since this if FTP I have control and data sockets, and also a dataport socket for accepting connections... I'll audit my use of sockets and handles.
11:44:12 <ibid> creature: i have - python does that
11:44:24 <creature> Anyway, earlier, we were discussing the function "howManyOfFourAreDifferent", and much mutterings were made of recursion.
11:44:39 <creature> Would someone care to prod me in the apposite places to make me realise how to write that? 
11:45:02 <dark> creature: Hmm, you already have a howManyOfThreeAreDifferent.
11:45:15 <creature> dark - I've got a howManyOfFourAreDifferent, too.
11:45:21 <creature> But with recursion, no.
11:45:25 <dark> creature: Do you see how you could write howManyOfThreeAreDifferent in terms of howManyOfFourAreDifferent?
11:45:32 <creature> I don't just see, I've done it! 
11:45:47 <dark> creature: I'm asking it the other way around now :)
11:46:11 <creature> Are, yes, so you are.
11:46:58 <creature> And no, I don't.
11:47:15 <creature> Ooh, yes, I do.
11:47:31 <creature> Just call hMOFD x x y z"
11:47:34 <creature> surely? 
11:47:46 <dark> Yes :)
11:48:10 <dark> Of course, if you do just that, it won't work, because the functions will just keep calling each other and never stop.
11:48:51 <creature> Yes, because hMOFD uses hMOTD.
11:48:55 <creature> I see.
11:48:57 <dark> So you need a way to make it terminate.
11:49:13 <dark> Mind you, I don't know if the way this is heading will be any prettier than what you have now :)
11:49:25 <tez> Yes, a base case!  A little like the cases in your fibonacci function.
11:49:27 <creature> I don't mind, if I'm going to learn something new.
11:51:48 <creature> OK, so, how would I make it terminate?
11:51:52 <creature> And stop it getting stuck?
11:53:03 <dark> I'm back, I had to think about this a bit :)
11:53:26 <creature> Heh.
11:53:35 <creature> I can send you what I've done so far, if you like.
11:53:51 <dark> Well, first, a syntactic step: instead of calling hMO3D, just inline it and call hMO4D with one duplicate argument.
11:54:38 <dark> This just makes explanations less confusing, and it can suggest solutions.
11:54:59 <creature> "just inline it"? 
11:55:06 <dark> Oh, sorry :)
11:55:17 <creature> So we're all singing from the same score, you can see what I've got so far at www.alexpounds.com/Assessment2.hs
11:55:23 <dark> inlining is something a compiler does, when it substitutes the definition of a function where you have a function call.
11:55:31 <creature> and we're working on unmarked stuff right now, so don't worry about what you can and can't tell me.
11:55:47 <creature> ah yes, I've met inlining before. 
11:56:30 <creature> But I can't remember much of it.
11:56:53 <dark> It's something you can also do by hand, if it simplifies the code.
11:57:43 <creature> so instead of calling hMO3D from hMO4D, I call hMO4D from hMO4D, yes? 
11:57:48 <dark> So if you have howManyOfThreeDiffer x y z = howManyOfFourDifferent x x y z, then you can write that out instead of calling howManyOfThreeDiffer.
11:57:51 <dark> Right :)
11:58:41 <dark> Now, to make it terminate, you need two things: a base case, which gives an answer without further recursion, and a recursive step, which is guaranteed to bring you closer to the base case.
11:59:44 <dark> In this case, a likely base case seems to be the one where all arguments are equal.  I'm not sure why that seemed likely to me, though.
12:01:13 <dark> Well, probably it seemed so because when you call hMO4D with one argument repeated, you're reducing the number of different arguments.  So the natural place to end would be if all of them are the same.
12:01:38 <creature> I follow that, ish. 
12:01:46 <creature> I can see the ideas behind it but not how to implement it.
12:02:42 <dark> Well, if you add the base case, you get something like this:
12:02:59 <dark> | w == x && x == y && y == z = 1
12:03:17 <dark> | w == x || w == y || w == z = hMO4D x x y z
12:03:28 <dark> | otherwise = 1 + hMO4D x x y z
12:04:41 <dark> This won't work, though, it needs a little change :)
12:04:48 <creature> Yes, I've just found out that doesn't work. :)
12:04:55 <dark> Do you see why?
12:05:22 <creature> I think it's because it never hits the first case, but not sure why.
12:05:32 <creature> Let me look a little closer.
12:06:04 <creature> Is it because of the w == x bit? 
12:06:22 <creature> On our first recursion, w == x and so that clause is always true.
12:08:56 <creature> Am I wrong?
12:11:04 <dark> Sorry, I had a girlfriend interrupt :)
12:11:30 <creature> Is that a standard IRQ? :)
12:11:56 <dark> Sometimes it's a NMI :)
12:12:00 <creature> Heh. 
12:12:34 <creature> Anyway, am I wrong?
12:12:42 <dark> Anyway, yes :)  Because w is the argument you inspect, and w is also the argument you duplicate, you end up repeating the same duplication, instead of duplicating more and more arguments.
12:13:01 <dark> Oh, I answered you in reverse :)
12:13:29 <creature> yes, I see. 
12:13:39 <creature> x is the argument inspected, and it's duplicated.
12:13:42 <dark> Hmm, I said that wrong... x is the argument you duplicate, but it ends up being w in the next call.
12:14:41 <creature> OK. So how do we correct it?
12:16:16 <dark> Well, I haven't tried this :-)
12:17:15 <dark> But I think the correction is simply to repeat the last element, rather than the first.  By recursing with "x y z z", you make the arguments move up one by one into the w spot.
12:17:29 <tez> Yes, that's right.
12:18:41 <creature> That's really cool. 
12:18:45 <creature> And yes, it does work.
12:20:29 <dark> This is a somewhat unusual example of recursion :)
12:21:53 <dark> Not unusual in concept, but most functions recurse over lists or similar data structures, with the base case being "empty list" and the reduction step "make the list shorter".
12:22:24 <creature> Right.
12:24:07 <creature> Whilst we're talking about lists, there was mention of a one-line way to do a general case for HMO4D using them.
12:27:23 <creature> How would I go about that?
12:27:48 <tez> Well, I think starting with a multiline version using lists would be a good start :-)
12:28:08 <creature> This means someone is going to have to introduce me to lists, I think.
12:28:14 <creature> Bearing in mind I have met them before, briefly.
12:28:22 <dark> The one-line way is almost cheating :)  There's a function in the List module that does nearly the same thing already.
12:28:36 <dark> So the multi-line way is probably a better example.
12:30:13 <creature> I suppose farming it out to a shell and doing echo "x y z w" | uniq | wc -c" is cheating too. :)
12:31:38 <creature> OK, so, lists. Where do I start?
12:31:55 * Marvin-- is away: I'm busy
12:32:01 <dark> Okay, lists at warp speed :)  [] is an empty list.  If you have a list called xs, then (x : xs) is the same list with element x added in front.
12:32:04 * Marvin-- is back (gone 00:00:08)
12:32:08 <tez> Lists are composed of an element added to the head of an existing list.
12:32:19 <tez> Oops, one at a time.  dark, you first!
12:32:34 <dark> tez might be better at explaining this :)
12:32:50 <dark> After all, I was going at warp speed ;-)
12:32:55 <creature> I've done a bit of programming before, and know about arrays, and I don't think that lists look too difficult.
12:33:19 <tez> They're more like linked lists.
12:33:32 <creature> I've met them before, but ran away again screaming.
12:33:47 <dark> Fortunately in Haskell, you don't have to fiddle with pointers to get linked lists :)
12:34:01 <creature> ah yes, pointers. That would be why I ran away screaming. :)
12:34:52 <dark> Actually that's what I liked most about Haskell: we had an AVL-tree assignment, and I could swap subtrees around just by writing them down that way, rather than by doing 20 lines of pointer manipulations.
12:34:55 <dark> s/most/first/
12:36:02 <creature> OK, I get the idea of a list.
12:36:10 <creature> PHP! I think that's where I've encountered lists before.
12:36:12 <creature> Maybe in Perl.
12:36:18 <creature> I've dabbled a lot, you see.
12:36:29 <dark> So, a Haskell list always has a head (the first element) and a tail (the rest of the elements).  Unless it's the _empty_ list, [].  The tail is itself a list.  So a list of one element 'x' would be (x : []), which has a shorthand notation [x]
12:37:01 <creature> OK.
12:37:22 <dark> `:` is an operator that constructs a list, given its head and its tail.  You can also use it when pattern-matching, as in: length (x : xs) = 1 + length xs
12:37:49 <creature> OK.
12:38:21 <dark> Oh, the shorthand notation extends to as many elements as you want: [x,y,z], etc.
12:39:10 <dark> Now, the straightforward way to write the length function is like this:
12:39:13 <dark> length [] = 0
12:39:28 <dark> length (x : xs) = 1 + length xs
12:39:59 <creature> OK, I see that, I believe.
12:40:04 <dark> When dealing with lists you often have to remember that the empty list doesn't have a head or a tail, and if you try to access them anyway you get an error.
12:40:35 <dark> There are some helper funtions for lists: null xs will be True if xs is [], and False otherwise.  head (x : xs) is x, and tail (x : xs) is xs.
12:40:45 <creature> ok.
12:40:55 <dark> I have this sense that I'm going too slow :)
12:41:04 <creature> Nah, spoonfeeding's good.
12:41:24 <creature> Just because I understand doesn't mean I know this. :)
12:42:01 <dark> Most of the functions you see in the prelude will not be defined directly like length was, but in terms of other functions that operate over lists, mainly: foldr.
12:42:39 <dark> I think the easiest way to explain folder is with an example of its effect.
12:42:57 <dark> foldr (+) [a, b, c, d] expands to (a + (b + (c + d)))
12:43:10 * dark checks if he hasn't gotten it confused with foldl again.
12:43:16 <hdaume> that's correct
12:43:19 <dark> Oh, I got it confused with foldr1 :)
12:43:26 <hdaume> oh, yeah :)
12:43:37 <creature> So it's a bit like zipWith, only it operates on one list.
12:43:41 <dark> foldr1 (+) [a, b, c, d] expands to (a + (b + (c + d)))
12:44:15 <dark> Yeah, a bit, but notice how it results in one answer, instead of in a new list.
12:44:30 <hdaume> i like to think of foldr in terms of :/[] notation.  if you have a list a:b:c:d:[] and you apply foldr with the function # and the initial value k, then this "replaces" all the occurances of : with # and [] with k.  thus you get a#b#c#d#k.  in the case of + and 0, you get a+b+c+d+k
12:44:34 <hdaume> erm, d+0
12:45:12 <dark> The difference between foldr and foldl is how the parentheses go.  foldl1 (+) [a, b, c, d] expands to (((a + b) + c) + d)
12:45:56 <creature> ah, useful.
12:46:05 <dark> foldr1 has a "1" in its name because it doesn't work on empty lists.  It wants a list with at least 1 element.  Otherwise it has nothing to work with.
12:46:31 <dark> foldr takes an extra "zero" argument, which says what to start with.  With foldr you get what hdaume showed.
12:47:04 <dark> So: foldr 0 (+) [a, b, c, d] is (a + (b + (c + (d + 0)))), and foldr 0 (+) [] is just 0.
12:47:21 <creature> Right, with you so far.
12:47:36 <hdaume> actually, it's '
12:47:41 <hdaume> foldr (+) 0 [a,b,c,d]
12:47:46 <hdaume> but yeah
12:48:07 <dark> Oh I always mix up that order :)
12:48:19 <dark> Now, for some cute things to do with the fold funtions, see Prelude:
12:48:23 <dark> sum                     =  foldl (+) 0
12:48:23 <dark> product                 =  foldl (*) 1
12:49:35 <creature> neat.
12:50:08 <dark> I'm looking for more examples but few of them are cute :)
12:50:22 <hdaume> length?
12:51:10 <dark> hdaume: I only have ghc's library here, and its length function is monstrous :)
12:51:33 <hdaume> really?  shouldn't it just be 'foldr (const (+1)) 0'?
12:51:55 <dark> Oh, here's a cute one:
12:51:58 <dark> reverse                 =  foldl (flip (:)) []
12:52:08 <dark> This reverses a list, i.e. reverse [a, b, c, d] is [d, c, b, a]
12:53:00 <dark> To understand it you probably need this part :)
12:53:02 <creature> length           :: [a] -> Int
12:53:02 <creature> length            = foldl' (\n _ -> n + 1) 0
12:53:09 <creature> That's what it is on this system.
12:53:13 <hdaume> same thing
12:53:16 <dark> flip f x y = f y x
12:53:33 <dark> So I could write reverse as:
12:53:41 <hdaume> i also like sort = foldr insert []
12:53:53 <hdaume> where insert x l inserts x into l according to order
12:53:59 <hdaume> (this is insertion sort, obviously)
12:54:22 <dark> Oops, I got confused.
12:55:32 <creature> Ah, I see, I think.
12:55:35 <dark> reverse = foldl (\xs x -> x : xs) []
12:57:01 <dark> Anyway, no discussion of lists is complete without map and filter :)  I use them way more than foldl and foldr, but that's probably just because I am not worthy of the power of foldl.
12:57:18 <hdaume> creature: you might find ~p24 of http://www.isi.edu/~hdaume/htut/tutorial.{ps,pdf} instructive...
12:57:38 * hdaume uses folds more :)
12:57:43 <hdaume> especially foldM
12:58:05 <dark> "map" takes a function and a list, and applies that function to each element of the list, and returns the results as a new list.  So map abs [3, -4, 8, -1] is [3, 4, 8, 1]
12:59:14 <dark> An example closer to home might be upcaseString str = map upcaseChar str
12:59:40 <hdaume> or, after eta reduction: upcaseString = map upcaseChar :)
12:59:51 <dark> hdaume: Yeah, yeah :)
13:00:05 <tez> A, pointless programming!
13:00:12 <tez> s/A/Ah
13:00:14 <hdaume> pointFREE, please ;)
13:00:17 <tez> lol
13:00:24 <Marvin--> hdaume: no no no, it's called pointless :)
13:00:27 <Marvin--> really ;)
13:00:40 <creature> That's nice, re: map.
13:00:51 <creature> eta reduction?
13:00:59 <Marvin--> creature: lambda calculus
13:01:11 <hdaume> creature: if you have a function that looks like 'f x = something x', you can get rid of the xs to just leave 'f = something'
13:01:17 <dark> "filter" takes a boolean function and a list, and returns the elements for which that function is True.  For example, (filter even xs) will return a list of all elements from xs that are even.
13:02:35 <dark> creature: We already used eta reduction with the sum = foldl (+) 0 example.  Notice how the actual list doesn't appear in that definition.
13:03:03 <creature> OK, I see.
13:03:11 <dark> The definition just says what "sum" is, and it leaves it up to the user to apply it to something :)
13:03:54 <dark> Anyway, map and filter are the functions I miss most when I program in other languages.  Fortunately perl has map and grep which do similar things.
13:05:36 <dark> creature: Want to try countUniqueElements now?
13:06:25 <creature> I think I could.
13:06:39 <dark> hdaume: I can't think of any use for foldM :)
13:07:38 <dark> creature: Usually the first step is to figure out what it should return for an empty list.
13:07:48 <hdaume> say you're building some structure from files, use 's <- foldM (\s f -> do readFile f; return (combine s (process f))) emptyStrcture filelist'
13:08:21 <dark> hdaume: Hmm, this might be where I reach for "let loop =" :-)
13:08:35 <hdaume> ewwww ;)
13:09:39 <Marvin--> foldM good
13:10:01 <Marvin--> foldM is your friend, trust foldM
13:10:08 <dark> creature: I'm going off to beat my program into submission, but I'll keep an eye on this channel :)
13:10:15 <creature> dark - OK, thanks for your help.
13:10:17 <creature> I really appreciate it.
13:10:28 <hdaume> sometimes I wish there were a foldM_ in the std libs
13:13:16 <creature> The way I'd be inclined to attack this problem would be to sort the things into order, then do a recursive thing to compare pairs of them and decrement a counter when it hit pairs of them.
13:13:28 <creature> pairs of identical digits, I mean.
13:13:48 <hdaume> creature: that would be a very reasonable approach
13:14:12 <hdaume> creature: though i would *increment* a counter
13:14:39 <hdaume> Marvin--: who are you IRL?  do you post to the mailinglist?
13:15:00 <creature> Why increment? Or check for nonidentical digits, and increment?
13:15:07 <hdaume> creature: right
13:20:50 <creature> How do I get it to wander over each element in the list?
13:22:40 <hdaume> think about how length was defined (not using a fold)
13:22:41 <Marvin--> hdaume: In the "haskell world" I'm pretty much nobody ;) I recently subscribed to ghc-users but haven't posted anything yet
13:22:48 <dark> Marvin: I think I found it :)  You guessed close, there was a point where I called socketToHandle but didn't use the handle, and later called sClose on the socket.
13:22:52 <hdaume> Marvin--: oh, okay
13:23:06 <Marvin--> dark: heh
13:23:08 * hdaume sends Marvin-- to the corner
13:23:21 <Marvin--> nooooooo, not the corner!
13:23:43 * Marvin-- ponders the significance of the corner
13:24:01 <dark> Marvin: So the garbage collector would sometimes wake up, clean up the handle, and end up closing a fd I was using :)
13:24:15 <dark> Marvin: corner cases are the most interesting.
13:25:01 * Marvin-- doesn't feel all that interesting :P
13:25:21 <Marvin--> and I'm tired of reading these stupid smalltalk bank models now :(
13:28:56 <Marvin--> "L2 is a small functional language. The main difference from our previous language L1 is that L1 was an imperative language." <- how's that for a description? ;)
13:29:37 <hdaume> haha
13:32:48 <dark> Marvin: With my code, it's hard to tell the difference anyway :)
13:35:09 <Marvin--> dark: have you seen the HWS code?
13:47:53 <dark> Marvin: I _thought_ I found the problem.  I'm fairly sure I fixed an actual bug.  But it's still failing the same way.
13:48:02 <dark> Marvin: No, I haven't looked at HWS.
13:49:53 <Marvin--> dark: it's very imperative ;)
13:50:08 <dark> I made it say "Bing!" before each garbage collection.  Pathetic.
13:51:52 <dark> I don't get this at all.  Now it closes the fd between opening a socket and calling connect on it.
13:57:28 * Marvin-- sneaks up behind dark and shouts "BING!"
13:57:34 <dark> ("It's just a simple functional language" is an unregisterised trademark of Peyton Jones Enterprises, plc.)
13:57:46 * dark leaps up and collects garbage.
13:57:57 * Marvin-- hands dark a broom
14:04:35 * dark finally finds it and cackles madly for several minutes.
14:05:21 <dark> I checked all my uses of "close" functions, but I didn't see that I did handleToFd on an fd I later close...
14:05:38 <dark> There doesn't seem to be a way to drop a Handle without closing it.
14:05:58 <dark> So I guess I need to make sure it's an Fd all the way to its source :)
14:06:31 <Marvin--> ugh
14:10:46 <dark> Marvin: "import Posix" is proliferating :)
14:10:54 <Marvin--> bleh, now I've been correcting assignments all day
14:11:08 <dark> Marvin: There's a tight deadline?
14:11:22 <Marvin--> except for an hour when I sat in a meeting with the people I'll be working with the next half of the semester, talking about *drumroll* assignment correcting among other things
14:11:52 <Marvin--> dark: yeah, their final date to hand in fixed solutions is Sunday, so I want to get the damn things out of my hands
14:11:59 <Marvin--> I need a cognac
14:14:01 <dark> Marvin: So they get them back from you tomorrow, and have until Sunday to fix?
14:15:13 <Marvin--> dark: actually, it's electronic so it's nearly instantaneous :)
14:15:19 <dark> shapr might have the right idea with Counterstrike :)
14:15:29 <dark> Blasting pixels to bits can be a stress relief.
14:15:46 <Marvin--> it's not stress, it's boredom, it's fucking boring
14:16:28 <dark> Gahrahrargh, now I have to roll my own version of hPutStr for Fd.
14:17:47 <dark> Oh, cool, I don't -- this is a write to a file.  Posix filesystem semantics to the rescue.
14:18:38 <dark> I probably ended up making the program more efficient :)
14:19:14 <Marvin--> haha
16:08:29 * shapr bounces
16:08:51 <tez> Was someone earlier saying they had a Sharp Zaurus?
16:09:17 <tez> Oh, nevermind.
16:15:09 <dark> A shapr zaurus perhaps?
16:15:18 * shapr grins
16:15:38 <dark> My Agenda VR3 broke a while ago.  I'm in the market again for an entirely-free-software PDA.
16:17:12 <creature> Anyway, I'm off to bed 
16:17:20 <creature> Thanks lots for all the help tonight, guys.
16:17:25 <creature> I'm sure I'll be in again soon.
16:17:38 <shapr> g'night creature
16:18:56 <shapr> hi Pseudonym
16:18:58 <shapr> g'mornin
16:21:17 <Pseudonym> G'day.
16:21:36 <Pseudonym> Have you read the monad transformer papers yet? :-)
16:21:45 <shapr> reading now
16:21:48 * Pseudonym nods
16:22:09 <Pseudonym> You've got me thinking about it again now.  On the train in to work today I worked out another way to derive monad transformers.
16:22:16 <Pseudonym> Not sure how effective it is yet, though.
16:22:47 <shapr> so far, it looks like monad transformers are the spiffiest thing I've seen in programming yet...
16:22:57 <shapr> though honestly all of combinator theory fascinates me
16:24:02 <Pseudonym> Oh, monad transformers are SO useful for writing real programs.
16:24:18 <Pseudonym> The neatest thing of all, though, is liftIO.
16:24:21 <shapr> ?
16:24:28 <dark> I'm using a monad transformer in my roguelike game :)
16:24:41 <Pseudonym> class Monad m => MonadIO m where { liftIO :: IO a -> m a }
16:24:58 <Pseudonym> instance MonadIO IO where { liftIO = id }
16:25:28 <Pseudonym> instance (MonadIO m) => MonadIO (MonadTrans m) where { liftIO = lift . liftIO }
16:25:33 <Pseudonym> That's all you need.
16:25:50 <Pseudonym> Then from any monad transformer, you liftIO and you're lifted straight to the IO monad if it's at the bottom of the stack.
16:26:32 <Pseudonym> Lifting to the bottom of a stack is an odd metaphor.
16:26:41 * hdaume basically thinks that without monad transformers, monads would be more or less useless
16:26:48 * Pseudonym agrees
16:26:52 * Heffalump disagrees
16:27:06 <Heffalump> 99% of all Haskell programs use monads but not monad transformers
16:27:17 <Pseudonym> 99% of all Haskell programs are small.
16:27:19 <Heffalump> you don't see them anywhere in the core libraries
16:27:29 <Heffalump> So? Small programs are still useful.
16:27:35 <Pseudonym> Heffalump: IMO, that's a problem with the core libraries.
16:27:48 <Heffalump> but the core libraries are useful, and they just use monads
16:27:53 <Heffalump> whether or not they could be better
16:28:02 <Heffalump> I'm inclined to agree that most large programs require monad transformers
16:28:07 <Pseudonym> In fact, the reason why there are no monad transformers in the core libraries is because the core libraries by definition don't support multi-parameter type classes.
16:28:26 <Pseudonym> Historical and practical reasons, both of which are good reasons.
16:28:50 <hdaume> Heffalump: but i'd imagine they'd be much cleaner with MTs
16:29:14 <Pseudonym> I think the core libraries are less useful than they could otherwise be if they used MTs.
16:29:51 <Pseudonym> But I acknowledge the extremely good reasons why they don't currently support MTs.
16:30:54 <Pseudonym> Small programs are useful, but Haskell was designed with big programs in mind.
16:31:07 <Pseudonym> Thus distinguishing it from Miranda.
16:33:40 <shapr> there's surprisingly little published about arrows
16:33:46 <Pseudonym> I know.
16:34:10 <Pseudonym> I suspect it's because a) few people have found a use for them, and b) of those that could use them, few understand them.
16:34:15 * shapr wonders if anyone has written a PostScript interpreter in Haskell
16:34:27 <Pseudonym> Almost certainly not.
16:34:43 <shapr> imho, there's very little difference in difficulty between monads and arrows
16:35:08 <Heffalump> I understand monads better than I understand arrows
16:35:26 <Heffalump> arrows have /lots/ of laws, and I don't intuitively see why they're all essential
16:35:45 <shapr> hm
16:35:46 <Pseudonym> hdaume: Do you have a sourceforge account?
16:36:30 <Pseudonym> Heffalump: Yes, me too.
16:36:48 <Pseudonym> Apart from the parser example, I can't see why I would use them instead of monads.
16:37:18 <Pseudonym> Probably because I've never needed a monad-esque abstraction which can't be expressed as a monad.
16:37:33 <Heffalump> Pseudonym: well, there's the FRP/Yampa example
16:37:36 <shapr> arrows expose static properties of monads
16:37:54 <Pseudonym> Heffalump: True, but I've always been a bit suspicious of FRP.
16:37:55 <Heffalump> shapr: can you explain that statement?
16:37:58 <shapr> also, I suspect the FRP/Yampa style arrows could be extended to make mobile code.
16:37:59 <Heffalump> Pseudonym: why?
16:38:10 <Pseudonym> Heffalump: I dunno.  The whole paradigm seems a little weird to me.
16:38:36 <Pseudonym> I have absolutely no sensible reasons not to like FRP.
16:39:22 <shapr> one of the advantages of arrows given in the Hughes paper is that the "b" part of "a (b -> c)" exposes static properties of the input requirements
16:39:31 <Heffalump> shapr: meaning?
16:39:53 <Heffalump> Pseudonym: so what's your new way for deriving monad transformers?
16:40:16 <Pseudonym> Heffalump: I'm going to sit on it until I've decided if it's worth writing up or not.
16:40:25 <shapr> means that you can't find input properties of monads without applying the a -> m a
16:40:34 <Pseudonym> But it's based on a few techniques from pure lambda calculus programming.
16:40:48 <shapr> with arrows, you don't have to apply it to know whether it'll be successful
16:40:51 <Pseudonym> i.e. lambda calculus without data structures
16:40:57 <shapr> hi mmc
16:41:01 <mmc> :)
16:41:21 <Heffalump> shapr: wdym by "successful"?
16:41:25 <shapr> so far, my favorite part about Haskell is monad transformers, but I just discovered them yesterday :-)
16:41:32 <Heffalump> I understand what it means in the case of parsers, but not in general
16:41:33 <Pseudonym> Do you mean that it doesn't call "fail"?
16:42:02 <shapr> mmc: haskell is very different from scheme in that it's purely functional
16:42:17 <shapr> no side-effects allowed (unless you use a monad, but that's different)
16:42:27 <shapr> pseudonym: I think that's true.
16:42:30 <Pseudonym> Monad programming is side-effect-free too.
16:42:36 <shapr> yes, it is
16:42:48 <shapr> mmc: have you tried Haskell before?
16:43:06 <hdaume> grrr...i keep splitting
16:43:11 <mmc> shapr:  no.
16:43:26 <shapr> I really enjoy it...
16:43:37 <mmc> some  short intro  text ?
16:43:55 <shapr> the gentle intro on the haskell.org site is probably better than I am
16:44:00 <Pseudonym> hdaume: While you're here... Do you have a sourceforge account?
16:44:01 <hdaume> Pseudonym: i'm hcdaume3 on sf
16:44:05 <Pseudonym> OK.
16:44:06 * shapr looks for the url
16:44:11 <Pseudonym> Want me to add you as a hfl developer?
16:44:26 <hdaume> (i'm not the most creative person in the world when it comes to things like names)
16:44:29 <Pseudonym> You're not expected to actually do anything. :-)
16:44:33 <hdaume> Pseudonym: sure ;)
16:44:37 <shapr> mmc: http://www.haskell.org/aboutHaskell.html
16:45:03 * Pseudonym is curious who the other hcdaumes on sourceforge are
16:45:05 * hdaume thinks about all the havok he can wreak with that
16:45:17 <hdaume> Pseudonym: it's because i'm hal daume iii (hence the 3)
16:45:27 <Pseudonym> Ah, gotcha/
16:45:31 <mmc> shapr: thanks
16:45:42 <hdaume> Pseudonym: my dad uses hdaume as a log in for many things (travelocity), so i decided if i go with hcdaume3 there'll be virtually no overlap ever and i only have to ever remember one id
16:46:07 <Pseudonym> Yer in.
16:46:11 <hdaume> woohoo!
16:46:18 <hdaume> fame and fortune, this way come
16:46:21 <Pseudonym> Please commit that.
16:46:25 <Pseudonym> The size fix.
16:46:31 <hdaume> okay
16:46:52 <Pseudonym> I know that Ternary Trie isn't very polished yet.
16:47:03 <shapr> so...
16:47:06 <Pseudonym> Part of it is that I'm still mutating the Edison interfaces.
16:47:22 <shapr> as far as I can tell, part of the advantage of Arrows is that they expose static information to the compiler and runtime system
16:47:33 <hdaume> shapr: static info of what sort?
16:47:37 <hdaume> Pseudonym: it's all good
16:47:42 <Pseudonym> And how can the compiler use it?
16:47:49 <Pseudonym> hdaume: Thnaks.
16:47:51 <shapr> I think whatever static info you want to expose.
16:47:52 <Verbophobe> Mornin'.
16:48:00 <Pseudonym> Verbophobe: G'day.
16:48:06 <shapr> I can't believe I'm trying to explain arrows to you people ;-)
16:48:08 * shapr laughs
16:48:12 <Verbophobe> How's the wife?
16:48:34 <Pseudonym> Whose?
16:48:41 <shapr> I don't have a wife.
16:48:44 <shapr> so must not be mine.
16:48:46 * Pseudonym does and she's fine
16:48:51 <shapr> see, there's static info ;-)
16:49:04 <shapr> that question can only be applied to people who have at least one wife ;-)
16:49:18 <Verbophobe> No one in particular.  It's the generic "Wife" everyone has.  The one that haunts the dreams of masturbating teenagers world wide...
16:49:24 <shapr> um
16:49:32 <Verbophobe> Sound like a good movie: The Wife!
16:49:36 <Verbophobe> Sounds*
16:49:46 <hdaume> aw crap.  i just rememberd that i had to change my ssh key and so now i can't commit to sourceforge...
16:50:02 <Pseudonym> Ah.
16:50:17 <Pseudonym> I suspect that my wife doesn't haunt anyone's dreams.
16:50:18 <shapr> so, Monads do not expose static info, right?
16:50:29 <Pseudonym> She's not the haunting type.
16:50:37 <shapr> I think my fiancee does haunt people's nightmares sometimes, but only if they piss her off.
16:50:49 <Pseudonym> Oh, there's that, yes.
16:51:16 <Pseudonym> I once described my (then) fiancee as "subtle femininity with just the right amount of ruthless bitch".  She put it on her web site.
16:51:17 <Verbophobe> Of course.
16:51:21 <shapr> hah
16:51:24 <shapr> good description
16:51:29 <Verbophobe> Hehe...
16:51:46 <Pseudonym> OK, static info.
16:51:54 <Pseudonym> Is it just whether or not it can fail?
16:52:12 <Pseudonym> I assume, BTW, that's whether the programmer can prove it can fail or not.
16:52:35 <Pseudonym> Since every monad is an arrow and you can't tell if a monad fails or not in advance, I assume it's "may fail" information.  It may fail or it may not.
16:52:57 * shapr looks at the arrows paper by his elbow
16:53:24 <shapr> in the duponcheel parser example
16:53:53 <shapr> the two pieces of info are a) static list of symbols that the arrow can accept
16:53:58 <shapr> and b) the function that does the parsing
16:54:49 <Pseudonym> I remember from the motivation part of the paper, part of it is that parsing monads don't expose lookahead information.
16:54:59 <Pseudonym> Whereas parsing arrows do.
16:55:11 <Pseudonym> Hmmm.
16:55:16 <shapr> right
16:55:21 <Heffalump> I don't really have an intuitive understanding of why that is
16:55:44 <Heffalump> wooh. All my regexps finally simplify back to the original ones.
16:55:51 <shapr> because an arrow is like a monad with a sign on the front saying "I can accept only these items"
16:56:02 <Heffalump> unfortunately I had to include two rather complicated rules to make this work :(
16:56:16 <Pseudonym> Cool.
16:56:40 <Pseudonym> OK, so I think I see what is meant by "static information".
16:56:50 <Pseudonym> But I can't think of another use for it except FRP.
16:56:51 <Pseudonym> :-)
16:57:04 <Pseudonym> FRP makes sense because it's "I accept these events".
16:57:06 <Pseudonym> Right?
16:57:19 <shapr> what about including parallelization info as the static part?
16:57:32 <shapr> then you could more easily output EPIC for example
16:57:39 <Pseudonym> Er...
16:57:49 <Pseudonym> EPIC is a bit too fine-grained for this sort of thing.
16:58:18 <shapr> you could still get a lot closer to transparent parallelization with the exposed static info from an arrow
16:58:27 <Pseudonym> I guess it could be useful for Parallel Haskell.
16:58:29 * hdaume2 is getting frustrated
16:58:47 <hdaume2> NO I HAVEN'T!
16:58:50 <shapr> I suspect lots of info could be statically exposed.
16:58:54 <Pseudonym> hdaume or hdaume2: Why don't you try another server?
16:59:04 <shapr> yah, which one are you using?
16:59:06 <hdaume2> erm.  that could work
16:59:13 <hdaume2> irc.us.openprojects.net
16:59:32 <shapr> that should lookup to many different servers
16:59:36 <Pseudonym> It's only you an sethk who are having problems.
16:59:57 <shapr> for example, I use irc.eu.freenode.net mostly, but irc.se.freenode.net when things are flaky
17:00:09 * hdaume2 will try one of those
17:00:11 <hdaume2> bbias
17:00:31 <Pseudonym> I use netselect to choose one.
17:00:33 <shapr> Pseudonym: what kind of static info can be precomputed and exposed from various monads you've written?
17:00:40 <Pseudonym> Err...
17:00:42 * Pseudonym thinks
17:00:50 <hdaume3> let's try this one :)
17:00:54 <Heffalump> presumably you actually mean programs written using those monads.
17:01:03 <Pseudonym> Yes.
17:01:07 <shapr> or the monads themselves...
17:01:16 <Pseudonym> Well, I guess I could expose determinism information from my logic monad.
17:01:21 <shapr> parser monads don't expose what symbols they can accept, parser arrows do
17:01:29 <Pseudonym> Erk.  I'm having flashbacks from Mercury.
17:01:58 * shapr sends emergency coffee to Pseudonym ;-)
17:02:15 <Pseudonym> For my nondeterminism monad, for example, you could expose whether or not they can fail, and also whether or not they can have multiple solutions.
17:03:32 <shapr> hughes says that exposing static info allows for greater optimization at compile-time, leading to better runtime performance
17:03:45 <Heffalump> independently of the input. Hmm.
17:03:57 <hdaume3> my curiousity is now piqued
17:04:10 * shapr thought everyone else on #haskell already knew all this
17:04:13 <hdaume3> shapr: what paper are you going off of ;)
17:04:26 <shapr> John Hughes, "Generalizing Monads to Arrows"
17:04:38 <hdaume3> my knowledge of arrows is only greater than zero if we're in a model with infinitessimals
17:04:42 <shapr> I've been thinking about mobile code that uses arrows
17:05:15 <shapr> even spiffier, a modular interpreter that lets the agents be plugin arrows...
17:05:33 * shapr tries to use all the buzzwords at once
17:06:10 <shapr> Heffalump: I don't understand the laws part of either Monads or Arrows
17:07:05 <hdaume3> shapr: the laws of monads are easy and (i think) make logical sense
17:07:32 <Heffalump> each individual arrow law makes sense to me, but I don't really understand why they're essential
17:07:37 <shapr> it would make more sense to me if I could see the other alternatives that have been tried
17:07:40 <shapr> and why they didn't work
17:07:50 <Heffalump> especially cos it's not immediately obvious which ones are needed to make arrows syntax work
17:08:27 <hdaume3> shapr: basically, they say: returning the result of a computation is the same as just doing the computation; retruning a value into a computation is the same as just applying that computation to a value; and parenthesation around >>= is irrelevant
17:08:29 <Heffalump> the associative monad law is essentially necesary to guarantee substitutivity on do notation
17:09:22 <shapr> hdaume3: when you say it like that it really is easy to understand.
17:09:29 * shapr saves that quote into his haskell notes
17:09:57 <Heffalump> hdaume3: could you state the first two laws in symbols? I don't understand them.
17:10:27 * shapr put static info into the Heffalump arrow, "only accepts symbols" ;-)
17:10:36 <hdaume3> 'k >>= return  ===  k' and 'return a >>= k   ===  k a'
17:11:10 <Heffalump> ok.
17:11:13 <Heffalump> now I see :-
17:11:14 <Heffalump> )
17:11:37 <Heffalump> you were using the word "computation" to mean two different things
17:11:46 <shapr> he was?
17:11:48 <hdaume3> or, in do notation 'do a <- k; return a' is just 'do k' and 'do x <- return a; k x' is the same as 'do k a'
17:12:16 <Pseudonym> The other one is: m >>= k1 >>= k2 == m >>= (\a -> k1 a >>= k2)
17:12:47 <Heffalump> yeah, but I understood what he meant by the last bit of English he said :-)
17:12:52 <Pseudonym> I think that's what makes do notation possible.
17:12:54 <hdaume3> :)
17:12:57 <Heffalump> Pseudonym: yes
17:13:21 <Heffalump> shapr: the first time he really meant computation as in something of type Monad m => m a, whereas the second time he meant a function returning a computation, i.e. something of type Monad m => a -> m b
17:13:46 <Heffalump> (well, I dunno what he actually meant, but that's the way I'd interpret it :-)
17:14:05 <hdaume3> Pseudonym: is filter on TernaryTries strict?
17:14:37 <Heffalump> Pseudonym: without the last law, do {x ; y} where y = do { z ; w } isn't necessarily the same as do { x ; z ; w }
17:15:14 <Pseudonym> Right.
17:15:22 <Pseudonym> hdaume3: No.
17:15:33 <Pseudonym> The tree is strict but the values in it are not.
17:15:42 <hdaume> Pseudonym: okay
17:16:11 <Pseudonym> Actually, yes it is.
17:16:16 <Pseudonym> Now that I look at it. :-)
17:16:34 <Pseudonym> Because filter, by definition, must evaluate the values.
17:16:37 <hdaume> hehe, okay...i was getting weird performance behaviour, but i figured out the cause (i think)
17:17:20 <Pseudonym> Do you like my combinator in fold1?
17:17:25 <shapr> well, I'll reread the arrows paper (for the fourth? time) and then come back and try to explain it again.
17:17:28 * Pseudonym was particularly proud of that
17:17:39 <hdaume> actually, nevermind...i am getting weird performance
17:17:43 <shapr> I'm pretty sure you can use an Arrow to expose static info of whatever flavor you want
17:17:43 <hdaume> i may ask you about it tomorrow
17:17:47 <Pseudonym> OK.
17:17:56 * hdaume leaves
17:18:06 <shapr> I need to sleep also...
17:18:13 <Pseudonym> OK.
17:18:15 <Pseudonym> Night.
17:18:16 <shapr> g'night
17:18:27 * Pseudonym will have to reread the paper now
17:23:57 <Verbophobe> Hey, quick question: I've been "perusing" the "Gentle Introduction to Haskell", and have realised that it's not as gentle as advertised...  Would there be an "alternative" source from which I could derive my studies? 
17:24:38 <Verbophobe> Because I've gathered enough about how the functions work, but I'm basically lost after that...
17:27:44 <Pseudonym> I think there are some suggestions on the wiki.
17:27:45 <Pseudonym> Hang on.
17:28:26 <Verbophobe> "Wiki"?
17:28:36 <Pseudonym> http://haskell.org/wiki/wiki
17:28:40 <Pseudonym> Only it's broken at the moment.
17:29:06 <Verbophobe> Hmmm...  Looks interesting.
17:29:39 <Pseudonym> You'll find a lot of blank pages, which is the symptom of brokenness.
17:29:52 <Verbophobe> As I can see.
17:30:04 <Verbophobe> http://web.archive.org/web/20010822232003/http://haskell.org/wiki/wiki?HaskellNewbie <=== Web Archive to the rescue.
17:30:15 <Pseudonym> (http://www.cs.chalmers.se/Cs/Grundutb/Kurser/d1pt/d1pta/
17:30:28 <Pseudonym> There's also LearningHaskell.
17:30:32 <Pseudonym> On the wiki.
17:30:41 <Pseudonym> Which you'll also want to go to the archive for. :-)
17:31:28 <Verbophobe> Hehe...  Damn...  Can't seem to find it.
17:31:35 <Verbophobe> The archive, that is.
17:32:03 <Pseudonym> This is the one: http://www.cs.chalmers.se/Cs/Grundutb/Kurser/d1pt/d1pta/external.html
17:32:08 <Pseudonym> That's supposedly not bad.
17:32:23 <Verbophobe> Looking at it now...
17:32:43 <Verbophobe> Oh, and one more question: Where's some code I can look at?
17:34:08 <Pseudonym> Good question.
17:34:28 <Pseudonym> There's a lot of code as examples of advanced topics, but I don't know where there's a lot of beginner code.
17:35:09 <Verbophobe> Hmmm...  Well, I'll read a little, and if anything comes up, mind if I ask you?
17:35:10 <Verbophobe> Hehe...
17:35:42 <tez> What?  The is #haskell, not #haskellQuestions!
17:35:52 <Pseudonym> Absolutely.
17:35:54 <tez> s/The/This
17:36:00 <tez> ;-)
17:36:17 <Pseudonym> I assume you mean the plural "you" rather than me specifically. :-)
17:36:35 <Verbophobe> Well damn...  So, err...  What's better with Haskell: marmalade or strawberry jam?
17:37:04 <Pseudonym> How DARE you suggest using theoretically impure marmalade?
17:37:50 <Verbophobe> Whoa!  Relax...  The guy said the marmalade was pure, once the seringes are distilled.
17:37:58 * Pseudonym laughs
17:38:17 <Verbophobe> For now, comrade, I must proceed to reading.
17:38:59 <Pseudonym> Indeed.
17:39:07 <Pseudonym> Fight the good fight, and all that.
17:48:31 <Verbophobe> Is there a man(1) style refrence for Haskell functions?
17:50:42 <Heffalump> no, but someone should write a back-end for haddock to make one
17:50:49 <Pseudonym> Yes.
17:50:56 <Pseudonym> For now, look at http://haskell.org/ghc/
17:51:02 <Pseudonym> and go to the documentation link.
17:51:06 <Pseudonym> That's about the best you'll find.
17:51:20 <Verbophobe> Alright, good enough.
17:52:13 <Verbophobe> This is fascinating...  Comming from a C background, all of this really simplifies everything...
17:56:54 <Pseudonym> Yes, though it makes a few things you're used to a bit more complex.
17:57:01 <dark> Hmm, it seems that 3000 lines is the critical point at which Haskell programs start to suck.
17:57:04 <Pseudonym> At least until you start thinking in Haskell, anyway.
17:57:15 <Pseudonym> dark: Use more monad transformers. :-)
17:57:22 <Verbophobe> File IO seems simpler.
17:57:28 <Verbophobe> Emphasis on "seems"
17:57:33 <Pseudonym> Verophobe: Yes and no.
17:57:40 <dark> Verbophobe: I just got out of a grand fight with file IO :)
17:57:48 <Pseudonym> Sometimes mmap I/O is simpler, for example.
17:57:51 <dark> Took me two days to nail one bug.
17:58:06 <Pseudonym> Personally, I think stream input is way simpler in Haskell.
17:58:18 <Pseudonym> Output isn't so simple, though.
17:58:34 <dark> Other way around, I think :)  hGetContents is just difficult.
17:58:45 <Pseudonym> Not once you have it.
17:59:04 <Verbophobe> Hehe...  Anyway, I guess I'll find out, eventually.
17:59:06 <Pseudonym> dark: Can you honestly say you didn't have similar difficulties when you first learned stdio?
17:59:07 <dark> Pseudonym: Still is, if you want to deal with I/O errors properly.
17:59:24 <Verbophobe> I'll let you folks "discuss"
17:59:49 <dark> Pseudonym: I just spent two days trying to figure out why file descriptors were getting randomly closed in the middle of operations.  No, I had no similar difficulty with stdio :-)
18:00:52 <dark> On the other hand, this was a direct result of mixing the Handle and Posix interfaces, which is not normal.
19:17:19 <Heffalump> hi Chilli
19:17:43 <Chilli> Moin Heffalump
19:17:58 * Heffalump needs a bed in his office
19:18:07 <Chilli> :-)
19:19:11 <Heffalump> Oh, and I should start working in bigger clumps. Say 4 days of nothing but work and sleep, then 4 days off.
19:19:23 <Chilli> hehe
19:19:32 <Chilli> less context switching overhead
19:19:40 <Chilli> ok, I am off to lunch
19:19:42 <Heffalump> indeed
19:19:43 <Heffalump> cya
19:20:00 <Chilli> cya
19:20:22 <dark> Hmm I've had 3 weeks of coding and sleep.  fortunately it wasn't work :)
19:21:10 <Heffalump> My work is (often) fun
19:27:05 <dark> Heffalump: I've decided to look for fun work and not settle for less anymore.
19:27:25 <dark> In the meantime I'll improve my chances by writing lots of free code :)
19:47:10 <Pseudonym> Lunch for me too.
19:48:10 <hdaume> Pseudonym: finitemap kicks ttrie's ass ;)
20:25:03 <Pseudonym> :-)
20:25:05 <Pseudonym> Figures.
20:25:09 <Pseudonym> How long are your lists?
20:34:10 <Pseudonym> I checked in a new copy which shrinks trees on deletion.
20:34:24 <Pseudonym> It might not be as efficient as it could be.  Might be doing too many rebalances.
20:35:35 <Pseudonym> The other thing is that my version uses the "not just maybe" idiom in a few places that would benefit from specialisation.
20:36:38 <Pseudonym> Oh, missed a cas.e
20:59:34 <Pseudonym> OK, fixed now.
21:00:51 <Pseudonym> Incidentally, I think that using small tries won't buy you much.  Large ones will do much better.
21:01:16 <Pseudonym> Also, you will on lookup, not on insert.
21:01:20 <Pseudonym> win, not will
21:06:55 <lament> So what's the best haskell tutorial online?
21:21:24 <Pseudonym> Er... good question.
21:21:30 <Pseudonym> Define "the best".
21:21:46 <Pseudonym> OK, fairer question: How much programming experience?
21:23:33 <lament> Hmm... Quite a lot.
21:23:44 <Pseudonym> http://haskell.org/bookshelf/
21:23:55 <Pseudonym> Go down to "gentle introductions".
21:24:11 <Pseudonym> You might want to try the IBM one.
21:24:33 <lament> Ok, thanks.
21:24:43 <Pseudonym> It requires free registration.
21:24:51 <Pseudonym> You might also want to look at some of the others in the list.
21:25:24 <Pseudonym> And of course we're here if you get stuck.
22:35:46 <hdaume> Pseudonym: okay...i was just testing on insertWith.  my keys are between 1 and 8 long (only Ints) and my elts are Integers.  i just increment the integer on the insertWith.  FiniteMap was much faster, though i'll probably convert the FM into a TT later.  bed time now though.
23:19:30 * lament wonders if GHC will ever finish compiling
23:22:54 <Pseudonym> No.  It never ends.
23:23:42 <lament> Well, since it's supposed to compile itself, I'm ready to believe that :)
23:24:32 <dennisb> It's much more fun to just install a binary
23:25:06 <dennisb> i've seen ghc take 10h and similar to compile itself :-)
23:25:49 <lament> Ooh, err.
23:26:36 * Pseudonym has never gotten ghci out of a compile yet
23:26:42 <Pseudonym> Mind you, I didn't try hard.
23:26:46 <lament> I'll guess I'll do that another time, then.
23:29:08 <dennisb> ooh, I didn't mean to scare him away .-)
23:29:28 <dennisb> it's of course also dependent on the speed of the computer
23:30:06 <Pseudonym> Really?  I thought it was totally independent.
23:30:26 <dennisb> it's even more dependent om how much memory you have
23:30:39 <dennisb> at least it used to be
23:31:18 * dennisb likes to point out the obvious
23:31:21 <Pseudonym> This machine hasn't started swapping once yet.
23:31:34 <Pseudonym> Which is nice.
