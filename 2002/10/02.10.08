00:01:25 <dennisb> i'm home
00:01:34 <obraun> morning
00:01:49 <dennisb> I'm marking assignments.. Oooh what a joy
00:01:55 <dennisb> morning
00:09:13 <sethk> Better than working...
05:44:24 * shapr bounces
05:44:32 <cleverdra> Hello shapr =)
05:44:40 <shapr> hi cleverdra, how goes it?
05:45:47 <cleverdra> I'm in a very good mood =)  Focusing mainly on learning Haskell and O'Caml, and expect to finish that COM client today.
05:46:24 <Igloo> shapr: You might be interested in http://chaos.earth.li/~ian/mb-0.0.1.tar.gz (it's a bit tidier now, and does colour)
05:46:49 <shapr> yay, color!
05:46:55 <shapr> cleverdra: wow, that's quick work
05:46:56 <Igloo> Well, blue anyway  :-)
05:47:11 <shapr> cleverdra: COM took me months to figure out when I first played with it in VB
05:47:35 <shapr> blue is good!
05:48:35 <cleverdra> shapr - well, this is pretty simple =)  It opens a new document in Word, puts configuration and instructions into it, and then waits on a PopupBox to read the configuration back and generate a test.
05:49:04 <shapr> igloo: spiffy!
05:49:27 <shapr> it's *fast*
05:49:49 <Igloo> Yeah, if you use Double. Oh, haven't actually tried with Rational now I think about it
05:50:13 <shapr> do you use arrays in here?
05:50:13 * shapr greps
05:50:20 <Igloo> No, just lists
05:50:27 <shapr> oh
05:50:35 <shapr> I was wondering about hacking parr into it
05:50:37 <Igloo> But it's written out lazily - I don't see what good arrays would do me
05:51:06 <shapr> I'm just trying to find a good place to apply Parr
05:51:32 <Igloo> Ah. You could convert it to use arrays, but then it would take width*height space rather than constant space
05:51:59 <shapr> wow, PPM is really that simple?
05:52:25 <Igloo> Yeah - well someone had to come up with an image format that is
05:52:53 <shapr> heh
05:52:58 <Igloo> There's a variant in which the colour values are written as "123 " rather than "\123" too
05:53:19 <shapr> even simpler
05:53:25 * Igloo was going to use PNG, but then I discovered compression is compulsory
05:55:07 * shapr tries @ 1280x1024
05:55:50 <shapr> hm, it's single threaded
05:57:07 <shapr> ./unrolled  28.61s user 0.03s system 99% cpu 28.699 total
05:57:14 <Igloo> Yup, just plain old H'98
05:57:14 <shapr> that's at 1280x1024
05:57:30 <shapr> hi ski
05:57:35 <ski> hi shapr
05:57:39 <shapr> what's up?
05:57:48 * Igloo works out you have a 3GHz CPU, which seems unlikely
05:57:55 <shapr> I do actually
05:58:08 <shapr> 2 * 1.544 GHz
05:58:18 <Igloo> But only 1 was being used presumably?
05:58:23 <shapr> I think so
05:58:29 <ski> i gonna work more on a concurrent lab as soon as my lab pertner shows up. in the meantime i think i'll work a little at the AFP lab
05:58:34 * shapr tries again
05:58:55 <shapr> yup, only 1 CPU is being used
05:59:55 <Igloo> Curious, it seems to b going 7 times faster than my 500MHz CPU
06:00:14 <Igloo> Oh, but it's probably mostly the FPU at work
06:00:24 <shapr> yah, Athlon FPUs are extraspiffy
06:00:43 <shapr> sposedly that's why compilation is so fast
06:00:46 * shapr isn't sure if that's true
06:01:02 * cleverdra isn't sure either: what does compilation have to do with FP?
06:01:23 <shapr> cleverdra: I dunno, seems unlikely, and yet, I've heard that from several different people.
06:01:29 <shapr> maybe it's urban computer legend?
06:02:22 <shapr> is there a concurrent + socket demo somewhere?
06:02:38 <shapr> I'd like to see a single thread that hangs around and does reads and writes on a socket
06:05:38 <shapr> aha
06:05:44 <shapr> http://www.haskell.org/ghc/docs/papers/concurrent-haskell.ps.gz
06:52:49 <Igloo> Does anyone know in what way hGetContents, getContents, and readFile are lazy while the other IO functions aren't?
06:53:50 <cleverdra> I know that readFile is at least traditionally lazy: it's been that way since before monadic I/O.
06:54:19 <Igloo> traditionally lazy?
06:54:35 <cleverdra> "it's been that way since before monadic I/O"
06:56:33 <Igloo> I'm trying to understand what Simon Marlow meant by "hGetContents, getContents, and readFile are the lazy functions." given     main = do hSetBuffering stdout NoBuffering; hPutStr stdout ("foo" ++ show (f 0)) where f :: Int -> Int; f i = f (i + 1)      successfully prints "foo"
06:57:51 <ski> but that's output, not input ..
06:58:24 <ski> that seems to show that the output of previous computations are accessible before later computations are finished
06:58:57 <ski> (which isn't in general true about a random state monad)
06:59:22 <Igloo> The message is talking about all of the IO functions I think
07:00:18 <Igloo> Oh, so you mean they are lazy in the sense that a read might not happen before a putStr or other read it precedes?
07:00:41 <Igloo> OK, that makes sense, and is good news for me  :-)
07:01:16 <ski> i didn't think i meant so (don't know exactly what your response means)
07:01:21 <cleverdra> In the sense that you can read an entire file into a list, pop the first element of the list in a loop (doing mangling, writing it to stdout) without potentially requiring infinite memory.
07:01:50 <ski> that's what i though lazy input was about, yes
07:01:55 <cleverdra> At least, this is what I'd expect from a lazy input function.  I haven't used any of these yet.
07:02:51 <ski> (i however seem to recall that there was something fishy about at least getContents and hGetcontents. seem to recall it from some c.l.f discussion a while ago)
07:02:55 <Igloo> IM if you had getContents; putStr foo then stdin may not be read before foo is written, but with putStr foo; getcontents you are guaranteed that foo will be written first
07:03:29 <ski> perhaps, i don't know ..
07:03:58 <Igloo> That seems particularly dodgy in the case of hGetContents, though, given you could write to the same handle
07:04:54 * shapr boings
07:05:25 <Igloo> shapr?
07:06:04 * Igloo notices the time and leaves. With any luck foo/Rational will be finished when I return  :-)
07:06:15 <shapr> igloo: I'm cheerful.
07:06:32 <Igloo> Ah, OK, not a specific boing then  :-)
07:06:33 <shapr> bouncing, boinging, springing, and hopping are good cheerful things.
07:06:37 * Igloo really leaves
07:07:01 * cleverdra used to hop in place when he was happy.
07:07:16 <shapr> oh, hopping too
07:10:18 <ayrnieu> and for our next round of 'Earthlink KeepAlive', we introduce randomized groups.google.com searches!
07:10:28 <shapr> yay!
07:10:45 <shapr> hey, if you have xscreensaver installed you could run webwhacker in a window
07:10:51 <shapr> that would be both cute and useful
07:14:26 <ayrnieu> ah.  I'd have to set the delay on the screensaver to something like a minute, though.  That might work.
07:14:58 <shapr> er, the name is actually webcollage I think
07:15:16 <shapr> yah, if you set the delay between images to a minute it should be fine
07:19:06 <ayrnieu> ah!  OK.
07:19:33 <shapr> then you can run it in a window continuously, and it'll exercise your connect.
07:32:32 <shapr> yay, still connected :-)
07:34:28 <cleverdra> =)  I'm downloading, though.
07:34:36 <cleverdra> Maybe all that I need is someone's /dev/zero =)
07:39:22 * cleverdra gets around to reading http://lists.canonical.org/pipermail/kragen-fw/2000-September/000211.html
07:43:40 <shapr> cleverdra: ok, that's funny
07:46:40 <shapr> I expect that this article will lead to a flood of another 200 followups
07:46:41 <shapr> (and not a single practically useful library)... ;)
07:46:41 <shapr> How about this: for every article you write in c.l.f. you contribute at
07:46:41 <shapr> least 100 lines of code or documentation to a free software project that
07:46:41 <shapr> makes use of functional languages
07:47:03 <shapr> I like this guy.
07:47:33 * cleverdra nods.
07:47:51 * ski agrees
07:51:23 <shapr> in Java, I'm used to spawning a thread and making it listen to a socket (since socket reads are blocking as far as I know)
07:51:30 <shapr> is that the right way to do things in Haskell also?
07:52:33 <cleverdra> I'd prefer concurrency with non-blocking sockets, whatever the language.
07:53:12 <ski> or perhaps global gathing of all possible blocking requests and blocking 'til at least one of them is ready
07:53:15 <shapr> can it be done in Haskell?
07:53:21 <ski> s/gathing/gathering/
07:54:46 <ski> perhaps hSelect at http://haskell.cs.yale.edu/ghc/docs/latest/html/hslibs/select.html ?
07:58:59 <shapr> hm, seems that doesn't work with concurrent haskell
08:01:15 <ski> they seem to mean that one doesn't need to
08:01:46 <shapr> but select only works on files, not sockets, right?
08:01:51 <shapr> iirc, only windows can do select on sockets
08:02:32 <ski> socketToHandle : http://www.haskell.org/ghc/docs/latest/html/network/Network.Socket.html  :)
08:04:52 * shapr reads
08:05:28 <shapr> hm, so you think I can select on handle that's from a socket, and still do GUI stuff at the same time?
08:14:44 <ski> perhaps
08:59:56 <shapr> has anyone gotten SimonMar's webserver running in ghc5 ?
09:18:46 * shapr tries to fix SimonMar's webserver for ghc5
09:21:09 * shapr notes that exceptions are far cooler than they appear
09:22:41 <ski> (exceptions in haskell ?)
09:22:45 <shapr> yup
09:23:17 <shapr> exceptions have changed just a bit from GHC 4.08 to GHC 5
09:23:28 <shapr> the small differences are giving me a nice tour of exception handling in Haskell
09:23:31 <ski> how ?
09:23:55 <shapr> it seems that catchAllIO was a standard function before, but now it needs "catchAllIO = catchJust ioErrors"
09:24:15 <shapr> also, throwing exceptions to a specific thread has changed names
09:24:23 <shapr> raiseInThread has become throwTo
09:24:50 <ski> ok
09:25:59 <shapr> anyone know where fork# is?
09:28:14 * shapr has never heard of that one
09:28:33 * ski neither
09:29:54 <hdaume> according to the ghc docs, there's only forkIO, forkProcess and forkProcessPrim
09:30:27 <shapr> maybe it was only in 4.08
09:30:40 <hdaume> mebbe
09:35:15 <cleverdra> fork# would be an internal identifier, like ccall#
09:35:42 <cleverdra> meaning that it's very low-level by the naming, not that it isn't exported somewhere.
09:36:05 <ski> wouldn't fork# be like (+#) and the such (i.e. operations and constants having to do with unboxed values)
09:36:06 <shapr> right, but where is it exported?
09:36:48 <cleverdra> egrep -r 'fork#' fptools/ghc ?
09:36:54 * shapr tries that
09:37:23 <shapr> aha
09:37:51 <shapr> GHC.Exts
09:39:54 <hdaume> does anyone know why the views proposal hasn't had any steam...was it debunked or simply no interest...i skimmed the archives (via less and grep), but couldn't find anything relevant
09:40:13 <shapr> what is it?
09:40:26 <hdaume> it's a mechanism for doing pattern matching with adts, basically
09:40:39 <hdaume> http://haskell.org/development/views.html
09:40:43 * shapr reads
09:43:09 <shapr> looks straightforward
09:45:13 <shapr> where does hGetBufBAFull come from?
09:48:36 <ski> I think there was some disagreement about exactly what features and syntices should be added
09:48:51 * shapr finds hGetBufBAFull
09:49:10 <hdaume> ski: and so the whole thing was dropped?
09:49:13 <ski> (i read some paper recently about "transformational" patterns)
09:49:59 <hdaume> same idea?
09:50:13 <ski> hdaume : not necessarily dropped, but put a bit to rest until there was a clear consensus about what to include (or something like that, i imagine)
09:50:48 <ski> not exactly same idea, but overlapping
09:50:58 * shapr grumbles
09:51:12 <hdaume> shapr: i beleieve that function was removed
09:51:19 <shapr> yah, I just discovered that.
09:51:25 <ski> transformational patterns solves some things that views doesn't handle and vice verca, IIRC
09:51:37 <hdaume> shapr: i think there's a version without the 'BA' that does the same thing
09:51:47 <shapr> oh, lemme try that, thanks!
09:52:05 <hdaume> i ran into the same thing when updating the Binary module
09:52:27 <hdaume> ski: who was the paper by?
09:58:17 <ski> hdaume : unfortunately i can't remember now (even though i just read it some days ago 
09:58:49 <shapr> 	Expected type: GHC.Ptr.Ptr a
09:58:49 <shapr> 	Inferred type: MutableByteArray RealWorld Int
09:58:52 * shapr thinks
09:59:05 <hdaume> ski: oh, it's spj's pattern guards thing...yeah...i like that but i don't think it's enough
09:59:16 <hdaume> shapr: what are you doing?
09:59:35 <ski> Pattern Guards and Transformational Patterns - Martin Erwig , Simon Peyton Jones
09:59:38 <shapr> just tried to hack the hGetBufBAFull into hGetBuf
09:59:45 <ski> ok
10:00:19 <hdaume> the transformational stuff isn't implemented tho, is it?
10:00:30 <hdaume> shapr: on what module?
10:00:54 <ski> i don't know
10:01:21 <shapr> hdaume: Response.hs in SimonMar's web server
10:01:36 <hdaume> try just using hGetBufBA
10:02:05 <shapr> wow
10:02:06 <hdaume> it's exported from GHC.IOBase, I believe
10:04:03 <shapr> I don't see it in the Haddocs
10:07:34 <shapr> yay, now it's trying to compile Main.hs
10:07:36 <shapr> happiness!
10:11:47 <shapr> hrm
10:11:53 <shapr> weird error
10:12:00 <shapr> AccessLogger.hs:163:
10:12:00 <shapr>     Warning: Defined but not used:
10:12:01 <shapr> 		 resp_headers, resp_coding, resp_send_body
10:12:01 <shapr> /tmp/ghc8653.hc: In function `scvS_ret':
10:12:01 <shapr> /tmp/ghc8653.hc:4344: warning: implicit declaration of function `my_inet_ntoa'
10:12:01 <shapr> /tmp/ghc8653.hc:4344: warning: assignment makes pointer from integer without a cast
10:12:06 <shapr> AccessLogger.o: In function `scvS_ret':
10:12:06 <shapr> AccessLogger.o(.text+0x37e8): undefined reference to `my_inet_ntoa'
10:12:50 <shapr> any idea what to do with that?
10:15:33 <ski> my_inet_ntoa is perhaps like atoi or itoa or similar. i.e. a conversion function to ascii ?
10:15:42 <shapr> makes sense
10:15:45 <shapr> number to ascii?
10:15:57 <shapr> name,number, something
10:20:13 <shapr> looks like it's a getHostByAddr call
10:23:28 <cleverdra> com.ps is rather convincing in its portrayal of Haskell as far superior to Java or Visual Basic as a COM-scripting language.
10:23:59 * shapr hasn't read that paper
10:27:21 <cleverdra> http://www.cs.uu.nl/~daan/papers/com.ps "Scripting COM components in Haskell"
10:27:40 <ludde> What does this error message mean?
10:27:41 <ludde> ERROR "hw.hs" (line 33): Illegal type "HtmlCode -> HtmlCode" in constructor application
10:27:57 <ludde> the line is: tag :: TagName -> [Parameter] -> HtmlCode -> HtmlCode
10:28:16 <ludde> TagName is String, Parameter is (String,String), and "newtype HtmlCode a = HtmlCode ((a -> HW) -> HW)"
10:28:26 <ludde> where HW is a data type with a few items
10:29:10 <hdaume> then it nees to be 'tag :: TagName -> [Parameter] -> HtmlCode ___ -> HtmlColde ___' where ___ is some type
10:29:23 <ludde> oh, right. thanks
10:29:36 * ludde is stupid
10:35:25 <ludde> how does haskell's layout work when lines contain tab characters?
10:35:33 * shapr dunno
10:35:40 <shapr> I use spaces always, tabs never
10:35:48 <ludde> i prefer tabs.
10:36:00 <cleverdra> Why do you prefer tabs?
10:36:01 <ludde> but i always get problems with layout when i use them 
10:36:16 <shapr> tabs aren't the same size to all people
10:36:23 <cleverdra> I've been using tabs in windows, since I don't have Emacs here.  I'm having no problems, but I use tabs exclusively.
10:36:35 <shapr> what? no emacs?
10:36:41 <shapr> download xemacs for windows!
10:37:05 <cleverdra> I may have to, if I do too much more programming on this machine =)
10:37:53 <cleverdra> ludde - but why do you prefer tabs?
10:38:19 <ludde> it's easier to navigate in the code when it contains tabs (enough to press right once instead of like 4 times), it's easier to un-ident a line
10:39:16 <cleverdra> That doesn't seem to be true in Emacs Haskell-mode, but OK.
10:39:19 <ludde> I don't see any reason to hardcode spaces in the file when a tab is what I really mean.
10:40:40 <ludde> in layout-less languages, I don't force other people to use my tab-size
10:40:44 <cleverdra> ludde - if you don't mix tabs and spaces, as I am doing, you shouldn't have a problem.  If you want to know how tabs are treated, you might check either the Haskell98-base paper (which may have it) or your implementation's documentation.  You might also try a few tests and see what errors.  I imagine that tabs are a fixed number of spaces, probably 8 or 1.
10:41:14 <ludde> cleverdra: the problem is not when I mix tabs and spaces, but when I mix tabs and characters :)
10:41:25 <shapr> this must be a bug...
10:41:49 <cleverdra> ludde - huh?  You have tabs after characters in a line?
10:42:03 <cleverdra> after non-whitespace.
10:42:10 <ludde> let's say my code looks like: (tab size 4)
10:42:11 <ludde> ab = do bla1
10:42:11 <ludde> <tb><tb>bla2
10:42:23 <cleverdra> oh, right.
10:42:26 <cleverdra> I've been doing:
10:42:28 <cleverdra> ab =
10:42:33 <cleverdra> <tb>do
10:42:36 <cleverdra> <tb>bla1
10:42:45 <ludde> oh
10:43:08 <cleverdra> <tb><tb> in your use definitely depends on how tabs are treated.
10:43:14 <ludde> yeah
10:43:23 <ludde> if tab size is >=4 it should work
10:43:47 <ludde> i think layout is silly :/
10:44:00 <cleverdra> I work very differently in Emacs, using just spaces =)
10:44:12 <ludde> i don't like emacs
10:44:28 <cleverdra> Yes, and see how many troubles you have?
10:44:49 <hdaume> ludde: you don't *have* to use layout; you can use braces and semis instead
10:45:05 <cleverdra> ab = do { bla1; bla2 }
10:45:07 <ludde> hdaume: i know..
10:45:17 <ludde> but it would have been nicer if it allowed
10:45:21 <ludde> ab = do bla1
10:45:34 <hdaume> i used to not like it, but i wouldn't give it up now
10:45:44 <ludde> and then bla2 in any column.. but i guess it would be hard to make a difference between that and a new separate line
10:45:50 <hdaume> exactly :)
10:45:56 <hdaume> you can always do:
10:45:59 <hdaume> ab = do
10:46:00 <hdaume>    bla1
10:46:02 <hdaume>    bla2
10:46:07 <ludde> yeah..
10:46:13 <ludde> anyway, food time
10:46:18 <shapr> wow, it compiled
10:46:24 <shapr> I hope it works...
10:46:26 <hdaume> shapr: congrats :)
10:46:42 <shapr> credits to you and others on #haskell for help :-)
10:47:12 <cleverdra> Or you can get an intelligent editor (Emacs, VIM) and tell it to translate your tabs to such-and-such spaces when writing (and translate back when reading) a file so you can edit it as you like and still produce correct layout.
10:48:11 <cleverdra> OTOH, a third-party program would do this as well.  Less tedious if you're on unix, I imagine.
10:49:25 * shapr likes hasktags
11:00:16 <shapr> yay!!!
11:00:26 <shapr> happiness!
11:00:33 <shapr> 404 Not Found
11:00:33 <shapr> HWS/0.1
11:00:55 <shapr> Heffalump: ok, step zero is done.
11:01:46 <shapr> there is now a working ghc5.04.1 compatible haskell web server.
11:02:25 <shapr> next step is to make loadable modules for it.
11:04:46 <shapr> hm, now I need to figure out how to make a unified diff
11:12:03 <shapr> Heffalump: I think I created a working patch for SimonMar's web server: http://kungens.kemi.fi/~shae/src/haskell/hws.patch.gz
11:12:27 * shapr goes off to watch a movie
11:27:01 * cleverdra boggles: the Windows Script Host got a *type error* on a method that it apparently completed successfully, called by HaskellScript.
12:11:27 <ludde> how do I determine if a file exists?
13:24:58 * ribbon waves
13:25:18 <ribbon> Anyone here know how to get the literate stuff to play nice?
13:32:16 <toadx`> not yet, that is next on my list
13:39:17 <Igloo> How do you mean?
13:40:50 <Igloo> I've done http://urchin.earth.li/~ian/Haskell2LaTeX/ (includes a preprocessor to prettyprint Haskell in LaTeX and a sample application, a Tetris clone, written in a literate style)
13:43:20 <Igloo> Oh, incidentally, shapr, I should have mentioned XPM when we were talking about PPM. You assign colours to characters so you can make images look reasonable as ASCII art as well
13:43:23 * shapr boings
13:51:14 <obraun> Igloo: ./configure
13:51:15 <obraun> ./configure: 9: Syntax error: "(" unexpected
13:52:01 <shapr> big web page, cool tool: http://ls5-www.cs.uni-dortmund.de/~peter/Expander2/Expander2.html
13:52:48 <shapr> I don't really understand what Expander2 does... general purpose inference tool?
13:53:09 <ribbon> Igloo: Erp! I was just after a haskell style file I guess. Nothing earth shattering.
13:53:17 <shapr> wow, nice fractal pix from Expander2
13:53:20 <Igloo> obraun: What is /bin/sh?
13:53:27 * Igloo has probably used a bashism somewhere  :-(
13:53:56 <Igloo> Oh, try deleting the ()s from the function definitions
13:54:20 * Igloo will check the POSIX sh standard later
13:56:46 <obraun> Igloo: pure sh, not bash or something
13:56:52 * obraun working on FreeBSD
13:59:11 <shapr> is there a GHC version of O'Haskell ?
13:59:25 <Igloo> Ah, the standard says "fname() compound-command[io-redirect ...]
13:59:40 <Igloo> " so removing the function keyword is probably the correct fix
14:00:42 <obraun> Igloo: removing the function keyword did the job
14:01:07 <Igloo> Cool, thanks
14:01:15 <Igloo> Let me know if anything else breaks  :-)
14:01:50 <Igloo> Oh, I don't know if you'll need gmake or not, but you're probably used to that anyway   :-)
14:03:04 <obraun> topevel `gmake` leads to: 
14:03:04 <obraun> seq: not found
14:03:04 <obraun> gmake: *** No rule to make target `Haskell2LaTeX/PC.o', needed by `Haskell2LaTeX/Haskell2LaTeX'.  Stop.
14:04:36 <obraun> seems to be another shell problem in report/Makefile.
14:05:02 <Igloo> You'll need to change `seq 0 69` to 0 1 2 3 [...] 69 if you don't have seq
14:05:29 <Igloo> Actually, that isn't built normally anyway. Just comment the line out
14:05:37 <Igloo> What version of gmake do you have?
14:05:44 * Igloo tries to remember what the error with an old version was
14:05:53 <obraun> GNU Make 3.80
14:06:30 <Igloo> Presumably it doesn't work with that line commented out either?
14:08:17 <obraun> which line? the DIAGS:= ..... seq .... in report/Makefile?
14:08:25 <Igloo> Yup
14:08:40 <obraun> gmake: *** No rule to make target `Haskell2LaTeX/PC.o', needed by `Haskell2LaTeX/Haskell2LaTeX'.  Stop.
14:08:55 <obraun> still the above one
14:10:16 <Igloo> Do you have "Haskell2LaTeX/PC.o: PCLib/PC.o" in Haskell2LaTeX/Makefile?
14:11:41 <Igloo> Oh, I suspect it's different ls -l output, actually, so configure is failing to create such dependencies
14:12:14 * Igloo should write a more portable program to do that properly but I don't have time right now
14:13:03 <obraun> ok, just feel free asking me to test it on FreeBSD after you have made it more portable.
14:13:18 <Igloo> OK, thanks  :-)
14:13:39 <obraun> You are welcome.
14:13:40 <Igloo> If you are keen then all you should need to do is create lines like the above in the Makefiles for all the symlinks
14:13:56 <Igloo> But it would be quite tedious by hand  :-/
14:14:32 <obraun> just wanted to try it out, but I have a lot of other work to do these days ;o)
14:14:41 <Igloo> :-)
14:30:49 * ribbon flutters in the breeze
14:57:40 <Igloo> Does anyone undrestand the relationship between gtk+hs and gtk2hs?
16:04:40 <shapr> yah
16:04:45 <shapr> gtk+hs is for gtk 1.x
16:04:49 <shapr> gtk2hs is for gtk 2.x
16:05:19 <shapr> does that mean that the versions are so different that they need two different modules?
16:05:21 * shapr doesn't know
16:07:02 <Igloo> OK, I was under the impression one superceeded the other, but they both seem to be being maintained
16:07:12 * Igloo is trying to build the latter now that the former has failed  :-)
16:07:21 <shapr> I got gtk+hs to build
16:07:28 <shapr> I had problems with gtk2hs for some reason
16:07:32 * shapr can't remember why exactly
16:07:43 <shapr> I'm using the cvs version of gtk+hs though
16:07:48 <shapr> oh wait
16:08:00 <shapr> ghc5.04.1 has a major problem with gtk+hs I think
16:09:04 <Igloo> It said it found 5050 where it expected 5040 IIRC, so it's probably due to me having a CVS version of GHC that it wasn't expecting or something. Or possibly it needs c2hs to be compiled by the same version
16:09:32 <shapr> yah, you need c2hs same version
16:09:40 <shapr> I got that error when I needed to rebuild c2hs
16:10:07 <shapr> actually, I think my numbers were only off by one, not ten
16:10:43 * shapr wonders whether counterstrike or hws plugins are more interesting
16:11:51 <Igloo> Ah...do you know if gtk2hs is going to have the same problem?
16:12:07 <shapr> nope, haven't tried building gtk2hs with 5.04.1
16:12:09 * shapr tries
16:12:15 <Igloo> Perhaps I should have read the docs more carefully first, although I did skim INSTALL
16:12:31 <shapr> I'm using 0.9.0 of gtk2hs, do you have a later version?
16:12:43 <Igloo> Well, it's compiling Main now so I guess it worked
16:12:55 <shapr> aha, 0.9.1
16:13:05 <Igloo> Think i have 0.9.1, yup
16:13:46 * shapr grabs the latest
16:14:41 * shapr runs make
16:14:59 <Igloo> After configure I hope?
16:15:07 <shapr> yes :-)
16:15:52 * shapr waits
16:16:40 <shapr> yay, linking....
16:19:35 <shapr> crap, it explodes on UTFCForeign
16:20:47 <shapr> hm
16:20:53 <shapr> where does .&. come from?
16:21:17 <Igloo> Bits or similar
16:21:50 <shapr> #if __GLASGOW_HASKELL__<=502
16:21:50 <shapr> import Bits
16:21:50 <shapr> #endif
16:21:51 <shapr> hm
16:22:05 <Igloo> Oh, it's doing c2hs stuff now. Maybe it will break shortly
16:22:42 * shapr whacks out the conditional stuff
16:22:46 <shapr> yay
16:22:58 <shapr> it's working now
16:25:15 <shapr> f00
16:25:31 <shapr> what the heck does that mean
16:25:48 <shapr> glib/GValueTypes.hs:200:
16:25:48 <shapr>     Warning: foreign declaration uses deprecated non-standard syntax
16:25:48 <shapr> /tmp/ghc16767.hc: In function `GValueTypes_zdwvalueGetString_fast2':
16:25:48 <shapr> /tmp/ghc16767.hc:650: warning: assignment discards qualifiers from pointer target type
16:25:48 <shapr> Compiling StoreValue       ( treeList/StoreValue.hs, treeList/StoreValue.o )
16:25:49 <shapr> StoreValue.hsc:162: Variable not in scope: `destruct'
16:25:52 <shapr> hah bumbug
16:26:17 <shapr> hi buggs
16:26:23 <buggs> hoi shapr
16:26:27 <shapr> what's up?
16:26:50 <buggs> just came home from work (1:30 am)
16:26:58 <shapr> did you have fun at work?
16:27:13 <buggs> i got a alpha box to play
16:27:25 <shapr> wow, spiffy
16:27:28 <shapr> how do you like it?
16:27:52 <buggs> very cool, but most time i spent with srm
16:27:59 * Igloo spots the dependencies of c2hs. Bother, it's not going to work.
16:30:53 <buggs> then i installed freebsd and it runs very fine
16:31:13 <shapr> what's srm?
16:31:41 <buggs> it's the preboot enviroment
16:31:43 <shapr> where does destruct come from?
16:31:54 <shapr> er, that's a gtk2hs question :-)
16:34:39 <Igloo> No idea
16:34:39 <shapr> maybe I should get the cvs version
16:34:51 <shapr> this doesn't appear to compile very well....
16:35:22 <Igloo> Working fine for me so far
16:35:31 <Igloo> But I fully expect it to break later
16:36:00 <shapr> you got past the UTFCForeign and treeList/StoreValue modules?
16:36:24 <Igloo> Given how long it's been compiling I guess so. Otherwise I'm even more jealous of you  :-P
16:36:37 <shapr> heh
16:36:56 <shapr> well, save up your money and buy a fast machine :-P
16:37:22 <Igloo> Oh, you don't want to know how much negative money I have
16:37:46 <shapr> well, you do have a Ph.D.
16:38:07 <shapr> isn't that true?
16:38:11 <Igloo> No
16:38:14 <shapr> oh
16:38:17 <shapr> I thought...
16:38:24 <shapr> you defend your dissertation and stuff?
16:38:29 * shapr is confused now.
16:38:32 <Igloo> In 3 years, all things going to plan, I will have a dPhil, though
16:38:36 <shapr> oh
16:38:40 <Igloo> defend my dissertation?
16:38:48 <shapr> I must be lost :-)
16:39:33 <shapr> I thought you went through some sort of graduation process recently.
16:39:35 <Igloo> Heff fairly recently graduated, but passed his viva a while ago
16:39:44 <Igloo> Undergraduate degree
16:39:47 <shapr> ah
16:40:02 <shapr> I was convinced it was your Ph.D. graduation.
16:40:11 <Igloo> I'm now a BA, or will be when I get around to graduating
16:40:31 <shapr> cool
16:42:33 <shapr> well, I think you know more than many Ph.D.s I know.
16:43:34 * shapr can't find destruct in any of the indices
16:44:22 <Igloo> I suspect not many of the Ph.D.s you know focussed on Haskell then  :-)
16:45:06 <Igloo> Oh, it's just failed to cmopile lots of Bits stuff
16:45:22 <shapr> yah, you gotta take out the conditional stuff around the "import Bits"
16:46:06 * Igloo was more being surprised how long it took. I guess it's possible it cmopiled in a different order, but I can't think why
16:46:33 <Igloo> Did you do make or make install?
16:46:41 <shapr> I did make first
16:46:55 <shapr> haven't done make install
16:47:33 <Igloo> OK, it's not that then
16:48:34 <shapr> what's the relationship between matching hsc and hs files?
16:48:49 <shapr> which one is the original?
16:48:54 <Igloo> hsc2hs generates the latter from the former
16:49:01 <shapr> oh
16:49:33 <shapr> destruct = free
16:49:34 <shapr> aha
16:49:46 <Igloo> Why aren't you using gtk+hs, BTW? Didn't you get it to work in the end?
16:49:55 <shapr> I think I did...
16:50:09 <shapr> but you wanted to see if gtk2hs would work, and I don't feel like going to sleep.
16:50:17 <Igloo> lol
16:50:44 <shapr> playing counterstrike is fun, but kind of like cotton candy
16:50:59 * Igloo just wants a canvas to draw on a receive mouse clicks/drags, so either should be fine for me
16:51:26 <Igloo> And this seems much more memory hungry
16:51:30 <shapr> haskell is fun, and the fun is cumulative
16:51:37 <Igloo> Don't think I've played CS
16:51:52 <shapr> it's the ultimate first person shooter
16:51:56 <shapr> everything else pales in comparison
16:52:40 <Igloo> Single or multi-player?
16:52:59 <shapr> multi
16:53:11 * Igloo hasn't played anything multiplayer more fun than QuakeWorld Team Fortress
16:53:11 <shapr> thirty two people max, online multiplayer only
16:53:32 <shapr> yay, "destruct = free" fixed that one
16:54:25 <shapr> counterstrike aims to be a somewhat realistic simulation of terrorists and counterterrorists fighting it out
16:54:46 <shapr> for example, one headshot with a midsize bullet will kill you, even if you have a helmet
16:54:58 <shapr> hi Pseudonym!
16:55:02 <Pseudonym> G'day.
16:55:06 <shapr> how's life?
16:55:15 <Pseudonym> Oh, not bad.
16:55:47 <Pseudonym> Yerself?
16:55:51 <shapr> doing well
16:56:15 <shapr> I fixed up SimonMar's Haskell Web Server to compile and run with ghc5.04.1 earlier
16:56:34 <shapr> written any cool code lately?
16:56:45 <Pseudonym> Actually, I'm writing a negation-as-failure monad.
16:56:56 <Pseudonym> Not sure if it's going to be any use.
16:57:07 * shapr doesn't know what one is
16:57:26 <Pseudonym> OK, monads can in principle succeed (i.e. return) or fail (i.e. fail).
16:57:43 * Igloo gets "Unacceptable argument type in foreign declaration: GObject" and decides to compile c2hs
16:57:51 <Pseudonym> Some of those monads can support the operation: mnot :: m a -> m ()
16:57:58 <Pseudonym> Which turns success into failure and failure into success.
16:58:08 <shapr> ok
16:58:50 <Pseudonym> It gets more interesting when you have monads which support both negation-as-failure and nondeterminism.
16:59:20 <Pseudonym> All you need to add is logic variables and you have Prolog written entirely in monads. :-)
17:00:22 <Pseudonym> Actually, you guys may be able to help.  I need two versions of if-then-else and I don't know what to call them.
17:00:40 <Pseudonym> One of them has type: m a -> (a -> m b) -> m b -> m b
17:01:06 <Pseudonym> If the first argument succeeds, it's basically >>=.  If not, it uses the third argument.
17:01:31 <Pseudonym> The other is: m a -> m b -> m b -> m b
17:01:40 <Pseudonym> Which is the same only it's >> instead of >>=.
17:02:03 <shapr> sounds like Monad + or
17:03:05 <Igloo> mIfPred and mIf?
17:03:31 <Igloo> shapr: Did you use the CVS version because of things like "SysDepPosix.hs:59: Module `PosixUtil' does not export `ProcessID'"?
17:03:45 <Pseudonym> Igloo: Not bad except I don't like the camel case.
17:03:47 <shapr> cvs version of what? c2hs or gtk2hs ?
17:04:13 <Igloo> Well, I was just going for a more Haskell standard libraries look  :-)
17:04:15 <Igloo> c2hs
17:04:24 * shapr thinks of mOr and mAnymOr
17:04:27 * shapr snickers
17:04:51 * shapr looks to his c2hs version
17:05:04 <shapr> I'm using 10.15
17:05:34 <Pseudonym> Actually, the Haskell standard libraries are inconsistent.
17:05:38 <Pseudonym> You don't have mPlus and mZero.
17:06:09 <shapr> igloo: what version are you using?
17:06:22 <Igloo> 0.10.17
17:06:27 <shapr> oh
17:06:30 <shapr> well then
17:06:34 <shapr> I guess I need to update
17:08:11 <shapr> bah humbug
17:08:15 <Pseudonym> OK, I have a tougher one.
17:08:17 <shapr> make -j4 explodes
17:08:27 <Pseudonym> Nondeterminism monad.
17:08:47 <Pseudonym> Should >> prune or not?
17:08:52 <Pseudonym> Let me explain.
17:09:17 <shapr> monads usually return all results... that's what the meijer parsing paper says
17:09:29 <shapr> I think that's what I says... maybe it's the Parsec paper that says that.
17:09:35 <Pseudonym> Ah, but >> doesn't actually use any results from its first argument.
17:09:56 <Pseudonym> So it really doesn't "return" any.
17:10:01 <Pseudonym> Only whether it succeeded or failed.
17:10:14 * shapr thinks about that
17:10:21 <Pseudonym> It does make a difference.
17:10:38 <Pseudonym> Looking for subsequent solutions might raise an exception.  Or, if it's a transformer monad, it might do I/O or something.
17:11:11 <Pseudonym> Told you it was tougher. :-)
17:11:12 <shapr> I think it shouldn't prune... because you want every leg of the Trousers of Time
17:11:18 * Pseudonym nods
17:11:27 <Pseudonym> I do support mcommit :: m a -> m a
17:11:32 <Pseudonym> Which commits to one solution.
17:11:43 <Pseudonym> So if you really need it, you could use: mcommit m >> n
17:12:09 <shapr> I vaguely recall that Mercury returns one of the possible solutions in cases of nondeterminism
17:12:15 <shapr> is that what mcommit does?
17:12:29 * shapr installs c2hs
17:12:44 <Pseudonym> Mercury has strong determinism, so it can tell if you need multiple solutions or not.  If you don't, it commits.
17:13:07 <Pseudonym> It's actually quite clever about this.
17:13:35 <Pseudonym> some [X] p(X)  commits, but some [X] p(X,Y) doesn't (if Y is an output variable)
17:15:12 * shapr starts to get hotfoot from make -j4 warming up the CPUs
17:16:10 <shapr> so Mercury checks to see if you're going to do something with that result, and if not, it doesn't calculate it, right?
17:16:49 <Pseudonym> Kind of.
17:17:02 <Pseudonym> It checks to see whether the computation succeeds or fails.
17:17:06 <Pseudonym> That's always important.
17:17:55 <shapr> I'm missing something....
17:18:04 <shapr> commit means choose one of the possibilities?
17:18:09 <Pseudonym> Yes.
17:18:12 <Pseudonym> Commit to one solution.
17:18:26 <Pseudonym> class (MonadPlus m) => MonadNondet m where
17:18:28 <Pseudonym>     msolutions :: m a -> m [a]
17:18:28 <Pseudonym>     mcommit    :: m a -> m a
17:18:31 <shapr> like a parsing monad with ambiguous syntax, you have to go with one or the other
17:18:37 <Pseudonym> Right.
17:18:49 <Pseudonym> The thing is, if you fail later, you don't backtrack into the commit.
17:18:53 <Pseudonym> Because you have committed.
17:18:57 <shapr> oh, I see.
17:19:02 <shapr> makes sense.
17:19:18 <shapr> how do you decide which one to commit to?
17:19:37 <Pseudonym> In this case, the programmer adds it explicitly.
17:19:41 <Pseudonym> Oh.
17:19:50 <Pseudonym> Uhm... complex question.
17:20:07 <Pseudonym> We get into the wonders of "computation rule" and all that.
17:20:27 <shapr> igloo: same errors, even with c2hs 10.17
17:20:29 <Pseudonym> It's like asking what you get if you type (error "1") + (error "2") in Haskell.  It's not well defined.
17:20:41 <shapr> ok, fair enough.
17:20:48 <shapr> otherwise it wouldn't be nondeterminism, right? ;-)
17:20:53 <Pseudonym> Right. :-)
17:20:54 <Igloo> What errors, shapr?
17:21:25 <shapr> the one about destruct
17:21:45 * shapr cleans out his gtk2hs dir and tries again
17:21:45 <Igloo> Ah, in gtk2hs?
17:22:03 <Igloo> Right
17:22:21 <shapr> since I made a few hacks in various places, I'll try it again in a fresh unpack
17:23:23 <shapr> so commit just grabs one from the bag
17:23:42 <shapr> does that mean there are Monads that support choosing what you commit to?
17:23:54 <shapr> or is that just like saving the whole backtrack path and choosing at the end?
17:25:10 <shapr> well, it hit a different error at least...
17:26:58 <shapr> are .hs files made from .chs files also?
17:27:21 <Pseudonym> shapr: Well, yes.  Most support left-to-right depth-first search.
17:27:35 <Pseudonym> In principle you could write others.
17:28:51 <shapr> ghc-5.04.1: chasing modules from: general/Gtk.hs
17:28:51 <shapr> embedding/Socket.hs: file name does not match module name `Socket'
17:28:52 <shapr> hm
17:29:32 <shapr> I wonder if there are reversible Monads...
17:29:43 <shapr> quantum computers will make life great fun
17:30:28 <Igloo> Yeah, you'll be able to read all the private correspondence you intercepted encrypted transmissions of  :-)
17:31:13 <shapr> I was thinking more about doing Monads as reversible computations
17:31:26 <Pseudonym> You mean like multi-moded functions?
17:31:35 <Pseudonym> As in, say, Mercury?
17:32:04 <shapr> I don't know what a multi-moded function is
17:32:16 <shapr> I'll learn Mercury after I learn Haskell :-)
17:32:16 <Pseudonym> Have you used a logic language before?
17:32:23 <shapr> I don't think so.
17:32:25 <shapr> not that I'm aware of
17:32:29 <Pseudonym> You'd remember if you did.
17:32:53 <Pseudonym> Computations are reversible.
17:32:54 <shapr> heh, ok then :-)
17:33:14 <shapr> because = is just a relationship, not an operation, right?
17:33:23 <Pseudonym> Correct.
17:33:29 <Pseudonym> This is using gnu prolog:
17:33:32 <shapr> so x = y + z can return any of those three as long as you give it two of them
17:33:34 <Pseudonym>  ?- append([1,2],[3,4],Zs).
17:33:41 <Pseudonym> Zs = [1,2,3,4]
17:33:44 <Pseudonym> So far so good.
17:34:03 <Pseudonym> ?- append(Xs, Ys, [1,2,3,4]).
17:34:11 <Pseudonym> Xs = []
17:34:12 <Pseudonym> Ys = [1,2,3,4] ? ;
17:34:18 <Pseudonym> Xs = [1]
17:34:19 <Pseudonym> Ys = [2,3,4] ?
17:34:25 <Pseudonym> And so on.
17:34:35 <shapr> um
17:34:41 <Pseudonym> Basically, that's "give me all lists which, when appended, give [1,2,3,4]".
17:34:45 <shapr> did you just append a variable to some data?
17:34:56 <shapr> er
17:35:14 <shapr> huh, neat
17:35:24 <Pseudonym> In practice, it's hard to write predicates which are reversible under all the right circumstances.
17:35:35 <shapr> would be fun for a text editor
17:35:41 <Pseudonym> How so?
17:36:01 <shapr> just thinking about reversibility
17:36:06 * Pseudonym nods
17:36:21 <Pseudonym> By "it's hard", I mean it's really hard sometimes.
17:36:35 <shapr> yah, I've thought about reversibility some
17:36:40 <Pseudonym> You would think, for example, that if you want to find all permutations of a list, all you have to do is run "sort" backwards.
17:36:54 <Pseudonym> Trouble is, for all the interesting/efficient sort algorithms, it won't work.
17:36:57 <shapr> unsort all lists
17:36:58 <shapr> neat idea
17:37:09 <shapr> why not?
17:37:24 <Pseudonym> Because of the way you have to write it.
17:38:11 <Pseudonym> Basically, if you write (say) merge sort in the most efficient way when running forwards, it probably won't run backwards.
17:38:20 <shapr> sounds fascinating
17:38:36 <shapr> it's tempting to learn Mercury to see why that is true
17:38:45 <shapr> I promise I'll bug you about it when I get there :-)
17:38:55 <Pseudonym> :-)
17:39:09 <Pseudonym> Mercury is an interesting data point, but I don't think it's a practical language.
17:39:23 <Pseudonym> I think I was the first person to realise this, too.
17:39:24 <shapr> I'm really looking for mental tools
17:40:02 <shapr> my plan so far was to go from procedural to functional
17:40:10 * Pseudonym nods
17:40:11 <shapr> and Haskell was the best way to learn about "functional"
17:40:31 <shapr> afterwards I want to learn logic/constraint
17:40:56 <shapr> and I'll try to choose whatever is most towards that end of the spectrum
17:41:12 <shapr> I'm not sure what other paradigms I need to learn
17:41:18 <shapr> do you know of any others?
17:41:41 <shapr> I accidentally picked up stack-based stuff from Joy (very much fun)
17:41:43 <Pseudonym> Hmmm.
17:42:05 <shapr> I got OO from Python, and prototype oriented stuff from reading about Self (and using JavaScript)
17:42:08 <Pseudonym> Hang on, I'll look at my resume.  I can't remember all the languages I know.
17:42:12 <shapr> heh, same here
17:43:20 <shapr> I've never learned C... read a book about it, wrote a tiny bit of code.
17:44:14 <Pseudonym> I learned it by doing.
17:44:27 <Pseudonym> I did it for a holiday job while in high school.
17:45:15 <shapr> C takes a lot of focus, concentration, and detail work
17:45:19 <shapr> I'm not so good at those.
17:45:23 <Pseudonym> Let's have a look... have you tried Erlang?
17:45:36 <shapr> read about it
17:45:44 <Pseudonym> Erlang is really interesting to work in.
17:45:53 <shapr> afaiu, it's major features are distributed code and runtime upgrading
17:46:01 <Pseudonym> Right.
17:46:21 <shapr> written by Ericsson for their switches
17:46:38 <Pseudonym> Yes.
17:46:49 <Pseudonym> The idea behind it is you have a lot of threads.
17:46:49 <shapr> Luke Gorrie likes Erlang a lot
17:46:54 <Pseudonym> And you communicate with message passing.
17:47:04 <Pseudonym> Each thread has its own heap.
17:47:11 <Pseudonym> So they can be garbage collected separately.
17:47:17 <shapr> hm, cute
17:47:23 <shapr> nice way to do it
17:47:39 <Pseudonym> Plus, if you replace the code running in a thread with other code, it won't have an effect on anyone else's so long as it responds to the same messages.
17:47:49 <Pseudonym> All the new code has to do is know how to update the code in its own heap.
17:48:21 <Pseudonym> Sorry, the data in its own heap.
17:48:27 <shapr> makes me think a bit of Inferno, Dis... what's the name of that?
17:48:38 <Pseudonym> And because it's functional, all the data in its own heap is passed as function parameters.
17:48:56 <Pseudonym> Oh, uhm...
17:49:03 <Pseudonym> Yes, the Bell Labs system.
17:49:05 <shapr> Lucent did that language that uses two-way pipes for every process to talk to each
17:49:11 <shapr> not acme...
17:49:24 <Pseudonym> No... it's based on ideas from dataflow languages, though.
17:49:27 <shapr> right
17:49:49 <Pseudonym> I remember reading a book on Euler once.
17:50:15 <Pseudonym> I think the Bell system is kind of based on Euler.
17:50:18 * Pseudonym can't remember
17:50:27 <Pseudonym> OK... let's see here...
17:50:31 <Pseudonym> You could learn PostScropt.
17:50:35 <Pseudonym> PostScript
17:50:38 <Pseudonym> That's kinda funky.
17:50:45 <Pseudonym> Saves you from learning Forth, too.
17:51:12 <shapr> well, Joy is postfix concatenative stack-based functional
17:51:23 <Pseudonym> Haven't looked at Joy.
17:51:28 <shapr> it's cute
17:51:36 <shapr> (* x y percent approxEqual *)
17:51:36 <shapr> DEFINE approxEqual == 100.0 / rotate [0 =] [pop] [dup rolldown - swap /] ifte > .
17:51:50 <Pseudonym> Oh, my.
17:51:54 <Pseudonym> Forth on steroids.
17:51:56 <shapr> heh
17:52:02 <Pseudonym> With some Logo thrown in for fun.
17:52:22 <shapr> something make a lot of sense in Joy
17:52:34 <shapr> [0 !=] filter .
17:52:48 <shapr> plus the lists are also program fragments
17:52:55 <shapr> so you can manipulate them and then execute them
17:53:09 <Pseudonym> Have you looked at APL?
17:53:13 <shapr> nope
17:53:24 <Pseudonym> APL is based on arrays.
17:53:28 <shapr> heard it has pretty symbols
17:53:33 <shapr> that sounds interesting
17:53:39 <Pseudonym> Oh, yes, it uses non-ASCII characters.
17:54:02 <Pseudonym> Your program is a pipeline of array operations.
17:54:13 <shapr> interesting
17:54:54 <shapr> would be nice to implement on top of Nepal's parr lib
17:56:15 <shapr> thanks for the suggestions
17:56:36 <shapr> I'll definitely check out APL
17:57:05 <Pseudonym> Here's some APL code: file:/home/ajb
17:57:07 <shapr> as for Erlang, I'd like to figure out how to do runtime upgrading of Haskell modules
17:57:07 <Pseudonym> Sorry.
17:57:16 <Pseudonym> http://www.chilton.com/~jimw/gsrand.html
17:57:27 <Pseudonym> Runtime upgrading of Haskell will be hard.
17:57:35 <Pseudonym> Because Haskell code might hold, say, IORefs.
17:57:54 <Pseudonym> If they're shared with other modules, you could clobber data that they need.
17:58:38 <shapr> hm
17:59:01 <shapr> have you seen Andre Pang's runtime loader? does it make life any easier?
17:59:59 <Pseudonym> I don't think his code solves the problem of upgrading running code.
18:00:20 <Pseudonym> You can stop doing whatever the module is doing, unload the module, reload it and then start it again.
18:00:22 <shapr> maybe a refholder?
18:00:40 <shapr> put your eggs in the basket before you go out the door?
18:01:11 <Pseudonym> Maybe.
18:04:17 <shapr> well, time for me to go to sleep
18:04:27 <shapr> thanks for the language help
18:04:30 <Igloo> Night  :-)
18:04:36 <shapr> g'night igloo
18:04:43 <Igloo> I'll let you know if I get anywhere with this tomorrow  :-)
18:04:55 <shapr> ok, cool
18:05:04 <Pseudonym> Night.
18:19:21 <Igloo> Oh, cool, hello world works  :-)
