02:06:48 <Marvin--> morning
02:06:55 <dash> hi marvin
02:07:07 <dash> maybe you can answer a haskell question for me :)
02:07:12 <ChilliX> Moin Marvin--
02:07:44 * Heffalump is hungry, and it's only 10am
02:08:08 <ChilliX> Heffalump: try having breakfast?
02:08:18 <Heffalump> I had breakfast before I left the house
02:08:33 <dash> have another one?
02:08:35 <Heffalump> I always have this problem when I get up early (for values of early that involve getting to work before 11am)
02:08:41 <Heffalump> well, I'm at work now, it's a bit harder
02:08:48 <dash> mmh. yes
02:09:10 <Marvin--> "what about second breakfast?"
02:09:42 <dash> and elevenses, etc
02:10:11 <ChilliX> Heffalump: there must be somewhere to get some food...
02:10:28 <Marvin--> dash: just ask the question and see what happens, dammit :)
02:10:40 <dash> marvin: well, i think i may have it figured out :)
02:10:47 <Heffalump> yeah, but it's a bit of a pain - I have to balance hunger against hassle :-)
02:10:50 <dash> Marvin--: but anyway
02:11:04 <dash> i want to be able to produce a type that 'or's together a few others
02:11:35 <dash> I originally figured it'd be something like:
02:11:37 <dash> type FooExpr = SpecialForm | Symbol | Integer | Float | String | Application
02:11:43 <dash> but obviously that doesn't work
02:11:45 <Marvin--> dash: generealized Either?
02:11:53 <dash> ah, hmm
02:11:57 <dash> did not look at Either yet.
02:12:09 <Marvin--> well, data Either a b = Left a | Right b
02:13:12 <dash> hmm, dont think that helps here
02:13:22 <dash> or maybe i'm just missing it
02:14:00 <Heffalump> dash: you need constructors in front of those types in FooExpr
02:14:05 <Marvin--> well, what you want is a generalized form of that, isn't it?  data FooExpr = F1 SpecialForm | F2 Symbol | ...
02:14:08 <dash> Heffalump: yeah, i figured that.
02:14:31 <Heffalump> just make up names
02:14:33 <dash> hmm
02:14:38 <dash> yeah =/
02:15:11 <Marvin--> anyone knowledgable of the fptools cvs?
02:15:14 <dash> it just seems like i'll end up with this big stack of constructors
02:15:24 <Marvin--> dash: join the club
02:15:33 <dash> eh?
02:15:40 <Marvin--> dash: that's usually what you end up with
02:15:43 <dash> bleck
02:15:46 <dash> because i've already got my other types defined like so:
02:15:55 <dash> data Application = Application Symbol [FooExpr]
02:16:10 <dash> etc. 
02:16:23 <dash> is this just something i'll have to live with? :)
02:16:28 <Marvin--> yes
02:16:32 <dash> sigh
02:16:45 <Marvin--> what do you think the constructors are *for*? :)
02:16:54 <dash> Marvin: Not sure, really.
02:17:07 <Marvin--> in data Either a b = Left a | Right b, Left and Right are "functions" from a/b to Either a b
02:17:13 <Marvin--> Left :: a -> Either a b, Right :: b -> Either a b
02:17:15 <dash> yes, got that part
02:17:27 <Marvin--> so Left 3 and Right "foo" can have the same type
02:17:34 <dash> yes
02:17:41 <Marvin--> but not Left 3 and Left "foo"
02:17:51 <andersca> (btw, I'd just use Application = Application Symbol FooExpr)
02:18:10 <Marvin--> yeah, what's the list for?
02:18:36 <Marvin--> does anyone know if the ghc lib path (e.g. /usr/lib/ghc-5.04) is in a variable somewhere in the fptools mk stuff?
02:18:37 <dash> well, there can be more than one...
02:18:54 <dash> oh, there
02:18:56 <andersca> isn't application a FooExpr?
02:18:59 <dash> yeah, that's the arglist
02:19:02 <Marvin--> more than one expression for a symbol?
02:19:04 <Marvin--> oh
02:19:30 <dash> i'm attempting to write a lisp parser
02:20:03 <andersca> then you just need data Expr = Atom Expr | Atom
02:20:03 <andersca> ;)
02:20:17 <dash> andersca: huh?
02:20:28 <andersca> dash: you can use cons for lists
02:20:40 * dash is thoroughly confused
02:20:57 <andersca> '(4 5 6) = cons (cons (cons nil '4) '5) '6)
02:20:58 <andersca> or something
02:22:03 <dash> the idea was that "(foo a b 42)" would end up being Application (Symbol "foo") [Symbol "a", Symbol "b", 42]
02:22:51 <dash> andersca: so i dont understand what you mean...? cons isn't a haskell thing, is it?
02:23:00 <dash> i mean, haskell uses : right?
02:23:02 <andersca> no, it's a function in lisp
02:23:08 <dash> yes, i know that part. :-P
02:23:24 <andersca> so (cons 'nil '5) = (5)
02:23:25 <andersca> I think
02:23:42 <dash> right, bu i dont see what that has to do with anything
02:23:57 <andersca> just that you can define application recursively
02:24:13 <dash> oh. and (cons nil 5) is (5 . nil) :)
02:24:17 <andersca> like in haskell f a b c is just (((f a) b) c)
02:24:24 <dash> andersca: right, but it isn't in lisp
02:24:59 <andersca> hmm, perhaps it isn't
02:25:00 * andersca shrugs
02:25:09 * dash is even more confused.
02:26:01 <dash> but anyway, i cant do it like i described above, can i?
02:26:48 <andersca> shouldn't application be Application = Expr [Expr] then?
02:27:00 <andersca> since you can have a lambda expression and apply it
02:27:08 <dash> in scheme you can
02:27:12 <dash> but not in this lisp.
02:27:39 <andersca> oh, ok
02:27:42 <dash> so, it'd have to be Application (Symbol "foo") [FooSym Symbol "a", FooSym Symbol "b", FooInt 42]
02:27:43 <dash> right?
02:27:49 <Marvin--> I'd recommend having data Expr = ELit Lit | ESym Symbol | ...
02:27:58 <dash> yeah =/
02:28:02 <dash> oh well
02:28:10 * Marvin-- tries putting together a tarball of hws-wp
02:32:50 <Heffalump> hmm, if I get a spare few hours I might try to port my existing Haskell CGI code to being a plugin
02:34:58 <dash> ok, stupid monad questionm
02:35:01 <dash> symbol =  do { s <- identifier; return $ Symbol s}
02:35:08 <dash> how do i rewrite that with >>= ?
02:35:20 <Heffalump> identifier >>= (return . Symbol)
02:35:23 <Marvin--> identifier >>= return . Symbol
02:35:24 <ibid> identifier >>= \s -> return $ Symbol s
02:35:25 <dash> aha
02:35:34 <dash> i knew it looked better that way :)
02:35:39 <Marvin--> hmm, maybe >>= binds harder than ., don't remember
02:35:48 * Heffalump either, that's why I played safe :-)
02:35:48 <ibid> (direct translation, the others also applied other conversions)
02:36:03 <Heffalump> ah, but he said rewrite, not do the equivalent :-p
02:36:11 <ibid> hehe :-)
02:36:37 <ibid> Heffalump: but he didn't say repeatedly rewrite until you get a cool version :-)
02:36:44 <ibid> übercool, sorry :-)
02:36:47 <dash> hah
02:39:58 <Heffalump> ah, but I only rewrote once :-p
02:40:22 <Heffalump> oh, twice maybe.
02:40:46 <Heffalump> depends whether you view composition introduction and then eta-reduction as a valid composite rule
02:43:37 <Marvin--> hmm, should we clean up the topic a bit? I want to stick a notice about hws-wp there :P
02:44:08 <Heffalump> feel free to delete my "contribution" :-)
02:44:26 <Heffalump> I think the only thing that really ought to stay is the logs URL
02:48:24 --- topic: set to 'mo' nads than you || We put the Funk in Funktion || See logs @ http://tunes.org/~nef/logs/haskell/ || hws-wp: http://www.dum.chalmers.se/~marvin/hws-wp/' by Marvin--
02:49:10 <Marvin--> aaaaaaaargh
02:49:13 * Marvin-- swears at Jan-Willem
02:52:26 <dash> any of you guys used Parsec?
02:53:17 <Marvin--> no, I find Parsek easier to use :)
02:53:28 <dash> that one i haven't seen.
02:53:30 <dash> url?
02:53:43 <Marvin--> hmm, somewhere on Koen's homepage probably
02:54:34 <dash> google isn't helping a lot
02:55:47 <Marvin--> bleh
02:56:15 <dash> anyhow, what's the difference?
02:56:18 <Marvin--> we used it in the Semantics course anyway: http://www.cs.chalmers.se/Cs/Grundutb/Kurser/nasem/labfiles/haskell/Parsek.hs
02:56:46 <Marvin--> ''The aim was to get a library that was equally fast, without having to use the cumbersome "try" combinator.''
02:57:04 <dash> hmm
02:57:19 <dash> why is 'try' considered cumbersome?
02:57:58 <Marvin--> I don't know, I don't understand it ;)
02:58:01 <dash> seems natural to me
02:58:05 <dash> and i haven't needed it yet :)
02:58:34 <dash> parsec has a big wad of useful stuff on top of it, it seems
02:59:08 <dash> "almost as fast", "almost compatible", and no docs -- i'll stick with parsec, for today =)
02:59:26 <dash> oh, and it's gpled =(
02:59:40 <Marvin--> bah
02:59:41 <Marvin--> :)
02:59:48 <dash> hmm?
03:00:02 <Marvin--> but yeah, maybe LGPL would be more appropriate
03:00:48 <dash> it's silly. manual backtracking _isn't hard_ :)
03:01:43 <Marvin--> parallel composition is easier
03:02:01 <Marvin--> p1 <|> p2
03:02:16 <dash> explain the "parallel" part
03:02:19 <Marvin--> I guess it boils down to what you're used to
03:02:29 <ChilliX> hehehe - have another topic extension
03:02:40 <Marvin--> Chilli?
03:02:47 <dash> <|> is the choice operator and it's not exactly related to backtracking..
03:02:57 <dash> well, assuming it does the same as in parsec
03:03:12 <Marvin--> oh right, I misunderstood you
03:03:15 <Marvin--> and I'm not awake yet ;)
03:03:53 <dash> so explain the "parallel" part?
03:03:54 <Marvin--> well, I should go get productive
03:04:21 <Marvin--> I meant parallel choice
03:04:24 --- topic: set to 'mo' nads than you || We put the Funk in Funktion || See logs @ http://tunes.org/~nef/logs/haskell/ || hws-wp: http://www.dum.chalmers.se/~marvin/hws-wp/ || 2002 Haskell Workshop proceedings now online @ ACM: http://www.cse.unsw.edu.au/~chak/hw2002/' by ChilliX
03:04:57 <dash> Marvin--: i dont understand what that means :)
03:05:07 <Marvin--> dash: neither do I in retrospect... never mind
03:05:10 <dash> heh!
03:06:21 * Marvin-- waves and leaves
03:06:32 <Heffalump> bye
03:09:03 * Heffalump builds hws-wp
03:15:41 <raphael_> has marvin been around today?
03:15:47 <Heffalump> yes, he just left
03:15:55 * Heffalump is trying to get his project to build, but failing
03:16:22 <raphael_> oh ... probably headed here then (to school, that is)
03:18:33 * raphael_ proud 'cause I just did my first unsafeInterleaveIO program that didn't die horribly
03:19:23 <Heffalump> cool :-)
03:19:55 <raphael_> I won't say what it actually *does*, because that would spoil everything ;)
03:23:08 <Igloo_> Heff: MAG or your recent stuff?
03:26:15 <Heffalump> igloo: MAG
03:26:21 <Heffalump> my recent stuff ain't Haskell :-)
03:45:35 <dash> hmm
03:46:33 <dash> do {n <- naturalOrFloat ; case (n) of {Left  i -> return AInt i; Right f -> return AFloat f}}
03:47:04 <dash> is there a way to do this that actually works? :) it doesn't like taking different types as input
03:50:38 <dash> do {n <- naturalOrFloat ; case (n) of {Left  i -> return AInt i; Right f -> return AFloat f}}  -- any way to make this actually work? it doesn't like the different types in the case =/
03:53:56 <Heffalump> return AInt i should be return (AInt i)
03:54:00 <Heffalump> or return $ AInt i
03:54:01 <Heffalump> (equivalent)
03:54:04 <dash> hm
03:54:08 <Heffalump> ' ' associates to the left
03:54:15 <Heffalump> so what you wrote actually parses as (return AInt) i
03:54:21 <Heffalump> which makes no sense
03:54:25 <dash> right, i keep forgetting that
03:54:32 <Heffalump> so do I :-)
03:54:56 <dash> well, no
03:55:09 <dash> oh wait. same error different line :D
03:55:14 <Heffalump> yeah
03:56:34 <dash> whee. now it loads
04:27:21 <dash> hmm, what's "apply" named in haskell
04:28:32 <dash> (that function that takes a function and a list and calls the function with the elements)
04:28:53 <andersca> map?
04:29:02 <dash> nah, not map
04:29:10 <andersca> oh
04:31:21 <andersca> well it's easy to just use lambda for it
04:31:27 <dash> oh?
04:31:38 * dash looks again
04:31:54 <andersca> \(f, [x, y,z]) -> f x y z
04:32:02 <andersca> doh, f:y:z:[] I mean
04:32:11 <andersca> f:x:y:z:_ even
04:32:15 <dash> mean which time?
04:32:33 <cleverdra> dash - there's a recent thread on this on clf
04:32:53 <dash> cleverdra: i take it that means there's no obvious way.
04:33:04 <cleverdra> dash - don't take that; read the thread.
04:33:09 <dash> bah
04:33:52 <cleverdra> dash - anyway, there's no general 'apply', but you probably don't need one.
04:34:23 * shapr boggles
04:34:30 <shapr> it's dash
04:34:37 <andersca> hey shapr
04:34:45 <shapr> hi andersca, what's up?
04:34:46 * cleverdra notes that one of the factorials on evolution.html invents a little language with an 'apply' =)
04:35:16 <dash> shapr: i've been sucked in
04:35:18 <shapr> w00
04:35:25 * shapr bounces with extreme happiness
04:37:00 * shapr looks at the haskell workshop proceedings url
04:37:18 <dash> oh right, you _cant_ write apply in haskell
04:37:19 <dash> duur
04:38:08 <shapr> the space between a function and an arg is kind of like apply
04:38:12 <dash> not really
04:38:36 <shapr> well, in joy the space does function concatenation
04:38:48 <dash> heh.
04:39:18 <shapr> I think c.l.f had a thread on writing scheme's apply in Haskell
04:39:29 <dash> yes
04:39:34 <dash> and the answer is "you cant, silly"
04:39:40 <shapr> heh, good answer
04:40:10 <cleverdra> dash - why were you looking for one?
04:40:39 <dash> cleverdra: blame it on my lispish habits.
04:41:36 <cleverdra> Does anyone remember who 'mage' (the roguelike game) belongs to?  ibid?
04:42:09 <shapr> it's dark's
04:42:17 <shapr> aka Richard Braakman
04:43:09 <cleverdra> ah, thanks.
04:43:47 <shapr> dash: so what sucked you in?
04:43:51 * cleverdra just got around to looking at it, yesterday; it's nifty after the keymap is fixed.
04:43:54 <shapr> denotational semantics?
04:44:06 * shapr needs to fix up a dvorak keymap for magee
04:44:10 <dash> shapr: yes
04:44:10 <shapr> er, "mage"
04:44:15 <dash> shapr: well, and parsec.
04:44:22 <shapr> yah, parsec roxx
04:44:35 <shapr> and there's more cool stuff too :-)
04:44:41 <dash> it's not far from the parser system i'm fond of in lisp
04:45:11 <shapr> I think parsec is monadic
04:45:15 <dash> it is
04:45:29 <andersca> it is
04:45:52 <shapr> arrow based parsers can save space with left factored LL(1) grammars
04:45:53 <cleverdra> shapr - I just gave it traditional roguelike navigational commands, since I prefer those under Dvorak.  Keymap.hs seems fairly straightforward.
04:45:59 <dash> shapr: bah
04:46:09 <shapr> dash: you know I'm picky ;-)
04:46:36 <dash> shapr: i'm not in this for efficiency
04:46:39 <dash> or i'd go back to CMUCL
04:46:49 <shapr> hi dark!
04:46:53 <dark> Hello :)
04:46:59 <shapr> must have heard us talking about mage
04:47:57 <dark> No, it's just my normal time in the morning :)  What did you discuss about it?
04:48:23 <shapr> cleverdra is/was playing with it
04:49:29 <dark> I'd love to hear about stuff that can be done better :)
04:49:37 <cleverdra> dark - I destroyed all the helpless monsters that weren't protected by locked doors, and I changed the Keymap to have traditional roguelike navigational commands.
04:49:54 <dark> cleverdra: The hjkml ones?
04:50:02 <cleverdra> Indeed, those.
04:50:08 * shapr hacks up a dvorak keymap
04:50:17 <dark> cleverdra: It should be easy to make it accept both, too.
04:50:54 <shapr> dash: so what kind of stuff are you doing right now? anything I can help with?
04:51:11 <dark> cleverdra: Of course a proper roguelike should have a remappable keymap :)
04:51:31 <cleverdra> shapr - what does that look like?  dhtn fg bm ?
04:51:46 <dash> shapr: eh, just building a simple parser and tripping over all the language features
04:52:11 <shapr> cleverdra: I dunno, I'm making it up as I go along... ideas?
04:52:20 <dash> shapr: here's what i got so far: http://ghostwheel.ddts.net/~washort/arnis.hs
04:52:24 <shapr> dash: reading the parsec tutorial?
04:52:28 <dash> yeah
04:52:29 * shapr looks at dash code
04:53:05 <cleverdra> shapr - well, that's where the roguelike keys in Qwerty map physically to Dvorak.
04:53:09 <dark> Hmm... taking 'd' (drop) and both 't' and 'f' (likely candidates for fire/throw) as movement keys would be problematic :)
04:53:35 <dark> On the other hand, I wonder if the language setting should affect the keymap, or if that will cause convulsions of agony in the players.
04:53:36 <dash> dark: simple, invent a new language with words that can map to unused dvorak keys for those.
04:53:55 <shapr> cleverdra: I have a kinesis, so I use
04:54:18 * shapr was sposed to type an escaped "enter" there
04:55:01 <shapr> my keymaps for counterstrike et al, use htns and enter/space
04:55:16 <dark> dash: That would be cool :)
04:55:25 <dark> I was actually intending to add "Orcish" to the language choices.
04:55:30 <dash> heh
04:55:35 <dash> shapr: so, how bad is my code :)
04:55:47 <shapr> dash: looks good to me
04:55:54 <shapr> I snickered at the "import as P"
04:55:59 <shapr> imho, that's very pythonic
04:56:06 <dash> shapr: well, that was from the parsec tutorial
04:56:39 <dash> mt leijen is obviously a PSU agent
04:56:46 * shapr laughs
04:56:46 <dash> er, s/mt/mr/
04:57:22 <dash> i mean, he's even from .nl! how obvious can you get
04:57:34 <shapr> he probably also speaks the secret language of python programmers.
04:57:35 <dark> shapr: In all my shooter games I use X for fire and Z and C for strafe... but many of them are uncooperative about key assignments to the control keys near that hand :)
04:58:19 <shapr> dark: I started using the keypad for custom keymaps, now with a kinesis I've taken over the entire right hand side of the keyboard
04:58:40 <shapr> happily, kinesis keys are vertically and horizontally aligned, so it works
04:58:42 <dark> If I have room to shove the keyboard to the side, I use a numpad / mouse combination.
04:59:26 <dark> Anyway, this is off-topic, except perhaps to the extent that it can be applied to mage :-)
04:59:39 <dash> shapr: is the secret language of python programmers "dutch"?
04:59:46 <shapr> dash: yes! it is!
04:59:49 <dash> figures
05:00:04 <dash> hmm
05:00:07 <shapr> I've heard rumors that some people on the #haskell channel also speak dutch.
05:00:35 <dash> these do {} <|> do {} <|> ... sequences look icky
05:00:53 <shapr> multichar operators confused me mightily at first
05:01:05 <andersca> dash: I'm loving it
05:01:07 <andersca> :)
05:01:10 <shapr> I do agree that the parsec tutorial could have been formatted differently
05:01:23 <dash> well, it's not so much that as it seems like there ought to be a better way to factor it syntactically
05:01:23 <shapr> I don't like curly braces
05:02:28 <dark> I don't like the way records use curly braces.
05:02:55 <dash> hmm
05:02:58 <cleverdra> number = whenDash <|> whenPlus <|> whenNum where ...
05:03:02 * dash left-factors viciously.
05:03:28 <cleverdra> That would make everything look prettier, IMO.
05:03:42 <dash> cleverdra: yeah, that'd work
05:03:44 <shapr> I think I've seen something like that
05:03:49 * dash forgot about the 'where' keyword
05:04:48 <liiwi> it's dash
05:04:57 <dash> liiwi: muahahahahaha.
05:06:03 * shapr dances happily
05:06:15 <shapr> bea just called me, the doc finally fixed my prescription.. yay!
05:06:17 * shapr bounces
05:06:57 <shapr> ahem. so.
05:07:15 <shapr> dash: oh, you'll love monad transformers and arrows
05:07:17 <shapr> they're *so* cool.
05:07:21 <dash> heh
05:07:23 <dash> one thing at a time
05:07:29 <shapr> right, patience :-)
05:07:39 * shapr bounces happily
05:09:11 * dark is going to teach Haskell to his girlfriend.
05:09:21 <shapr> dark: wow, cool
05:09:31 <shapr> I've been teaching Python and Scheme to my girlfriend
05:09:33 <liiwi> dark is rather ... dark
05:09:55 <shapr> but it goes slowly, since programming is hard to learn.
05:10:12 * liiwi pythoneers
05:10:24 * shapr shows off his haskillz
05:10:41 <liiwi> I think I will do some brainfuk soon
05:10:50 * dark brags about chompWhile.
05:10:50 <shapr> try unlambda too
05:10:53 <dash> befunge! BEFUNGE
05:11:03 <dash> they're writing a befunge interpreter for parrot
05:11:08 <shapr> whoa, scary
05:11:15 <dash> it mostly works already
05:11:33 <liiwi> I have few optimization ideas for my Ook program, still..
05:11:42 <shapr> hey I got an email from John Hughes, says he'll probably come visit #haskell someday
05:11:50 <ac_mtg> shapr: yay
05:11:50 <shapr> magic the gathering?
05:11:52 <Heffalump> coool
05:11:58 <ac_mtg> then we can all fanboy him
05:12:01 <ac_mtg> shapr: meeting
05:12:03 <shapr> oh
05:12:07 <shapr> yah, major fanboy
05:12:55 <dark> What timezone is he in?
05:13:02 <shapr> sweden
05:13:12 <shapr> one hour earlier than you and I
05:13:28 <dark> Okay :)
05:13:43 <dark> Yesterday I became all confused about the time anyway.
05:13:44 <cleverdra> http://www.math.chalmers.se/~rjmh/
05:13:48 <shapr> well, two days from now I'll be in that timezone.
05:13:53 <dark> Heck, I've been confused about the calendar for weeks now :)
05:14:06 <dark> shapr: For how long?
05:14:11 <shapr> years.
05:14:27 <shapr> the DSL guy is taking his modem back tomorrow.
05:14:54 <shapr> the next day we put all the boxes in the truck.
05:15:13 * shapr is looking forward to that
05:16:11 <dash> shapr: you're moving? 
05:16:21 <shapr> dash: yup, moving to sweden.
05:16:41 <dash> shapr: wow. still working with the same company?
05:16:49 <shapr> nah, I'm a contract programmer now.
05:16:51 <dash> whee
05:17:08 <shapr> seems to work. I get more flexibility and so do my clients.
05:17:44 <shapr> also means I can write in Haskell if the clients don't mind :-)
05:19:24 <shapr> dash: how are things in B'ham?
05:19:35 <dash> shapr: pretty good
05:19:47 <dash> shapr: hasn't gotten cold her eyet
05:20:18 <liiwi> it's far too warm here also
05:20:26 * shapr has lots of snow in the yard
05:25:17 * shapr tries to derive show for a monad
05:26:40 <shapr> cool, it works
05:31:56 <cleverdra> What does it look like?
05:35:01 <shapr> unicode ;-)
05:35:03 * shapr is joking
05:36:21 <shapr> actually it just looks like "Return 5"
06:01:45 <shapr> hi marvin
06:02:42 <shapr> marvin: how did your report go?
06:02:52 <shapr> did you end up staying under nine pages? :-)
06:03:15 <Heffalump> hi marvin
06:03:24 <Heffalump> I can't get hws-wp to build, mostly cos I can't figure out the makefile
06:05:00 <Marvin--> shapr: topic ;)
06:05:39 <Marvin--> Heffalump: it's something of a mess... you'll have to ./configure *and* edit the makefiles, I didn't have time to figure it out nicely
06:05:48 <Marvin--> I'm off to eat lunch now, but I'll be back in a while
06:06:04 * Marvin-- -> food
06:06:14 <Heffalump> ok :-)
06:07:26 * shapr reads the hws-wp report
06:11:22 <shapr> "and since changing the implementation of GHC is out of the scope of this project" <--- bwahahaa
06:12:08 <ayrnieu> hm?
06:12:38 <shapr> it's from marvin--'s hws-wp report
06:12:42 <shapr> url in the topic
06:48:55 * Marvin-- is back
06:59:40 <Marvin--> Heffalump: did you get it to work?
07:03:05 <Heffalump> haven't had time to try again
07:03:13 <Heffalump> but I couldn't really work out what to do to the makefile before
07:03:26 <Heffalump> I edited hws-wp/mk/config.mk to point to hws-wp instead of hws, which helped slightly
07:03:36 <Heffalump> but it was still complaining about something
07:04:05 <Heffalump> the most I got it to do was after then, when I tried "make dist Project=hws-wp"
07:04:12 <Heffalump> but it still didn't get very far
07:05:23 <Marvin--> oh, damn, had I forgotten that
07:05:33 <Marvin--> what did it complain about?
07:05:48 <Marvin--> I don't know anything about the fptools cvs stuff, and haven't had time to look into it in more detail :/
07:06:25 <Marvin--> ./configure --with-ghc=`which ghc`
07:06:25 <Marvin--> gmake -C runtime_loader
07:06:25 <Marvin--> cd hws-wp
07:06:25 <Marvin--> gmake -C src depend
07:06:25 <Marvin--> gmake -C src
07:06:26 <Marvin--> gmake -C plugins
07:06:32 <Marvin--> that's what I do to compile the stuff from scratch
07:07:40 <Marvin--> but you'll have to change runtime_loader/GHCLibraryPath.hs and hws-wp/src/Makefile to point to the right paths
07:07:48 <Marvin--> when I get the time, I'll do this in a proper way :/
07:08:15 <Heffalump> progress :-)
07:08:16 <Heffalump> ta.
07:11:01 * Heffalump has built it, and will try to actually run it later when he gets a bit of time
07:13:38 <shapr> marvin: you should announce hws-wp on haskell@ or at least ghc-users@
07:13:40 <shapr> it's spiffy
07:16:09 <Marvin--> yeah yeah yeah, I'll get around to it sooner or later :P
07:16:32 <Marvin--> maybe I should mail simonmar about it
07:16:46 <shapr> bah, announce :-)
07:17:04 <Marvin--> well, not about announcing it
07:17:12 <Marvin--> more "here's what I did to wreck your web server"
07:17:16 <shapr> hah
07:17:18 <shapr> yes, do it :-)
07:17:35 <shapr> great idea
07:18:00 * shapr dreams of an xml-rpc server plugin
07:19:49 <galority> Hi, where do I find that hws-wp? I like to play with it ;o)
07:19:52 * dark bahs about xml.
07:20:02 <ayrnieu> galority - topic.
07:20:24 <galority> ayrnieu: thanks
07:20:32 <dark> It's always nice when my programs finally do something, even if it's the wrong thing :)
07:21:57 <shapr> I just finished reading the hws-wp report
07:26:42 <dark> shapr: Going to write any plugins?
07:28:02 <shapr> dark: yah, I thin kso
07:29:03 <shapr> I'd like to put some time into runtime upgrades, and getting .so files to be reloadable
07:35:51 <dark> shapr: Are you moving to gothenburg?
07:42:11 <dennisb> dark: wasn't it to Boden he was moving? It was to the northen parts of sweden, that much I remember
07:49:21 <dark> dennisb: I just knew sweden :)
08:08:37 <Marvin--> lousy university computer system *mutteR*
08:29:10 <Argentum> hi ppl. silly question: how can i get argv in a haskell program (ghc)
08:29:30 <ibid> import System, getArgs, iirc
08:30:08 <Argentum> thnx
08:30:48 <ayrnieu> Why is that a silly question?
08:31:58 <Heffalump> I think most people see getting arguments as something that should be obvious
08:32:08 <Marvin--> definitely not
08:32:27 <Marvin--> a more intuitive way would be main :: [String] -> IO () :-)
08:33:01 <ayrnieu> How is that more intuitive?
08:33:06 <Heffalump> but then only suitable for command-line usage
08:33:08 <Marvin--> I think it is
08:33:19 <Marvin--> uh?
08:33:22 <Heffalump> i.e. the top-level interface to Haskell programs would have to depend on context (which is possibly sensible)
08:33:33 <Marvin--> ... yes? :)
08:33:38 <Heffalump> ok :-)
08:33:45 <Heffalump> yeah, you're probably right.
08:33:47 <Marvin--> maybe I'm just biased from languages like C and Java
08:34:10 <Marvin--> but in e.g. python you import sys and then use sys.argv
08:34:14 <ayrnieu> getArgs lets you know exactly which parts of a program rely on the command-line arguments, and thus may have variable effect by them?
08:34:16 <Marvin--> so *shrug*
08:34:40 <Marvin--> I think c-l args is something top-level
08:35:06 <Marvin--> most of my main functions look like this:  main = getArgs >>= iMain
08:35:15 <Marvin--> iMain can be used interactively, main cannot
08:35:24 <ayrnieu> There are systems which lack 'command line arguments'
08:35:33 <Marvin--> oh?
08:35:45 <Marvin--> interesing
08:35:48 <Marvin--> +t
08:35:54 <ayrnieu> +t?
08:36:03 <Marvin--> interesTing :)
08:42:58 <Argentum> ibid, next silly q: how to use that marvelous getArgs?
08:43:39 <Argentum> can i find a human-readable Haskell library doc anywhere?
08:45:06 <ayrnieu> The HTML documentation that GHC comes with (err, that is also produced; GHC actually comes with evil DocBook) is almost readable.
08:45:55 <Argentum> getArgs returns(?) IO [String], but getOpt needs [String]
08:46:05 <Heffalump> do you know about do notation?
08:46:13 <Argentum> yes
08:46:29 <ayrnieu> main = do args <- getArgs; getOpt args
08:46:43 <Argentum> sorry, guys, i don't have a guru nearby ;)
08:47:07 <Argentum> thnx however ;)
08:47:17 <Heffalump> I'd point you at the Wiki but it's broken again
08:49:58 <ayrnieu> Argentum - generally, { do x <- b; f x } where b :: IO a, x :: a, f :: a -> ???
08:53:24 <hdaume> Argentum: and then in ayrnieu's {...}, the whole expression has type IO ???
09:09:57 <andersca> Marvin--: so I got 56 out of 60 on the exam
09:11:16 <Marvin--> andersca: I'm not surprised, I had something like that too :)
09:11:39 <andersca> Marvin--: didn't know what aliasing was though, otherwise I'd have 59/60 :)
09:14:25 <Marvin--> andersca: aliasing? In what context?
10:27:45 <shapr> dark: Boden, way in the north. Closest large city will be Lulea
10:27:55 <shapr> hi pesco
11:27:33 * shapr wishes for a way to save his interactive ghci sessions for later examination
11:28:19 <shapr> hi dalroth
11:29:57 <Marvin--> shapr: there's this cute program that logs everything you do to a file, but I don't remember what it's called
11:30:44 <Heffalump> ohh.
11:30:49 <Heffalump> I know someone who knows. hangon
11:31:11 <shapr> I could use tee maybe
11:31:46 <Heffalump> script?
11:31:55 <Heffalump> yep.
11:33:58 <Marvin--> ah, yeah, script... very cute program :)
11:34:41 <shapr> cool, thanks
11:38:53 <Heffalump> hehe, hws tried to read my Apache Config
11:39:04 <Heffalump> I don't think it appreciated it too much.
11:39:21 <Marvin--> haha
11:39:34 <Marvin--> yeah, the default directory for httpd.conf is /etc :P
11:39:44 <Heffalump> well, /etc/httpd/conf/httpd.conf
11:39:49 <Heffalump> which is exactly where redhat puts it
11:40:02 <Marvin--> oh
11:40:14 <Heffalump> are you interested in receiving patches for it, btw? (not that I have one atm, but if you will at least look at any I might make some)
11:40:14 <Marvin--> Debian puts it in /etc/apache/httpd.conf
11:40:17 <Heffalump> yeah.
11:40:31 <Heffalump> I have both RH and Debian boxen
11:41:35 <Marvin--> re patches... well why not... but on the other hand, this was more a course project than a "fun open source project that I'll keep working on" I'm afraid
11:41:55 <Heffalump> ok :-)
11:41:56 <Marvin--> I mean sure, it was fun, but I'm not going to use the server myself, which makes it sort of silly to maintain it
11:42:13 <Marvin--> I don't want to maintain software I don't use :/
11:42:39 <Marvin--> but I may keep fiddling with it from time to time, e.g. generalizing the config stuff
11:42:48 <Marvin--> but if someone else wants to pick it up and wreck it more, that's fine too ;)
11:43:02 <Heffalump> right :-)
11:43:34 <Heffalump> I have a feeling a few people here might hack on it a bit, if so I can possibly provide a CVS server if that would be useful
11:44:21 <Marvin--> maybe I can get strakt to host it just because some of the people there think Haskell is a cool language :P
11:58:09 <shapr> hah, emacs paren-match gets confused by \() ->
11:58:16 <shapr> it thinks that first paren has just been escaped
12:00:24 <shapr> no deriving on a type statement, right?
12:02:10 <Marvin--> heh
12:12:01 <ayrnieu> Emacs's haskell-mode has a lot of problems, sadly.
12:12:08 * shapr fights haskell-mode
12:12:21 <ayrnieu> So does its erlang-mode, and all the problems of each have to do with 'escape' characters.
12:12:24 <shapr> for one thing, integrating fume into speedbar should be done...
12:12:37 <Marvin--> vim's lhs support is lacking :/
12:12:50 <ayrnieu> Marvin - lhs?
12:12:59 <shapr> imho, the correct solution is to write a decent editor in Haskell :-)
12:13:07 <shapr> or even better, an elisp engine
12:13:47 * shapr figures the best realistic solution is to fix emacs haskell-mode
12:15:06 <ayrnieu> (The O'Caml-Elisp may help.)  Yes; I worry that the problem involves delving deeply into Emacs's syntax systems.  It's worrying that the documentation mostly gives examples for C and C++
12:15:29 <shapr> I've delved before and come out successfully with a partial mode for Joy
12:16:40 <ayrnieu> Have I mentioned '[' already?  My temporary solution is to change it to '\[' while editing -- the errors don't seem to propagate beyond the definition involved.
12:18:36 <Marvin--> literal haskell
12:19:36 <ayrnieu> Marvin?
12:19:59 <shapr> ayrnieu: seen .lhs files?
12:20:18 <shapr> text is comments by default, actual code has "> " in the first two columns
12:20:50 <Marvin--> the > works fine in vim, but not \begin{code}
12:20:52 <ayrnieu> Yes, I know, but that's 'literate haskell'
12:20:59 <shapr> ah, good point :-)
12:21:12 <Marvin--> doh, I meant literate
12:22:16 <ayrnieu> Marvin - it shouldn't be difficult to add \begin{code} to vim; look at how other modes do block-comments.
12:25:11 <ayrnieu> (Except, of course, that you don't want \begin{code}...\end{code} to act like a comment.  I'm thinking something like /(?<!\\begin{code}).*(?!\\end{code})/)
12:25:47 <Marvin--> yah
12:27:04 <ayrnieu> Should '>' and \begin{code} \end{code} work in the same file?
12:28:27 * ayrnieu listens to taty.
12:28:48 <Marvin--> probably
12:29:21 <Igloo> I probably have something to do what you want, but I wasn't reading
12:29:59 <Marvin--> for vim or emacs?
12:30:04 <Igloo> vim
12:30:17 <Marvin--> cool
12:31:47 <Igloo> http://chaos.earth.li/~ian/haskell-vim/lhaskell.vim
12:33:52 <ayrnieu> yay
12:35:01 <Igloo> http://www.haskell.org/pipermail/haskell/2002-January/008783.html may be useful too, but the URL there is out of date
13:59:08 <Heffalump> bah, the debian GHC packages are out of date
14:01:32 <toadx> atleast they only take 6 or so hours to rebuild ;)
14:01:47 <Heffalump> hmm...
14:02:07 <Heffalump> I could I guess
14:04:06 <toadx> what are you try to update to?
14:04:18 <Heffalump> well, I need 5.04 to use Marvin's webserver, I think
14:04:24 <Heffalump> I'll just use my redhat box instead
14:04:35 <toadx> what version of 5.04?
14:04:47 <Heffalump> dunno, but 5.02.2 doesn't work
14:04:54 <Heffalump> probably cos of out-of-date FFI support
14:05:02 <Marvin--> unstable has 5.04
14:05:14 <Heffalump> how long's it had it?
14:05:20 <toadx> a while
14:05:27 <Heffalump> how come it hasn't made it into testing then?
14:05:55 <toadx> dunno
14:06:06 <Marvin--> good question
14:06:34 <Marvin--> http://bugs.debian.org/cgi-bin/pkgreport.cgi?pkg=ghc5-hopengl&repeatmerged=yes <- probably because of this
14:07:16 <Heffalump> so it's all shapr's fault :-)
14:07:34 <Marvin--> haha
14:07:56 <toadx> if you want a 5.04.1 deb, you will have to build it yourself. But its easy, it just takes forever
14:09:16 <Marvin--> not really, you can configure apt to fetch packages from unstable as well
14:09:17 <Heffalump> yeah, I know - I just can't be bothered when I can easily enough use my redhat box
14:09:21 <Marvin--> apt-get install ghc5/unstable
14:09:33 <Heffalump> how do I pin the default versions to testing?
14:09:41 <Heffalump> people keep telling me I can do it but I've never managed to find out how
14:09:53 <Heffalump> or do I just have to include testing apt lines?
14:10:01 <Heffalump> and it'll figure out the unstable ones automatically?
14:10:06 <Marvin--> put   APT::Default-Release "testing";   in e.g. /etc/apt/apt.conf.d/99local
14:10:21 <Marvin--> you must have both testing and unstable apt lines in sources.list
14:11:06 <Heffalump> ahah, ta.
14:14:39 <Heffalump> hmm. It appears to have decided to install acroread from unstable when I do an upgrade
14:15:00 <Marvin--> uh
14:15:19 <Heffalump> I don't really care about acroread, but that's slightly worrying behaviour
14:15:45 <Marvin--> weird
14:15:57 <Heffalump> might be something slipped into testing when it shouldn't have
14:16:05 <Heffalump> I'll try forcing a downgrade once this upgrade finishes and see what happened
14:16:10 <Heffalump> s/happened/happens/
14:19:44 <Heffalump> hmm, looks like it's not in testing for some reason
14:20:03 <Heffalump> or that the mirror I'm using has a problem with non-free testing
14:20:04 <Marvin--> maybe it's been removed because of licensing issues...
14:20:15 <Heffalump> why'd it be in unstable then?
14:20:20 <Marvin--> true, that'd be weird
14:25:10 <Heffalump> btw, is the --with-ghc=`which ghc` necessary for configure, cos it seems to detect it fine without
14:27:48 <Marvin--> it was bleedin' necessary on our university system I can tell you
14:27:53 <Heffalump> :-)
14:28:02 <Marvin--> but I don't trust that computer system as far as I can throw it
14:28:03 <Heffalump> maybe my ghc is somewhere more sensible
14:28:09 <Heffalump> I notice you were explicitly using gmake
14:28:32 <Marvin--> more sensible than  /.../chalmers.se/fs/cab/cs/work/proj/multi/pub/bin/ghc, really? ;)
14:28:43 <Marvin--> well, yeah, because the Solaris make doesn't support -C
14:29:00 <Marvin--> and most people (like the lab accounts) don't have the GNU stuff in their paths
14:29:00 <Heffalump> I really don't understand why people run Solaris any more
14:29:08 <Marvin--> me neither
14:29:29 <Marvin--> well, we get cool reduced prices from Sun since we're the biggest customer in northern Europe ;)
14:29:45 <Heffalump> heh
14:29:49 <Marvin--> I think we got twenty blade 1000 at an outrageous price
14:29:52 <Heffalump> I think we get a lot of cheap/free stuff too
14:29:54 <Marvin--> too bad they haven't found their way down to the labs yet
14:30:39 * Marvin-- sighs at the DFS servers having been b0rken all day today too
14:55:17 <Pseudonym> Eeek.
14:55:25 <Pseudonym> Template Haskell.  Eeek.
14:55:32 <Heffalump> Eeek?
14:55:34 <Igloo> Ooo, where?
14:55:41 <Pseudonym> It's on the ACM DL.
14:55:49 <Igloo> ACM DL?
14:55:53 <Heffalump> He just means the HW paper, then
14:55:54 <Pseudonym> Digital Library
14:55:54 <Heffalump> why eek?
14:55:59 <Pseudonym> Yes, just the paper.
14:55:59 <Igloo> Ah
14:56:10 <dash> so which sense of "template" is this?
14:56:12 <Pseudonym> Well, it's like a mix of C++ templates and strongly-typed Lisp macros.
14:56:19 <dash> hmm
14:56:22 <Heffalump> not really
14:56:29 <dash> you mean "statically typed" :)
14:56:35 <Heffalump> well, strongly-typed Lisp macros, yeah
14:56:41 <Heffalump> it's not entirely statically typed
14:56:46 <Pseudonym> True.
14:56:46 <dash> well, lisp is strongly typed anyway
14:57:08 <Pseudonym> dash: Nobody is sure what is meant by "strong" vs "weak".
14:57:12 <dash> Pseudonym: i am
14:57:15 <Pseudonym> :-)
14:57:31 <dash> "strong" means "no casts (well, except maybe float<->int)"
14:57:31 <Pseudonym> I think of "strong" as a stronger condition than "static".
14:57:35 * Igloo isn't convinced it's not statically typed
14:57:40 <Heffalump> strong means that there can't be a runtime type error that's not first caught by the type system, right?
14:57:46 <Heffalump> Igloo: the templates aren't
14:58:06 <Heffalump> since some of the consequences only get typechecked at program compile time, not template compile or template instantiation time
14:58:08 <dash> Heffalump: hmm. not in any usage i've encountered
14:58:17 <Heffalump> what does it mean then?
14:58:21 <dash> Heffalump: "non-dynamic" is the best i can come up with for that
14:58:35 <Pseudonym> Heffalump: I call that "strictly typed".
14:58:37 <Heffalump> static to me means that there won't be any dynamic type errors
14:58:37 <Igloo> They are, but the actual types of the generated code aren't known
14:58:57 <Heffalump> igloo: so it's possible for the templates to cause a type error in the generated code
14:58:58 <dash> Heffalump: strongly-typed languages dont do casts or implicit conversions 
14:59:11 <Igloo> OK, I see your point
14:59:17 <dash> Heffalump: strongly typed languages include lisp, smalltalk, haskell, ML
14:59:29 <dash> Heffalump: weakly typed languages include perl, C
14:59:50 <Heffalump> I'd hesitate to say perl is typed at all
14:59:57 <Pseudonym> It is.
14:59:59 <dash> it is 
15:00:04 <Pseudonym> Perl can't (in principle) core dump.
15:00:23 <dash> well, that's not really a typesystem issue
15:00:30 <Pseudonym> And every Perl reference knows what it's a reference to.
15:00:36 <Heffalump> hmm, ok
15:00:41 <dash> previous versions of tcl were untyped
15:00:48 <dash> i.e. "everything is a string"
15:01:32 <Pseudonym> dash: I think it is a typesystem issue.  If C didn't let you reinterpret pointers or freely mix pointers and arrays, it wouldn't core dump either.
15:01:45 <dash> Pseudonym: sure it would
15:01:50 <Pseudonym> There are a few more conditions needed.
15:01:53 <dash> Pseudonym: just dereference a null pointer
15:02:03 <dash> no reinterpretation needed =)
15:02:08 <Pseudonym> :-)
15:02:27 <Pseudonym> Well, arguably there should be no such thing as null pointers.
15:02:39 <Pseudonym> In fact, pointers aren't a good abstraction for most purposes.
15:02:51 <dash> Pseudonym: if you mean "C would benefit from a better typesystem" then i'd mostly agree with you :)
15:02:55 <Pseudonym> Yeah, yeah, bootstrap loaders etc.
15:03:15 <Pseudonym> So you admit it.  It _is_ a type system issue!
15:03:26 <dash> Pseudonym: no --
15:03:31 * Pseudonym was kidding
15:03:32 <dash> there are untyped langauges which are pointer-safe
15:03:36 <dash> like tcl
15:03:44 <Pseudonym> I don't think tcl is untyped.
15:03:48 <Pseudonym> It has a type.
15:03:51 <Heffalump> ooh, /me finally gets hws-wp to return something other than an error
15:03:54 <Pseudonym> So does awk.
15:03:57 <dash> well, the latest few versions aren't
15:04:04 <dash> but it used to be all strings
15:04:09 <Pseudonym> Even bash has a type.
15:04:14 <Pseudonym> A string is a type.
15:04:41 <dash> "a type" isn't enough :>
15:04:54 * Pseudonym thinks there are few untyped languages
15:04:57 <Pseudonym> Assembly language.
15:06:10 <Pseudonym> Pretty much all medium-level-and-up languages put some interpretation on a certain location in memory.
15:06:14 <Pseudonym> That interpretation is a type.
15:06:47 <Pseudonym> Languages which let you reinterpret at will are "weakly typed".
15:07:00 <Pseudonym> Or at least that's how I've always used the term.
15:07:33 <Pseudonym> Anyway, template haskell.
15:07:56 <Pseudonym> It's like vegemite.  Both gross and compelling at the same time.
15:08:50 <Heffalump> hmmm...
15:09:17 <Pseudonym> But I suspect it's necessary.
15:55:20 <dark> Assembly language has types too, such as "byte" and "word".
15:55:33 <dash> yeah
15:55:37 <dark> Even arrays of such :)
15:55:45 <dash> "untyped" pretty much just means "only one type"
15:56:03 <dash> like BCPL
15:56:38 <Pseudonym> I disagree.
15:56:50 <Pseudonym> Assembly language only has addresses and their contents.
15:56:51 <dash> Pseudonym: then no language is untyped.
15:56:54 <dark> Hmm... I don't consider a language "dynamically typed" if it doesn't remember the types for you.
15:57:17 <dark> Pseudonym: Addresses don't have contents :)
15:57:21 <dash> dark: well yeah. dynamic typing does involve objects knowing their types
15:57:39 <Pseudonym> I agree that to be dynamically typed you need run-time type information.
15:57:41 <dark> Pseudonym: Memory regions have contents, but to access them you need to know their type, even if it's only a primitive notion such as "byte" or "word".
15:57:50 <Pseudonym> No you don't.
15:58:04 <Pseudonym> You just need two pieces of code to interpret the same location has having the same "type".
15:58:18 <Pseudonym> They don't have a type, they just have bits.
15:58:40 <Pseudonym> To access them, you need to decide how you want to interpret those bits.
15:59:06 <Pseudonym> The types are all in the programmer's head, not in the language.
15:59:18 <dark> So you're telling me "addl 500, counter" has no concept of a 32-bit integer?
15:59:44 <Pseudonym> Sure it does.  The instruction interprets the contents of "counter" as a 32-bit integer.
15:59:50 <Pseudonym> But "counter" doesn't have a type.
16:00:53 <dark> Hmm.  I think of it as "counter" having a type but the language doesn't offer any type checking :)
16:01:09 <dark> After all counter is declared as "counter dd 0" or something.
16:01:15 <Pseudonym> The code sequence (in x86 assembler) movl %eax,counter ; fld counter  has the concept of a 32-bit integer and a floating point number.
16:01:25 <dark> Usually something like "counter" is not a label, but a variable declaration.
16:01:42 <Pseudonym> I agree that we program it that way.
16:01:51 <Pseudonym> But we program Lisp in the same way.
16:02:18 <Pseudonym> It also raises the question of what a type is.
16:02:29 <Pseudonym> One person's type is another person's precondition.
16:05:24 <Pseudonym> Every program is well-typed according to somebody's type checker.
16:05:43 <dash> every _correct_ program, you mean :)
16:05:53 <Pseudonym> True. :-)
16:06:22 <dark> Hmm, I think I agree with you.  I _have_ seen assemblers that will complain if you declare "counter" as a word and access it as a byte, but none of the ones on my system seem to have even a facility for declaring a typed variable :)
16:06:50 <Pseudonym> I'm just quibbling about my personal terminology, of course.
16:06:56 * Pseudonym is probably full of it
16:07:08 <dash> terminology is important, how else would we talk about things? :)
16:07:17 <dark> nasm does allow record declarations, though.  It then defines the offsets of the members for you, and calculates the size.
16:07:19 <Pseudonym> Arguing is talking, of sorts.
16:07:43 <Pseudonym> Isn't it much more fun to talk about talking about such things, anyway?
16:07:48 <dark> Pseudonym: I have seen many arguments where the basic disagreement is obviously (to outsiders) simply the definitions of some words.  They get tedious after a while :)
16:08:00 * dark used to hang out on alt.atheism
16:08:06 * Pseudonym did for a while, too
16:08:16 <Pseudonym> The bandwidth killed me in the end.
16:08:53 <dark> Pseudonym: I studied argumentation theory later that year, the experience came in handy :)
16:09:10 <Pseudonym> :-)
16:09:46 <Pseudonym> I was reading Programming on Purpose III while commuting this morning.
16:10:08 <Pseudonym> There's a wonderful quote which applies perfectly here.
16:10:39 <dark> Anyway... perl might give the impression of untypedness because it does not distinguish between strings and numbers.  But it very carefully keeps track of the difference between scalars, arrays, and hashes -- something that C with its pointers does not do.
16:10:58 <Pseudonym> "We shouldn't confuse thinking with logical reasoning."
16:11:05 <dark> Heh.
16:11:09 <dash> thinking _sucks_
16:11:21 <Pseudonym> Right.
16:11:28 <Pseudonym> Perl is definitely typed.
16:11:38 <Pseudonym> Dynamically, but it's still typed.
16:11:48 <dark> Pseudonym: That reminds me of how argumentation theory scared me.
16:12:11 <Pseudonym> The other choice quote is "Whatever we do that passes for thinking has kept us going so far."
16:12:13 <dark> Pseudonym: We'd get a one-page text that seemed to make sense.  Then we'd study it, and discover that none of its points proceeded logically from any other, and its assumptions were questionable.
16:12:20 <dark> Pseudonym: This would take an hour or so.
16:12:35 <dark> Pseudonym: I suspect that the vast majority of things I'm _not_ spending an hour on are just as weak.
16:12:49 <Pseudonym> Most likely, yes.
16:13:35 <dark> That second quote is a good reminder to people who tell you not to generalize, or not to make assumptions :)
16:13:46 <Pseudonym> Right. :-)
16:13:50 <Pseudonym> Or that you're being too emotional.
16:14:15 <dark> I sometimes explain to them that every morning I blindly assume that jars of fruit jelly have not become explosive overnight.
16:14:58 <dark> Then they laugh at my silly example, and then I remind them that there are countries where this assumption does not hold :)  (i.e. having to be suspicious of containers left on a bar)
16:15:13 <Pseudonym> Such people have not studied any AI.
16:15:21 <Pseudonym> We reason partly by stereotyping.
16:16:07 <Pseudonym> Jars of fruit jelly have never become explosive before.
16:16:34 <Pseudonym> It's also important for our survival.  We get out of the way of something that's about to fall on us _before_ we pause to consider what it might actually be.
16:16:38 <dark> Once would be enough, though :)
16:16:45 <Pseudonym> Yes. :-)
16:17:52 <Pseudonym> alt.atheism is a bad place.
16:18:06 <Pseudonym> For everyone, no matter what their creed or lack thereof.
16:18:12 <dark> Hmm, when I visited, it was cheerful enough.
16:18:27 <Pseudonym> Maybe I just met the wrong people.
16:18:28 <dark> I mean, I was introduced to the cult of the invisible pink unicorn.
16:18:36 <Pseudonym> Ah, yes.
16:19:47 <Pseudonym> I'm currently the only member of the Cult of Freedom.
16:20:03 <Pseudonym> We believe that the purpose of freedom is to promote the status of people like me.
16:20:26 <Pseudonym> Others are free to be not like me, but shouldn't expect their status raised.
16:21:30 <dark> This sounds very similar to the DNRC.
16:21:37 <Pseudonym> Yes, very similar.
16:21:53 <Pseudonym> In the Cult of Freedom, we have the sacrament of excommunication.
16:22:04 <Pseudonym> People who disagree with me are called abusive names.
16:22:14 <dark> This is the editorial "we", presumably :)
16:22:20 <Pseudonym> The worst abusive name we have is "typical".
16:22:37 <Pseudonym> It covers all eventualities.
16:22:50 <Pseudonym> Well, you're free to join if you think like I do.
16:23:06 <Pseudonym> Otherwise, that's _so_ typical.
16:27:41 <dark> http://www.chaosphere.com/cof/charter.txt
16:28:16 <Pseudonym> Danb.,
16:28:18 <Pseudonym> Damn
16:28:42 <Pseudonym> Beat me by about 6 months.
16:29:01 <Pseudonym> Well I'm still a member of the flat earth society, so that's good.
16:30:27 <dark> I once made a role-playing setting for a flat world.
16:31:09 <dark> It had the sun at the center, unmoving.
16:31:41 <dark> Well, _above_ the center :)
16:32:11 <dark> But it would look pretty weird, with all the plant life growing on only one side of the hills.
16:33:46 <Pseudonym> It would, yes.
16:39:54 <dark> Bah, I haven't done any programming today.
16:40:26 * Igloo neither - not even logical today
16:46:21 <dark> logical as in logic programming, or as in being logical?
16:46:54 <dark> Or that today is not a good day for logic? :-)
16:50:04 <Pseudonym> Today is not a good day for temporal logic.
16:50:18 <Pseudonym> Fortunately the axioms will hold tomorrow.
16:51:09 <Igloo> Logical today - i.e. since I got up, rather than the last 50 mins
16:54:42 <dark> Oh, I see :)
16:55:06 <dark> Yeah I didn't even think of that, I decided long ago that days start when I wake up and end when I go to sleep.
16:55:34 <Igloo> The problem comes when you e-mail someone at 1am to arrange a meeting "tomorrow"
16:55:59 <dark> For what it's worth, the opinion of the dutch railway system is that days end at 04:30 :-)
16:56:23 <Igloo> Interesting
16:56:30 <Pseudonym> It's as sensible as any other time.
16:56:47 <dark> Igloo: Yeah, but arranging meetings has so many hazards already that I tend to specify date and weekday in addition to "tomorrow".
16:58:17 <dark> The real problem is when you stay up more than 48 hours in a row.
16:58:33 <dark> But then you probably have bigger problems than the meaning of "today".
17:01:16 <Pseudonym> The meaning of "sleep" is a bit of a problem then.
19:38:38 * shapr pokes dnm
19:38:52 <Pseudonym> G'day shapr.
19:39:01 <shapr> heya pseudonym
19:39:03 <shapr> how's life?
19:40:35 <dnm> Hey shapr.
19:45:57 <shapr> well, time for me to sleep, I'll back in a month or less
19:46:02 <shapr> moving to sweden....
19:46:15 <Pseudonym> Gee, that was suffen.
19:46:17 <Pseudonym> sudden
20:33:21 <Verbophobe> Morning.
21:00:41 <Pseudonym> G'day.
21:02:49 <Verbophobe> I'm halfway through that tutorial you reffered me to.
21:03:13 <Verbophobe> Been doing all exercises without cheating, like a good little boy.
21:03:22 <Pseudonym> Oh, he's a clever little fello!
21:03:39 <Verbophobe> Aren't I?
