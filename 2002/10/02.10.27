01:22:49 <Marvin--> how odd
01:23:45 <ludde> hehe, my log looks like:
01:23:45 <ludde> <dark> [02:46] I got worried about not_null not being inlined.
01:23:45 <ludde> <dark> [02:46] Heffalump: Well, it's marked up with interface versioning numbers.
01:23:45 <ludde> <dark> [02:15] resolve_changes is a horrible function, but it fits in 24 lines :)
01:23:53 <ludde> time warp
01:27:00 <Marvin--> my computer clock didn't change for some reason
01:27:08 <Marvin--> maybe because I'd forgotten to run ntp
01:27:36 <Marvin--> but I think it used to change before I started using ntp too
01:29:39 <andersca> I think I'm using ntpd
01:29:46 <andersca> ye
01:29:46 <andersca> s
01:31:38 <Marvin--> well, I am NOW :)
01:50:17 <ludde> how can I find out what the operator precendence of ++ is
01:50:31 <Marvin--> :i (++)
01:50:45 <Marvin--> when in doubt, :i ;)
01:50:48 <ludde> okay
01:50:55 <ludde> thanks
01:52:10 <Heffalump> if your timezone is set correctly you shouldn't need ntp to update it (and in fact I think ntp uses UTC only)
01:52:52 <Marvin--> Heffalump: exactly.. and the timezone is correct
01:53:05 <Heffalump> weird
01:53:06 <Heffalump> what OS?
01:53:20 <Marvin--> Debian
01:53:29 <Marvin--> (GNU/Linux/etc/etc)
01:53:34 <Heffalump> :-)
01:53:42 <Heffalump> AFAIK my Debian box updated fine.
01:53:43 <ludde> Marvin--: grosse.mdstud doesn't seem to work, do you know any other computer where I can run ghci?
01:54:05 <Marvin--> I set some ntp servers and /etc/init.d/ntpdate and it's back to normal
01:54:10 <Marvin--> Heffalump: but do you have UTC=yes or no?
01:54:15 <ludde> Marvin--: there are all those fraggelNN, but since ghci uses 100% cpu, maybe it's not a good idea?
01:54:23 <Marvin--> ludde: scooter.mdstud, but it's Solaris 6
01:54:30 <ludde> Marvin--: ghci crashes on scooter
01:54:35 <Heffalump> Marvin--: in the kernel settings for what the BIOS does?
01:54:37 <Marvin--> ludde: afaik you can't ssh directly to a fraggel
01:54:48 <ludde> hmm, i think i can
01:54:55 <Marvin--> Heffalump: I mean in /etc/defaults/rcS
01:55:06 <ludde> yes you can
01:55:18 <Marvin--> ludde: weird... well, as long as there's no-one else logged in, I don't see the problem
01:55:23 <ludde> okay
01:55:34 <Heffalump> ah, it's set to yes
01:55:44 <Heffalump> (I thought that was actually a kernel setting)
01:56:03 <Marvin--> hmm, okay, I have UTC=no
01:56:12 <Marvin--> so it can play nicely with windows
01:56:13 <ludde> can I speed up ghci in some way? turn off optimizations?
01:56:26 <Marvin--> ludde: dunno :(
01:56:38 <ludde> compared to hugs, the speed of ghci is almost unusable
01:57:03 <Marvin--> ludde: if you want to use a fraggel, check out ~md9ms/bin/warnlogin :P
01:57:26 <ludde> oh
01:57:32 <Marvin--> but I've always used UTC=no and it's always (afaik) updated fine before
01:57:58 <ludde> Marvin--: that's nice
01:57:59 <Heffalump> that setting only affects what happens at boot
01:58:12 <Marvin--> Heffalump: well the computer was turned off during the night, so...
01:58:16 <Heffalump> ah.
01:58:20 <Heffalump> that explains it then.
01:58:36 <Marvin--> really? It has to be turned on during the rollover?
01:58:36 <Heffalump> is TZ set anywhere?
01:58:47 <ludde> hmm
01:58:48 <Marvin--> $TZ? Hmm, no doesn't seem so
01:58:53 <Heffalump> well, it can't know that something else didn't update your system clock
01:59:00 <Marvin--> hmm
01:59:08 <ludde> is there any way to "pre compile" modules that are never changed, a la precompiled headers in modern compilers?
01:59:12 <Heffalump> the usual reason for that setting is that you're running doze, which changes the BIOS clock
01:59:39 <Heffalump> ludde: you can just compile them, surely?
01:59:47 <Marvin--> ludde: compile them, ghci can load .o files
01:59:55 <ludde> ok
02:00:20 <Marvin--> Heffalump: hmm, where can I read about $TZ?
02:00:46 <Heffalump> well, I was just reading /etc/init.d/hwclockfirst.sh
02:01:14 <ludde> hmm, so ghci compiles everything to C, and then it invokes GCC, each time I reload a module?
02:01:28 <Heffalump> ludde: no, it has an interpreted mode too
02:01:40 <Heffalump> where things run slower but don't get fully compiled first
02:01:57 <Heffalump> and ghc outputs assembler itself these days, without invoking GHC, AIUI
02:02:01 <Heffalump> s/GHC/GCC/2
02:03:11 <Marvin--> oh well, I forcibly set my hwclock and date thingy, let's see what breaks :)
02:03:30 <Heffalump> do you dual-boot Windows?
02:03:55 * andersca just runs redhat-config-date
02:04:03 <Marvin--> Heffalump: yes
02:04:13 <Marvin--> grr, why didn't it pick up /etc/localtime as it should? :(
02:05:58 <Marvin--> Heffalump: I play the occasional game, though you wouldn't believe it after the last few weeks/month(s) when I've been too damn busy
02:08:08 <Heffalump> :-)
02:08:22 <Heffalump> I pretty much gave up playing games when I started university, cos I just didn't have time
02:09:07 <Marvin--> oh I usually have time, but this semester I've not only been studying full time but also teaching, and it's taken waaay too much time
02:09:18 <Marvin--> this course really should have three assistants and not two
02:12:28 <ludde> gah, how can i figure out why GHCi fucks up my terminal window (it seems to exit, and all that is printed is fraggel22> all over the screen)
02:12:57 <Marvin--> I think Koen said that's a known bug
02:13:07 <ludde> oh
02:13:49 <ludde> but what can I do about it? when I load my .hs files, it becomes like that
02:15:54 <ludde> oh
02:15:55 <ludde> GHCi runtime linker: fatal error: I found a duplicate definition for symbol
02:15:55 <ludde>    __stginit_MonadTrans
02:15:55 <ludde> whilst processing object file
02:15:55 <ludde>    MonadTrans.o
02:15:55 <Marvin--> dunno
02:43:18 <Marvin--> dark
02:44:37 <ludde> why doesn't this work:
02:44:37 <ludde> class AttributeFmt a where
02:44:37 <ludde>   fmtattr :: a -> String
02:44:37 <ludde> instance AttributeFmt String where
02:44:37 <ludde>   fmtattr = id
02:45:04 <ludde>     Illegal instance declaration for `AttributeFmt String'
02:45:04 <ludde>         (The instance type must be of form (T a b c)
02:45:04 <ludde>          where T is not a synonym, and a,b,c are distinct type variables)
02:45:16 <ludde> oh
02:45:23 <ludde> string is a synonym :/
02:45:56 <ludde> hrm
02:46:03 <ludde> how would I do this then?
02:46:55 <Igloo_> You could create a Char instance and have a [a] instance concatMap fmtattr
02:47:00 <dark> Greetings
02:47:04 <Igloo_> Or wrap your strings in a constructor and define an instance for that
02:47:08 <ludde> hmm
02:47:10 <Igloo_> What's a dozen number?
02:48:29 <dark> ludde: I've found it helpful to define newtypes for String in many cases, anyway.  It gives extra typechecking help, and it means you can do consistency checks in the type's constructor (such as: valid characters, correct format)
02:48:40 <ludde> but i want to be able to write
02:48:41 <dark> ludde: The only problem is that I end up abusing "show" as the way to turn it back into a normal string :)
02:48:52 <Marvin--> dark: heh
02:48:57 <ludde> "NAME" @= "hej" or "NAME" @= 123
02:49:21 <Marvin--> so instantiate Read *cough*
02:49:26 <ludde> hmm?
02:49:31 <ludde> why would that work?
02:49:44 <ludde> read converts a string to an A
02:49:57 <ludde> I need to convert "hej" to "hej" and 123 to "123"
02:49:58 <Marvin--> yeah, sorry
02:50:02 <dark> ludde: Converting a -> String is the job of show :)
02:50:13 <ludde> dark: show a /= a though :)
02:50:23 <dark> ludde: Ah, yeah, for String arguments.
02:50:31 <ludde> yeah
02:50:46 <Marvin--> do you want 'a' -> "a" too?
02:50:53 <ludde> yeah
02:51:11 <ludde> or well, it doesn't really matter, but that would be the way i would choose if I wanted Char
02:51:12 <Marvin--> then  AttributeFmt Char  and  AttributeFmt a => AttributeFmt [a]  is probably the way to go
02:51:16 <ludde> okay
02:51:42 <dark> That does mean that [4, 5] becomes "45" :)
02:51:47 <Marvin--> as long as you can live with   "foo" @= [1,2,3]  being the same thing as  "foo" @= 123
02:52:22 <dark> Hmm, how does Show itself do it?
02:52:52 <Marvin--> [] -> "[]"; [a] -> "[" ++ show a ++ "]"; ... I suppose
02:53:08 <dark> Marvin: I was thinking of strings :)
02:53:11 <Marvin--> oh
02:53:16 <dark> But I see it now, the Show class defines a showList functin.
02:53:18 <Marvin--> magic
02:53:29 <ludde> but
02:53:31 <dark> Greater minds than mine have solved this already :-)
02:53:35 <dark> No, not magic at all.
02:53:38 <ludde> show doens't print Strings in the same way as it prints lists
02:53:45 <dark> class  Show a  where
02:53:45 <dark>     showsPrec :: Int -> a -> ShowS
02:53:45 <dark>     show      :: a   -> String
02:53:45 <dark>     showList  :: [a] -> ShowS
02:54:03 <Marvin--> yeah, and showList has a default behaviour
02:54:06 <dark> ludde: Indeed, that's because the showList for Show Char is different.
02:54:23 <dark> ludde: You could solve it the same way with your AttributeFmt class if you wanted to.
02:54:24 <ludde> oh
02:54:31 <ludde> nah
02:54:58 <ludde> instance Num a => AttributeFmt a where  
02:54:58 <ludde>   fmtattr = show  
02:55:10 <ludde> what's wrong with this
02:55:10 <Marvin--> showsPrec is pretty smart, using function composition instead of ++ is nifty
02:55:20 <Marvin--> ludde: you must have an explicit type somewhere
02:55:35 <ludde> oh
02:55:54 <Marvin--> I've cursed that too, and I don't know why it's a requirement
02:56:26 <dark> Marvin: There's a ghc extension to turn that off... :)
02:56:30 <Marvin--> you'll have to do instance AttributeFmt Int where fmtattr = show; instance AttributeFmt Integer where fmtattr = show; ...
02:56:35 <Marvin--> dark: oh, neat, which one?
02:56:47 <dark> Marvin: allow-foo-instances, for some foo
02:56:53 <dark> I don't remember the differences between them :)
02:56:57 <Marvin--> heh
02:57:02 <ludde> *Main> "hej" @= 1
02:57:02 <ludde> <interactive>:1:
02:57:02 <ludde>     Ambiguous type variable(s) `a' in the constraint `AttributeFmt a'
02:57:02 <ludde>     arising from use of `@=' at <interactive>:1
02:57:02 <ludde>     In the definition of `it': "hej" @= 1
02:57:24 <ludde> instance AttributeFmt Int where   
02:57:24 <ludde>   fmtattr = show
02:57:40 <Marvin--> dark: -fglasgow-exts isn't enough...
02:58:15 <ludde> I also get
02:58:15 <ludde>   Ambiguous type variable(s) `a' in the constraint `Num a'
02:58:56 <ludde> anyone?
02:59:15 <dark> How do you define @= ?
02:59:18 <Marvin--> dark: overlapping instances?
02:59:27 <ludde> (@=) :: AttributeFmt a => String -> a -> [Attribute]
02:59:27 <ludde> s @= a = [(s,fmtattr a)]
02:59:55 <dark> Marvin: I don't know, you'll have to read the descriptions.  I read them all at once and I don't remember which one did what.
03:00:09 <Marvin--> ah, no, -fallow-undecidable-instances
03:00:20 <Marvin--> "the intent here is to make sure that context reduction terminates. Voluminous correspondence on the Haskell mailing list has convinced me that it's worth experimenting with a more liberal rule. If you use the flag -fallow-undecidable-instances can use arbitrary types in an instance context. Termination is ensured by having a fixed-depth recursion stack. If you exceed the stack depth you get a sort of backtrace, and the opportunity to i
03:00:20 <Marvin--> the stack depth with -fcontext-stackN."
03:00:20 <ludde> i guess i can try with -fallow-undecidable-instances too
03:01:02 <Marvin--> err
03:01:15 <Marvin--> aha, you need -fglasgow-exts too
03:02:06 <ludde> hmm
03:02:06 <dark> ludde: I wonder if it's complaining because it can't tell which numeric type "1" is.
03:02:08 <ludde> doesn't seem to help
03:02:29 <Marvin--> damn, I need negation of contexts :-)
03:02:32 <ludde> dark: that's what I thought, that's why I wanted instance Num a => AttributeFmt a where
03:02:44 <dark> ludde: What does ghc say about it?
03:02:57 <Marvin--> ludde: and Attribute = (String,String)?
03:03:01 <ludde> Marvin--: yes
03:03:15 * Marvin-- wants instance (Foo a, -Num a) => Foo [a] where.. :-)
03:03:18 <ludde> dark: ghc says    Illegal instance declaration for `AttributeFmt a'
03:03:18 <ludde>         (The instance type must be of form (T a b c)
03:03:18 <ludde>          where T is not a synonym, and a,b,c are distinct type variables)
03:03:48 <Marvin--> dammit, I really do need negation here
03:04:33 <Marvin--> Errrr, but how can this be an overlapping instance, Char isn't Num!
03:04:39 <dark> Marvin: This would be tricky, the compiler doesn't know ahead of time what kind of Num instances you might get it into your head to declare :)
03:04:56 <Marvin--> maybe it's because Num requires Show :/
03:05:02 <ludde> Marvin--: does instance Num a => AttributeFmt a where work for you when you enabled that flag?
03:05:04 <Marvin--> and Char is also Show
03:05:23 <Marvin--> ludde: instance Num a => Foo a does anyway, and Foo has foo :: a -> String
03:05:29 <Marvin--> ludde: but I can't declare instance Foo Char
03:05:30 <pesco> Marvin--: OOI, why must a not be instance of Num in your example?
03:05:39 <ludde> hmm
03:06:12 <Marvin--> pesco: well, it doesn't, but I can't do  instance Foo Char  either
03:06:12 <dark> pesco: Because he's done a blanket instance for Num a already :)
03:06:26 <dark> Marvin: You might need another flag, like allow-incoherent-instances or whatever :)
03:06:30 <pesco> Hm.
03:06:30 <ludde> bleh, ghci makes me crazy :(
03:06:41 <dark> Marvin: There's one for making it DWIM when there are multiple applicable instances.
03:06:58 <Marvin--> dark: sorry :)
03:07:19 <Marvin--> ah, tha classic -dwim flag
03:08:12 <Marvin--> There was one program I compiled once, whose configure script accpeted the --enable-voodoo flag ("when all else fail")
03:08:35 <ludde> why does "show 1" work then? why doesn't it get that error with not knowing which Num instance it is
03:08:40 <Marvin--> Enlightenment is a classic too... "Checking for Bass ale in your fridge... failed."
03:09:13 <Marvin--> the funny thing is that when I compiled Enlightenment I actually *did* have Bass in the fridge
03:09:34 <pesco> Marvin--: Then you probably should have used --with-bass-ale.
03:09:37 <andersca> we have such a check in libegg too
03:09:57 <Marvin--> pesco: ooh
03:11:04 <pesco> The autocheck probably relies on /dev/fridge being mounted
03:14:59 <Marvin--> damn, I need to go to the supermarket, but it's raiiniiing :(
03:21:38 <dark> Marvin: You'll have to weigh starvation against the storm :)
03:21:51 * dark considers writing a concatUntilBitterEnd function.
03:24:50 <Marvin--> heh
03:25:19 <dark> I already have concatWhileProductive, which takes a list and a partitioning function, and keeps concatting the "yes" partitions and rerunning the function on the "no" partititons until the "yes" side becomes empty.
03:26:35 <dark> Now I might need one that keeps at it until the "no" side is empty :)
03:27:10 <Marvin--> heh
03:27:33 <Marvin--> I'm surprised there isn't a function that splits up lists in sublists given a splitter function... or at least I haven't found one
03:27:44 <Marvin--> something like :: ([a] -> ([a],[a])) -> [a] -> [[a]]
03:28:39 <dark> How far should it split?
03:29:02 <Marvin--> splitter f xs = let (ys,zs) = f xs in ys : if null zs then [] else splitter f zs
03:29:18 <Marvin--> that's a function in my "standard library" :)
03:29:21 <dark> Ah... yes.
03:29:39 <dark> Hmm, that might be a nicer way to write concatWhileProductive :)
03:29:54 <dark> Use this splitter and concat the resulting list :)
03:29:57 <Marvin--> in a project in a course we had a module called Coolness that had some functions that "we felt should be in the prelude, but isn't"
03:30:10 <dark> Heh I have piles of such functions :)
03:30:24 <dark> Well, not in the prelude perhaps... but in a standard library.
03:30:33 <Marvin--> well, yeah
03:30:47 <dark> sortWith f = sortBy (\x y -> compare (f x) (f y))
03:31:04 <dark> This way I can sort lists of pairs with sortWith fst or sortWith snd :-)
03:31:10 <Marvin--> heck, this was about half a year after I first saw Haskell ;)
03:31:24 <Marvin--> heh
03:31:51 <dark> Marvin: Well I've been seriously hacking in Haskell for only a month or two.
03:32:27 <Marvin--> dark: but I hadn't been hacking seriously in it at that time, only solving some programming assignments.. This was when I was studying mainly maths
03:32:31 <dark> The standard libraries seem seriously small :)
03:33:16 <Marvin--> you could say that that was the time when I actually started hacking Haskell, since what we did was reimplement a Java assignment in Haskell
03:33:22 <Marvin--> (path finding using Dijkstra's algorithm)
03:33:29 <Marvin--> with CGI interface and stuff :P
03:33:31 <dark> It might be nice to have a project to take the best features from everyone's libraries.  I bet that a lot of people have cool libraries that aren't being adopted because they're half brilliant and half bogus.  We should have a brilliance detector though.
03:33:46 <dark> CGI interface for path finding?
03:33:59 <Marvin--> well, CGI interface to an application of path finding
03:34:09 <Marvin--> To be more precise, the tram system in Göteborg
03:34:13 <dark> Oh :-)
03:34:29 <dark> I remember being unnerved at seeing a big red tram coming at me saying "ANGERED".
03:34:35 <ibid> bah, nhc98 is on ajt's list of removals (and no action from maintainer...)
03:34:39 <Marvin--> ROFL
03:35:04 <dark> ibid: Yeah, but maintainer was pretty responsive a few weeks ago when I filed a bug on hmake.
03:35:14 <Marvin--> dark: that one goes into my quote book (as soon as I've repaired it)
03:35:19 <dark> ibid: I don't understand how the same maintainer can have a spelling error open for half a year.
03:35:26 <ibid> dark: and not responsive when *i* filed a bug on hmake
03:35:37 <ibid> i just sent him a warning...
03:35:39 <dark> ibid: It's possible that your bug was the result of the fix for my bug )
03:36:06 <ibid> i'd rather not have nhc98 removed, but i don't have the competence to fix m68k assembler errors
03:36:15 <ibid> dark: your bug was...?
03:36:15 <Marvin--> heh
03:36:36 <dark> ibid: hmake didn't work without nhc98 installed
03:36:41 <Marvin--> I suppose Debian policy forbids it being removed from just m68k :/
03:36:42 <dark> ibid: even though I had ghc 
03:36:57 <ibid> dark: my bug is about hmake hardcoding an old version of ghc
03:37:01 <dark> Marvin: It doesn't forbid that, actually.
03:37:08 <ibid> Marvin--: there is nothing that forbids it
03:37:22 <ibid> Marvin--: debian policy does not cover removals, actually
03:37:27 <Marvin--> true
03:37:48 <ibid> and ajt as the rm and a fm does have the authority :-)
03:37:53 <Marvin--> but policy also says that one should never ever put anything else than "Architecture: any" unless you have seriously good reasons, doesn't it?
03:38:07 <ibid> although he is imho a little too trigger-happy
03:38:27 <dark> ibid: I think his policy is better than mine was.
03:38:27 <Marvin--> I think it's good
03:38:41 <dark> ibid: He removes early and often, but allows reinstatements.
03:38:50 <ibid> dark: heh
03:38:54 <Marvin--> sometimes threatening to remove a package is the only way to make osmeone fix its RC bugs :)
03:39:08 <Marvin--> dark: when were you rm?
03:39:13 <dark> Marvin: The irony of that is that expendable packages get fixed first :)
03:39:24 <Marvin--> yeah
03:39:29 <dark> Marvin: Yeah, for potato.  Anthony took over before the actual release, though.  I was seriously overworked at the time :)
03:39:34 <Marvin--> ah
03:39:50 <Marvin--> I think aj's policy on keeping sarge releasable constantly is a good one
03:39:53 <ibid> dark: i don't think removing stuff in unstable is warranted given that we have testing
03:40:00 <dark> potato went into the freeze with about 350 bugs, and I estimate that 1200 more were reported before the release.  It was like this vast tide coming in.
03:40:04 <Marvin--> unfortunately d-i is nowhere near releasable and we're hideously understaffed
03:40:14 <dark> ibid: Yeah, I'm not sure what his reasoning is there.
03:40:16 <ibid> dark: removing from testing, well, that is an entirely different matter
03:40:58 <ibid> Marvin-- is d-i people?
03:41:05 <Marvin--> ?
03:41:12 <ibid> 13:40 < Marvin--> unfortunately d-i is nowhere near releasable and we're hideously understaffed
03:41:15 <Marvin--> duh
03:41:22 <ibid> Marvin--: you are involved with d-i?
03:41:25 <Marvin--> ibid: yes
03:41:28 <ibid> ok
03:41:44 <ibid> like to help but as always, i can barely handle the present load...
03:41:49 <dark> Even now, the vast majority of RC bugs seem not release-critical at all.
03:42:21 <Marvin--> the irony of the situation is that I'm the one who works most on several of the d-i packages, and I'm not even a developer yet
03:42:35 <dark> People keep holding the simultaneous opinions, "this bug is critical and must be fixed" and "this bug does not warrant removing the package".
03:42:35 <Marvin--> so I can't be in the Uploaders fields
03:42:48 <Marvin--> heh
03:42:57 <dark> Sorry, old frustrations speaking :)
03:43:03 <Marvin--> gotta love human behaviour
03:43:15 <dark> When I was release manager, removing a package was significant manual work, so I was pissed that people would always fix them two days *after* removal.
03:43:26 <Marvin--> hahaha
03:43:51 <ibid> dark: removing from unstable for rc bugs is imho too much, rc bugs really apply to testing only
03:44:02 <Marvin--> ibid: tell that to aj
03:44:36 <Marvin--> if a package is removed from testing because it has RC bugs it won't percolate down again until the bug is fixed, sounds good to me
03:44:49 <dark> I already see the same complaints :)  "Aj didn't look at my bug closely enough!".  Quick calculation: 650 bugs, 2 minutes per bug, is about 20 hours of work.  By that time it's a week later so you have 50 new bugs to look at.
03:45:05 <ibid> Marvin--: i dare not tell ajt anything... he seems to get raving mad from people questioning him
03:45:24 <ibid> and please, don't call him aj... makes me feel identityless :(
03:45:30 <Marvin--> ibid: not really, he's just stressed :)
03:45:55 <ibid> Marvin--: that does not contradict what i said :_)
03:46:10 <Marvin--> ibid: sorry, but he's using aj as irc nick and that's how I know him
03:46:16 <ibid> true
03:46:26 <ibid> i once asked him not to... he ignored me
03:46:35 * ibid is often called aj irl
03:46:55 <Marvin--> heh
03:46:59 <ibid> but then again, i try to teach those people not to do that
03:47:06 <ibid> because aj is way too generic
03:47:18 <dark> Is it as generic as "Richard"? :-)
03:47:33 <ibid> dunno
03:47:55 <ibid> surprisingly, ibid is quite unique (i have never gotten a nick collision in ircnet)
03:48:10 <ibid> but i wouldn't like people calling me ibid irl
03:49:32 <ibid> (but i sometimes toy with the idea of publishing my eventual fictional book under the pseudonym "ibid":-)
03:49:52 <dark> "dark" is bad, collision-wise, but I'd already been using it for about 10 years before I started ircing, and I can't change now :)
03:54:46 <dark> Hmm, if I could nominate any one function of mine for the standard library, it would be hGetStr.
03:54:52 <Marvin--> hmm, haskell.sty doesn't seem to have support for let-in-do
03:55:10 <dark> Marvin: Hmm, I use that lots.
03:55:19 <dark> Of course, in my current program, 90% of the functions are IO :-)
03:55:30 <dark> s/functions/top-level functions/
03:55:31 <Marvin--> dark: what do you think a web server is then? ;)
03:58:20 <dark> Marvin: Obviously it's a pure function from requests to replies :)
03:58:54 <Marvin--> hahahaha
04:00:52 <dark> I hate it when I thought I solved a problem yesterday, and then realize in the morning that the solution doesn't work at all.
04:00:53 <Marvin--> fuck, I just went over eight pages
04:00:59 <dark> Late-night delusions, I guess.
04:02:24 <Marvin--> I think my implementation of calling the hook functions is really cute
04:02:31 <dark> Marvin: delete the "Secret plan for world domination" from pages 5 and 6.  It's supposed to be Secret.
04:02:38 <Marvin--> hook and runHooks are combinators on HandlerFunc :-)
04:02:59 <Marvin--> dark: what, "1. Implement a cool Haskell Web Server, 2. ???, 3. Profit!"?
04:03:07 <Marvin--> or optionally, "3. World Domination"
04:03:24 <dark> "2. Replace apache everywhere"
04:03:45 <Marvin--> hook :: (HWSPlugin -> Maybe HandlerFunc) -> Maybe ResponseCode -> HandlerFunc
04:04:57 <Marvin--> hook phase mrc rdata = do { plugins <- getPlugins; let hooks = [ hf | Just hf <- map phase plugins ]; runHooks hooks mrc rdata }
04:06:50 <Heffalump> Marvin--: have you seen Igloo's Haskell2LaTeX (http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/Haskell2LaTeX/)
04:06:57 <Marvin--> Heffalump: yes
04:07:07 <Heffalump> ok, just checking since you were complaining about haskell.sty :-)
04:07:55 <Marvin--> Heffalump: but a) I haven't written this in .lhs, b) I only want to highlight small implementation notes in the report since they will have access to the source code anyway, c) HWS isn't written in .lhs either
04:08:03 <dark> Marvin: It took me a while but I think I get it now :)
04:08:05 <Marvin--> give me some time and I could probably think of a d and e too ;)
04:08:37 <Heffalump> :-)
04:08:40 <Marvin--> dark: the 'phase' is records in the plugins: HWSPlugin = HWSPlugin { ..., pURITransHandler :: Maybe HandlerFunc, pAccessHandler :: Maybe HandlerFunc, ... }
04:08:57 <Marvin--> dark: er, selectors in the record even
04:08:58 <dark> Marvin: Oh, so the meaning of rdata changes too?
04:09:14 <Marvin--> rdata is the argument of the returned HandlerFunc
04:09:37 <Marvin--> first I wrote   hook :: (HWSPlugin -> Maybe HandlerFunc) -> Maybe ResponseCode -> RequestData -> ServerM (HandlerResult RequestData)
04:09:59 <Marvin--> but since  HandlerFunc = RequestData -> ServerM (HandlerResult RequestData)  it's cuter to think of hook as a combinator :D
04:10:02 * Heffalump discovers dark wrote lintian
04:10:18 <dark> Heffalump: Co-wrote with Christian Schwartz actually :)
04:10:45 <Heffalump> s/wrote/helped write/ :-)
04:10:46 <dark> Marvin: ah, I was thinking of it as a string or something, but I guess it represents everything about a request :)
04:11:02 <Marvin--> dark: HandlerFunc is uber-general ;)
04:11:17 <Marvin--> HandlerResult a = HR_OK a | HR_Decline a | HR_Error ResponseCode
04:11:48 <Marvin--> but this will all be in the report
04:11:49 <dark> What does Decline do?
04:12:05 <Marvin--> it means "I didn't handle this phase, someone else better"
04:12:12 * Heffalump likes lintian, it reduces my worry that I'm doing something stupid whilst learning to write .debs
04:12:51 <dark> Heffalump: I wanted something that automated the boring checks I did on my packages, so that I'd have more time for nethack :-)
04:12:53 <Marvin--> dark: e.g. the DirPlugin's mime type handler declines to handle files that are not directories
04:13:11 <dark> Heffalump: These days lintian has a competitor, linda.
04:13:22 <Marvin--> I use both lintian and linda
04:13:40 <Heffalump> oh, I didn't know about linda
04:13:43 * Heffalump --> look at it
04:13:49 <dark> Marvin: Hmm, but if a handler returns OK, no-one else gets to handle it?
04:14:05 <Marvin--> dark: depends on the phase... some phases don't care about the distinction between OK/Decline
04:14:13 <Marvin--> That's what the 'Maybe ResponseCoe' is
04:14:32 <Marvin--> dark: do you feel like looking at a draft of the report and tell me what's bad in it?
04:15:16 <Heffalump> ooh, linda finds lots of errors
04:15:48 <Heffalump> but there's no linda-info :(
04:16:37 <dark> Marvin: Yeah.  I can tell you which parts I didn't understand :)  Can you send a pdf?
04:17:17 <Marvin--> dark: is .ps good enough?
04:17:32 <Heffalump> ps2pdf is someone's friend here :-)
04:17:38 <Heffalump> though the fonts tend to look a bit nasty
04:17:53 <dark> Yeah I have ps2pdf.
04:17:57 <Marvin--> yeah, I've had many problems with ps2pdf
04:18:07 <Marvin--> actually, wait, LyX can export pdf
04:18:10 <Marvin--> wonder how well it works
04:18:11 <dark> My screen is too small to for the ps viewer.
04:18:31 <Marvin--> surprise surprise, it used ps2pdf ;)
04:19:19 <dark> Marvin: To give you some understanding of my working environment... in order to view this file at all I will have to go start X :-)
04:19:24 <Heffalump> if you setup the fonts right to begin with, using ps2pdf is fine
04:19:38 <Marvin--> dark: heh
04:19:42 <Heffalump> the problem is that when you use embedded bitmap fonts in .ps, they scale horribly when used in .pdf
04:19:53 <Marvin--> dark: there are links from http://193.11.232.159:2080/
04:20:21 <Marvin--> whoa, this looks horrible in acroread
04:20:25 <Marvin--> looks great in gv though
04:20:37 * dark downloads Haskell warez.
04:20:47 <Heffalump> ooh, there are Haskell warez?
04:21:12 <dark> Heffalump: I was referring to Marvin's url :)
04:21:38 <Marvin--> yeah, the code is unreleased yet, so hush ;)
04:23:22 <Heffalump> aww, no fun :-)
04:23:34 <Heffalump> what's the difference between sh -e and sh with set -e near the top?
04:23:51 <Marvin--> none, I guess
04:23:59 <Marvin--> except that you can only have one argument to the program called in #!
04:24:08 <Heffalump> well, linda is complaining about my maintenance scripts cos they use sh -e
04:24:17 <Marvin--> so if you have #!/usr/bin/env some-other-sh, you can't have -e there
04:24:18 <Heffalump> and I can't figure out how to get it to explain in more detail
04:24:26 <Marvin--> there's no -v flag or so?
04:24:33 <dark> Obviously lintian is the superior tool ;-)
04:24:44 <Heffalump> neither -v or -f long helps
04:24:55 <Marvin--> hmm
04:24:58 <dark> Heffalump: StevenK is online, you could ask him about it.
04:25:03 <Heffalump> dark: well, lintian-info is broken on my install for no apparent reason (I have to set LINTIAN_ROOT to make it work)
04:25:06 <Marvin--> what dark said ;)
04:25:20 <dark> Heffalump: Weird.
04:26:03 <dark>   * Fixed lintian-info's broken $ENV{LINTIAN_ROOT} use.
04:26:06 <Heffalump> I can't work out why, since without LINTIAN_ROOT set it ought to default to the right thing, but doesn't
04:26:08 <dark> This is from 1.21.1
04:26:34 <Heffalump> ah, I'm on 1.21
04:26:48 <dark> What's it look like in your version?  (curious)
04:26:56 <Heffalump> what's what look like?
04:27:08 <dark> From the top of lintian-info:
04:27:09 <dark>   # determine LINTIAN_ROOT
04:27:09 <dark>   my $LINTIAN_ROOT = $ENV{'LINTIAN_ROOT'} || '/usr/share/lintian';
04:27:09 <dark>   $ENV{'LINTIAN_ROOT'} = $LINTIAN_ROOT
04:27:09 <dark>     unless exists $ENV{'LINTIAN_ROOT'};
04:27:33 <Heffalump> # determine LINTIAN_ROOT
04:27:33 <Heffalump> my $LINTIAN_ROOT = $ENV{'LINTIAN_ROOT'} || '/usr/share/lintian';
04:27:33 <Heffalump> if (not exists $ENV{'LINTIAN_ROOT'}) {
04:27:33 <Heffalump>     $ENV{'LINTIAN_ROOT'} = $LINTIAN_ROOT;
04:27:33 <Heffalump> }
04:27:43 <Heffalump> I don't understand the difference between the two.
04:27:50 <Marvin--> the power of perl! ;)
04:27:53 <Heffalump> oh, exists.
04:28:07 <Heffalump> does the ENV hash think everything exists?
04:28:10 <dark> I still don't see it :)
04:28:31 <Heffalump> well, exists foo and foo aren't the same truth value
04:28:34 <Marvin--> I wouldn't mind unless (I use the monadic unless in haskell) if it wasn't suffix, I really don't like the suffix unless/if stuff in perl
04:28:37 <Heffalump> in particular foo could exist but be false
04:28:49 <Marvin--> Heffalump: uh, but both versions use exists
04:28:55 <Heffalump> oh, duh.
04:28:57 <Marvin--> <dark>     unless exists $ENV{'LINTIAN_ROOT'};
04:28:58 <Heffalump> hmm.
04:28:59 <Marvin--> <Heffalump> if (not exists $ENV{'LINTIAN_ROOT'}) {
04:29:01 <Heffalump> sorry :-)
04:29:19 <Heffalump> dark: what happens in the use lib line?
04:29:37 <dark> use lib "$ENV{'LINTIAN_ROOT'}/lib";
04:29:42 <Heffalump> hmm. same here.
04:30:58 <dark> Marvin: Hmm, the suffix conditions can do a lot of good if used right; the idea is to use them for conditions that are rarely false.
04:32:04 <dark> Heffalump: hmm... is your version in a BEGIN block too?
04:32:08 <Heffalump> no.
04:32:17 <dark> Ah, then that is it :) 
04:32:18 <Heffalump> ahhhh
04:32:20 <Heffalump> that explains it :-)
04:32:24 <Heffalump> use lib is in an implicit BEGIN block
04:32:27 <Heffalump> nasty.
04:32:29 <Marvin--> dark: I suppose I just don't agree with the perl "there's more than one way to do it" philosophy
04:32:35 <Heffalump> that aspect of perl semantics is evil
04:32:41 <dark> Heffalump: I think that I wrote it with "require" originally.
04:32:45 <dark> Heffalump: For this reason :-)
04:32:53 <Heffalump> doesn't require have an implicit BEGIN too?
04:32:56 <Heffalump> it's do that doesn't
04:33:10 <Heffalump> ah, no
04:33:24 * Heffalump withdraws that
04:34:16 <Marvin--> dark: I'm much more fond of Python's "there should only be one intuitive way to do it"
04:34:24 <Marvin--> unfortunately that fails if you want efficient python code :-)
04:34:32 <Heffalump> grr, OPN allowing such long nicks means that the nicks list in #debian only uses 3 columns
04:34:39 <dark> Marvin: And Haskell's "there's one way to do it but a thousand ways to write it down"? :)
04:38:56 <dark> Marvin: This efficient-code thing is why I prefer compiled languages over interpreted :)  I like knowing that there's an optimizer behind my code.
04:39:18 <Heffalump> perl does have an optimizer
04:39:26 <Heffalump> I don't think it ends up being that much slower than Haskell, TBH
04:39:34 <dark> Heffalump: Yeah but perl's optimizer runs at runtime.
04:40:37 <dark> ghc's optimizer isn't restricted by user impatience, just by developer-dying-of-old-age :)
04:40:52 <Heffalump> lol
04:40:59 * dark wants a -Oharder-and-faster option
04:43:32 <Marvin--> dark: any comments on the draft?
04:43:47 <dark> Marvin: Oh, sorry... I got distracted :)
04:43:54 <Marvin--> heh
05:02:03 <dark> Okay, I was confused by the first paragraph of 2.2 :)  I had to read it a couple of times to figure out which parts were rhetorical.
05:02:48 <Marvin--> hmm
05:02:52 <dark> In 3.3, I never did figure out what the sentence that starts "Calling all plugins for access control" means.
05:02:57 <Marvin--> yeah, that section is a likely candidate for removal
05:03:35 <dark> The whole section?  Yeah it's a bit of a sideline, even though it probably represents a lot of work :)
05:03:51 <Marvin--> you mean 3.2, right?
05:03:58 <Marvin--> well, subsection... 2.2
05:04:12 <dark> Er, yeah, 3.2
05:04:20 <dark> My notes aren't very clearly written :)
05:04:43 <Marvin--> To be honest, I'm not quite sure how to motivate the difference between access and auth
05:04:54 <Marvin--> I don't consider "'cause apache does it" valid ;)
05:05:43 <Marvin--> That sentence probably needs some work, but what I mean is that fixup and logging will be called in all plugins is pretty intuitive, while it's harder to see the reason for access control to be called in all plugins
05:05:44 <Heffalump> access is more general than auth, right?
05:05:47 <Marvin--> yes
05:05:56 <Heffalump> and any plugin can take part in access control
05:06:02 <Heffalump> though I suspect only auth actually does
05:06:28 <Marvin--> my intuition is that since different plugins can implement vastly different means of access, all of them have to asked
05:07:29 <Marvin--> and since "access denied" is implemented as returning 403 Forbidden, there's no _harm_ in asking all of the plugins
05:07:31 <dark> Also, your description of * in mime types seems wrong.  application/xml* does not match application/xml-dtd as far as I know.
05:07:45 <dark> Or even application/xml :-)
05:07:57 <Marvin--> dark: probably not, but I probably don't follow the standards on the matching, the matching is very primitive :-)
05:08:20 <Marvin--> If it makes you happier, I can add a footnote about it not being standards-compliant
05:08:46 <Heffalump> oh, and something might need to return access denied if it can't read a file on disk
05:08:46 <dark> Marvin: The standards are very simple, though :)  Split on /, and the right-hand side can be "*" to match all right-hand sides, or both sides can be "*" to match everything.
05:09:16 <dark> Marvin: Do you have any logic about more and less specific matches, so that a text/plain handler would override a text/* handler?
05:09:21 <Marvin--> dark: hmm, okay, I'll change the code then
05:09:39 <Marvin--> dark: no, the content handlers are called in order of declaration, the Core plugin is called last
05:09:48 * Marvin-- adds that too
05:12:13 <dark> Maybe you could solve it by merging the access and auth phases, and have dedicated auth plugins just use the access phase.  Then there's nothing to document :)
05:12:29 <Heffalump> there are separate phases? I don't understand that.
05:12:39 <Heffalump> I assumed the distinction was that access was a phase and auth a plugin.
05:12:43 <Marvin--> no
05:12:48 <Marvin--> access is one phase, and auth is another
05:12:49 <Heffalump> ah.
05:13:11 <Marvin--> dark: afaik, apache has only one module that uses the access phase and several that use the auth phase
05:13:26 <dark> Marvin: Oh then I understood it the wrong way around.
05:13:37 <Marvin--> mod_access implements the "allow,deny" thingy
05:14:09 <dark> Sounds like a wart to me :)
05:14:12 <Heffalump> <aol>
05:14:30 <dark> But... maybe it's to give that module the first shot at request-transformations?  The access phase is still allowed to transform requests, right?
05:14:44 <Marvin--> but there are several auth modules... mod_auth, mod_auth_pam, mod_auth_db...
05:15:07 <Marvin--> all phases are allowed to, but I don't know if they actually do
05:16:09 <Marvin--> I think it's this way: access control is based on the URI, whereas authorization is based on user identity
05:16:48 <Heffalump> but surely the two need to be combined?
05:18:57 <Marvin--> no, access modules use Forbidden and auth modules (should, afaik) use Auth Required
05:19:33 <Marvin--> 401 Unauthorized
05:19:55 <Marvin--> Forbidden means that nobody can access this URI, Unauthorized means *you* can't ;)
05:20:34 <Marvin--> but this feels like http details, not something I want to spend too much time on in the report
05:21:55 <Marvin--> dammit, it rains even more now than during the morning :/
05:22:19 <Marvin--> y'all went very quiet
05:22:23 <dark> In a few months, you will look back longingly to the days when the rain wasn't frozen :)
05:22:42 <dark> Oh I'm still pondering my algorithm :)
05:23:15 <Marvin--> I dunno, snow is better than rain
05:23:21 <Marvin--> at least if it stays put and doesn't melt
05:23:27 <dark> I want to do an arbitrary renaming on directory trees, with a minimum of shuffling things off to a temporary directory.
05:23:28 <Marvin--> which, alas, it has a tendency to do in Göteborg
05:23:38 <dark> This is what I needed concatWhileProductive for :)
05:23:51 <dark> I have it solved for the files now, but directories are a more general case.
05:24:37 <Marvin--> any ideas on how I should rewrite the sentence on "Calling all plugins for access..."?
05:25:26 <dark> Hmm, the description of access and auth you gave just now doesn't match up to the phase descriptions.
05:26:32 <Marvin--> true
05:27:18 <Marvin--> how about "globally determining whether a resource can be accessed or not" phase 2?
05:27:48 <Marvin--> s/ a / the /
05:27:50 <dark> So I guess the distinction here is that only one module needs to approve auth, but access needs to be approved by all modules?
05:28:19 <Marvin--> and authorization is "determining whether a certain user can access the resource"
05:28:35 <Marvin--> sort-of yes
05:28:40 <dark> Yeah those sound good.
05:29:10 <dark> Maybe add "based on credentials provided" to auth
05:29:28 <Marvin--> ok
05:30:04 <dark> hmm, so it's that authorization can be gained in a number of different ways, and a user only needs to provide one of them.
05:30:23 <Marvin--> well, that depends on how you configure the plugins
05:32:07 <Marvin--> in a certain directory you may have e.g. an .htaccess that specifies which auth mechanism is required
05:32:11 <Marvin--> (I think :))
05:32:24 <dark> I still think the phases should be merged :)  Client IP is just one more piece of information about the user.
05:32:47 <Marvin--> well, I retract the part about the client IP
05:32:55 <Marvin--> thus "globally"
05:34:01 <dark> Okay, so the access phase checks that none of the plugins veto the request.  And the auth phase checks that at least one of them approves of it.
05:34:13 <Marvin--> yeah
05:34:26 <dark> Hmm, but the Core always approves, right?
05:34:28 <Marvin--> doesn't help that the apache docs says "Needs Documentation. Code is;" ;)
05:34:31 <Marvin--> yes
05:34:45 <Marvin--> well, auth plugins can still veto
05:34:50 <Marvin--> by returning an error code
05:34:56 <dark> Yeah but that sort of removes the distinction :-)
05:35:19 <raphael_> weeeee ... i somehow cirumvented the forall a b. (a -> b) -> a -> b thingy when using runST.  I'm not using $ (that's impossible), but somehow my program works!
05:35:22 <Marvin--> but it's a different kind of access control
05:35:23 <dark> I guess it could simply be that auth checks are a lot of work, so an initial scan for vetos is useful.
05:36:02 <Marvin--> the auth phase is based on the popup-dialog-asking-for-username-and-password
05:36:02 <raphael_> eventhough i do some pretty weird stuff
05:36:14 <dark> Marvin: Isn't that just one implementation of it?
05:36:28 <dark> I mean, that sounds like Basic auth, even HTTP itself provides for others :)
05:36:50 <Marvin--> dark: 401 Unauthorized is the server's way to tell a browser to send a username+password, afaik
05:37:07 <dark> And I remember that .htaccess files can refer to user identity in their rules.
05:37:08 <Marvin--> if the username+password isn't approved, 403 Forbidden is sent back
05:37:55 <Marvin--> anyway, the purpouse of the exercise is not to redesign the security phase of apache :/
05:38:04 <dark> Marvin: IIRC it's Forbidden if the password is wrong, but another Unauthorized if the username is unknown.
05:38:11 <dark> Heh :)
05:38:18 <Marvin--> yeah
05:40:13 * Marvin-- leaves the sentence alone for now
05:40:29 <Marvin--> remind me to grep for FIXME before printing this ;)
05:40:59 <Marvin--> raphael_: you know we're supposed to hand in a printed version of the report too, right?
05:41:38 <Marvin--> dark: hmm, did you find anything else than 2.2 and the access/auth confusion?
05:41:51 <Marvin--> and the mime stuff
05:47:22 <Marvin--> bah, he went missing again :)
05:47:48 <raphael_> Marvin--: yeah, why?
05:49:15 <raphael_> my code looks sort of weird now. To use a heap you say "withHeap (do insert 3; insert 6; c <- top; blah blah)
05:49:28 <raphael_> so your sort of "inside" the heap
05:49:52 <Marvin--> raphael_: I'm just wondering when you'll go to MC to hand it in
05:51:09 <raphael_> Marvin--: guess tomorrow at 07:59 ;)
05:52:01 <Marvin--> raphael_: okay, I'm going pretty soon, gonna make sure the code works there and all that, print the report on paper and see how it looks, et.c.
05:53:31 <raphael_> i just have to switch implementation from my simple priority queues to my new leet heap and then document the changes.  But that'll take me all of today, I think
05:56:13 <Marvin--> right
05:56:18 <Marvin--> so no coffee breaks with you then :)
05:56:27 <raphael_> sorry
05:57:39 * Marvin-- prods dark with an electric cattle prod
06:01:30 <dark> Marvin: I was doing morning rituals :)
06:01:42 <raphael_> recommandatoin: never prepar to supervise a course on an object oriented language while doing apocejt inhaskell
06:01:52 <raphael_> a project
06:02:32 <dark> Marvin: I thought about the access/auth thing in the shower.  I'm fairly sure that apache access processing does use the user info.  What I think happens is that access checks if the user is allowed to access the resource, but it takes the credentials on faith.  The auth phase is not authorization but authENtication, and it verifies those credentials.
06:03:06 <Marvin--> dark: hmm
06:03:23 <Marvin--> dark: you may be right
06:03:31 <Marvin--> fuck, search and replace on authorization it is
06:04:51 <raphael_> Marvin--: do I sense some angst here? ;)
06:05:44 <Marvin--> raphael_: I have to motivate something I don't understand myself, of course there's angst involved
06:05:57 <dark> Marvin: I vote for "because apache does it that way" :)
06:06:48 <Marvin--> dark: actually, I'm going to change authorization to authentication and gloss over the difference between access and authorization, and if someone asks about it, I'll mumble a bit and claim that it's not important for the rest of the project *cough*
06:07:01 <Marvin--> err, between access and authentication
06:07:15 <Marvin--> I may have been thinking authentication while writing authorization actually
06:08:00 <dark> *grin*
06:09:16 <Marvin--> heck, the examination on this is a twenty-minute sit-down with Koen and/or Jan-Willem, it's not as if we have time to talk about this in detail
06:10:33 <dark> I think it's like this: access is called in all plugins, so that each plugin can have its own access rules for resources it makes available.  For example, a request that's ok with a simple url check might not be ok with the database interface.
06:10:55 <dark> On the other hand, authentication stops at the first OK, because the user either is or is not who he/she claims to be, and that doesn't depend on the resource being accessed.
06:11:26 <dark> So the key here is that the concept of "user" is global.
06:12:28 <Marvin--> I'll keep that in mind if pressed on the issue ;)
06:12:29 <dark> I think this would imply that the Core should _reject_ the auth phase, unless no user identity is being claimed.
06:13:40 <Marvin--> well, the thing is, user identity will only be presented if an auth plugin sends back an Unauthorized error code
06:14:03 <Marvin--> and I think that inherently means "I'll take care of the reply to this"
06:14:03 <dark> Hmm, but this is awkward if parsing out the username is auth-specific :)
06:14:51 <Marvin--> so if we get to the core it means that no authentication is *needed* and it should therefore be approved
06:14:54 <dark> Marvin: I think sending Unauthorized is primarily the task of the access phase, if it finds an access rule that requires a particular user identity.
06:15:18 <dark> Marvin: The auth plugin would only error if the password is wrong or something.
06:15:59 <dark> Hmm, I guess auth plugins could "fill in" the username they parse out of the headers.
06:16:16 <Marvin--> no, the access plugin sends Forbidden
06:16:27 <dark> Which would mean that the access plugin only _sees_ a username if an auth plugin provided one.
06:16:29 <dark> Marvin: In apache?
06:16:34 <Marvin--> yes
06:16:44 <dark> Marvin: did you try this with a .htaccess that allows access only to certain users?
06:17:27 <Marvin--> I use mod-auth-pam on my apache server
06:17:38 <Marvin--> and .htaccess files that 'require user martin'
06:20:03 <dark> Hmm, interesting.  mod-access and mod-auth seem to share the htaccess info somehow.  I thought one of them was in charge of parsing it.
06:21:01 <Marvin--> .htaccess apply to all phases :)
06:21:12 <Marvin--> it's just a way of locally extending the configuration
06:21:33 <dark> I remember that htaccess parsing could be turned on or off, I thought that was a module too :)
06:22:09 <Marvin--> I don't know which module handles the Options directive
06:22:31 <Marvin--> or rather, AllowOverride
06:23:23 <Marvin--> it's probably handled by the core
06:23:45 <Marvin--> yup
06:24:26 <Marvin--> well, I should get my ass moving towards a) the shower, b) the supermarket, c) the university
06:24:27 <dark> It looks like mod_auth and mod_auth_db actually have different taksks.
06:25:04 <dark> Even though they use the same phases :)
06:25:48 <Marvin--> their problem, not mine! ;) I still have sections to write!
06:25:55 * Marvin-- waves and disappears
06:39:54 <Pinkeleph> Ah
06:39:55 <Pinkeleph> Wow
06:39:59 <Pinkeleph> A real Haskell channel
06:40:31 <dark> Pinkeleph: The spiffiest.
06:41:32 <Marvin--> opposed to what? unreal haskell channels?
06:41:53 <dark> "virtual Haskell"
06:42:04 <Pinkeleph> As opposed to Haskell channels with two users in them....
06:42:08 <dark> Where programmers pretend to program, and compilers pretend to compile!
06:42:37 <Marvin--> Pinkeleph: don't tell anyone, but it's just me an dark, the rest are bots</conspiratorical whisper>
06:42:50 <Pinkeleph> gasp
06:43:18 <dark> We keep fighting over who gets to control Heffalump, though.
06:43:34 <Pinkeleph> hmm
06:43:35 <Pinkeleph> Alright
06:43:48 <Pinkeleph> Time for me to attempt to be productive
06:44:41 <dark> let (toghost, fromghost) = mkghost (head bad) n
06:44:48 <dark> Sometimes it feels like I'm writing a game :)
06:46:11 <Igloo_> :-)   What is it?
06:46:47 <dark> Igloo: It's in a function for resolving arbitrary renaming of files.  This is the loop breaker, it moves a file off into a "ghost" directory temporarily.
06:47:01 <dark> Igloo: I called it "ghost" because the other directory, for directories to be deleted that still contain files, is called "undead" :-)
06:47:07 <dark> Ghosts can still come back.
06:48:30 <dark> *sigh* The next step is resolving arbitrary rearrangement of directory trees.  I hopes I'd be able to generalize this solution but I don't see how.
06:49:07 <Igloo_> Oh, cool
06:49:10 <dark> I could move everything off into temporary directories and then move it back in the right order, but I'm looking for something less wasteful :-)
06:50:22 <Igloo_> Grrr, the reason I can't get useful information out of gdb is because some files have struct foo {...what I want...}  while others have struct foo{int dummy} to apparently appease broken compilers
06:50:34 <Igloo_> And my casts are going to the dummy one
06:50:43 <dark> Appeasing broken compilers is the root of some evil.
06:51:07 <dark> Nethack is disgustingly appeasatory in that regard :)
06:52:51 <Igloo_> Portability is the problem - everyone should just assume everyone else runs Linux 2.4/x86  :-)
06:53:04 <dark> Well, Linux at least :)
06:53:21 <dark> I have a policy of not caring about portability to non-free systems.
06:54:05 <Igloo_> I tend to try to find a standard and stay within it, which amounts to about the same thing  :-)
06:54:14 <dark> And broken compilers should just die and be replaced by gcc.
06:54:30 <dark> Igloo: I've found standards unsatisfactory :)  At least, staying within their limits is.
06:54:49 <Igloo_> Which ones in particular?
06:55:11 <dark> Igloo: Well, Posix specifies very little.  I'd like to assume that I can select() on a socket descriptor, for example.
06:55:40 <Igloo_> Ouch - Does SuS allow you to?
06:55:42 <dark> Igloo: C recently got an upgrade :)  But before C99, the maximum length you could count on for identifiers was 6 characters.
06:55:55 <dark> Igloo: I don't really know.
06:56:25 <dark> Igloo: Which was the one that's available online?
06:56:40 <dark> I tend to believe my manpages when they say what they're compatible with :)
06:56:47 <Igloo_> SuSv2 is online, but you need to tell it your name and e-mail address IIRC
06:56:55 <dark> Ah, I hate that.
06:56:58 <Igloo_> POSIX is more recently available online too
06:57:16 <dark> Anyway, I also have a policy of not caring about non-free standards :)  (Of course I still care about existing practice in such cases)
06:57:57 <dark> But standardization for the sake of standardization is just make-work, and usually is implicitly catering to broken non-free systems (whose vendors tend to have a strong voice in standardization committees)
06:58:05 <dark> Anyway, end of soapbox :-)
06:58:06 <Igloo_> non-free as in need-to-pay-for?
06:58:28 <dark> Igloo: As in can't-include-a-copy-of-in-my-source-code-to-explain-why-it-does-things-this-way
06:58:53 <dark> For example my FTP code tends to come with a copy of RFC 959.
06:59:23 <Igloo_> Right
06:59:27 <dark> okay-to-download-but-not-distribute is something I had enough of with WAP :-)
06:59:32 <dark> If the site goes down, bam, undocumented program.
07:03:09 <dark> I think my biggest concern is that requiring compatibility with a non-free standard creates a barrier to contribution from other programmers.  That makes the program less free.  And freeness is why I'm writing it in the first place :-)
07:07:28 <BlizzNL> Why do I get a "IO Error: User error" "Reason: Prelude.readIO: noparese" when I simply read a string from console?
07:08:15 <dark> Getting a UserError from Prelude.readIO seems strange in itself.
07:09:03 <BlizzNL> dark: strange
07:09:24 <dark> Might be a re-thrown error with the original error as a string in the UserError.  But that would be a strange way to do it.
07:11:56 <dark> Oh wait, maybe "error str" throws a UserError.  I tend not to use it, but the Prelude might.
07:15:30 <BlizzNL> dark: ReadLn throws it for some reason, I use getLine now which works fine
07:18:05 <dark> BlizzNL: readLn tries to convert its line into the return type you expect.
07:18:22 <dark> BlizzNL: If that's a string, it probably expects "foo" with quotes and all.
07:22:01 --- topic: 'mo' nads than you || We put the Funk in Funktion || See logs @ http://tunes.org/~nef/logs/haskell/ || Gtk+HS  0.14.10 released http://www.cse.unsw.edu.au/~chak/haskell/gtk/ || ICFP is over <Erwin> Your mother asked you to write COM program? Who are you, Dilbert? || Ganesh's HaskPerl challenge: make Haskell look like line noise too!'
07:22:01 --- topic: set by Heffalump on [Wed Oct 23 04:33:47 2002]
07:22:01 --- names: list (clog BlizzNL Pinkeleph[a] galority Ig o3 dblack raphael_ ChoJin dark norpan dennisb liiwi andersca Heffalump ibid skylan mmc shreya jewel ludde Chilli ChilliX smklsmkl Logan Igloo_ tetryl)
07:22:47 --- topic: 'mo' nads than you || We put the Funk in Funktion || See logs @ http://tunes.org/~nef/logs/haskell/ || Gtk+HS  0.14.10 released http://www.cse.unsw.edu.au/~chak/haskell/gtk/ || ICFP is over <Erwin> Your mother asked you to write COM program? Who are you, Dilbert? || Ganesh's HaskPerl challenge: make Haskell look like line noise too!'
07:22:47 --- topic: set by Heffalump on [Wed Oct 23 04:33:47 2002]
07:22:47 --- names: list (clog BlizzNL Pinkeleph[a] galority Ig o3 dblack raphael_ ChoJin dark norpan dennisb liiwi andersca Heffalump ibid skylan mmc shreya jewel ludde Chilli ChilliX smklsmkl Logan Igloo_ tetryl)
08:56:54 * Igloo_ finally gets Haskell code to decompress something
09:53:39 <dark> I found out why I can't generalize my solution to the renaming problem.  It's because it doesn't work :-)
09:54:23 <Igloo_> Heh
09:54:52 <dark> Or rather, it's not a true sub-problem.  It works if I rename only files.  But if I also have to rename directories, I can't just ignore them -- directory names and filenames might collide.
09:55:46 <dark> I think I'm on the trail of a true solution now, though :)
09:57:37 <Igloo_> *nod*
10:17:39 <BlizzNL> If I want to let the user select which function I have to execute, where the function name comes from the console as a string is it possible to define a function like execFunction :: String -> (some result which depends on given functoin) ?
10:22:11 <Igloo_> If you know the set of possibilities at compile time then yes
10:22:38 <Heffalump> or you have a plugin architecture :-)
10:22:56 <BlizzNL> Igloo_: you by patternmatching the string?
10:23:10 <BlizzNL> Heffalump: don't push it Heffalump ;)
10:23:13 <Igloo_> Well, using lookup or lookupFM
10:23:48 <Heffalump> patternmatching would be better actually
10:24:57 <Heffalump> it should get compiled to something quite efficient
10:25:10 <BlizzNL> Heffalump: ok thnx
10:25:16 <Igloo_> Oh, I guess if it's complete strings lookup isn't any easier to write. But lookupFM would be more efficient, and lookup as efficient as pattern matching (asymptotically speaking)
10:26:19 <Heffalump> errm, the pattern matching should get compiled to consider each element one at a time, surely?
10:26:27 <Heffalump> i.e. foo "banana" =...
10:26:30 <Heffalump> foo "baz" = ...
10:26:34 <Heffalump> foo "splat" = ...
10:27:08 <Heffalump> it should get compiled to an automaton that looks at each character only once
10:28:17 <Heffalump> I guess there's no guarantee of that, but I'd imagine a sensible implementation would.
10:31:02 <Igloo_> Oh, I guess that's possible
11:45:42 * Igloo_ tries to think of an efficient, simple way of handling things like "The 5 characters starting 10 characters ago" in a functino that produces a list of bytes
11:46:02 <Heffalump> efficient in what sense?
11:46:10 <Heffalump> small?
11:47:50 <Igloo_> Well, an obvious way to do it is to pass the result and position as an argument to the function and use take 5 (drop (pos - 10) res), but that would be hideously inefficient
11:48:35 <Igloo_> Oh, the functino is recursing through input, not a single instance of the functino generating the list
11:51:52 <Igloo_> And the memory usage will be linear even though a 32k window is known to be sufficient
11:54:10 <Heffalump> sorry?
11:54:23 <Heffalump> oh, you just want a fast implementation of the decompression function
11:54:57 <Igloo_> Not necessarily fast, but preferably not mindblowingly slow and space using  :-)
12:03:02 <Heffalump> hmm
12:03:13 <Heffalump> how would you indicate that the 32K window was all that was needed
12:51:33 <Igloo_> Well, you could do it explicitly by passing a 32k list around, but then you either need ++ [x] or init, both of which are rather inefficient
12:51:46 * Igloo_ will probably go for the simple code but really inefficient method above
12:58:44 <BlizzNL> I have a, I guess, very basic question, but since I am having problems with it I'll just ask. In my main function (main :: IO()) I do some basic things like reading from stin and performing some actions on a small database-like thing, but now I need to repeat this main and not exit until some condition is true.. (e.g. last keyboard input == "quit") Can someone give me some pointer, cause I keep getting irritating last line in do must be an expressi
12:59:36 <Heffalump> how about if foo then main else return ()
12:59:42 <Heffalump> for the last line
13:00:41 <BlizzNL> that's exactly what I did but I had the layout incorrect. Thnx Heffalump
15:09:57 <Marvin--> phew, got it down to nine pages in the end
15:10:08 <Pseudonym> What are you working on?
15:10:46 <Marvin--> a report on a project in an advanced course on functional programming
15:11:20 <Pseudonym> What's your project?
15:14:56 <Marvin--> extending Simon Marlow's web server with dynamic loading of plugins
15:15:18 <Marvin--> well, I'd better go home now
15:15:32 <Pseudonym> Bye. :-)
15:43:27 <Marvin--> well, now I'm home
15:43:59 <Pseudonym> That was quick.
15:44:07 <Marvin--> bike :)
15:44:12 <Pseudonym> :-)
15:44:17 <Marvin--> five minutes downhill ;)
15:44:20 * Pseudonym lives 50 minutes away by train
15:44:26 <dark> downhill from Chalmers?
15:44:35 <Marvin--> yup
15:44:45 <Marvin--> Chalmers is pretty high up
15:44:46 * andersca lives three minutes uphill
15:45:01 <dark> I remember hiking up that hill.  It was good for my endurance :)  And it was worth it, there was internet at the top.
15:45:01 <Marvin--> hahaha
15:46:32 * Pseudonym laughs
15:46:48 <Pseudonym> Must... jack... in... *puff puff*
15:51:18 <Heffalump> lol
16:12:45 <h3lpm3> hey all
16:12:52 <Heffalump> hi
16:13:20 * Marvin-- sips a celebratory cognac since the report is finished :-)
16:13:57 <Pseudonym> G'day.
16:18:57 <Marvin--> good thing shapr isn't here or he'd bug me for a tarball of hws-wp
16:19:09 * Marvin-- is a bit sick of it after working on it constantly for a week ;)
16:19:40 <Pseudonym> How did you handle dynamic loading, as a matter of interest?
16:19:53 <Pseudonym> Not that you probably want to talk about this.
16:20:04 <o3> Marvin--: well done!
16:20:22 <Marvin--> Pseudonym: well, GHC and GHCi are written in Haskell, and GHCi does dynamic loading
16:20:28 <Marvin--> Pseudonym: I'm using o3's RuntimeLoader module :-)
16:20:37 <Pseudonym> Ah. :-)
16:20:58 <Marvin--> s/written/mostly written/
16:21:45 <Marvin--> Maybe I should mail a URL to Simon Marlow too since I based it on his HWS
16:22:14 * o3 wonders if any evil Dennis Ritchie-ish compiler hacks are in GHC :)
16:22:23 <o3> (can't remember if it was ritchie, but anyway)
16:22:31 <Marvin--> what compiler hacks are that?
16:23:27 <o3> hmm
16:24:25 <o3> ah, here we go
16:24:26 <o3> http://www.acm.org/classics/sep95/
16:24:46 <o3> "You can't trust code that you did not totally create yourself."
16:24:48 <o3> :)
16:24:54 <Heffalump> :-)
16:25:04 <Heffalump> (read it many times before)
16:25:21 <dark> Don't remember to design your own bios, solder it onto a circuit board, and use that to program an FPGA.
16:25:33 <Heffalump> you trust FPGAs?
16:25:41 <o3> i just wonder if the simons have put in equivalently evil work into GHC :)
16:25:43 <dark> Heffalump: Hmm, you have a point.
16:25:55 <Pseudonym> I don't even trust transistors.
16:26:08 <Heffalump> they've got a real advantage with GHC, cos it's the /only/ thing that can sensibly compile itself
16:26:18 <Marvin--> I don't trust myself
16:26:22 <dark> There's _definitely_ something suspicious about transistors.
16:26:26 <Pseudonym> Hand-blown valves only for me.
16:26:49 <Pseudonym> In fact, the IRC client I'm using now is microcoded using diodes and valves only.
16:27:05 * Pseudonym is very fast at keyswitching
16:27:08 <dark> The "official" physics for transistors are obviously a cover-up for something else.
16:27:31 <dark> Pseudonym: Do you have a small army of miniskirted assistants to replace blown valves?
16:27:48 <Pseudonym> dark: No, they're wearing jeans, but at least they're tight.
16:28:05 <Pseudonym> Actually, I never trust any topic on which Britney Spears is an expert.
16:28:20 * o3 wonders how the conversation managed to go from compilers to Britney
16:28:28 <dark> o3: Semiconductors.
16:28:29 <Marvin--> o3: I was wondering that too
16:28:34 <Marvin--> oooh
16:28:43 <Pseudonym> Have you guys seen this?
16:28:44 <Chilli> OSS actually has (arguabley weak) form of protection against Thompson's hack
16:28:45 <Pseudonym> http://britneyspears.ac/lasers.htm
16:28:56 <o3> Pseudonym: is that safe for work?
16:28:56 <dark> This Britney angle definitely shows there's some kind of conspiracy around semiconductors.
16:29:15 <o3> dark: almost quotable
16:29:16 <Heffalump> chilli: only if you're prepared to rebuild a compiler from the ground up yourself
16:29:21 <Pseudonym> o3: If your colleagues have a good sense of humour.
16:29:24 <Pseudonym> It's not rude or anythign.
16:29:32 <dark> Heffalump: And... rebuild it with what? :)
16:29:38 <Chilli> The point is that the trojan would have to be inserted at some point
16:29:42 <Heffalump> in machine code
16:30:05 <dark> Done properly, the hack should be able to survive bootstrapping on a new architecture.  If it inserts itself in an earlier translation phase.
16:30:06 <Marvin--> that page is really mean :)
16:30:21 <Heffalump> chilli: but how big a conspiracy would it require? you (as Redhat packager), the Simons, Michael Weber (Debian), and whoever it is that does SuSE, and that's most of the users covered
16:30:27 <Pseudonym> Chilli: That is a good point.  It's one reason, I think, why there are so few easter eggs in OSS.
16:30:32 <Chilli> to propagate it to everybody, it would have to be included in all binaries of GHC that are used to com[pile other GHCs
16:30:34 <Heffalump> the untrojaned ones would never see the altered code
16:30:57 <Heffalump> so nobody would ever find out - not 100% coverage of the installed base, sure, but still a very low risk of detection
16:31:10 <o3> Pseudonym: some people have tooo much tiiime
16:31:19 <dark> apt-get moo
16:31:53 <Chilli> Heffalump: sure, but a paranoid used like you ;-) could have protected himself by always compiling using his own binaries only
16:31:57 <Chilli> used = user
16:32:04 <Pseudonym> I once had a version of sendmail that had an easter egg, but sendmail isn't the most shining example of security.
16:32:30 <Pseudonym> Heffalump: The secret is to use a different compiler to boostrap.
16:32:42 <Heffalump> chilli: I only started using GHC 2-3 years ago, at a guess
16:32:45 <Chilli> Pseudonym: sendmail is one of the most shiny examples of how a kludge on a kludge on a kludge can still work
16:32:57 <Heffalump> and I didn't bootstrap from hc, so I trusted someone's binaries then (probably yours)
16:32:57 <Pseudonym> For some definition of "work".
16:33:10 <Heffalump> Pseudonym: but GHC won't build with anything else
16:33:19 <Chilli> Heffalump: hahaha - than all your base belong to us *evil laughter*
16:33:49 <Chilli> than = then
16:33:58 <Heffalump> bah :-)
16:34:05 <Chilli> :-)
16:34:10 <Heffalump> I suppose I could rescue myself by bootstrapping from hc now.
16:34:12 <Pseudonym> Heffalump: Yes, true. *sigh*
16:34:24 <Heffalump> but there'd only be a point if I actually read and understood it all...
16:34:33 <Chilli> Heffalump: no, the hc must be generated by GHC
16:34:41 <Pseudonym> GHC needs a lot of refactoring.
16:34:52 <Heffalump> chilli: sure, but I could read it before I gave it to GCC
16:34:57 <Pseudonym> Preferrably with a large hammer.
16:34:58 <Chilli> well, you could review the generated hc files, but that wouldn't be much better than reviewing the machine code
16:35:00 <Heffalump> (assuming I trust GCC here)
16:35:01 <o3> Pseudonym: We should rewrite it from scratch!
16:35:17 <Pseudonym> o3: Uh... yeah!
16:35:19 <o3> yeah, maybe GCC has been backdoored by chilli
16:35:39 <Heffalump> yeah, he's a shifty sort
16:35:43 <Heffalump> wouldn't trust him an inch
16:35:50 <o3> definitely
16:35:55 <Pseudonym> Wouldn't trust him as far as I could /kick him.
16:36:03 <Chilli> o3: no, it's only that hc files are barely more intelligibile than assembly
16:36:22 <o3> it's all a conspiracy involving chilli, gcc, and britney
16:36:31 <Chilli> *pfff*
16:36:39 <Pseudonym> I'll bet Simon P-J is in on it too.
16:36:49 <Pseudonym> Him and his amusingly titled papers.
16:37:14 <Pseudonym> He once gave a talk to the Mercury group and accused us of being "too fixated on performance".
16:37:26 * Pseudonym found that highly amusing
16:37:28 <Chilli> SPJ?
16:37:30 <Heffalump> how longa go?
16:37:36 <Pseudonym> Long time ago.
16:37:41 <Pseudonym> Oh, maybe it was Phil Wadler.
16:37:42 <Heffalump> hehe
16:37:44 <Heffalump> ah
16:37:48 <Heffalump> that I can understand.
16:38:06 <Chilli> yeah, would make more sense
16:38:08 <Pseudonym> It was because we included an optimisation whose only purpose was to fill a delay slot on the SPARC.
16:38:29 <Marvin--> haha
16:38:37 <Pseudonym> Actually, make that a whole compiler pass just to fill one delay slot.
16:38:43 <o3> laugh
16:38:58 <o3> world's first 603-pass compiler
16:39:01 <Pseudonym> :-)
16:39:42 <Pseudonym> It made sense at the time.  Mercury was designed by taking the source code, hand-designing the equivalent of the hc code that we wanted to generate, then deciding what steps were needed.
16:40:28 <Marvin--> Hmm, where is the desugar function in GHC defined?
16:41:51 <Chilli> ghc/compiler/deSugar/Desugar.lhs
16:42:14 <Pseudonym> What a completely unobvious place.
16:42:16 <Marvin--> hmm, so it's not readily available
16:42:47 <Marvin--> I'm curious how a binding with several patterns translate into Core
16:43:04 <Marvin--> that is, assume I have a function taking two arguments, and I decide which binding to use based on patterns on both arguments
16:44:49 <Pseudonym> http://www.cse.unsw.edu.au/~chak/haskell/ghc/comm/the-beast/desugar.html
16:44:59 <Pseudonym> Note in particular, the phrase "pattern matching compiler".
16:46:18 <Pseudonym> If you can dig up a copy of "The Implementation of Functional Programming Languages", it has some old PMC code in it.
16:47:00 <Marvin--> okay
16:47:31 <Marvin--> I think I have it somewhere here
16:49:22 <Chilli> Marvin--: what did you mean by it is not readily available?
16:50:11 <Chilli> that's the current CVS version: http://cvs.haskell.org/cgi-bin/cvsweb.cgi/~checkout~/fptools/ghc/compiler/deSugar/Desugar.lhs?rev=1.57&content-type=text/plain
16:51:39 <Marvin--> Chilli: well, yes, but I meant, in the form of 'import Desugar' :)
16:52:11 <Chilli> it's not available as a library if that's what you mean
16:52:32 <Chilli> but pattern matching compilation is quite straight forward
16:52:56 <Chilli> and the explanation in the above cited book is also quite clear, I think
16:53:49 <Chilli> why do you need a pattern compiler?
16:54:27 <Marvin--> oh I'm just curious
16:54:52 <Pseudonym> That's always to be encouraged.
16:55:09 <Marvin--> hmm, but the Core language in pjlester uses lambda lifting...
16:55:35 <Pseudonym> That doesn't matter.  The pattern matching compiler works the same way.
16:56:11 <Pseudonym> In principle, anyway.  The book doesn't cover quite the whole Haskell pattern syntax, but the rest is fairly straightforward.
16:56:40 <Chilli> but I think we are talking two different books
16:56:45 <Pseudonym> Are we?
16:56:49 <Chilli> pjlester is the tutorial
16:56:54 <Pseudonym> Ah, right.
16:57:03 * Pseudonym has spent more time with the '85 book
16:57:04 <Marvin--> oh
16:57:06 <Chilli> The Impl of Functional Programming Languages is by SPJ alone
16:57:13 <Marvin--> hmm
16:57:15 <Pseudonym> With the odd chapter by other people.
16:57:23 <Chilli> yes
16:57:25 <Marvin--> but is it downloadable or do I have to go buy it?
16:57:35 <Pseudonym> It's not downloadable yet.
16:57:47 <Pseudonym> Chances are very good that Chalmers library has a copy though.
16:58:07 <Pseudonym> It might be covered in the tutorial.  Not sure about that.
17:00:16 <Marvin--> yup, it's at the library
17:00:24 * Marvin-- makes a mental note to visit the library tomorrow
17:00:37 <Pseudonym> It's a really, really good book.
17:00:52 <Pseudonym> I never really understood Miranda (as I was using at the time) until I read that.
17:01:25 <Pseudonym> Yeah, it looks like tutorial doesn't cover pattern matching.
17:01:34 <Pseudonym> Or list comprehensions, even.
17:02:07 <Marvin--> the tutorial only handles case expressions for pattern matching
17:02:24 <Marvin--> which is at the *end* of the transition :-)
17:03:43 * Chilli -> meeting
17:04:09 <Pseudonym> Bye.
17:04:34 <Pseudonym> I dunno if I told you guys this, but here where I w*rk, the product used to be called Sim.
17:04:52 <Pseudonym> Our meetings are therefore referred to as "Sim Meetings", which sounds like the least popular Maxis game to me.
17:05:46 <Marvin--> heh
17:12:57 <Marvin--> is the 'as' pattern, the foo@(...) pattern?
17:13:08 <Pseudonym> Yes.
17:14:05 <Marvin--> interesting, so it's limited to varname@pattern? you can't do pattern1@pattern2?
17:14:58 <Pseudonym> No.  Why would you?
17:15:17 <Pseudonym> I guess if you had views it might make sense.
17:15:48 <Marvin--> I don't have any motivation except BWC :)
17:15:54 <Pseudonym> BWC?
17:15:58 <Marvin--> Because We Can
17:16:01 <Pseudonym> Ah. :-)
17:16:09 <Pseudonym> The thing is, []@(x:xs) would always fail.
17:16:15 <Marvin--> yeah
17:16:42 <Marvin--> you could do stuff like [_,_,_]@(x:xs) though, whyever you would want to do that
17:16:54 <Pseudonym> Right, when you could do this instead:
17:17:00 <Marvin--> (x:xs@[_,_])
17:17:06 <Pseudonym> Exactly.
17:17:25 <Pseudonym> In fact, lists are the only situation where this makes any sense.
17:17:34 <Pseudonym> Because there are two different syntaxes for pattern matching.
17:17:54 <Marvin--> yeah
17:18:40 <Heffalump> but if that's not legal x:(xs@[_]) would be equivalent
17:18:43 <dark> Actually, records also have two different syntaxes for pattern matching.
17:18:57 <Pseudonym> dark: That's true.
17:19:49 <Marvin--> hmm, yeah
17:20:23 <Heffalump> what's the production?
17:20:27 <Heffalump> pattern -> varname@pattern
17:20:27 <Heffalump> ?
17:20:57 <Pseudonym> Something like that.  There's some operator precedence issues.
17:21:19 <Heffalump> ahah, yes
17:21:41 <Heffalump> oh, that doesn't help, only one actual pattern allowed
17:21:42 <Heffalump> duh
17:21:55 <Heffalump> I was thinking it would mean you could do multiple patterns with just one variable
17:22:33 <Marvin--> well, I should go to bed
17:28:28 <Pseudonym> Does anyone know if there are any good partial evaluators out there?
17:33:32 <Pseudonym> Preferrably one that handles quantified types...
17:54:21 <dark> Hmm, I have a list of strings, and I need to find all strings that are not prefixes of other strings.
17:54:27 <dark> Presumably this is a Known Problem.
17:54:54 <dark> (Actually I need both the "are" and "are not" sets)
17:56:05 <dark> Oh, duh... sort and scan.
18:13:09 <dark> It's actually starting to make sense.
18:34:12 <Pseudonym> Yes. :-)
18:54:01 <dark> Ha!  It's always nice to reduce a function to one line.
18:54:13 <dark> I have harnessed the power of zipWith :-)
18:57:39 <Pseudonym> Now rewrite GHC in only one line using zipWith.
19:02:26 <dark> ghc = (popen "gcc" . concat . zipWith compile_line [1 ..] . lines) module
19:03:00 <dark> compile_line is left as an exercise for the reader.
19:36:14 <dark> Bah, I always do this.  First write code.  Then prove algorithm.  Or more to the point, disprove algorithm.  Panic.  Repeat.
19:36:32 <dark> It always looks so easy when I start :)
19:37:28 <Pseudonym> :-)
19:38:40 <dark> One thing I like about Haskell is how easy it is to restructure code, though :)
