00:54:46 <BlizzNL> I am reading a some lecture notes by Ralf Hinze and he states that 'The type List is obtained from String by extracting over Char' I don't understand it, can anyone explain this?
00:55:30 <ibid> i think i know what he wants to say but i've never heard it be said like that
00:55:38 <Heffalump> me neither :-)
00:55:53 <Heffalump> I think the point is that a String is a list of Chars
00:56:05 <Heffalump> so you can generalise String to List a by turning Char into a
00:56:24 <ibid> i think what he wants to say is that List is a generalization of String, where Char is generalized to any type
00:56:36 <ibid> are the lecture  notes in english?
00:57:19 <BlizzNL> ibid: yes, but he is German. You doubt his English or mine ;)
00:57:57 <ibid> i just wondered whether that was a direct translation from something that makes sense in some other language
00:58:20 <BlizzNL> Ah wait I think i get it: (data String = Nil | Cons Char Sting) so (data List a = Nil | Cons a (List a) is in his opinion an abstracion over Char
01:00:07 <Heffalump> yeah
01:24:17 <Chilli> ibid: the same sentence in German wouldn't make more sense either
01:25:03 <Chilli> (The words for extract and abstract are essentially the same in German and English; same Latin root.)
01:25:40 <ibid> i was more thinking of extra meanings that don't exist in english
01:25:55 <Chilli> not in this case
01:26:00 <ibid> right
01:26:19 <Chilli> probably a typo and was meant to say "abstract" rather than "extract"
03:58:34 * shapr bounces
04:04:07 <shapr> hi Erwin
04:04:11 <shapr> how's life treating you?
04:04:47 <liiwi> it's shapr
04:04:53 <shapr> hi liiwi
04:04:56 <shapr> wassup?
04:05:09 <Erwin> Oh, I guess I'm all right, 1 week till I start working again
04:05:11 <liiwi> hoping it would cool down so the snow would stick
04:05:26 <liiwi> Erwin: you're broken down? :P
04:05:44 <shapr> snow will probably stick here
04:12:47 * shapr plays with Haskore
04:12:55 <shapr> man this is nifty
04:38:49 * shapr plays with the funky beat
04:48:34 <BlizzNL> Yesterday I asked how to enable kind information with Hugs. Well I figured it out. You should use "Prelude>:s +k" and now kind information is provided when :info is used on a given type constructor . ex. ">:i []" will state that it has kind *->* !
04:50:44 <Heffalump> oh, cool
04:51:22 <BlizzNL> maybe not everybody is as enthusiastic about this as I am, but I posted it just in case ;)
04:57:11 <shapr> hi ustenzel
05:01:01 <ustenzel> hi
05:04:08 * BlizzNL wonders if anyone knows how to change compatibility mode to -98 using WinHugs. Because restarting doesn't seem possible..
05:11:47 <BlizzNL>  for people who want to know the answer is; you need to edit a key in the registry (bah!)
05:12:39 <cleverdra> or supply an argument, or edit the shortcut to supply the argument.
05:34:14 * shapr boings
05:34:46 <Igloo_> Hey shapr, what's new?
05:35:09 <shapr> playing with Haskore
05:35:22 <shapr> what's up with yoU?
05:36:11 <Igloo_> Not much - about to start converting a report to talk slides
05:39:00 <shapr> I sent my HWS patch to SimonMar with no response...
05:39:19 <shapr> I could throw the server into cvs on haskell-libs
05:39:25 * shapr thinks
05:42:54 <Igloo_> Have you got commit access?
05:43:16 * Igloo_ would give him a working day at least to respond if you haven't already, anyway
05:43:38 <shapr> it's been a few days, yah
05:44:26 <shapr> I'll just whack in a plugin API first
05:52:33 <shapr> hi flax
05:52:48 <shapr> you have haskell questions?
05:54:36 <flax07> no - i ended up here accidentally and thought i would check out what it was...
05:54:38 * shapr tries to come up with a decent plugin api for HWS
05:55:04 <shapr> Haskell is a purely functional programming language with lots of spiffy features. you can find lots info at http://www.haskell.org/
05:55:09 <shapr> or you can ask questions here...
05:55:12 <shapr> or both
05:55:57 <shapr> purely functional (if you don't know about it) means that a function call can be replaced by its result.
05:56:14 <shapr> Haskell works a lot more like an equation than procedural languages such as C
05:56:39 * shapr could go on at great length
05:57:21 <shapr> would you like to hear more?
05:57:36 <flax07> im looking at the website now - but do go on...
05:57:58 <shapr> Haskell has first class functions... that means that a function is a value just like a number
05:58:09 <shapr> functions can be input to other functions, and output from functions.
05:58:23 <shapr> the most common use of that feature is "map"
05:58:35 <shapr> map takes two arguments, a function, and a sequence
05:58:53 <shapr> it runs that function on each item in the sequence, and returns a new sequence with the results in the same order.
05:59:08 <shapr> for example:
05:59:16 <shapr> > map (+ 1) [1,2,3,4]
05:59:17 <shapr> [2,3,4,5]
06:00:18 <shapr> another nifty feature of Haskell is that it's lazily evaluated, meaning, something happens only when the program requires it.
06:00:35 <shapr> that means you can work with infinite data structures, and only use the pieces that you need.
06:01:25 <shapr> here's an example:
06:01:33 <shapr> > [1..9]
06:01:34 <shapr> [1,2,3,4,5,6,7,8,9]
06:01:39 <shapr> that's how you make a range in haskell
06:01:51 <shapr> I won't print [1..] for you, but you can probably guess it's infinite.
06:01:54 <shapr> :-)
06:01:57 * dennisb is convinced!
06:02:09 <shapr> :-) hi dennisb!
06:02:14 <shapr> > take 5 [1..]
06:02:15 <shapr> [1,2,3,4,5]
06:02:24 <shapr> that gets the first five numbers from an infinite range
06:02:49 <shapr> happily, I don't have to have an infinite sequence in memory to get those first five numbers.
06:02:55 <dennisb> I could say it shorter: haskell is the sexiest language today
06:03:01 <shapr> yah, I agree :-)
06:03:12 <shapr> so flax07, you wanna hear more?
06:03:48 <dennisb> I think you knocked him down...
06:04:03 <dennisb> (or her)
06:04:49 <shapr> yah, maybe so
06:05:17 <dennisb> well, I agree with all you said
06:05:39 <shapr> anyone here has used Simon Marlow's Haskell Web Server? I'm trying to come up with a decent plugin API for it, and would like to discuss with someone
06:05:44 <dennisb> on the other hand, haskell is just another language. I simply use it to get things done
06:06:06 <dennisb> shapr: sorry, I havn't even seen it
06:06:14 <shapr> the downside of Haskell is that it's not like C at all, so it's almost like learning programming all over again.
06:06:25 <dennisb> yes, that too
06:06:41 <shapr> it really is sexy though
06:06:59 <ustenzel> and forgetting about C can't be all that bad either
06:07:08 <tez> shapr: Alternatively, "The downside of C is the it's not like haskell at all.  It's like learning programming all over again" :-)
06:07:10 <cleverdra> the upside of Haskell is that it's not like C at all... =)
06:07:14 <tez> lol
06:07:27 <shapr> yah, it's an upside as much as it is a downside
06:07:37 <shapr> but most people don't seem to learn new stuff
06:07:47 <shapr> unless their job requires them to
06:08:17 <dennisb> most people don't have time to do that
06:08:55 <shapr> seems to me that it would just make sense...
06:09:04 <dennisb> funny headline on slashdot now: New RedHat Kernel Patch Illegal to Explain to U.S. Users
06:09:08 <shapr> especially for programmers
06:09:20 <dennisb> it's a bad time when we can't even talk about programs :-)
06:09:39 <shapr> yah, copyright law has gone off the edge of sanity
06:09:41 <dennisb> I just read the headline, so I know nothing about it..
06:09:48 <shapr> it's all about making money for the media companies now
06:10:18 <cleverdra> I spent all of last night engaged in futile cryptanalysis work.  The following functions helped: stats (character-frequency statistics) digraphs (likewise for letter-pairs) trigraphs (likewise for letter-triplets) doubles (likewise for double-letters) finals (likewise for end-word letters) firsts (likewise for first-word letters) ... sigh.  At least writing these functions was fun.
06:10:28 <dennisb> all true, but still. It's strange that there are things you are not allowed to talk about
06:11:15 <shapr> cleverdra: what are you trying to decrypt?
06:11:30 <shapr> is it a substitution cypher?
06:11:45 <cleverdra> shapr - simple substitution-cipher problems, meant as an exercise.
06:12:13 <shapr> dennisb: they came up with that law to shutdown cracker websites that distribute info on vulnerabilities
06:12:19 <shapr> which is the wrong solution entirely
06:12:44 <cleverdra> shapr - are you serious?  That's *insane*.
06:12:47 <shapr> in any case, it's now illegal to distribute security vulnerability info in the US
06:12:48 <dennisb> I've also written (haskell)functions to decipher simple cryptos for a course I took, it was great fun. 
06:13:19 <shapr> it's also illegal to own tools that can be used to break computer security or copyright protection.
06:13:31 <cleverdra> shapr - ... OK.  That is insane: nobody in their right mind can possibly abide by that law, so it'll go away.
06:13:54 <shapr> recently, Sony came up with music CDs that can't be read in a cdrom drive
06:13:55 <cleverdra> shapr - like Haskell?  Like a computer?  Like fingers and a pencil?  /me stops.
06:14:05 <shapr> the data track is an infinite loop or something
06:14:25 <shapr> so some guy figured out that you can use a felt tip pen to mark over that track and then you can read it.
06:14:37 <shapr> which meant that felt tip pens were then illegal in the US
06:14:45 <shapr> post-it notes also work btw
06:15:23 <dennisb> well, I guess as long it can be used for other things it's allowed, so you just have to make sure that every program you write can also make coffee
06:15:30 * shapr laughs
06:15:42 <dennisb> (like emacs can)
06:15:45 <shapr> right
06:15:48 <shapr> I'm using ERC 2.93 $Revision: 1.300 $ with XEmacs 21.4 (patch 8) "Honest Recruiter" XEmacs Lucid!
06:15:52 <shapr> yay emacs!
06:16:11 <cleverdra> dennisb - I don't have any hardware for that =)  I'll make virtual coffee.
06:16:40 <dennisb> well, i'm sure it's just a question of time until the coffee machines have ethernet ports
06:16:51 <shapr> or at least 802.11b or bluetooth
06:16:57 <shapr> or some flavor of 802.11
06:17:08 <shapr> a,b, or g
06:18:10 <dennisb> So, I managed to turn this channel into non-haskell again. I'll crawl back to my rock now. See you all later!
06:18:35 * shapr is looking at Main.hs for Haskell Web Server, thinking of a good plugin API
06:18:41 <cleverdra> dennisb - what kind of functions did you write?
06:19:00 <dennisb> cleverdra: same as you I guess. Lot's of functions to analyse text
06:19:49 <shapr> the Apache plugin API has lots of steps, URI -> Filename, Auth ID, Auth Access, determine MIME type, other, build response, and log request.
06:19:50 <dennisb> making statistics for english text, using it to decypher things, basic crypto stuff
06:20:47 <shapr> HWS has those pieces spread around a bit...
06:21:13 <shapr> in Apache, if a plugin handles one phase of a request, none of the others need to...
06:21:28 <shapr> I guess I could do that with something like a Success by Failure monad, right?
06:22:36 <shapr> I could have a list of plugins that can handle a phase, and then map (>>=) pluginList
06:23:50 <shapr> and the same with a list of phases...
06:23:59 <shapr> map (>>=) phaseList
06:24:22 * shapr wonders if that will work
06:25:32 <shapr> is that a normal idiom in Haskell?
06:26:15 <shapr> is there a way to invert >>= to keep calling only in case of failure?
06:26:42 <dennisb> sounds like a version of the error monad
06:26:55 <dennisb> or maybe monad, or whatever
06:28:09 <shapr> Parsec has the <|> backtrack op, which means try until one succeeds.. I want that except with >>=
06:28:12 <cleverdra> shapr - 'keep calling'?  You want to break out of the 'map' if something returns Failure ?
06:28:37 <shapr> I think that would be the normal behaviour of >>=
06:28:44 <shapr> but I actually want it the other way around.
06:30:10 <cleverdra> erm, I don't understand what >>= has to do with success or failure.  Isn't 'do a; b' the same as 'a >> b', as 'do a <- b; c' is the same as 'b >>= \a -> c' ?
06:30:50 <shapr> good point
06:30:52 <shapr> you're right
06:31:11 <shapr> the >>= only needs to happen between phases
06:32:41 * cleverdra 's sense of unreality grows as he reads http://www.thefreeworld.net/faq.php
06:37:42 <shapr> whoa wait a sec... it says *citizens* of the USA
06:39:01 <cleverdra> So you can't view it even if you're not resident in US territory.  Does this not follow the law?
06:39:02 <shapr> I hope that's not true.
06:39:06 <shapr> I don't know...
06:39:22 <cleverdra> regarding DMCA, it might as well be maximally evil.
06:39:42 <shapr> I'm a US citizen.
06:40:13 <cleverdra> So?  So am I.  But what's the point of the DMCA if you can still get information by walking across a border?
06:40:43 <shapr> the problem is that the person who disclosed that information to you can be arrested if that person enters the US
06:41:22 <shapr> that's why Alan Cox has been censoring his Linux kernel CHANGELOG files, because it can get him arrested in the US
06:41:36 <cleverdra> Foreign countries should force distinguishing features upon US citizens in their midst, I suppose.
06:41:37 <shapr> since they often disclose vulnerabilities that he has fixed.
06:45:44 <shapr> o3: any thoughts or suggestions for a multi-phase plugin?
06:46:43 <o3> oh, hi :)
06:46:47 <shapr> hi o3!
06:46:49 <o3> nice timing, got home about ten minutes ago
06:46:51 <shapr> wow, nice
06:47:01 <shapr> I expected an answer sometime in the next 24 hours :-)
06:47:05 <o3> multi-phase plugin?  not quite sure what you mean
06:47:20 <shapr> I'm trying to figure out how to make an Apache style plugin API for HWS
06:47:25 <shapr> apache has something like seven phase
06:47:26 <shapr> s
06:48:07 <shapr> something like URI -> Filename, Auth ID, Auth Access, determine MIME type, other, build request, and log request
06:48:28 <shapr> so I'd like to make plugins that can register for only one of those phases
06:48:32 <shapr> or for all of them
06:48:32 <o3> oh right
06:49:08 <o3> hmm, do a name lookup for "registerPhase1" in the plugin
06:49:16 <o3> if it has that, then the plugin can work for phase 1
06:49:23 <o3> then, do a name lookup for "registerPhase2"
06:49:27 <o3> if it has that, then the plugin can work for phase 2
06:49:29 <o3> etc
06:49:30 <o3> ?
06:49:34 <shapr> sounds good to me
06:49:37 <shapr> thanks :-)
06:50:18 <o3> sure, see the textfilter example; each of those plugins has a "registerPlugin" function which supplies the data structure that the core component needs
06:50:50 <o3> if you think of the registration request as registering for a service (i.e. "hi, i'm plugin X and i can do service Y"), then that works nicely
06:51:01 <shapr> yah, I see, nifty
06:51:28 <o3> yeah, loadFunction will just return "IO Nothing" if it can't find the function name
06:52:44 <shapr> that's cool
06:53:27 <cleverdra> well, it'll return "IO Maybe"
06:54:19 <o3> cleverdra :P
06:54:25 <shapr> actually, it looks like it throws an error at the moment...
06:54:29 <o3> oh
06:54:32 * shapr looks to see if it gets caught somewhere
06:54:35 <o3> guess i should fix that :)
06:54:41 <shapr> hi inapt
06:54:59 <inapt> hi shapr. <-- just lurking
06:55:04 <o3> Oh, it doesn't return a Maybe
06:55:13 <o3> hmm, i should throw an exception
06:55:17 <shapr> o3: that's still a valid way to do it, you can expect the named function to be a registration function
06:55:33 <shapr> that way you know you'll always have a single 'point of contact'
06:55:48 <shapr> inapt: are you new to haskell? have any questions?
06:56:15 <o3> shapr: yep, except that it's throwing an error if you can't find the function name, which is wrong :)
06:57:35 <shapr> hm
07:00:54 <shapr> inapt, hey, you're a Jython user, aren't you?
07:01:17 <shapr> I thought you looked familiar :-)
07:09:17 <inapt> shapr: no, I don't have any Haskell questions, yet.
07:09:30 <inapt> I've been using Jython a little, yes :)
07:10:12 <inapt> I think I still have a directory ~/src/learn_haskell, but so far it only contains hello-world style stuff ;-)
07:11:35 <shapr> feel free to ask questions if you have them.
07:11:52 <shapr> I just recognized your hostname (and then your username) from some messages on the jython-users list
07:15:15 <inapt> heh
07:30:05 <d00ludde> any smalltalk gurus here? my "new" method is not called when I send the message "new" to a class name.
07:31:57 <Dalroth> might want to try #ruby
07:32:02 <Dalroth> lots of small talk users use ruby
07:32:06 <ludde2> oh, ok
07:32:09 <Dalroth> err, #ruby-lang
07:32:10 <Dalroth> sorry
07:32:23 <ludde2> k, thanks
07:44:36 * BlizzNL was just told the Dutch Government capsized.. Stupid idiots
07:45:57 <cleverdra> google "dutch government" works
07:48:00 <BlizzNL> cleverdra: what do you mean?
07:48:55 <cleverdra> googling for "dutch government" appears to provide decent information on the subject of which you just spoke.
07:49:10 <cleverdra> This was an advisement to anyone else who might be interested.
07:49:56 <cleverdra> "Christian Democrats"?
07:50:23 <BlizzNL> well, it can be viewed live and streaming, but it's in Dutch ;) http://www.omroep.nl/nos/actueel-bb.asx
07:51:04 <cleverdra> if http://www.heise.de/tp/english/inhalt/te/9763/1.html is true of the falling government, good riddance.
07:52:09 <BlizzNL> cleverdra: that was an idea of the previous government 
07:52:45 <cleverdra> oh, OK.
07:55:40 <BlizzNL> But maybe some of you read some stuff about what happened with Pim Fortyun and his party. Well, they captured 31 out of 150 chairs, but where unable to come up with a consistent political program and as a result the 2 LPF (Fortyun's Party) Ministers quarreled about some subject and now the idiots decided to abandon the cabinet which results in the complete capsize.
07:56:24 <BlizzNL> I really don't care about those Ministers but now new election have to be planned and the land will be without any descent decision making for the time being. 
07:57:59 * BlizzNL anyway back to my Generic Haskell paper ;)
08:02:01 <cleverdra> http://filebox.vt.edu/users/bpatel/Internet%20Paper/introduction.htm
08:02:11 <cleverdra> more cryptology fun.
08:15:30 * shapr bounces
08:16:44 * shapr notices that the Apache API does allow for arrow style static information
08:16:48 <shapr> hm, spiffy
08:27:50 <shapr> hi hal
08:32:42 <hdaume> sup
08:33:02 <shapr> I'm hacking on for-pay python.. what's up with you?
08:33:44 <hdaume> not much...just installed the NDP haskell compiler from manuel et al
08:33:52 <hdaume> trying to get it to work :)
08:34:10 <shapr> cool!
08:34:27 <shapr> I know you updated hMPI
08:34:51 <hdaume> yup
08:35:25 <shapr> are you using Nesl? or the SCL lib? or what?
08:35:53 <hdaume> they have a cvs ghc with flattening -- that's what i'm using (or trying to use)
08:37:29 <shapr> whoa, I just figured out how Monadic IO is both functional and side-effect
08:37:40 * shapr has a major eureka moment
08:37:55 <shapr> it's just a State Monad
08:37:59 <hdaume> yup
08:38:02 <shapr> but the World is the State
08:38:20 <shapr> wow.....
08:38:22 <shapr> that's so cool
08:38:26 <cleverdra> shapr - concurrent-haskell.ps gives an introduction to Monadic IO which explains this.
08:38:38 <shapr> well, I've read that explanation a thousand times.
08:38:45 <shapr> but only now did I *understand*
08:38:51 <cleverdra> shapr - the *really* cool part is how the World is guaranteed to be single-threaded, so it can be updated in-place =)
08:39:11 <shapr> HEH
08:39:27 <cleverdra> shapr - the alternative is somewhat inefficient =)
08:39:28 * shapr falls out of his chair laughing
08:42:00 <cleverdra> (well, not just inefficient)
08:46:16 <shapr> now if only I can hang onto this realization long enough for it to stick permanently....
08:55:09 <shapr> hi buggs
08:55:31 <shapr> hey, I just had a total eureka moment where I grokked Monadic IO
08:57:10 <BlizzNL> speaking about Monads, can one of you suggest a nice introductory paper on Monads?
08:57:31 <shapr> I can tell you the two documents that worked for me...
08:57:43 <BlizzNL> shapr: that'll do
08:57:46 <shapr> first of all, John Hughes wrote a paper called "Generalizing Monads to Arrows"
08:57:58 <shapr> and also, there's this "monads for the working programmer" web page...
08:58:00 <shapr> lemme find the url...
08:58:20 <shapr> http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm
08:58:51 <BlizzNL> shapr: thnx a lot
08:59:04 <shapr> sure, I hope it helps.
08:59:24 <shapr> you need to understand the State monad before you can understand monadic IO
09:00:18 <cleverdra> could someone please explain why 'instance Bits [Char] of ...' doesn't work?  I don't understand the error message; I'd like to define 'xor' for [Char] arguments.
09:00:24 <BlizzNL> shapr: Well tonight is soccer night (Austria - The Netherlands) so I'll see what I can consume until that moment ;)
09:00:40 <shapr> heh, ok :-)
09:00:43 <Heffalump> cleverdra: IIRC you can only do instance Bits [a] in Haskell 98
09:00:47 <Heffalump> (or instance Bits Char)
09:00:52 <shapr> hi Heffalump!
09:01:10 <Heffalump> i.e. all but the outermost constructor must be a variable
09:01:30 <cleverdra> Heffalump - hm, OK.  I'll try defining both of those.  GHC extensions allow Bits [Chars] ?
09:01:36 <Heffalump> should do, yeah
09:01:59 <Heffalump> or hugs -98
09:02:19 <Heffalump> you might be best off doing instance Bits a => Bits [a]
09:02:22 <Heffalump> and instance Bits Char
09:02:37 <Heffalump> (I suspect at least instance Bits Char will already exist)
09:03:28 <cleverdra> OK.  I don't understand 'instance Bits a => Bits [a]'; I'll look at the spec.
09:08:43 <Heffalump> it means that your instance declaration defines an instance of Bits for [a] in the case where a is an instance of Bits.
09:21:40 <shapr> ok, I still have some very basic questions about monads...
09:21:54 <shapr> is there a way to get the Int out of IO Int?
09:22:03 <shapr> afaiu, you can't really
09:22:13 <BlizzNL> shapr: it
09:22:23 <shapr> once you're inside a monad of some flavor, you're always in a monad, right?
09:22:30 <shapr> at least, that's how I understand it....
09:22:35 <inapt> shapr: Any other good Haskell/Monad/IO links than referenced from http://www.zvon.org/other/haskell/Outputprelude/Monad_c.html ?
09:23:02 <Heffalump> shapr: no, monadic code can call "pure" functional code
09:23:21 <Heffalump> and pure functional code can call monadic code using the appropriate "run" operation, if one exists (e.g. runST)
09:23:23 <shapr> inapt: http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm
09:23:33 <Heffalump> there's no "run" for IO (apart from unsafePerformIO, which is evil)
09:23:42 <shapr> inapt: I read that and John Hughes paper "Generalizing Monads to Arrows" and that's how I got there
09:24:08 <shapr> Heffalump: I don't really understand that....
09:24:19 <inapt> shapr: ok, I'll give it a try and bug people here if I'm stuck
09:24:21 <shapr> I realize that monadic code can call pure code, that makes sense.
09:24:26 <shapr> inapt: yah, please do :-)
09:24:30 <shapr> I'll help you as much as I can
09:24:50 <shapr> admittedly, I had to read the Arrows paper about three times...
09:25:06 * shapr has a very large number of notes on his printout of the Arrows paper
09:25:26 <shapr> I think I've only heard of a "run" op once before
09:25:41 <Heffalump> runST :: (forall s.ST s a) -> a
09:25:51 <Heffalump> so given an ST computation, it gives you a pure value
09:26:26 * shapr thinks about that
09:26:51 <shapr> I still don't get that, but I'll think about it more
09:26:53 <shapr> next question...
09:27:16 <shapr> I know I can "join" Gen ( Gen a ) to Gen a
09:27:31 <shapr> though admittedly I'm not sure why..
09:27:33 <shapr> but
09:27:37 <shapr> what about two flavors of monads?
09:27:47 <shapr> IO (Gen a) for example?
09:27:52 <shapr> can that happen? can you join those?
09:27:55 <shapr> what do you do?
09:28:02 <Heffalump> not easily, no
09:28:05 <hdaume> shapr: not in general...check out mark jones' paper on combining monads
09:28:05 <Heffalump> and certainly not in general
09:28:58 <Heffalump> you can join Gen (Gen a) because Gen is the same as Gen. You can't do it with ST if you have (ST s1 (ST s2 a)), for example.
09:29:02 <shapr> so you need special logic to join two different Monad flavors?
09:29:12 <shapr> that makes sense.
09:29:24 <Heffalump> join foo = do foo' <- foo
09:29:49 <Heffalump>               foo'' <- foo'
09:29:57 <Heffalump>               return foo''
09:30:08 <shapr> hal: I'll read that, thanks
09:30:08 <Heffalump> (or just foo' instead of the last two lines)
09:30:23 <Heffalump> which is another explanation of why you can do it; because that code works.
09:31:01 * shapr thinks about that
09:32:06 <shapr> it's still weird to me that I can add two IO Int without having to do something strange to the (+) function, as long as the result has the IO part carried around with it
09:32:27 <Heffalump> you can get values out of a monad, it's just that any result you compute has to also be in that monad
09:32:41 <shapr> ok, that makes sense.
09:32:56 <shapr> effectively creating a separate "pure" area
09:33:12 <shapr> though in actuality it's still inside that monad
09:33:16 <Heffalump> sort of
09:33:41 <shapr> so if you have a bunch of values that are all inside the same monad, you can do whatever you want with them, as long as you don't try to cross the border
09:34:11 <Heffalump> well, there's no way you can cross the border
09:34:23 <shapr> you can lift an existing value into that monad, right?
09:34:27 <shapr> with return
09:34:28 <shapr> yes?
09:34:28 <Heffalump> yes
09:34:36 <shapr> but you can't add Int and IO Int
09:35:06 <Heffalump> not directly
09:35:12 <Heffalump> you can do it indirectly, but the result will be in IO
09:35:26 <shapr> right, ok
09:35:30 <shapr> I think I've got it then.
09:36:34 <shapr> arrows and monads are nearly the same thing
09:36:55 <shapr> only difference being that arrows have input restrictions, thereby exposing static properties
09:37:06 <shapr> imho, arrows are still a lot easier to understand than Monads
09:37:38 <shapr> would've taken me a lot longer to get to Monads without reading lots about Arrows
09:38:08 <Heffalump> umm, arrows are more general than monads
09:38:43 <shapr> guess that means I need to read the paper yet again.
09:38:55 <shapr> it's neat the way new things fall into place every time I read that paper.
09:39:35 <shapr> wouldn't you love to work on software project with Wadler and Hughes? ;-)
09:40:50 <BlizzNL> I'd like to work on generic haskell stuff with R.Hinze, maybe I'll understand it then ;-)
09:41:12 <shapr> are you going to?
09:41:41 <BlizzNL> shapr: no it hypothetically just like yours
09:41:46 <shapr> oh :-)
09:42:11 <shapr> Lava is pretty high up on the spiffy Haskell projects list.
09:42:16 <shapr> what's cooler than Lava?
09:43:03 * shapr thinks of his top five coolest Haskell projects
09:43:32 <ayrnieu> what are they?
09:43:38 <andersca> hugs and ghc
09:43:40 <andersca> :)
09:43:51 <BlizzNL> I am kinda new to Haskell too, but I think the Stock Contract combinators are spiffy
09:44:32 <shapr> when Parr allows transparent data parallelization in GHC, it'll be top of my list, no contest
09:45:12 <shapr> Lava is in there somewhere
09:45:16 <shapr> ok, ghc is too =)
09:46:16 <shapr> BlizzNL: is that the SimonPJ Enron paper?
09:46:26 <BlizzNL> shapr: Yes it is
09:46:31 <shapr> ayrnieu: what are the coolest Haskell projects you know of?
09:47:05 <ayrnieu> shapr - I don't know much about any of them.
09:47:26 * shapr adds the Enron paper to his list of things to read
09:47:38 <BlizzNL> and because I am from UtrechU I'd have to say generic-haskell.org is spiffy ;)
09:47:45 <shapr> :-)
09:48:54 <o3> shapr: the way i got taught monads made it really clear, and i'm a complete maths idiot
09:49:15 <o3> shapr: http://www.cse.unsw.edu.au/~cs4132/lecture/asquad.ps are chilli's lecture notes on it
09:49:31 <o3> http://research.microsoft.com/Users/simonpj/papers/marktoberdorf/ is the paper that the lecture notes are based from
09:49:50 <o3> you can ignore all the semantics stuff there if you just want to learn to use them
09:50:11 <ayrnieu> hm, how easy would it be to write a program that compiles Haskell (say, user configuration) at run-time?  Can I re-use GHC/Hug's compiler?
09:50:33 <shapr> we are approaching that with o3's runtime loader
09:50:47 <shapr> it's a goal of mine
09:50:47 <o3> ayrnieu: compiles or dynamically loads?
09:51:02 <o3> if you compile it, you'll need to basically put ghc/hugs/etc in your app
09:51:17 <ayrnieu> o3 - compiles is preferable; I'd like to be able to offer a ghci-like read-eval-print-loop to the user.
09:51:25 <shapr> loading config at runtime is possible without needing a runtime loader or haskell compiler
09:51:41 <o3> ayrnieu: you'll probably need to put in hugs, then
09:51:51 <o3> (good luck to you :)
09:52:47 <Heffalump> Well, GHC compiles Haskell during it's own run-time, and uses the result
09:52:58 <Heffalump> (this is for Template Haskell)
09:53:15 <Heffalump> s/it's/its/
09:53:16 <o3> shapr: i think my haskell project and thesis is cool, although they're not finished yet ;)
09:53:18 <shapr> isn't TH compile-time only?
09:53:26 <shapr> o3: HaskellWiki ?
09:53:29 <ayrnieu> shapr - what is the runtime loader like?
09:53:31 <o3> but at least it's guaranteed to be finish, otherwise i'll get a fail for my thesis, and i don't want that
09:53:39 <o3> shapr: yeah, chiba (markup language) and hicky (haskell wiki)
09:54:08 <shapr> I've been a Wiki addict for years, so you might get lots of code and comments from me :-)
09:54:29 <shapr> Igloo made a deal long ago that he would actually start using a Wiki as long at it's written in Haskell.
09:54:55 <shapr> ayrnieu: the runtime loader is straightforward
09:55:09 <o3> oh well, we'll have one in max. 8 months unless somebody beats me to it
09:55:56 <Heffalump> shapr: yeah, but it means GHC has to compile Haskell and use the result during it's /own/ run-time
09:56:07 <Heffalump> (and sort of similarly for ghci)
09:57:13 <shapr> that's a good point.
09:57:42 <shapr> I've read a bit of the TH paper, and it talks about a tight loop of: type-check, compile, load
09:58:30 <shapr> o3: hey, if you put your thesis stuff online when you have some, I'd love to read it.
09:58:42 <shapr> I agree, that's a cool project.
09:59:26 <o3> sure, although it won't be for a while.  my thesis work doesn't really start until next year, although i do have to give a prelim. presentation on it next week
10:00:10 <shapr> anyone know the status of Java interop with Haskell?
10:00:34 <shapr> I've read that Ashley Yakely has code to generate jvm bytecode
10:01:02 <shapr> I was wondering about reading bytecode
10:01:24 <hdaume> i believe he has that too
10:01:34 <BlizzNL> shapr:  Ashley Yakely doesn't appear on google, typo?
10:01:36 <hdaume> there's also the jvm bridge
10:01:37 <Heffalump> that's not exactly interop, though
10:01:38 <Heffalump> Yakeley
10:01:41 <hdaume> yakeley
10:01:47 <Heffalump> jvm bridge is interop
10:02:04 <Heffalump> generating/reading is code manipulation/language tool construction
10:02:25 <shapr> hm
10:03:27 <shapr> the bridge allows calling back and forth between Haskell and the JVM, and Ashley's code lets you read and write bytecode...
10:04:39 <Heffalump> is the bridge for hugs or for ghc?
10:05:34 <shapr> I think ghc...
10:05:36 * shapr looks
10:06:06 <hdaume> i'm sure ghc :)
10:06:41 <buggs> hoi shapr
10:07:04 <shapr> http://sourceforge.net/forum/forum.php?forum_id=138353
10:07:06 <shapr> yah, ghc
10:07:12 <shapr> requires x86 ??
10:08:15 <BlizzNL> shapr: why are you on your Palm currently? ;-)
10:09:40 <hdaume> sharp: no, i don't think so...a while back i had it running on sparc solaris
10:10:22 <shapr> hm, weird...
10:11:55 <shapr> BlizzNL: nah, just seems weird that either Haskell or Java would require x86
10:12:24 <shapr> hal: sounds like you do a lot of stuff with Haskell
10:12:41 <o3> yikes
10:12:41 <o3> 3am
10:12:43 <o3> night! :)
10:12:47 <shapr> g'night o3
10:12:51 <BlizzNL> o3 : gnight
10:12:55 <shapr> thanks for the links
10:12:55 <Heffalump> looks like it's semi-JVM specific
10:13:37 <hdaume> shapr: i installed it 6ish months ago because i was doing some ui stuff...i ended up just doing it in pure java, though
10:13:45 <shapr> I haven't used JNI stuff, is JNI usually jvm-specific?
10:14:01 <Heffalump> not sure, I was just wondering that
10:14:13 * shapr considers asking on #java, but decides it's not worth it
10:14:15 <BlizzNL> I haven't looked into it, but it seems that if it compiles to jvm is platform independant just like every other java compiled class
10:14:16 <Heffalump> FFI is implementation specific but the new FFI standard (courtesy of Chilli :-) ought to be fixing that, I think.
10:14:37 <hdaume> shapr: i used jni a while back for a java/c combo project.  in that case, it's platform independent, but of course the compiled c needs to be compiled on the right architecture
10:14:44 <hdaume> who is chilli irl?
10:14:54 <shapr> the great and powerful Chak
10:14:54 <Heffalump> Manuel Chakravarty
10:15:00 <hdaume> ooooh
10:15:13 <shapr> heh
10:15:19 <hdaume> i never made the connection :)
10:15:27 <hdaume> probably it's a bit easier with my uncreative nick :)
10:15:32 <Heffalump> :-)
10:15:40 * Heffalump tends to look at hostmasks which helps identify people
10:15:52 <shapr> SimonMar and SimonPJ were both on here at once some weeks back.
10:16:31 <cleverdra> There appear to be no projects on sf.net written in Haskell.
10:16:48 <shapr> I think there's an ls replacement there
10:17:02 <shapr> and jens' gtk panel connection meter
10:17:05 <shapr> isn't that on there?
10:17:24 <shapr> I wonder what's up with jens, haven't seen him on #haskell lately.
10:17:58 <cleverdra> browse-by-language doesn't have a 'Haskell' category, is what I mean.
10:18:12 <shapr> oh
10:22:23 <shapr> it needs one.
10:24:02 <shapr> anyone know the best 'vector format' for music?
10:24:11 <shapr> iirc, midi is only 16 channels...
10:27:28 <hdaume> yeah, i think midi is 16 chan...check out haschorus
10:27:53 <shapr> I've got it working, but I was hoping for a better format rather than CSound and MIDI
10:29:07 <hdaume> ah.  i dunno then :)
10:29:35 <shapr> #python suggest SAOL/MPEG 4 or tracker formats.. hmm
10:30:56 <cleverdra> Maybe you could use one of the MOD formats?  (or is that not a 'vector format'?)
10:31:04 * shapr dunno
10:35:00 <hdaume> standard MOD only has 4 channels, though it's variations can have more
10:35:12 <hdaume> if i understand what you mean by 'vector format' then yes, mod is vector format.
10:37:38 <shapr> SAOL is nearly an intermediate language... sfront compiles SAOL into C
10:37:42 <shapr> neato
10:37:44 <shapr> hi toadx
10:38:33 <toadx> hello
10:58:24 <shapr> saol is highly impressive. it can do pretty much everything I've ever thought about doing.
11:26:29 <hdaume> has anyone successfully used starrays?
11:30:58 <shapr> from #python:
11:31:02 <shapr> <drewp_> Michel Mauny was giving a guest lecture to new computer science students. After the students were seated, Michel pronounced "Today's lecture will be about Lazy Evaluation", he paused for a moment then concluded with, "Are there any questions?"
11:32:08 <shapr> hdaume: afaict, the latest version of parr doesn't interface with MPI yet, is that true?
11:32:15 <andersca> haha
11:32:33 <hdaume> shapr:lol
11:32:33 <andersca> shapr: that's cool :)
11:32:42 <andersca> shapr: kinda like the binary tree search john did
11:32:46 <hdaume> shapr: can't tell yet
11:33:29 <shapr> andersca: I don't know that one.
11:33:38 <andersca> shapr: with the telephone book
11:33:47 <shapr> tell me more :-)
11:34:07 <andersca> he was going to look up his name
11:34:11 <andersca> and first he did a linear search
11:34:21 <andersca> "Anna Andersson", no...that's not my name
11:34:29 * shapr grins
11:34:35 <andersca> "Annie Andersson", no..that's not my name
11:34:42 <andersca> then he showed binary search
11:34:51 <andersca> by riping the phone book catalog in half
11:34:58 * shapr snickers
11:35:42 <shapr> Hughes has lots of style.
12:35:30 <Clase> hi
12:38:58 <Clase> is there anyone who can help me?
12:39:15 <ayrnieu> clase - help you with what?
12:39:26 <Clase> i have a problem with a program
12:39:44 <Clase> can i put two "do" sentences together
12:39:50 <Clase> the compiler says me
12:40:06 <Clase> Last generator in do {...} must be an expression
12:40:19 <Clase> i think that's a layout problem but i can not see it
12:41:07 <dennisb> Clase: show an example that does not work and we will help you
12:41:13 <Clase> ok
12:41:24 <Clase> code4 :: Parser
12:41:24 <Clase> code4 = do dd <- code3
12:41:30 <Clase>            do dde <- code3
12:41:37 <Clase>                digit
12:41:37 <Clase>                ddd <- many (do digit)
12:41:37 <Clase> 	       q <- code5
12:41:56 <Clase> 	       return (q : "ss") 
12:42:08 <ayrnieu> code4 = do dd <- code3; dde <- code3; digit; ddd <- many digit; q <- code5; return (q:"ss")
12:42:13 <dennisb> you don't need the second do, and the indention seems strange
12:42:48 <Clase> the idention i thonk that is for the copy and paste
12:44:45 <dennisb> here it looks like the q is to much to the left, and that can give the error you got
12:44:55 <dennisb> why do you wan't to have a nested do?
12:45:10 <Clase> yes, the q is under the " ddd <- many (do digit)" sentence
12:45:23 <Clase> teh cpoy and paste fails me
12:45:33 <dennisb> Clase: no problem
12:46:00 <dennisb> As ayrnieu showed, you only need one do
12:46:15 <Clase> i will probe with that
12:47:39 <Clase> the problem is that  i have a source that is not mine and i must repair it
13:03:58 <Clase> why don't i need teh second do?
13:04:47 <cleverdra> You don't need any of the 'do' except the first
13:04:54 <cleverdra> Why do you think that you do?
13:05:08 <cleverdra> 'do a; b; c' <=> 'a >> b >> c'
13:05:59 <Clase> hmmm
13:06:12 <Clase> so i must not nested do
13:06:27 <cleverdra> Nested do is OK, just needless.
13:06:50 <cleverdra> 'do a <- b; c <- d; e c' = 'b >>= \a -> d >>= \c -> e c'
13:07:42 <Clase> O_O
13:07:52 <cleverdra> 'do a <- b; do { c <- d; e c b }' = 'b >>= \a -> { d >>= \c -> e c b }' = 'b >>= \a -> d >>= \c -> e c b'
13:08:35 <cleverdra> well, with parentheses instead of braces, for the second.  I'm not being very precise.
13:08:50 <Clase> hmm
13:09:17 <toadx> do a <- b; c d e >>= f; \g h (i j k) >>= \l -> m n (o:p); {q r s <- t u v} 'w x' y >>= \z
13:09:20 <cleverdra> but you of course need an expression as the last part of a 'do' -- or else what are you doing with the binding you're making?
13:10:04 <cleverdra> That's an error.
13:10:29 <Clase> i need a o folowed by a sentence so the do have a mean
13:10:48 <cleverdra> Clase - I don't follow...
13:11:36 <Clase> hmm
13:12:06 <Clase> i must put a sentece after a "do"
13:12:26 <cleverdra> I don't know what a 'sentence' is, Clase.
13:12:45 <Clase> a code line
13:12:46 <andersca> Marvin--?
13:13:07 <Marvin--> yea?
13:13:11 <cleverdra> Clase - I think that you're confused.  A 'do' must end in an expression.
13:13:37 <Clase> which kind of expression?
13:14:09 <Clase> i am europeanm, my english is not very well
13:14:11 <Clase> :)
13:14:14 <andersca> Marvin--: as to why replaceIO is needed; when you exit from a function you want to get rid of the variables changed in that function, but you do want to "move over" the IO streams to the caller environment
13:14:43 <Marvin--> andersca: ah, so that's what you meant
13:14:45 <Marvin--> andersca: ok
13:15:30 <cleverdra> Clase - are the English european? =)
13:15:36 <Clase> spain
13:15:44 <cleverdra> Clase - 'expression' is a technical term in many languages.
13:15:49 <Clase> yes
13:16:14 <cleverdra> Clase - programming languages, I mean; the Haskell98 spec, er, defines it.
13:16:43 <Clase> ok
13:16:47 <cleverdra> Clase - '1+1' is an expression, as is 'f x y', as is anything that has a value.
13:17:01 <Clase> so i must put e.g. a do and then a expression
13:17:08 <cleverdra> 'b <- x' does not have a value; it is an incomplete expression.
13:17:14 <Clase> and two do together has not sense
13:17:18 <cleverdra> 'x >>= \b'
13:17:41 <cleverdra> Clase - no, there's no reason to have multiple 'do's like that.  Why did you think that you needed them?
13:18:16 <Clase> teh source code is already write i must "repair it", is an exercise :)
13:18:31 <cleverdra> Clase - also, Haskell has *layout* rules.  Indentation matters unless you use explicit braces and like
13:18:43 <Clase> yes
13:19:15 <Clase> i must put the next line after a "do " at the right
13:19:18 <Clase> and things so
13:19:30 <cleverdra> Clase - at one point in your example, you have something similar to { a >>= \b -> }
13:20:48 <Clase> so strange is haskell..
13:21:47 <cleverdra> It's really very nice, intuitive, and easy -- once you learn it =)
13:22:14 <Clase> i supouse the problem is that...
13:23:15 <Clase> why do you write a \ before a char?
13:26:05 <Clase> ok sorry
13:26:20 <Clase> a lambda expression
13:26:22 <cleverdra> Oh, you know what it is?
13:27:10 <Clase> i think that i have read so quicky my tutorial
13:27:18 <Clase> i would must read it again
13:28:41 <Clase> well i save this log
13:29:09 <Clase> and i'll come back later
13:29:22 <Clase> i must go now
13:29:37 <Clase> thanks a lot for all cleverdra :)
13:29:53 <cleverdra> You're quite welcome.
13:30:05 <Clase> ok thx
13:30:08 <Clase> see you later
13:44:17 <BlizzNL> sometimes people declare a tree like this: data BinTree a = Leaf a | BinTree a :^: BinTree a, :^: is a Type Constructor in this case?
13:46:47 <ibid> no, a data constructor
13:46:54 <ibid> BinTree is a type constructor
13:48:00 <BlizzNL> ibid: ok, but I'd have done something like data BinTree a = Lead a | Node (BinTree a) (BinTree a) , but this is an alternative
13:53:38 <Marvin--> BlizzNL: infix data constructors must start with colon, like prefix constructors have to start with capital letter...
13:57:43 <ibid> BlizzNL: the difference is just syntax, prefix vs infix.  Node is a data constructor like :^:
14:15:51 <tez> Wow, I've *never* seen an infix data constructor before.
14:19:01 <ibid> it's cool to be able to write:
14:19:09 <ibid> data Expr = Expr :+ Expr
14:19:13 <ibid>   | Expr :- Expr
14:19:14 <ibid> etc
14:19:16 <ibid> :-)
14:19:43 <ibid> and, of course, the obvious:
14:19:55 <ibid> data Statement = Variable := Expression
14:19:56 <ibid> ...
14:19:57 <ibid> :-)
14:20:17 <ibid> (representing an AST type for an imperative PL)
14:22:01 <BlizzNL> ibid, Marvin--: great thnx for clearing this one out
14:22:44 <Marvin--> ibid: :P
14:23:01 <Marvin--> of course, you can't use :: as that's used for types
14:23:16 <ibid> why would i want to use ::?
14:23:21 <ibid> well, yeah
14:23:23 <Marvin--> I don't know, but I've seen ::: used
14:23:27 <ibid> but it's not as cool as :=
14:23:30 <Marvin--> heh
14:23:49 <ibid> in a prolog implementation, :- would be a cool data constructor in an AST
14:24:11 <Marvin--> but can you use ; in operators?
14:24:14 <Marvin--> :, and :;
14:24:18 <BlizzNL> Marvin--: ::: is used for kinds
14:24:36 <Marvin--> BlizzNL: well, only informally, right?
14:24:43 <ibid> i don't think kinds are notatable in haskell
14:25:05 <ibid> Marvin--: not ; as it's magic (remember the layout translation)
14:25:07 <BlizzNL> Marvin--: yeah, but to me really feals reserved for kinds ;)
14:25:24 <Marvin--> ibid: exactly
14:25:43 <Marvin--> ibid: so you still break the sugar :P
14:25:50 <BlizzNL> well when you do generic haskell programming you surely need them
14:26:14 <ibid> Marvin--: yeah, well, i didn't say it's general :-)
14:27:02 <ibid> Marvin--: one of my pet backburner projects is an extensible statically metaprogrammable programming language in which you could do just that
14:27:11 <ibid> the syntax is trivial
14:27:37 <Marvin--> :)
14:27:42 <ibid> 20 levels of infix priorities, one prefix priority. everything is such an expression
14:28:04 <Marvin--> iiik
14:28:05 <ibid> i should restart the project in haskell, the c version is going too hairy
14:28:37 <ibid> of course, in the language, you would have a "standard" syntax
14:29:05 <ibid> like, in scheme, everything is rebindable as long as you use the cambridge polish notation
14:29:25 <ibid> here it's similar, except that you can define infix ops too :-)
14:32:18 <ibid> but sleep time, bbl
16:19:47 <Pseudonym> G'day.
16:20:07 <Pseudonym> Has anyone here read the "Deriving Backtracking Monad Transformers" paper?
16:21:09 <Heffalump> I started reading it earlier
16:21:16 <Heffalump> but got distracted and didn't finish
16:21:35 * Pseudonym nods
16:21:52 <Heffalump> it was in ICFP 2000, wasn't it?
16:21:52 <Pseudonym> Just curious.  I tried it out and I found something curious.
16:21:59 <Pseudonym> I think so.
16:22:04 * Pseudonym got it from citeseer
16:22:23 <Pseudonym> Yes.
16:22:27 * Pseudonym checked the copyright
16:23:02 <Pseudonym> The curious thing I found was that for the monad I was deriving, some of the context in the context passing implementation ended up not being used.
16:23:36 <Pseudonym> But I'm 99% sure I worked out the context exactly as Ralf said to.
16:24:02 <Pseudonym> This means that there's actually something missing from the paper: Sometimes you have to optimise the context after you've derived it.
16:24:29 <Pseudonym> Assuming I did my working correctly, of course.  I haven't actually tested it yet.
16:28:45 <Pseudonym> hdaume, you there?
19:03:08 <Tawny> can anyone recommend a good windows editor for Haskell? 
19:30:16 <Chilli> xemacs
19:43:06 <Pseudonym> gvim
22:55:27 <o3> ello
22:55:32 <o3> vimacs!
22:55:48 <o3> although i think xemacs is arguably better for haskell stuff right now
22:56:37 <Pseudonym> It's fine if you're already negotiated the emacs learning curve.
22:56:57 <Pseudonym> If instead you've negotiated the vi learning curve, gvim is definitely the editor of choice.
22:57:22 <o3> if you've negotiated both, vimacs is good
22:57:23 <o3> :)
22:57:28 <Pseudonym> :-)
22:57:38 * Pseudonym doesn't have the tuits to invest in learning emacs
22:57:58 <o3> use vimacs.  vim + emacs.  you have nothing to lose :)
22:58:19 <Pseudonym> Well emacs has a vi mode.
22:59:23 <Jii> it's funny though that with emacs, you learn new keycombos from time to time that apply to programming which you weren't aware of, for me, the latest was M-/
22:59:25 <o3> true.  i'm just advocating my own project, or trolling, or both
22:59:32 <Pseudonym> Personally, I don't see any advantage in learning the other editor once you've learned one.
22:59:46 <o3> Jii: ooh, that was _the_ reason i switched to emacs
23:00:01 <Pseudonym> What does M-/ do?
23:00:34 <o3> Pseudonym: say you type in "GHC is a phenomenal compiler.  It's so phe<M-/>"
23:00:44 <Pseudonym> Oh, you mean autocompletion?
23:00:47 <o3> M-/ goes and searches backward in the buffer for the matching word
23:01:00 <Pseudonym> Gvim's got that.
23:01:01 <o3> yes, keep pressing it to cycle through the various words it matches
23:01:21 <o3> it does, although M-/ is a bit better in that it's context-sensitive; CTRL-N/CTRL-P in vim isn't, unfortunately
23:01:26 <Jii> pseudonym, yeah, i wasn't arguing for emacs, i just revealing my ignorance ;-)
23:01:32 <Pseudonym> :-)
23:01:35 <Pseudonym> I know.
23:01:47 <Pseudonym> Look, I'm not trying to start a flamewar here.
23:02:04 <o3> i know.  i use both :)
23:02:07 <Pseudonym> Emacs is good.  A modern vi is good.
23:02:35 <Pseudonym> If you know one, there's little advantage in knowing the other.
23:02:59 <Pseudonym> Unless you define "advantage" as the ability to straightforwardly write tetris in the macro language, of course.
23:03:12 <Jii> huh, that vimacs thingy sounds like a very powerful editor ;-)
23:03:47 <o3> Jii: www.vimacs.cx -- enjoy
23:04:00 <Jii> i mean, maybe _too_ powerful ;)
23:04:03 <Pseudonym> vimacs does look interesting.
23:05:31 <Jii> jajvirta@spy:~$ apt-cache search vimacs
23:05:31 <Jii> vimacs - Emacs emulation for Vim
23:05:34 <Jii> cool ;)
23:06:24 <Pseudonym> I was brought up on IBM's PE2, and later kedit.
23:06:37 <Pseudonym> Which is a PE2-alike.
23:06:44 <o3> Pseudonym: i found a _ridiculously_ comprehensive page about text editors
23:06:55 <Pseudonym> Oh?
23:06:55 <o3> it's worth looking at just to boggle at the sheer amount of research the guy has done into them
23:07:05 <Pseudonym> Where?
23:07:09 <Jii> i using borlands DOS IDEs, C/C++ and Pascal :)
23:07:27 <Pseudonym> PE2 was the editor for the PS/2.
23:07:39 <Pseudonym> Kedit was a commercial clone.
23:07:58 <o3> http://www.softpanorama.org/Editors/index.shtml
23:08:05 <Pseudonym> Kind of like vim/emacs in philosophy.  It was a REXX interpreter with editing primitives.
23:08:12 <o3> i wasn't even aware of editors like THE
23:08:21 <Pseudonym> THE is actually a kedit clone.
23:08:30 <o3> ah
23:08:36 <Pseudonym> Tried compiling it once, couldn't do it.
23:08:46 <Jii> i was kinda intrigued by the fact that this (core) python developer who is known to be emacs wizard, switched to some relatively unknown commercial editor (only in windows)
23:08:48 <Pseudonym> This was 8 or so years ago.  I just learned vi instead.
23:09:28 <o3> Pseudonym: that website has an entire page dedicated to kedit/the/etc
23:18:35 <Jii> nyah, vimacs seems to need some minor tweaking ;)
