01:14:31 * Chilli is away: Not at the machine...
04:30:57 <shapr> goood morning!
04:31:50 <ChilliX> Aehhm, yes...good evening, rather.
04:32:02 <shapr> that too :-)
05:28:03 <shapr> hi resolve!
05:28:08 <resolve> g'day :)
05:28:19 <shapr> I hear you're taking a Haskell class.
05:28:23 <shapr> who's your instructor?
05:29:12 <shapr> got any questions about Haskll?
05:29:17 <shapr> want to see some demo code?
05:29:28 <resolve> ahh it's not a haskell course as such, it's a course on predicate calculus and the like - basically a bunch of mathematics topics that relate to computing. my understanding is that they use haskell in the later parts of the course to demonstrate a bunch of these concepts
05:29:50 <resolve> but i wanted to learn haskell anyway, so i bought the 'recommended reading' textbook on it, and have been reading away in my spare time :)
05:30:03 <ChilliX> resolve: sydney uni?
05:30:04 <shapr> you got the Thompson book? or the Hudak book?
05:31:27 <resolve> well, one question, though it doesn't really relate to the language itself - is there any more interactive way to try stuff out than hugs? with hugs i can check the evalution of variables etc, but can't see to define new variables / functions
05:31:28 <resolve>     * Simon Thompson. Haskell: The Craft of Functional Programming. International Computer Science Series. Addison-Wesley, Wokingham, England, 1999.
05:31:39 <resolve> chilli: ANU, canberra
05:31:51 <shapr> yah, if you use GHCi, you can do more
05:32:13 <ChilliX> resolve: is canberra in nsw.bigbond?
05:32:19 <ChilliX> in = on
05:32:41 <resolve> yep, our adsl connections are routed through the NSW concentrator
05:32:44 <shapr> Prelude> let x = (+ 1)
05:32:44 <shapr> Prelude> x 2
05:32:44 <shapr> 3
05:32:47 <shapr> that's from ghci
05:32:52 <ChilliX> resolve: ic
05:33:00 <resolve> shapr: cool :)
05:33:05 <resolve> fetching the deb now
05:33:12 <ChilliX> resolve: ghci has much better error msg, too
05:33:30 <shapr> I've always heard it was the other way around.
05:33:39 <ChilliX> resolve: tell your lecturer, s/he better use ghci ;-)
05:33:52 <ChilliX> shapr: heh?
05:34:15 <shapr> ChilliX: I trust your knowledge of the differences.
05:34:24 <ChilliX> ever had formatting error in Hugs and it complaining about semicolons in a program that doesn't have a single one in it?
05:34:30 <shapr> um no.
05:34:34 <shapr> but then, I use ghci :-)
05:34:44 <Heffalump> blame the layout rule :-)
05:34:58 <shapr> I really like significant whitespace.
05:34:59 <ChilliX> ghci also often suggests how to fix an error (hugs just dumps all the gory details at you and let's you figure out the rest for yopurself)
05:35:12 <ChilliX> Heffalump: nah - blame the impl of the layout rule
05:35:14 <Heffalump> I used to see that all the time when I was demonstrating practicals, I can't remember how much it happens to my own code
05:35:38 <Heffalump> how does ghci deal with it? I don't really use it (I find it a bit slow)
05:35:43 <shapr> is there a better layout rule imlp?
05:35:57 <shapr> ghci is slow?
05:36:13 <Heffalump> oh, presumably it's the same error message as ghc, actually
05:36:30 <shapr> oh, ghci is probably not slow on my PC.
05:36:33 <Heffalump> shapr: I find it loads things much more slowly than hugs, and when I'm using an interactive environment I want quick reloads
05:36:48 <Heffalump> so I develop with hugs and build with ghc
05:36:50 <shapr> I'm using it on my spiffy dual 1.5GHz Athlon
05:36:56 <shapr> so I guess it's unfair for me to compare
05:36:58 <resolve> cool, i've got ghci up and running now. is the let a haskell thing, or just used in ghc to denote a definition?
05:36:59 <ChilliX> Heffalump: no, ghci tells you something is wrong with your indentation
05:37:10 <shapr> resolve: it's like let* in elisp
05:37:18 <shapr> resolve: and it's a standard per-function kind of thing
05:37:37 <shapr> resolve: it really only works inside a function, but ghci pretends to be inside a really big single function
05:37:40 <resolve> what's the thompson book regarded like?
05:37:43 <shapr> at least, that's how I understand it.
05:37:48 <resolve> shapr: cool, thanks. :)
05:37:58 <shapr> resolve: I like the Thompson book, it's my recommended way to learn Haskell
05:38:04 <ChilliX> shapr: close; it pretends to be in a do-cosntruct
05:38:13 <ChilliX> (that's why you don't need an "in")
05:38:18 <shapr> ChilliX prefers the Hudak book
05:38:26 <Heffalump> does it let you bind variables with <- , too?
05:38:33 <ChilliX> yes
05:38:37 <resolve> ChilliX: what do you prefer about it?
05:38:40 <shapr> ChilliX has actually taught Haskell, and I haven't so.... :-)
05:38:45 <resolve> :-)
05:38:45 <Heffalump> hmm, that's quite nice
05:38:57 <Heffalump> maybe I should suggest people move to it for practicals here
05:38:58 <shapr> Heffalump: show me an example?
05:39:00 <ChilliX> resolve: more interesting examples: graphics and stuff
05:39:04 <Heffalump> shapr: of what?
05:39:10 <ChilliX> resolve: deals with IO right from the start
05:39:10 <shapr> the <- binding in ghci?
05:39:28 <shapr> I can find an example
05:39:30 <Heffalump> chillix: what monad does it pretend to be in?
05:39:32 * shapr opens books
05:39:34 <ChilliX> IO
05:39:56 <resolve> can you define functions in ghci or do i need to do that with a separate file? (the let syntax doesn't seem to apply)
05:40:01 <Heffalump> Prelude> :m System
05:40:01 <Heffalump> System> xs <- getArgs
05:40:01 <Heffalump> System> xs
05:40:01 <Heffalump> ["-B/usr/lib/ghc-5.00.2","--interactive"]
05:40:02 <ChilliX> (which isn't pretence, as the GHCI eval-print loop *is* implemented in the IO monad :-)
05:40:13 <shapr> Heffalump: oh COOL
05:40:28 <shapr> that's SPIFFY!
05:40:33 <Heffalump> chillix: yeah, but it's pretending to implement do notation, surely?
05:40:39 * shapr bounces
05:40:50 <Heffalump> since the translation into >>= doesn't work one bit at a time
05:41:41 <shapr> that means I'll be able to do socket stuff in ghci
05:41:44 <shapr> interactively
05:41:49 <shapr> extra spiffy!
05:42:32 * shapr has too much energy
05:42:44 <Heffalump> the source of ghci itself defines some lifting of the IO monad, IIRC, which was why I asked what monad the command prompt presents
05:49:39 <resolve> shapr: now the quintessential question: haskell.el? :)
05:49:51 <shapr> resolve: haskell-mode.el
05:49:57 <resolve> cool, i'll hunt again
05:49:57 <shapr> with excellent support for ghci and hugs
05:50:00 <Heffalump> it's not bad, but it's not perfect
05:50:03 <shapr> it's a deb
05:50:33 <resolve> even better :)
05:51:48 <shapr> Heffalump: how could it be improved?
05:52:06 <Heffalump> oh, the syntax highlighting gets things a bit wrong occasionally, that's all
05:52:28 <shapr> in which cases?
05:52:34 <Heffalump> I don't remember, sorry
05:52:40 <Heffalump> I'll try to make a note of it next time it happens
05:53:18 <shapr> ok, cool
06:10:56 <ChilliX> Heffalump: the eval-print loop surely carries some extra state around, but in the end all the IO actions get to be executed in the embedded IO monad
06:12:53 <resolve> ahh, now i'm annoyed i took off my shoes and crawled into bed - i left the haskell book in the ccar :)
06:16:17 <shapr> that sucks
06:16:39 <shapr> I wish I could remember where the cvs tree for the YAHT went to
06:16:46 <shapr> YAHT == Yet Another Haskell Tutorial
06:17:01 <shapr> my blind friend can't read any of the Haskell print books
06:17:10 <shapr> and he's an excellent programmer
06:17:24 <ChilliX> can he read electronic stuff?
06:17:43 <shapr> yup
06:17:48 <ChilliX> hmmm
06:17:56 <shapr> I emailed Thompson with a request for an electronic version
06:17:57 <shapr> with no reply
06:18:03 <shapr> I think I emailed Hudak also
06:18:09 <shapr> I have it on my list to email Bird about his
06:18:10 <ChilliX> I have actually written a Haskell intro book together with Gabi
06:18:16 <shapr> wow, cool!
06:18:21 <shapr> which book is it?
06:18:29 <shapr> hi gene9!
06:18:31 <ChilliX> it's not as comprehensive as Hudak and Thompson
06:18:56 <shapr> ChilliX: the gentle intro seemed more like a brickbat to me.
06:19:00 <ChilliX> it's currently only published locally
06:19:18 <ChilliX> (ie, Australian publisher)
06:19:32 <gene9> hi shapr
06:19:34 <shapr> would your author contract allow you to distribute one version electronically?
06:19:37 <ChilliX> and I can't put an electronic version on the web
06:19:44 <shapr> er, one copy I mean.
06:20:05 <ChilliX> let's say, a copy for personal use (especially under the circumstances) shouldn't hurt
06:20:22 <shapr> excellent!
06:20:25 <ChilliX> but please don't curculate it
06:20:29 <ChilliX> is pdf ok?
06:20:29 <shapr> right
06:20:34 <shapr> um, lemme ask him...
06:20:35 <shapr> just a moment
06:21:46 <shapr> hi delYsid!
06:21:54 <delYsid> hey
06:21:57 <shapr> hey ChilliX this is the person I've been talking about.
06:22:24 <ChilliX> Hi delysid
06:22:38 <delYsid> ChilliX: greetings
06:22:44 <shapr> delYsid: you do pdf?
06:22:59 <delYsid> I've heard someone would be willing to distribute one electronic copy of a haskell book?
06:23:20 <delYsid> shapr: Depends on the pdf, most of them just work fine
06:23:22 <ChilliX> is pdf (produced from latex) ok?
06:23:43 <ChilliX> compiled with latex and then run through ps2pdf
06:23:49 <delYsid> yes, sure.
06:23:52 <delYsid> That should work nicely.
06:24:35 * shapr bounces
06:25:17 <resolve> delysid: i'm learning haskell too! :)
06:28:52 <shapr> resolve: TwistedHaskell will talk to TwistedEmacs ya know?
06:28:59 <shapr> I'm looking forward to that.
06:29:04 <shapr> hi spikeymik
06:29:54 <shapr> wassup?
06:30:10 <shapr> not much I guess :-)
06:32:25 <resolve> :)
06:32:42 <shapr> resolve: hey, tried the haskell-mode yet?
06:33:27 <resolve> yep! but my first.hs is only 4 lines at the moment, doesn't run in ghc (something about namespace problems), and doesn't do much
06:33:32 <resolve> so i haven't really had a chance to try out the mode :)
06:33:42 <shapr> the most basic first.hs could be:
06:33:48 <shapr> module Main where
06:33:53 <shapr> main = putStr "foo"
06:34:13 <resolve> ahh, hugs doesn't require the module bit
06:34:36 <shapr> oh
06:35:04 <resolve> hmm
06:35:22 <resolve> first.hs:1: Variable not in scope: `main'
06:35:31 <resolve> line 1 is: module Main where
06:35:41 <resolve> oh duh
06:35:43 <shapr> ?
06:36:00 <resolve> didn't assign to main :)
06:36:10 <shapr> oh
06:38:23 <resolve> shapr: do i have to do anything special to be able to access other functions defined in the where block?
06:38:46 <resolve> i've been spoilt by the simplicity of hugs so far :)
06:38:47 <shapr> nope
06:39:01 <shapr> with haskell-mode, assuming you've done M-x turn-on-haskell-ghci
06:39:11 <shapr> then C-c C-l
06:39:25 <shapr> and you can now run any functions defined in the buffer where you hit C-c C-l
06:40:12 <resolve> Main> deadd 3 4
06:40:12 <resolve> <interactive>:1: Variable not in scope: `deadd'
06:40:20 <resolve> where:
06:40:20 <resolve> deadd :: Int -> Int -> Int
06:40:20 <resolve> deadd = (+)
06:40:33 <shapr> then you hit C-c C-l in that buffer?
06:40:54 <resolve> which buffer?
06:41:02 <shapr> in the haskell source bufer
06:41:05 <shapr> er "buffer"
06:41:17 <resolve> yep
06:41:22 <resolve> i get a *ghci* buf
06:41:24 <shapr> right
06:41:38 <resolve> but typing 'deadd 3 4' in that gives me something about variable not in scope
06:41:38 <shapr> and it should have saved your .hs file, and then loaded it into ghci
06:41:41 <resolve> does it have to do with this?
06:41:45 <resolve> Skipping  Main             ( /home/resolve/first.hs, /home/resolve/first.o )
06:41:46 <resolve> Ok, modules loaded: Main.
06:42:18 <shapr> hm
06:42:25 <resolve> ahh, it seems it was the .o file that was causing problems
06:42:26 <shapr> can you paste your source?
06:42:29 <shapr> oh
06:42:30 <resolve> i removed that and it works :)
06:42:53 <shapr> I wonder why
06:43:19 <resolve> me too. i had compiled it earlier, but i'm pretty sure deadd was defined then
06:43:27 <shapr> weird
06:43:38 <shapr> hey, cool tricks to try in ghci
06:43:48 <shapr> [1..9]
06:43:58 <shapr> [1,3..12]
06:44:19 <resolve> yeah, i recompiled, same thing. the .o file seems to change whether my functions are available
06:44:47 <shapr> foldr1 (+) [1..9]
06:44:54 <resolve> hey that's crazy :)
06:45:02 <Heffalump> it is?
06:45:11 <resolve> as in good :)
06:45:32 <shapr> map show [1..9]
06:45:52 <shapr> map show $ map (+ 1) [1..9]
06:46:29 <resolve> lots of nifty things i need to learn about. :-)
06:47:00 <shapr> you know about partial evaluation?
06:47:07 <resolve> how so?
06:47:14 <resolve> lazy evaluation or something else?
06:47:19 <shapr> like "let addOne = (+ 1)"
06:47:22 <resolve> i'm only up to chapter 3 of thompson :)
06:47:27 <shapr> then  "addOne 1"
06:47:31 <shapr> or "addOne 4"
06:47:47 <resolve> yeah, i've picked that up, thought don't have a firm grasp on how it works just yet
06:48:03 <shapr> it's a great FP koan I think
06:48:18 <shapr> you saw that type that said Int -> Int -> Int right?
06:48:35 <resolve> yeah, i wrote that :)
06:48:40 <shapr> right
06:48:55 <shapr> in reality though, every function in Haskell takes only one argument, and returns only one argument
06:49:02 <shapr> the -> operator is right associative
06:49:09 <shapr> so in fact, that type is really this:
06:49:12 <shapr> Int -> (Int -> Int)
06:49:22 <shapr> which means it returns a new function of type Int -> Int
06:50:19 <shapr> make sense?
06:51:20 <shapr> maybe I should have waited and told you after you'd read more of the Thompson book?
06:51:56 <resolve> oh that's okay, i tend to like knowing what's going on exactly rather that taking things at face value
06:52:12 <shapr> ok, cool
06:52:30 <resolve> i remember you mentioning about the '1 argument, 1 return' thing on #emacs or somewhere, i figured that was the reason why the parameter lists are written in the way they are
06:52:38 <resolve> (which certainly look a bit odd when you're not used to haskell :)
06:52:50 <shapr> yah, I agree.
06:52:56 <shapr> it confused me at first
06:53:02 <shapr> now I love it :-)
06:53:49 <resolve> :-)
06:54:07 <shapr> I use partial evaluation to make "instances"
06:54:36 <shapr> for example, my mandelbrot code has a bail function that check whether to stop iterating
06:54:55 <shapr> the first argument it takes is an integer of "maxIters"
06:55:10 <shapr> so I make an 'instance' like "bail200 = bail 200"
06:55:23 * delYsid bounces happliy
06:55:35 <shapr> and then I can say doPoint z c = until bail200 oneIter (MandelData (0, z, c))
06:56:38 <shapr> hi delYsid! you got the doc?
06:57:04 <delYsid> yeah, gimme a week or so, then I'll have cought up again :)
06:57:11 <shapr> w00!
06:57:45 <delYsid> shapr: Thanks for acting as "author finder" :)
06:57:57 <resolve> shapr: it looks interesting, though i'm not quite there yet. all this nifty stuff you've shown me has motivated me to read the book faster now :)
06:58:03 <shapr> yay!
06:58:19 <shapr> delYsid: sure, anytime
06:58:53 <resolve> i need to get some rest for now though. i'll see you guys later :)
06:59:10 <shapr> g'night!
06:59:14 * shapr bounces
07:00:04 <shapr> delYsid: entirely selfish reasons come into this as well. I know I learn something faster when you're learning the same thing at the same time.
07:01:55 * shapr bounces off to do Zopey stuff.
08:22:31 * shapr bounces
09:37:13 <delYsid> fantastic
09:37:32 <delYsid> Binding vars and functions has the same syntax, smooth
09:37:52 <rozzin> Hm.
09:39:26 * delYsid is a Haskell newbie.
09:39:34 <delYsid> With lots of Lisp background...
09:40:13 <shapr> hi rozzin
09:40:20 <shapr> hi redcrosse
09:40:27 * rozzin waves.
09:40:42 <redcrosse> heya
09:40:47 <shapr> rozzin: I don't think I've seen you here before.. do you bring questions or answers?
09:41:01 <rozzin> Nope :)
09:41:23 <shapr> delYsid: you have hugs or ghc installed?
09:41:25 <shapr> I like ghci
09:41:34 <redcrosse> how come?
09:41:46 <shapr> because you can do bindings in it
09:41:52 <shapr> let x = (+ 1)
09:41:58 <shapr> map x [1,2,3]
09:42:12 <redcrosse> oh.
09:42:32 <shapr> also because ghci has Socket stuff
10:02:59 <delYsid> Prelude> fct :: Int -> Int
10:02:59 <delYsid> <interactive>:1: Variable not in scope: `fct'
10:03:06 <delYsid> What am I doing wrong there?
10:03:28 <ibid> the prompt does not take declarations
10:03:31 <ibid> write them to a file
10:03:56 <delYsid> ahh, really?
10:03:59 <ibid> (ghci or hugs?)
10:04:01 <delYsid> How should I use it interactively then?
10:04:09 <delYsid> ghci
10:04:49 <ibid> try the let syntax above
10:07:11 <delYsid> let inc = (+1)
10:07:17 <delYsid> inc 1 ) 2
10:07:25 <delYsid> fascinating!
10:15:20 <delYsid> shapr: Are there any nice tools for ghc and Emacs?
10:15:56 <ibid> delYsid: haskell-mode works, sort of
11:42:58 <delYsid> hmm, is ghci really ment to be used interactively?
11:43:09 <delYsid> I thought I could try out function definitions there.
11:47:30 <ibid> it's ghc interactive :-)
11:47:54 <ibid> you can try them out, but it's better to put defs in files, so you have them somewhere for later use
11:47:59 <ibid> :reload is your friend
12:34:42 <shapr> delYsid: still around?
12:48:05 <shapr> For Loops: part of a balanced NP-complete breakfast.
12:48:07 <shapr> from #emacs
13:25:32 <Igloo> Howdy
13:26:56 <shapr> hey
13:27:00 <shapr> it's Tom Moertel!
13:27:04 <shapr> famous ICFP contestant!
13:27:21 <shapr> and Igloo! famous hemispherical frozen water shape!
13:29:05 <shapr> hey tmoertel, do you already have plans to do an ICFP entry?
13:30:12 <Igloo> I'm not convinced - doesn't hemisphere imply half of a *solid* sphere?
13:30:26 <shapr> um
13:30:28 <Igloo> And don't even get me started on the entrance tunnel...
13:30:30 * shapr thinks about that.
13:30:36 <shapr> uh oh
13:30:40 <shapr> Igloo: I concede!
13:30:49 <Igloo> You are a wise man, young shapr
13:30:59 <shapr> Igloo: but now, you have to tell me what is the correct technical explanation for your shape?
13:31:14 <Igloo> "Igloo shaped"
13:31:16 <Igloo> HTH, HAND.
13:31:43 * shapr laughs
13:32:53 * shapr sings
13:34:15 * shapr decides it's time to get hacking
13:34:30 <shapr> hm, it's 11:30pm, probably not a good time to drink lots of coffee.
13:35:55 <shapr> tmoertel: hey, I sent you an email about the ICFP contest, and my computer crashed at nearly the same time.
13:35:58 <shapr> tmoertel: did you get that email?
13:43:10 <tmoertel> shapr: no, i didn't get the email
13:45:28 <shapr> well then
13:45:42 <shapr> are you already committed during the ICFP contest time?
13:46:03 <tmoertel> actually, yes, I'm on team \beer
13:46:33 <shapr> ok
13:47:00 <shapr> your kuro5hin writeup inspired me to start a #haskell team
13:47:26 <tmoertel> that's a cool idea
13:47:29 <tmoertel> do you have any takers yet?
13:47:43 <shapr> yah, see the HaskellWiki url in the topic :-)
13:48:18 <shapr> net accessible CVS courtesy of Andrew Bromage, aka Pseudonym on #haskell
13:48:48 <Igloo> I know where I should be living during it now. I ought to have 'net access too, and the odds are I'll actually be in the right city
13:48:55 <shapr> yay!
13:49:04 <tmoertel> wow, you are *organized*.  great work!
13:49:10 <shapr> Igloo: does this mean you're up to 75% sure you'll be participating?
13:49:30 <shapr> oh, jewel isn't listed on the page yet.
13:49:48 <shapr> tmoertel: I'm organized because I heeded the lessons in your write-up =)
13:49:54 <Igloo> shapr: If BT and $ISP get their act together the chances are good I'd say
13:50:02 <shapr> hah
13:50:05 <shapr> excellent
13:50:15 <tmoertel> I wish I would heed my lessons more. ;-)
13:50:18 * shapr laughs
13:51:04 <shapr> I need to work with QuickCheck more
13:51:24 <shapr> I use HUnit regularly, but that's all.
13:51:24 <tmoertel> QuickCheck *rules*
13:52:01 <shapr> it's a strange kind of testing to me.
13:52:05 <shapr> my native lang is Python
13:52:13 <shapr> well, native programming language.
13:52:36 <tmoertel> which, then, by inference I can conclude that you are, deep within, a Schemer?
13:52:41 <shapr> uh
13:52:44 <shapr> I dunno :-)
13:52:52 <shapr> I like Scheme, though I haven't used it much.
13:53:00 <shapr> I like Haskell a lot more though.
13:53:08 <tmoertel> don't we all? ;-)
13:53:16 <shapr> it is rather addictive.
13:54:04 <shapr> it seems so much more orthogonal than anything else I've used.
13:54:42 <tmoertel> the s/n ratio is the best I've ever seen in a programming language
13:54:50 <shapr> have you tried Joy?
13:55:00 <tmoertel> nope. what's its history?
13:55:14 <shapr> it's a concatenative stack-based purely functional lang.
13:55:22 <shapr> Haskell can be too concise at times.
13:55:32 <shapr> Joy just is too concise.
13:55:40 <shapr> in some ways it's very elegant
13:55:50 <shapr> because you never give names to your function arguments
13:56:01 <shapr> and functions are just a polite convention anyway, they don't really exist.
13:56:31 <shapr> DEFINE pairs == [["ward" "shae"] ["shae" "irene"] ["shae" "al"] ["al" "jewel"] ["irene" "lynda"] ["lynda" "jewel"]] .
13:56:31 <shapr> DEFINE buildFilter == [] cons [first] swap concat [=] concat .
13:56:31 <shapr> DEFINE collectEdges == pairs swap buildFilter filter .
13:56:42 <shapr> that's part of a connected graph algorithm
13:57:20 <shapr> http://c2.com/cgi-bin/wiki?JoyLanguage
13:59:24 <shapr> http://c2.com/cgi-bin/wiki?WardNumberInManyProgrammingLanguages
13:59:35 <tmoertel> interesting, especially the "quoting" aspects
13:59:39 <shapr> I wrote a crappy WardNumber implementation in JoyLanguage near the bottom of that page.
13:59:59 <shapr> yah, the ability to operate on quoted subprograms which are also lists is powerful and fun.
14:01:07 <smkl> instead of giving names to arguments you need to use swap and other hacks to access them, bit like pointfree haskell
14:03:18 <shapr> for some things, that's far more elegant
14:03:21 <smkl> [...] stuff is mostly needed for same kind of stuff as parentheses in normal languages
14:04:19 <shapr> in Haskell, more of the content of my programs is implied rather than explicit.
14:06:36 <shapr> Joy takes that another step further by operating exclusively on a stack.
14:06:39 <shapr> no names
14:06:58 <shapr> I'd like to see Joy used as a shell scripting language.
14:07:07 <shapr> I suspect it could be the Python of functional programming languages.
14:21:12 <shapr> tmoertel: written any haskell lately?
14:21:39 <tmoertel> I wrote a tool to convert a mini-markup langauge for slides into FoilTeX slides
14:21:46 <tmoertel> and my PFC 6 entry
14:22:35 <shapr> do you have your source online?
14:23:29 <tmoertel> the PFC 6 stuff is here: http://www.kuro5hin.org/story/2002/6/26/85025/3795
14:38:08 * shapr reads
14:44:22 <shapr> hey buggs, what's up?
14:45:00 <buggs> hey shapr
14:46:32 * shapr reads about QuickCheck ( http://www.cs.chalmers.se/~rjmh/QuickCheck/ )
15:04:51 * tmoertel must walk the dog...
15:06:07 <shapr> Human -> Dog -> Leash -> Tree -> umm
15:41:36 <shapr> hm
15:41:50 <delYsid> hey
15:41:56 <shapr> hi delYsid, wassup?
15:42:09 <shapr> want random tips on haskell-mode usage?
15:42:11 <delYsid> Trying to figure out how to use Haskell interactively
15:42:19 <delYsid> I cant seem to enter expressions in ghci
15:42:26 <shapr> if you have a haskell-mode buffer
15:42:33 <shapr> C-c C-l dumps the source into ghci
15:42:54 <shapr> ghci only lets you do some stuff, not everything.
15:43:00 <delYsid> hmm
15:43:01 <shapr> some parts need to be compiled
15:43:08 <shapr> but, that's as easy as C-c C-l in the source buffer.
15:43:20 <delYsid> Is there a haskell-mode deb?
15:43:22 <shapr> yup
15:43:26 <shapr> that's what I'm using.
15:43:35 * shapr considers drinking coffee
15:44:02 <shapr> how do you like the intro book by Chilli?
15:44:15 * shapr eyes rozzin
15:44:16 <delYsid> Its very good
15:44:39 <shapr> hello Mr Bromage.
15:44:41 <shapr> how ar ya?
15:44:47 <shapr> you have a cool website.
15:44:48 <Pseudonym> Not bad, not bad.
15:44:50 <Pseudonym> Oh, thanks.
15:44:56 * Pseudonym is married to a graphic designer
15:45:01 <shapr> wow, nifty :-)
15:45:18 <delYsid> Although I really dont grok the Formal Reasoning section.
15:45:25 <delYsid> Not enough math background.
15:45:35 <shapr> I'm just beginning to understand that section in the Thompson book.
15:45:44 <shapr> the QuickCheck tool explains much about that.
15:45:58 <shapr> Haskell is the first language where asserting properties about code makes sense.
15:46:27 <Pseudonym> Hrm.
15:46:33 <shapr> ?
15:46:37 <Pseudonym> Not really.  A type declaration is an assertion, too.
15:46:42 <Pseudonym> Lots of languages have that.
15:46:51 <shapr> that's true.
15:46:54 <shapr> design by contract is also.
15:47:04 <delYsid> What are literate-scripts?
15:47:08 <shapr> I think DBC may be a subset of QuickCheck though.
15:47:08 <Heffalump> assertions make sense in most languages
15:47:28 <shapr> delYsid: a .lhs file looks like an email reply
15:47:38 <shapr> the stuff after the > chars is the code
15:47:38 <Heffalump> lol
15:47:42 <shapr> everything else is comments
15:47:46 <Pseudonym> I think that in a pure language like Haskell, you can sensibly make _more_ assertions than you can in an impure language.
15:47:48 <Heffalump> well, it does if you don't top-quote
15:47:54 <shapr> top quote?
15:48:17 <Heffalump> reply above the stuff you're quoting
15:48:21 <shapr> hm
15:48:26 <Pseudonym> Although Mercury has "purity" as an assertion.
15:48:28 <shapr> why would anyone do that?
15:48:36 <shapr> Pseudonym: I haven't gotten to Mercury yet.
15:48:42 <Pseudonym> Not many have.
15:48:48 <shapr> it's on my list after Haskell.
15:48:51 * Pseudonym worked on the compiler, otherwise he wouldn't have either
15:48:59 <shapr> oh, wow.
15:49:09 <shapr> quickcheck: http://www.cs.chalmers.se/~rjmh/QuickCheck/
15:49:25 <shapr> lets you assert lots more properties about your code than any other testing framework I've used.
15:49:43 <shapr> I'm familiar with xUnit, and I've read some about Design By Contract
15:50:08 <shapr> Seems to me that DBC is less useful in a purely functional language.
15:50:23 <Heffalump> why?
15:50:49 <shapr> because so much more is explicit already.
15:51:15 <Pseudonym> I think it's more correct to say that DBC is less _used_ in pure languages.
15:51:22 <Heffalump> well, types
15:51:35 <Pseudonym> Types, sure.  But but preconditions and postconditions.
15:51:42 <Heffalump> in any complicated program the type doesn't tell you that much about an interface
15:51:46 <shapr> that's true.
15:51:49 <Pseudonym> I meant to say "not" rather than repeat "but".
15:51:59 <shapr> we read and speak fluent typo :)
15:52:20 <Pseudonym> Haven't finished my first coffee yet.  Having trouble with my worms.
15:52:28 <shapr> worms?
15:52:34 * shapr is afraid to ask.
15:52:38 <shapr> fingers?
15:52:40 <Pseudonym> Words.
15:52:43 <shapr> hah
15:52:47 <shapr> I guess I'm not as fluent as I thought.
15:53:17 * Pseudonym reminds himself not to try typing bad puns in future
15:53:29 <shapr> it was a good pun
15:53:38 <shapr> but it's 2am here, and I'm tired.
15:53:45 <Pseudonym> Anything is funny at 2am.
15:53:49 <shapr> that's true :-)
15:54:27 <delYsid> shapr: C-c C-l?
15:54:29 <delYsid> Doesnt work
15:55:02 <shapr> delYsid: M-x turn-on-haskell-ghci
15:55:06 <Pseudonym> I think that DBC is less used because pure languages remove a number of classes of bugs that DBC is designed to help diagnose.
15:55:07 <shapr> then try it
15:55:13 <shapr> I agree.
15:55:17 <Pseudonym> Not all, but some.
15:55:34 <shapr> I wonder if all of DBC could be done with QuickCheck?
15:55:57 <Pseudonym> When all data types are printable and outputs only depend on inputs, it's much easier to debug, at least in principle.
15:55:59 <shapr> I'd like to have xUnit, QuickCheck, and DBC available in every language I use.
15:56:09 <Pseudonym> Haskell debugging still has some way to go, of course.
15:56:13 <shapr> truly
15:56:16 <delYsid> /tmp/xy.hs:5: parse error (possibly incorrect indentation)
15:56:17 <delYsid> Failed, modules loaded: none.
15:56:25 <shapr> delYsid: if your source is short, paste it.
15:56:39 <Heffalump> shapr: QuickCheck doesn't prove specifications, so no
15:56:40 <delYsid> fct :: Int -> Int
15:56:40 <delYsid> fct 1 = 1
15:56:40 <delYsid> fct n = n*fct 1-n
15:56:40 <delYsid> fct 5
15:57:21 <shapr> hm
15:57:53 <Pseudonym> Actually, now that I think about it, DBC probably isn't used in Haskell because Haskell programmers are lazy.  And Haskell programmers are lazy because they can be.
15:59:11 <shapr> delYsid: try putting "module Test where" as your first line
15:59:48 <shapr> Heffalump: good point, DBC operates at run time as well
16:00:18 <delYsid> shapr: well, it still complains about the fct 5 call
16:00:42 <shapr> take the fct 5 out of the source, and try it in ghci
16:00:53 <Igloo> You can't just put "fct 5" in the source if that's what you are trying to do
16:00:54 <shapr> well, try it once you've loaded the source :-)
16:01:03 <delYsid> aha!
16:01:05 <Igloo> You can put f = fct 5 in
16:01:34 <delYsid> well, now I have to figure out whats wrong with my fct.
16:01:38 <shapr> :-)
16:01:58 <tmoertel> do you get 0 for the value of fct 5?
16:02:06 <delYsid> Test> fct 5
16:02:06 <delYsid> *** Exception: stack overflow
16:02:10 <Igloo> Do you want a hint?
16:02:10 <delYsid> w00t! :)
16:02:25 * shapr grins
16:02:34 <delYsid> hmm :)
16:02:45 <delYsid> first I got 0
16:03:00 <delYsid> now I've n-1, and get stack overflow, hmm
16:03:14 <tmoertel> think: parens
16:03:44 <delYsid> ahh,
16:04:41 <delYsid> fct :: Int -> Int
16:04:42 <delYsid> fct 1 = 1
16:04:42 <delYsid> fct n = n*fct (n-1)
16:05:01 <tmoertel> that looks good for n > 0
16:08:23 <shapr> trace gets confusing.
16:08:46 <Heffalump> yes, I have to take it out sharpish once I fix the bug I'm looking for
16:09:18 <Heffalump> or sometimes I define notrace _ v = v a then eithe rchange all the traces to no traces or remove the import of Trace and define trace=notrace instead
16:09:50 <shapr> there must be a better way.
16:10:07 <shapr> maybe I should check out hat
16:10:50 <delYsid> map fct [1..60] -- hehe
16:10:53 <shapr> heh
16:10:55 <shapr> evil :-)
16:11:06 <shapr> how long did that to calculate?
16:11:11 <delYsid> I had to change fct signature to make it work.
16:11:20 <delYsid> fct :: Num a => a -> a
16:11:23 <shapr> ah
16:11:34 <shapr> you know about => already?
16:11:35 <delYsid> It takes no time on my cpu.
16:11:38 <delYsid> Impressive
16:11:41 <shapr> how far have you gotten??
16:11:48 <delYsid> But I've to admit, I've upgraded to p4 2.2 lately
16:12:09 <delYsid> er, how far?
16:12:15 <shapr> 2.2 Ghz?
16:12:23 <delYsid> well, I've read 65% of the book already.
16:12:28 <shapr> oh. wow
16:12:32 <shapr> how long is the book?
16:12:38 <delYsid> 330k ascii
16:12:53 <shapr> wow. you read fast.
16:13:06 <Pseudonym> Most Haskell implementations don't thrash the CPU as much as they thrash memory.
16:13:06 <delYsid> no, viavoice does :)
16:13:20 <Pseudonym> I suspect you'd find no difference between that and a 1GHz CPU.
16:13:25 <Igloo> Why did you need to change the signature?
16:13:46 <delYsid> Igloo: With Int, I got sign errors.
16:13:59 <delYsid> With Num type-class, it appears to work.
16:14:22 <Igloo> sign errors?
16:15:02 <shapr> oh, I've already built and installed hat.
16:15:10 <delYsid> Go> map fct [1..20]
16:15:11 <delYsid> [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,1932053504,12789\
16:15:11 <delYsid> 45280,2004310016,2004189184,-288522240,-898433024,109641728,-2102132736]
16:15:45 <delYsid> Thats  fct :: Int -> Int
16:15:57 <Igloo> Oh, overflow, right
16:16:11 <shapr> is there some kind of test suite thingy for QuickCheck?
16:18:57 * shapr tries to figure out how to use hat
16:19:12 <delYsid> map fct [1..199] -- Wow, still completes in nearly no time
16:19:15 * delYsid is impressed
16:19:26 <clausen> why?
16:19:30 <clausen> you'd expect it to be fast
16:19:43 <clausen> it should take O(n²) time
16:19:55 <clausen> (I think... what's the complexity of multiplication?)
16:20:14 <Pseudonym> Multiplication is O((log n)^2)
16:20:34 <Pseudonym> Quadratic in the number of digits.
16:20:35 <clausen> ah, that sounds right
16:20:35 <clausen> thanks
16:20:42 <clausen> so, it would be O(nlog²n)
16:20:56 <Igloo> I thought only the results of CAFs were cached
16:21:04 * delYsid goes back to his learning material
16:21:18 <Pseudonym> Besides, the constants of proportionality are low.
16:21:41 <Pseudonym> The overhead of the Haskell interpreter probably dominates multiplication with such small numbers.
16:22:14 <delYsid> ha, in reality it's the output of the result :)
16:22:21 <delYsid> Emacs needs 99% of cpu, 1% ghci :)
16:22:40 <shapr> amusing
16:23:21 * delYsid needs to figure out closures today
16:23:21 * shapr reads the Hat tutorial
16:23:28 <shapr> delYsid: in which lang?
16:23:35 <delYsid> At least I'd like to know how to maintain some kind of local state
16:23:41 <delYsid> shapr: Haskell
16:25:12 <shapr> like what?
16:25:58 <delYsid> Like, binding some variable, and changing it later :)
16:26:37 <delYsid> btw, I very much like infix operators.
16:26:41 <delYsid> That's really cute stuff
16:26:41 <shapr> you only get constants in Haskell
16:26:44 <Pseudonym> You may be trying to solve the wrong problem.
16:26:47 <shapr> though you can pretend
16:27:15 <Pseudonym> Haskell has mutable variables, but it's often better to rethink to avoid them.
16:27:17 <delYsid> so what, I can't even imagine writing complex programs without assignment.
16:27:38 <delYsid> For simple functions and problem set, that may be easy, but...
16:27:54 <Pseudonym> It depends what you mean by "complex".
16:28:09 <shapr> you can do what is effectively assigment
16:28:15 <shapr> you just have to approach it differently.
16:28:38 <delYsid> well, let's say I've some internet protocol client written in haskel..
16:28:49 <Pseudonym> Had you been a programmer 40 years ago you might have said that you couldn't imagine writing complex programs without gotos.
16:28:51 <delYsid> Say that communicates with a server.
16:29:05 <delYsid> Now, that would need to maintain some kind of state in relation to the session.
16:29:13 <shapr> actually
16:29:14 <Pseudonym> Yes.
16:29:19 <shapr> I am writing an internet protocol thingy in Haskell
16:29:53 <delYsid> So, what is it that makes all that possible?
16:30:12 <delYsid> shapr: I've actually thought of writing hirc :)
16:30:15 <shapr> me too
16:30:16 <shapr> that would rock
16:30:42 <shapr> I've heard jens is interested in that idea also.
16:30:43 <Pseudonym> There's state and there's state.
16:30:48 <delYsid> But well, how'd I do some simple thing like current-nick?
16:31:10 <shapr> lemme email you Imap.hs, written by xbill aka wli
16:31:22 <Pseudonym> delySid, have you looked into the Monad Template Library?
16:31:22 <delYsid> k
16:31:45 <delYsid> Pseudonym: I'm a newborn fish a foreign waters.
16:31:50 <Pseudonym> Ah. :-)
16:32:00 * delYsid started his first Haskell book 5h ago...
16:32:06 <Pseudonym> Once you've got the hang of monads, the MTL is your next step.
16:32:29 <Pseudonym> If you want exceptions, continuations, state, and you want them all together, the MTL is your friend.
16:32:31 <shapr> delYsid: should I send to lexx specifically?
16:32:39 <delYsid> no
16:32:41 <shapr> ok
16:32:48 <delYsid> shapr: mlang@delysid.org
16:32:59 <delYsid> well, C-x o
16:33:36 <shapr> sent
16:37:01 * shapr suspects Math is hard
16:38:34 <shapr> anyone using hat here?
16:39:28 * shapr grumbles
16:41:29 <Pseudonym> Apparently not.  Even so, what's you rproblem?
16:42:22 <shapr> hmake -hat Test_Banana.hs fails because it can't find TPrelude.fnegate
16:42:39 <shapr> it appears that hat uses a custom Prelude that's instrumented
16:42:50 <shapr> there are several negate functions
16:44:07 <shapr> gnegate, pnegate show up immediately. I'm not sure what fnegate is though.
16:47:07 <shapr> looks like Hat generates new instrumented source files for each existing source file
16:50:04 <Pseudonym> module Math (isHard) where
16:50:06 <Pseudonym> isHard = True
16:51:15 <shapr> truly
16:52:06 * shapr subscribes to the hat mailing list
16:52:24 <shapr> looks like a bug.
16:53:26 <Pseudonym> Or a nontrivial dependency.
16:53:37 <Pseudonym> Which is a configuration management bug.
16:54:30 <shapr> I think the prefixed letters show type specialized tracing replacements
16:54:51 <shapr> it appears to be trying to negate a file handle.
17:08:40 <Pseudonym> Does ghci have a way to show the strictness of a function?
17:09:51 <shapr> not that I can see
17:10:40 <tmoertel> Which version of GHC are you using?
17:10:56 <Pseudonym> 5.02.2
17:11:19 <tmoertel> You can get the strictness information by examining the .hi files.
17:11:34 <Pseudonym> Only for exported functions.
17:11:53 <Pseudonym> My problem was that I had a function that was running much faster in hugs than in ghci.
17:12:39 <Pseudonym> I guessed (correctly, as it turned out) that it was because the strictness analyser in GHC wasn't analysing one of the functions correctly.
17:13:13 <Pseudonym> By "correctly", of course I mean "too conservatively". :-)
17:14:14 <Pseudonym> Addition of one strict apply fixed the problem.
17:15:27 <Pseudonym> The problem is that I use a lot of CPS, and CPS interacts badly with strictness analysis.
17:17:38 <Pseudonym> Oddly enough, the number of times I've written factorial, especially with students, and this is the first time I've actually _needed_ it in a real program.
17:17:50 <Pseudonym> And it turns out to be too slow!
17:18:06 <tmoertel> Did you use fact n = product [1..n] ?
17:18:17 <Pseudonym> Originally.
17:18:38 <tmoertel> Was (*) applied lazily in its second argument?
17:18:41 <Pseudonym> Then I went to accumulator recursion with strict apply, and it used _more_ memory.
17:18:52 <Pseudonym> Though much less time.
17:19:01 <Pseudonym> Now I'm using a better algorithm.
17:19:15 <Pseudonym> Original: fac:  (44.39 secs, 419288472 bytes)
17:19:22 <Pseudonym> Final: fac3: (24.93 secs, 335104364 bytes)
17:19:39 <Pseudonym> That's for the factorial of 10000
17:19:50 <tmoertel> Your second version was fac2 n = foldl' (*) 1 [1..n] ?
17:19:58 <Pseudonym> No, it was:
17:20:03 <Pseudonym>         fac2' 1 acc = acc
17:20:04 <Pseudonym>         fac2' n acc = fac2' (n-1) $! (n*acc)
17:20:10 <Pseudonym> With the appropriate wrapper.
17:20:21 * tmoertel fires up GHCi
17:22:23 <Pseudonym> This is the final one: http://alicorna.net/Factorial.hs
17:30:32 <tmoertel> On my host, fac3 10000 takes 0.44 sec, and the foldl' version takes 0.87 sec.
17:31:24 <Pseudonym> This machine only has 128Mb of RAM.
17:31:37 <tmoertel> This has 256 MB.
17:31:49 <Pseudonym> Oh, and it's a slower CPU too.
17:31:59 <tmoertel> This is PII/233.
17:32:06 <tmoertel> (Laptop.)
17:32:11 <Pseudonym> This is an original Pentium.
17:32:21 * Pseudonym chooses weird machines to develop on sometimes
17:32:22 <tmoertel> Ouch!
17:33:19 <Pseudonym> Just goes to show, though: Use a better algorithm.
17:51:02 <delYsid> Chilli: Still there?
17:54:30 * delYsid stares at http://alicorna.net/Factorial.hs and doesnt understand it at all
17:58:12 <shapr> delYsid: which parts?
17:58:27 <delYsid> ahem :)
17:58:43 <shapr> that much? :-)
17:58:43 <delYsid> (\nn r -> r) e.g.
17:58:46 <shapr> oh
17:58:59 <shapr> that's a lambda
17:59:09 <shapr> (\x -> x + 1)
17:59:30 <shapr> if you have ghci open:
17:59:31 <Pseudonym> It's an anonymous function
17:59:33 <delYsid> let nn' = nn+1 in k nn' $! nn' ?????
17:59:36 <shapr> let x = \y -> y + 1
17:59:46 <Pseudonym> $! is strict apply
17:59:55 <Pseudonym> It's like k nn' nn' only it evaluates nn' first.
18:00:42 * delYsid has a long way to go
18:00:51 <Pseudonym> It also might help to know the CPS idiom.
18:00:52 <Pseudonym> http://haskell.org/wiki/wiki?ContinuationPassin
18:00:59 <Pseudonym> http://haskell.org/wiki/wiki?ContinuationPassingStyle
18:01:14 <shapr> you can also use http://purl.org/wiki/haskell/ContinuationsPassingStyle
18:01:25 <Pseudonym> Yes, that too.
18:01:50 <shapr> not much shorter for HaskellWiki
18:02:49 <delYsid> How are things like
18:02:50 <delYsid> (+1)
18:02:52 <delYsid> called?
18:02:59 <shapr> partially resolved function?
18:03:08 <Pseudonym> (+1) means \x -> x+1
18:03:29 <Pseudonym> Or (let f x = x+1 in f)
18:03:55 * Chilli is back (gone 16:49:24)
18:04:25 <delYsid> Pseudonym: What does the 'in f' do there exactly?
18:04:33 <shapr> delYsid: it's like let
18:04:37 <shapr> in elisp
18:04:43 <shapr> the in part denotes the body
18:04:53 <Pseudonym> Consider: let one = 1 in one+2
18:04:57 <Pseudonym> That returns 3.
18:05:04 <Pseudonym> Like a where clause.
18:05:23 <delYsid> ah, the in separates the binding part from the body.
18:05:26 <Pseudonym> Well (let f x = x+1 in f) defines a function then returns it.
18:05:54 <Pseudonym> Right.
18:06:24 <shapr> time for me to sleeep
18:06:26 <shapr> g'night all
18:06:40 <delYsid> (lambda (x) (+ x 1))
18:06:44 <Pseudonym> G'night.  Don't forget to send me that password thingy.
18:06:48 <shapr> oh rgiht
18:07:40 <shapr> y0 liiwi
18:07:41 <shapr> wassup?
18:08:09 <liiwi> yoyo
18:08:30 <dark> I didn't even know there was a #haskell here :)
18:08:33 <liiwi> shapr, meet dark
18:08:38 <shapr> hi dark
18:08:45 <shapr> wassup?
18:09:09 <shapr> Pseudonym: thingy sent
18:09:15 <liiwi> dark has discovered haskell
18:09:16 <Pseudonym> Thnaks muchly.
18:09:20 * liiwi starts this like AA meeting
18:09:26 <shapr> Pseudonym: nay, thanks to you :-)
18:09:36 <dark> shapr: liiwi invited me here because we were talking about Haskell on #debian-devel :)  I'm writing my next project in Haskell.  I'm a bit rusty, the last time I used it was at the university.
18:09:39 <shapr> hi dark, I'm glad you've found the light side of the force.
18:10:06 --- topic: set to 'GHC 5.04 released http://www.haskell.org/ghc/download_ghc_504.html || http://icfp2002.cs.brown.edu/ - looking for team members for a #haskell ICFP contest entry, more info on http://purl.org/wiki/haskell/IcfpContest || Welcome to Haskellers Anonymous' by shapr
18:10:14 <Pseudonym> What's the project?
18:10:23 * shapr is also curious
18:10:53 <Pseudonym> My name is Pseudonym, and I use... Haskell.  *sob*
18:11:04 <Pseudonym> Haskell Anonymous.
18:11:11 * shapr snickers
18:11:22 * shapr laughs more
18:11:34 <shapr> Pseudonym: at 4am, things are even more funny than at 2am.
18:11:36 <dark> A decompiler :)  It will transform executables back to C when it's done.  Probably with a hint file.  I'm targeting only ELF x86 for the first version.
18:12:15 <dark> I've done that by hand for a few programs already, I'm seeing how much of it I can automate.
18:12:37 * Pseudonym thinks the dataflow analysis will be tricky
18:12:54 <dark> Pseudonym: But eminenly suited for Haskell, right? :)
18:13:01 <Pseudonym> Well, yes...
18:13:11 * shapr puts the ICFP 2002 #haskell mailing list url on the IcfpContest page
18:13:17 <Pseudonym> Cool.
18:13:55 <shapr> anything else you can think of that would get the #haskell team closer to victory?
18:14:06 <dark> My inspiration to actually write the thing was the Honeynet Reverse Challenge (http://honeynet.project.org/reverse/).  There's a real need for decompiling code found in the wild.
18:14:48 <liiwi> heh, no crap
18:15:55 <Chilli> dark: cool project
18:15:55 <Pseudonym> Suggestion: You might want to start with single subroutines in assembler format.
18:16:25 <dark> The ICFP contest will be of the type "here are some puzzles; write solver programs in a limited time"?
18:16:31 <shapr> dark: yup
18:16:37 <Pseudonym> Like the output of "objdump -d"
18:17:04 <dark> Pseudonym: Hmm, how do you mean?
18:17:27 <shapr> dude, it's 4:15am in .fi, why are we awake?
18:17:31 <dark> Pseudonym: Something like void movl(void *src, void *dst) ?
18:17:34 <Pseudonym> On the ICFP: I think what you need is some practice with writing code which produces successively better answers to some problem, which is killed after some time limit.
18:17:37 <dark> shapr: Because it's summer :)
18:17:47 <shapr> Pseudonym: suggestions?
18:18:10 <Pseudonym> dark: I was thinking of just doing "objdump -d" on some program, pulling out a random function and trying that.
18:18:13 <shapr> I was thinking that practice in team solving might also be useful.
18:18:27 <dark> Pseudonym: Ah, you referred to testing and not implementation :)
18:18:49 <Pseudonym> shapr: Dunno.  Maybe start with something simple like Newton-Raphson root finding.
18:19:00 * shapr googles
18:19:04 <dark> Pseudonym: I plan to use the binary from the Honeynet challenge for testing.  I already did that one by hand, so I know it intimately.
18:19:26 <Pseudonym> OK.  I dunno if that comes in simple subroutines.
18:19:40 <Pseudonym> BTW, decompiling C++ code is _hard_.
18:19:58 <Pseudonym> Exception handing is write-only.
18:20:12 <dark> Pseudonym: Yeah, it does.  It also has an interesting feature: a function that was completely inlined by gcc, but which still has object code (which is never called) in the binary.
18:20:35 <Pseudonym> Very cool.  Well, I wish you luck.  Let us know how you're going.
18:20:46 <dark> Pseudonym: Yeah my first target is code compiled with a C compiler.  Maybe even specifically gcc :)  Decompiling C++ code is probably not as hard as decompiling Haskell code, BTW :)
18:21:12 <Pseudonym> Decompiling Haskell code isn't as hard as you think, at least if you decompile to C.
18:21:19 <dark> Pseudonym: I know from by-hand practice that it's possible to "decompile" code that was originally written in assembler, though.  As long as it's not self-modifying.
18:21:37 <Chilli> dark: definitely go with C first and stick to code from a specific compiler
18:21:42 <Pseudonym> shapr: I'll post a simple problem to the list.
18:21:44 <dark> Pseudonym: hmm, but I've seen the C that ghc generates.  It sort of defeats the point if the C is not readable :)
18:21:51 <shapr> Pseudonym: cool, thanks
18:22:00 <Pseudonym> C = high-level assembler
18:22:12 <Chilli> dark: if you are out to decompile code like stuff you might find in a honeyney, I guess, a lot of the code will have been produced by a C compiler
18:22:43 <dark> Chilli: Right, especially for portability.  No script kiddie wants to install a C++ compiler on a random machine :-)
18:22:53 <Pseudonym> Quite. :-)
18:24:36 <dark> I was glad to find that ghc has Word32 and Word64 types, by the way.
18:24:49 <dark> My first try at this project was in Java (boo, hiss), and I was dismayed to find that it had no unsigned long :)
18:24:58 <shapr> gick
18:25:00 <shapr> Java
18:25:08 <shapr> I'm an not fond of Java.
18:25:16 <dark> shapr: Thank liiwi for pushing me to the True Way :)
18:25:22 <shapr> heh :-)
18:25:24 <shapr> thank you liiwi!
18:25:25 <dark> shapr: I hadn't used it for a real project before, I wanted to give it a chance.
18:25:34 <dark> shapr: ... it failed :-)
18:25:37 <shapr> I've been using Java since it was beta
18:25:49 <shapr> when it was the only language I knew, I liked it.
18:25:52 <shapr> then I found Python.
18:26:23 <Chilli> dark: in the module Foreign.C, you will find Haskell types for all C basic types
18:26:39 <Pseudonym> I used Miranda before Python, Perl or Java.
18:26:53 <Pseudonym> Back in the days before the Haskell standard.
18:27:11 <shapr> I'm such a newbie :-)
18:27:12 <Pseudonym> I also used Orwell and Miracula.
18:27:19 <Pseudonym> And Gofer, of course.
18:27:28 <shapr> hey, I used Basic on a Sinclair Spetrum
18:27:30 <shapr> er
18:27:32 <shapr> Spectrum
18:28:11 * shapr falls over unconscious
18:28:17 <Pseudonym> Sleep.
18:29:00 <dark> Chilli: I'm using the Word types because I want to be independent of the native platform.  Even though it'll be an x86 decompiler in the first version, it should be possible to run it on an Alpha :)
18:29:23 <dark> Yeah, Gofer was my first functional language.
18:29:58 <Pseudonym> Gotta love continuation-based IO.
18:32:39 <dark> shapr: That programming contest doesn't sound like my kind of thing.  I prefer turn-based to realtime :-)
18:37:15 <liiwi> game of freeciv, someday?
18:37:39 <dark> liiwi: Hmm freeciv is realtime if you play with CosmicRay :)
18:38:01 <Pseudonym> You mean one turn year equals one real year?
18:38:04 <liiwi> do you see him around? :P
18:38:13 <dark> I lovehate it when I suddenly see a way to simplify a page of code to a couple of lines.
18:38:29 <liiwi> *poof*
18:39:32 <dark> Pseudonym: No, other way around :)  He's fast, and FreeCiv uses fastest-click-goes-first rules for movement, including attack.
18:39:59 <dark> liiwi: Have you ever tried Spellcaster?  It's in the spellcast package.
18:40:10 <liiwi> hrm. no
18:46:50 <liiwi> hmm. was there some game like that on c64 or spectrum?
18:52:01 <dark> liiwi: might have been, it's pretty old.
18:52:17 <liiwi> wizardry or something like that
18:52:48 <dark> liiwi: A different wizardry than the classic Wizardry series?
18:53:16 <dark> (which I also decompiled, btw, in order to get out of a place where I was stuck :)
18:53:54 <liiwi> hrm. I've forgotten
19:07:25 <dark> It compiles without warnings.  I can go sleep now :-)
19:08:13 * Pseudonym has been hanging around comp.lang.prolog far, far too long
19:08:41 <liiwi> bedtime for me too
19:08:55 <dark> Pseudonym: I never got the hang of prolog.  It simultaneously tries to hide all details of execution from you, and expects you to intimately know the sequence of execution so that you can insert those dang !'s.
19:09:11 <Pseudonym> Yes.  Use Mercury instead. :-)
19:09:30 <dark> Pseudonym: I'll stick with Haskell for a while :)
19:09:44 <Pseudonym> It's a tradition on c.l.p to answer homework questions with answers which are 100% correct and 0% helpful.
19:10:29 <Pseudonym> Unfortunately I've started doing it everywhere else, now.
19:11:19 <liiwi> ooh, lovely, grey morning outside
23:37:18 <Pseudonym> I've set up the ICFP team CVS repository.
23:38:15 <Pseudonym> If you don't have an account (and you know if you do or not) you can't get to it, so sign up for the mailing list and ask.
