01:16:00 <shapr> y0 shreya
01:44:40 <shreya> hey
02:29:28 * shapr bounces
02:41:25 <hornby> hey shap man
02:41:36 <shapr> hey hornby, what's up?
02:42:00 <hornby> not much. bored :)
02:42:14 <hornby> I think I've given up on my haskell project
02:42:19 <hornby> for now anyway. 
02:42:39 <shapr> aww :-(
02:43:10 <hornby> I've not given up on haskell, just the project :)
02:43:19 <hornby> but yeah, it was just too frustrating
02:43:52 <shapr> I'd suggest starting something smaller that you can write in one sitting.
02:43:59 <hornby> ya, definately :)
02:44:11 <shapr> that's the best way to start with anything new.
02:44:18 <hornby> I got a little ahead of myself :) How's your project going? 
02:44:32 <shapr> I'm nearly done with Banana.hs
02:44:41 <hornby> awesome
02:44:57 <shapr> I just need to get Floats dealt with as Doubles, and then all my unit tests will pass.
02:45:06 <shapr> then I'll get to start on the next layer up, Jelly.hs
02:45:34 <hornby> still working on that double problem? ieee 374 or whaever?
02:45:52 <shapr> nah, I got that figured out about an hour after the last time I talked to you about it.
02:45:58 <hornby> cool :)
02:46:11 <shapr> talking to you abouh it those two times really helped :-)
02:46:16 <hornby> Figure Jelly is easier or harder?
02:46:27 <hornby> yeah, I guess sometimes it helps to think outloud :)
02:46:31 <shapr> yah it does.
02:46:41 <shapr> I think Jelly will be mostly easy
02:46:53 <shapr> there's one part that everyone says is hard
02:47:07 <shapr> that being serialization of recursive lists
02:47:29 <shapr> I think it'll be easier in Haskell, but the #twisted guys aren't so sure.
02:48:01 <hornby> hm. 
02:48:20 <hornby> Well, you'll find out soon enough. :) Then there is the final layer on top, right? 
02:48:33 <shapr> I've looked at test_jelly.py and jelly.py very shortly, but not enough to know much about it.
02:48:48 <shapr> yah, after Jelly.hs, only PB.hs will be left!
02:49:21 <hornby> PB is less complex? 
02:49:28 <hornby> More high level? 
02:49:48 <shapr> I think it's like TCP on top of UDP
02:49:52 <shapr> so in some sense, yes...
02:50:34 <shapr> I don't remember exactly what PB does..
02:50:35 * shapr goes to look
02:50:41 <hornby> heh
02:52:00 <shapr> http://www.twistedmatrix.com/products/spread
02:54:50 <hornby> I dont' really understand spread
02:54:58 <shapr> I vaguely understand it
02:55:20 <shapr> in one sense it's a Remote Procedure Call mechanism
02:55:27 <shapr> much like xml-rpc, CORBA, etc
02:55:28 <hornby> i mean I get the basic idea, but I don't understand what it would look like
02:56:02 <shapr> banana just turns some basic datatypes into a bit-level standard format
02:56:25 <hornby> right, which is neat. important. but ... dull
02:56:32 <shapr> yah banana is dull
02:56:38 <shapr> jelly is a bit more exciting
02:56:41 <shapr> pb is even more exciting
02:56:42 <hornby> very low level
02:56:56 <hornby> well what does jelly do, I'm unclear on that
02:57:08 <hornby> I mean, it and banana are very closely linked. 
02:57:15 <hornby> Almost two sides of the same process?
02:57:19 <shapr> jelly takes objects to serialize and calls banana to do the actual serialization
02:57:34 <hornby> Right ... so its just a useless data passing later? 
02:57:37 <hornby> er alyer
02:57:52 <hornby> er. whatever. bah. 
02:58:03 <shapr> part of what jelly does is break down complex pieces into small chunks banana can understand
02:58:22 <hornby> Ah .. 
02:58:38 <hornby> takes big complex objects and turns it into "lists of strings and numbers"
02:58:38 <shapr> for example, complex Haskell datatypes
02:58:42 <shapr> riiight
02:58:54 <hornby> Are there examples of data lying around somewhere? 
02:59:00 <hornby> Hrm, maybe I"ll read the tests
02:59:05 <shapr> that's what I did
02:59:08 <shapr> first I read the tests
02:59:15 <shapr> but there are examples in the top of jelly.py
02:59:42 <shapr> Dictionary: {'a' : 1, 'b' : 'c'} --> ['dictionary', ['b', 'c'], ['a', 1]]
02:59:45 <shapr> that's one example
02:59:48 <hornby> ah, yeah, that one caught my eye
02:59:52 <shapr> obviously a dictionary is a Python datatype
03:00:00 <hornby> interesting. 
03:00:10 <shapr> but you can break it down into a list of strings easily
03:00:20 <shapr> and banana understands lists and strings
03:00:37 <hornby> so cool
03:00:45 <hornby> and then pb sends it over the wire
03:00:54 <shapr> I think so :-)
03:01:00 <hornby> and then back up the banana -> jelly chain .. 
03:01:08 <shapr> yep, you got it
03:01:08 <hornby> Function: string.join --> ['function', 'join', ['module', 'string']]
03:01:20 <hornby> Would appear in Haskell as a HASKELL function. 
03:01:26 <shapr> you think so?
03:01:31 <hornby> NO?
03:01:33 <hornby> er No?
03:01:38 <shapr> I have no idea :-)
03:01:43 <shapr> if you have ideas, I'm listening!
03:01:45 <hornby> Well isn't that the point? 
03:01:52 <shapr> sure I guess so.
03:02:06 <shapr> that leads me to some other questions though
03:02:08 <hornby> That you can send these objects around?
03:02:20 <hornby> But yeah, it does raise a lot of questions
03:02:26 <shapr> this is actually a reference or name that's being sent, isn't it?
03:02:37 <shapr> not the guts of the function itself
03:03:07 <hornby> yeah, well you send the guts too I imagine. 
03:03:07 <shapr> so I don't know if it's normal to call those functions...
03:03:19 <hornby> I mean you can send arbitrary objects? 
03:03:22 <shapr> how do you send the guts of a python function to a haskell system?
03:03:27 <hornby> heheh
03:03:27 <shapr> what good is it to send those guts?
03:03:29 <hornby> Good question :)
03:03:32 <shapr> haskell doesn't understand python.
03:03:34 <shapr> so...
03:03:46 <hornby> Right, but you don't send it PYTHON, you send it a s-exp. 
03:03:48 <shapr> should I make aliases that point to their haskell equivalents?
03:03:57 <hornby> and then it translates them back up? Maybe? 
03:04:10 <hornby> Which seems an awful lot like magic
03:04:18 <shapr> I don't understand
03:04:28 <hornby> Have you looked at the Java implementation? Or the elisp one?
03:04:34 <shapr> just a bit
03:04:57 <shapr> I haven't looked it them with these questions in mind though.
03:06:04 <hornby> I think its funny that you have just as many questions as I do about a system you're building :)
03:06:09 <shapr> really?
03:06:13 <hornby> or translating :)
03:06:14 <shapr> I thought that was normal?
03:06:32 <shapr> that's how I write most of my software.
03:06:39 <hornby> Well I don't assume you know everything about something you haven't yet done, but I thought you'd have an idea of what you were working towards :)
03:06:48 <shapr> sometimes I don
03:06:49 <hornby> I know I experience the same thing. I have no idea how something will look in the end. 
03:06:50 <shapr> er "do"
03:06:54 <shapr> same for me
03:07:08 <shapr> I do know that writing unit tests first can speed up the process
03:07:13 <shapr> so I try to always do that
03:07:22 <shapr> then I know how I want to talk to the code
03:07:47 <shapr> so I know a lot more about the code I want, without having to throw away one or two crappy implementations
03:08:03 <hornby> yeah you have to know where to start
03:08:14 <shapr> also, when the unit tests pass, I know a) the code works and b) I'm done with this part
03:08:24 <shapr> so I also know where to end
03:08:37 <hornby> So long as your unit tests are well written :)
03:08:41 <shapr> having unit tests also means I can go back and hack furiously
03:08:52 <shapr> and if the tests still pass, I did it right :-)
03:09:06 <shapr> my first few unit tests were sucky, but I've gotten better at it
03:09:46 <hornby> I sometimes get lazy about unit tests though
03:09:57 <shapr> nowadays I write a unit test, check to see if it fails, then write code, run test, write code, run test, write code run test
03:10:00 <hornby> or leave them off completely... they are a lot of work :)
03:10:00 <shapr> until the test works
03:10:26 <shapr> unit tests are less work than trying to track down a bug six weeks later.
03:10:34 <hornby> mebbe
03:10:35 <hornby> true
03:10:59 <shapr> or even worse, having a client call you up and say your code is broken in an obvious way
03:11:29 <hornby> embarassing :)
03:11:47 <shapr> and not good for future business with them, or whoever they tell that to
03:11:57 <hornby> ya
03:12:13 <shapr> so the summary is that it's better to do it right the first time.
03:12:18 <shapr> at least, that's how I see it.
03:12:34 <hornby> Definately. 
03:12:37 <hornby> Quality always wins
03:12:45 <shapr> unless you're microsoft
03:12:48 <hornby> hah
03:12:58 <shapr> actually, the quality of their GUI is what wins for them.
03:12:59 <hornby> "Unit test? Huh? Where are my stock options?"
03:13:19 <hornby> The GUI is pretty decent. 
03:13:33 <shapr> Windows GUI is an excellent GUI for new users, and it's 99% consistent
03:13:41 <hornby> Yeah, it is good that way. 
03:14:00 <shapr> that's a huge advantage for people who want to use the computer as a tool only
03:14:15 <hornby> A simple tool 
03:14:19 <shapr> right
03:14:33 <hornby> I don't think I could go back to windows now
03:14:39 <shapr> it's called "the principle of least surprise"
03:14:46 <shapr> something perl does *not* have :-)
03:14:49 <hornby> heh
03:14:54 <shapr> yah, I couldn't go back to windows either.
03:15:09 <hornby> principle of least surprise is good, but windows only has it because it doesn't let you DO anything
03:15:14 <shapr> recent research has shown that customization is a bad thing for most users
03:15:20 <hornby> shapr: Really? 
03:15:27 <shapr> I strongly suspect you and I fall outside of that "most"
03:15:30 <hornby> shapr: I can't live without out. I hate being told what to do
03:15:31 <shapr> and that's why we're not using windows.
03:15:41 <shapr> right, same for me
03:15:45 <shapr> I want to find out stuff for myself
03:15:46 <hornby> Yeah, I think consistency is important to casual users
03:16:07 <shapr> but most of the people I work with want to do the minimum amount of work they have to do to keep their jobs.
03:16:25 <hornby> Thats sort of sad. 
03:16:33 <hornby> But definately understandable
03:16:37 <shapr> it's *really* irritating to work with.
03:16:46 <shapr> I'm not sure I understand that attitude.
03:16:58 <hornby> Well, if you really hate what you're doing ...
03:17:24 <hornby> I try to strive for quality myself, and I appreciate when others to the same. 
03:17:24 <shapr> but they don't
03:17:38 <shapr> same for me
03:17:41 <hornby> I'm a bit of a perfectionist :)
03:17:51 <shapr> me too
03:18:14 <shapr> I realize that commercial software requires pragmatism over idealism
03:18:26 <hornby> Hrm, but yeah, I don't understand how people can do shoddy work that they KNOW is shoddy, and show it to other people, and make other people suffer for it
03:18:31 <shapr> right
03:18:37 <shapr> pragmatic != shoddy
03:18:39 <hornby> shapr: Yeah, but it still has to work. 
03:18:51 <hornby> You should at least apply best practices, and a bit of sweat
03:19:12 <shapr> imho, pragmatic means deliver functionality in small, regular, thoroughly tested chunks
03:19:37 <shapr> that way you can deliver business value to the customer in a very short time
03:19:40 <shapr> and you know it'll work
03:19:46 <hornby> "chunking" is the best software process ever :)
03:20:07 <shapr> and then you do that again in two weeks with another feature, and you know everything still works since you have all those unit tests
03:20:30 <hornby> I wonder how many firms follow that sort of development model
03:20:40 <hornby> More now than before, but many? Hmm
03:21:21 <shapr> all of this that I'm saying is eXtreme Programming
03:21:23 <shapr> have you heard of it?
03:21:51 <hornby> yeah
03:21:57 <shapr> have you read about it?
03:21:59 <hornby> I've read up on it a bit
03:22:04 <shapr> it's great.
03:22:14 <hornby> I haven't read the book(s) but I've seen the website. And lots of random stuff on wikis and whatnot :)
03:22:22 <shapr> it started on TheWiki
03:22:31 <shapr> so that's still the best source of info for XP
03:22:37 <hornby> yeah I love some of the ideas
03:22:49 <shapr> anything in particular?
03:23:12 <hornby> tests, refactoring, user .. hrm, whats it called
03:23:28 <hornby> oh use scenarios, or something
03:23:34 <shapr> user stories?
03:23:39 <hornby> yeah, thats it :)
03:24:15 <hornby> and the simple, common sense stuff, like coding standards, simplicity, etc. 
03:24:27 <shapr> it's not that common
03:25:27 <hornby> Know of any case studies? For large systems? 
03:25:54 <shapr> yah sure
03:26:03 <shapr> the first XP project was the C3 system
03:26:13 <shapr> it was a payroll program for Chrysler
03:26:26 <hornby> ah, right
03:26:31 <hornby> I remember I read something about that
03:26:44 <hornby> In smalltalk right?
03:26:47 <shapr> yup
03:27:11 <hornby> I remember thinking that was so cool, that people actually used Smalltalk :)
03:27:29 <shapr> it's a powerful language
03:28:07 <hornby> yeah, I've dabbled. 
03:28:13 <hornby> It looks like loads of fun. 
03:28:24 <hornby> No one uses it though :(
03:29:00 <shapr> there are several commercial implementations available and making money
03:29:04 <shapr> so I think people are using it
03:29:46 <hornby> yeah, I guess 
03:29:57 <hornby> pretty quietly though
03:30:05 <hornby> I wanna get a job as a Smalltalk programmer :)
03:30:28 <shapr> I think you could
03:30:36 <shapr> do you know Smalltalk?
03:30:43 <hornby> Mmm, a little bit
03:30:52 <hornby> its a pretty simple language
03:31:18 <hornby> I can't imagine anyone hiring me though
03:31:30 <shapr> if you're good, people will hire you.
03:31:36 <hornby> hrm, 40 jobs
03:31:40 <hornby> shapr: but how do I prove I'm good? :)
03:31:48 <shapr> one of my sysadmin friends is blind
03:31:56 <shapr> one of the two best programmers I know is deaf
03:32:05 <hornby> recently blind/deaf?
03:32:13 <shapr> no
03:32:19 <hornby> whole life kinda thing?
03:32:24 <shapr> yup
03:32:25 <hornby> Wow
03:32:38 <shapr> makes me feel like a weenie when I say it's too hard to learn something.
03:32:38 <hornby> text to speech? 
03:32:46 <shapr> and braille
03:32:54 <hornby> braille sysadmining? 
03:32:57 <shapr> yup
03:33:10 <hornby> I can't imagine many computer texts come in braille? 
03:33:15 <shapr> that's correct
03:33:20 <shapr> he wanted to learn Haskell
03:33:52 <hornby> What'd he do?
03:33:54 <shapr> but the online tutorials aren't comparable to the print books
03:34:00 <shapr> he learned Goo instead.
03:34:30 <shapr> I would have skipped haskell also, but my fiancee bought me two Haskell books for my last birthday
03:34:41 <shapr> my reason was that the online docs aren't sufficient.
03:34:56 <hornby> hmm
03:34:58 <shapr> hornby: you've been learning without a book, right?
03:35:04 <hornby> Haskell? Thats right
03:35:18 <shapr> I'm impressed by how much you've learned without a book.
03:35:29 <shapr> I got frustrated quickly.
03:35:47 <hornby> I tried it once before and failed miserably. But the resources have gotten a bit better :)
03:35:58 <hornby> I still get frustrated. :) This channel helps :)
03:36:24 <shapr> that's good
03:36:38 <shapr> I need to find some time to put into the tutorial
03:36:40 <hornby> And I still haven't done anything really productive. Hmm. I should translate something, that'd be a good start
03:36:49 <shapr> I'd suggest something small...
03:36:59 <shapr> and something that doesn't do much input or output
03:37:43 <hornby> heh ya
03:38:05 * hornby thinks
03:39:26 <hornby> ah
03:40:05 <hornby> I recently adapted a C function to determine if a point was in a polygon for Python. I think I'll move it to Haskell now :)
03:40:15 <shapr> oh, cool idea!
03:47:15 <hornby> my python program takes a polygon in the form: [(1,2),(3,4),(5,6)] 
03:47:25 <hornby> I have no idea what that would look like in haskell 
03:48:06 <hornby> hrm 
03:49:51 <hornby> pt_in_poly :: Fractional a => (a,a) -> [(a,a)] -> Bool
03:49:53 <hornby> Thats my guess
03:51:26 <shapr> sounds good to me
03:53:09 <hornby> hm this is fun
03:53:16 <hornby> and yeah, it seems to be right :)
03:53:58 <hornby> pt_in_poly [] _ = False
03:53:58 <hornby> pt_in_poly _ [] = False
03:54:04 <hornby> The easy ones, out of the way
04:00:09 <hornby> ugh
04:00:10 <hornby> heh
04:00:32 <shapr> now what?
04:00:36 <shapr> as in
04:00:39 <shapr> what's the third case?
04:00:45 <hornby> the first two don't work :)
04:00:48 <hornby> problems with () and []
04:01:39 <hornby> [] doesn't match (a,a)
04:01:53 <hornby> and I can't get head (5,5) even
04:02:13 <Igloo> That's because (5, 5) is a tuple, not a list
04:02:35 <hornby> Igloo: I know, but ... How can I get the first element of a tuple?
04:02:41 <Igloo> fst
04:02:47 <hornby> I'm used to having a fuzzy line between tuples and lists :)
04:02:51 <hornby> Igloo: awesome
04:02:57 <Igloo> (well, of a pair)
04:03:02 <hornby> Igloo: Yeah, its a point
04:03:10 <Igloo> You can pattern match on the structure of a tuple too
04:03:22 <hornby> Igloo: I want to do something like pt_in_poly () _ = False
04:03:25 <hornby> ie, if its an empty pair
04:03:44 <hornby> just for completeness sake :)
04:03:50 <Igloo> () has type () not (a, a)
04:04:02 <hornby> well yeah ... 
04:04:06 <Igloo> You'd need a Maybe (a, a) if you wanted to do that
04:04:08 <hornby> It doesn't act like []
04:04:29 <Igloo> No, what with being completely different and all  :-)
04:04:45 <hornby> Maybe I'll just assume that a valid pt is passed ? :)
04:05:16 <Igloo> You're type signature doesn't allow no point to be passed
04:05:20 <hornby> at least the one case works
04:05:29 <Igloo> Bah, Your
04:05:43 <hornby> Igloo: Well good :) That's what I was aiming for .. it does allow an empty list though
04:06:15 <Igloo> For the second argument, yes
04:06:21 <hornby> right
04:06:31 <hornby> Now I just need to figure out how to handle the args. 
04:08:20 <Igloo> Why do you say "pt_in_poly _ [] = False" OOI?
04:08:49 <hornby> Igloo: Well the point isn't in an empty list 
04:09:10 <hornby> (OOI?)
04:09:26 <Igloo> Out Of Interest
04:09:50 <Igloo> And I thought you were finding out if the point is in the polygon defined by the list
04:10:22 <hornby> Igloo: yes, I am
04:10:49 <hornby> If there is no list, the point can't be in it? 
04:11:00 <Igloo> So no point is in the polygon defined by 0 points?
04:11:04 <hornby> Or ... you figure if there is no list, the polygon is infinately large? 
04:11:28 <hornby> Igloo: Right. 
04:11:53 <hornby> hell, a polygon defined by less than 3 points is False
04:12:00 <Igloo> I'm mainly wondering because you could do without the base case if you only consider convex polygons and check it's in all the right half planes
04:12:45 <Igloo> Oh, except you'd end up doing tail [] so you'd need one anyway
04:12:55 <hornby> Now I'm just confused :)
04:14:26 <Igloo> Oh, just ignore my ramblings  :-)
04:14:47 <hornby> hrm, I have no idea how to transfer this to Haskell
04:14:54 <hornby> I'm going to have to completely rethink it
04:17:29 <hornby> oi, this is tougher than I thought
04:19:26 <Igloo> Are you trying to do it by firing infinite rays and counting crossing points?
04:20:02 <hornby> Ya :)
04:20:13 <hornby> Not really a method meant for haskell
04:20:22 <hornby> I'm translation from some Pytohn
04:21:08 <hornby> easier to rethink the problem from a theoretical solution, perhaps
04:22:35 <hornby> Igloo: thoughts? 
04:23:17 <hornby> or maybe I should use a different method hm
04:24:12 <Igloo> If it were me I'd probably zip it with its tail and then calculate intersections fo a vertical ray above the point
04:24:39 <Igloo> Oh, except you want to rotate th list by 1 rather than take the tail
04:25:10 <hornby> zip it?
04:25:19 <hornby> why?
04:25:28 <hornby> i dont get it
04:25:56 <Igloo> Because you care about line segments, not points
04:26:09 <hornby> right ... 
04:26:47 <hornby> rotated by one you mean .. [(1,2),(3,4),(5,6)] -> [(3,4),(5,6),(1,2)]?!
04:28:53 <Igloo> Yes, then zip them
04:29:21 <hornby> [((1,2),(3,4)),((3,4),(5,6)),((5,6),(1,2))]
04:29:44 <Igloo> Right, and what has that given you?
04:30:06 <hornby> the lines
04:30:07 <hornby> neat
04:31:22 <hornby> is there a function to rotate them?
04:32:07 <Igloo> Don't think so OTTOMH
04:32:24 <shapr> what about rotate = last ++ init ?
04:32:36 <shapr> actually that should be rotateL I think
04:32:51 <hornby> Mm? 
04:32:59 <Igloo> Or tail xs ++ [head xs]
04:33:04 <shapr> right
04:33:05 <shapr> good point
04:33:13 <shapr> that rotateR
04:33:19 <hornby> doesn't matter though
04:33:21 <hornby> neat
04:33:36 <Igloo> And that should be more efficient, but that's not particularly important here  :-)
04:34:19 <hornby> Main> rotate [(1,2),(3,4),(5,6)]
04:34:19 <hornby> [(3,4),(5,6),(3,4)]
04:34:26 <hornby> rotate (x:xs) = xs ++ [head xs]
04:34:37 <hornby> oops forgot a bit
04:34:43 <Heffalump> xs ++ [x] I'd hope...
04:34:52 <shapr> yah, I was thinking that
04:34:54 <Heffalump> otherwise you're chucking away x
04:34:55 <hornby> hah
04:35:56 <hornby> you guys are awesome :)
04:36:04 <hornby> rotate (x:xs) = tail xs ++ [x] ++ [head xs]
04:36:08 <hornby> works :)
04:36:09 <Heffalump> eeeek!
04:36:14 <hornby> what, no? 
04:36:19 <Heffalump> why are you rotating it by two elements at a time?
04:36:30 <Heffalump> and if that's really what you want,
04:36:37 <Heffalump> rotate (x:y:xs) = xs ++ [x,y] would be nicer
04:36:42 <hornby> Main>  rotate [(1,2),(3,4),(5,6)]
04:36:43 <hornby> [(5,6),(1,2),(3,4)]
04:36:52 <Igloo> Try it on a list of length 4
04:36:55 <hornby> oh
04:37:04 <hornby> heh
04:37:23 <hornby> here, let me actually think for a moment
04:38:06 <Heffalump> if you want to rotate it backwards you'll probably need the init and last functions
04:38:43 <Igloo> It doesn't metter which way you rotate it for this purpose, though
04:39:09 <hornby> right
04:39:19 <hornby> Sorry, whats the final rotate function?
04:39:39 <shapr> something that put its head on the end of its tail
04:39:53 <hornby> rotate (x:xs) = xs ++ [x]
04:39:54 <hornby> right?
04:40:04 <shapr> ourobourous :: [a] -> [a]
04:40:12 <shapr> hornby: looks good to me
04:40:17 <hornby> ourobourous? 
04:40:40 <shapr> snake from norse mythology :-)
04:40:44 <hornby> ah :)
04:42:53 <Igloo> I thought they made batteries in Red Dwarf
04:43:27 <hornby> okay, more confusion
04:43:53 <hornby> pt_in_poly (x1,x1) (x:xs) = zip ([x:xs] (rotate [x:xs]))
04:44:05 <hornby> now I know that ain't Bool, but 
04:44:17 <Igloo> You can replace (x:xs) with xs everywhere
04:44:42 <hornby> everywhere?
04:44:59 <Igloo> Yes.
04:45:13 <hornby> pt_in_poly2 (x1,y1) xs = zip (xs (rotate xs))
04:45:21 <Igloo> Oh, and you meant (x:xs) not [x:xs] on the right
04:45:27 <Igloo> Yup
04:45:51 <hornby> undefined variable x
04:45:55 <hornby> oh
04:46:08 <Igloo> And there's no reason not to rename x1, y1 to x, y
04:46:17 <hornby> well I didn't want it to clash
04:46:23 <hornby> pt_in_poly2 (x1,y1) xs = zip ((x:xs) (rotate (x:xs)))
04:46:28 <Igloo> Yeah, but it doesn't any more  :-)
04:46:39 <Igloo> Ermmm, you were right before
04:46:47 <hornby> but you said ... 
04:47:02 <Igloo> OK, when you said "pt_in_poly (x1,x1) (x:xs) = zip ([x:xs] (rotate [x:xs]))" it was wrong
04:47:16 <Igloo> "pt_in_poly (x1,x1) (x:xs) = zip ((x:xs) (rotate (x:xs)))" would be right
04:47:19 <hornby> ok
04:47:47 <Igloo> But there's no reason for using (x:xs) everywhere - you may as well just use xs
04:48:06 <hornby> ok ... 
04:48:22 <hornby> pt_in_poly2 (x1,y1) xs = zip (xs (rotate xs))
04:48:24 <hornby> ?
04:49:00 <Igloo> Yup
04:49:05 <hornby> um
04:49:15 <hornby> ERROR pt_in_poly.hs:7 - Type error in application
04:49:39 <hornby> term xs, type b -> c, ... does not match [a]
04:49:46 <Igloo> You need to do the actual intersection counting too
04:50:01 <hornby> Well I'm working up to that :)
04:50:13 <Igloo> Oh, you've used zip incorrectly too
04:50:21 <hornby> oh
04:50:33 <hornby> oh fixed
04:50:40 <hornby> zip xs (rotate xs) doesn't bork
04:54:29 * hornby ponders intersection counting
05:02:23 <hornby> a vertical line huh
05:08:49 <hornby> hmm
05:09:12 <hornby> ooh
05:10:45 <hornby> so I just test each line segment for intersections with my vertical line y=0 and if the intersection is within x1 and x2 I count it as a cross ... if its an even number of crosses then the pt is not in the polygon
05:11:24 <hornby> hrm perhaps .. hm
05:11:58 <hornby> a recursive function that does only the tail might work, but I would need to keep tract of the number of crossings.
05:12:08 <Igloo> y=0 is a horizontal line. And you sound generally confused to me
05:12:24 <hornby> er, 
05:12:30 <hornby> yeah, good point. I am pretty confused :)
05:12:45 <hornby> but hey, a horizantal line works too
05:12:48 <hornby> right/ :)
05:12:59 <Igloo> And you want to treat each line segment separately and check the parity of the result, which should bring a couple of prelude functions to mind
05:13:33 <Igloo> Well you can't alway use y=0 - that just gives the impression you can't visualise what's going on
05:13:34 <hornby> parity?
05:13:39 <Igloo> Odd or even
05:13:47 <hornby> what about y = x?
05:14:06 <hornby> i like y =x 
05:14:41 <Igloo> Think about what the half ray test actually does
05:15:06 <hornby> I thought I had. 
05:15:44 <Igloo> OK, so describe it
05:15:50 <hornby> Uh, I thought I had :)
05:16:18 <Igloo> OK, put it this way: Where does you algorithm depend on the point you pass to your function?
05:16:57 <hornby> it only uses it when checking intersections with the lines? 
05:18:20 <Igloo> Unless I have misunderstood what you've written you haven't used the point anywhere in your description (starting "so I just test")
05:18:50 <hornby> well the vertical line is up from the pt
05:20:37 <Igloo> The vertical line y=0?
05:20:50 <hornby> x=x ... 
05:21:30 <Igloo> OK, that's not what you said earlier though  :-)
05:21:40 <hornby> well yeah,  :)
05:21:46 <hornby> I got mixed up
05:22:13 <hornby> you know what I mean by x=x though, right?
05:22:20 <Igloo> But yes, essentially. You also need to check it is above (i.e. y > y1) and think about what to do with vertical line segments it crosses, what happens if it crosses the intersection of 2 line segments and what to do if the point is on the boundary
05:22:34 <Igloo> YM x = x1 given your functino way up there ^
05:24:00 <hornby> You mean if x = 5, and it goes through a line [(5,1), (5,6)]?
05:24:26 <Igloo> Yup
05:24:43 <hornby> I have no clue :) what if I check to see if its the same as both, then .... 
05:25:09 <hornby> I Dunno, is it in or out? It doesn't change ... so if it was in before, its still in
05:25:55 <hornby> pt_in_poly (x,y) xs crossings = pt_in_poly (x,y) (tail xs) (inc crossing if magic)
05:25:59 <hornby> Is that sane?
05:26:16 <hornby> xs will already have been zipped
05:27:00 <hornby> whats this y > y1 bit? If the line y is greater than the pt y?
05:45:00 <hornby> Whats an easy way to say if a < b < c
05:47:55 <hornby> fst (a,b) is a ... how do I get b? not last or lst :(
05:49:17 <hornby> ah, snd
05:53:40 <xbill> fst (a,b) = a, snd (a,b) = b
05:55:52 <hornby> hmmm
05:56:06 <hornby> this is too simple to be right
06:03:41 * shapr grumbles
06:05:18 <hornby> ditto
06:05:34 <shapr> emacs is single threaded >:-(
06:05:43 <shapr> and it blocks on network reads
06:06:03 <hornby> bummer
06:06:07 * xbill shouts "rewrite" and of course advocates that it be done in Haskell
06:06:11 <hornby> still, my problem is great: my brain is too small
06:06:14 <shapr> yay xbill!
06:06:34 <shapr> xbill: I'll raise you an elisp vm written in haskell
06:06:43 <xbill> hmm
06:07:11 <shapr> hornby: the solution is to make the problem smaller
06:07:48 <xbill> I wonder if the Haskell runtime is up to the point of a multi-tasked threading engine these days.
06:07:56 <hornby> shapr: mm :) Its a pretty small solution -- thats my problem actually
06:07:59 <hornby> needs to work :)
06:08:28 <shapr> xbill: closest I've seen is: http://cristal.inria.fr/ICFP2001/Abstracts/50.html
06:08:47 <shapr> I think Concurrent would give a decent multi-threaded engine.
06:09:27 * xbill is writing a symbolic G-machine code to x86 assembly translator again.
06:09:48 <shapr> I'd be *very* happy to assist on such a project, but I do not even approach the level of knowledge needed to be lead dev on it
06:09:52 <xbill> I was under the impression concurrent only used a single kernel thread to back its library threads.
06:10:10 <shapr> afaik, it uses multiple OS threads on both Linux and Win32
06:10:22 <shapr> probably not like you expect though...
06:10:31 <xbill> That's changed or something.
06:10:34 <shapr> Concurrent uses anonymous OS threads
06:10:54 <shapr> anytime a Haskell thread needs to do something it grabs a thread out of the crowd and tells it to do something
06:11:02 <xbill> Linux has no such beast, so any kernel threads it uses should appear in process listings.
06:11:31 <shapr> right, it uses explicit OS threads to implement the anonymous os threads
06:11:45 <hornby> I suck 
06:11:47 <hornby> grr
06:12:08 <shapr> that really screwed the HOpenGL implementation recently, since GLUT can only talk to one thread, and it always has to be the *same* thread
06:12:19 <shapr> interesting discussion about that on the HOpenGL mailing list.
06:12:43 <xbill> Moving on, so I'm trying to brew up this G-machine code to whatever translator and am running into a nasty one.
06:12:51 <shapr> xbill: hey, you had a Haskell module with at least thirty-two flavors of spiffy self calling lists, whatever happened to that?
06:13:01 <shapr> what's the nasty problem?
06:13:05 * shapr pretends to have a clue
06:13:10 <xbill> x86 (Cond t f) = unlines $
06:13:10 <xbill>                         [       "popl %eax"
06:13:10 <xbill>                         ,       "cmpl $0, %eax"
06:13:10 <xbill>                         ,       "jz 0f"
06:13:22 <xbill>                         ,       "jnz 1f"
06:13:22 <xbill>                         ,       "0:"
06:13:22 <xbill>                         ,       concatMap x86 f
06:13:36 <xbill>                         ,       "jmp 2f"
06:13:36 <xbill>                         ,       "1:"
06:13:36 <xbill>                         ,       concatMap x86 t
06:13:36 <xbill>                         ,       "2:"
06:13:36 <xbill>                         ]
06:13:40 <xbill> so
06:13:55 <xbill> There's a slight problem.
06:14:20 <shapr> Cond is a lisp-like cond?
06:14:43 <xbill> not quite
06:14:47 <shapr> ok
06:14:58 <shapr> the problem is not obvious to me
06:15:03 <shapr> what is it?
06:15:15 <xbill> The assembly labels may clash with the nested code.
06:15:50 <xbill> There may be a nested if
06:16:00 <xbill> or nested Cond rather
06:16:20 <xbill> if there is then this is boned as it will jump to the wrong labels.
06:16:47 <shapr> "jmp 2f" is getting input from the f passed to Cond somehow?
06:17:30 <xbill> No
06:17:39 * shapr reads again
06:17:43 <xbill> 2f means "first label named 2, looking forward"
06:18:25 <shapr> how can the labels clash with the code? aren't the labels always data?
06:18:27 <xbill> It's actually the cleanup code, 0 is the false label and 1 is the true label.
06:18:33 <shapr> or are you doing a "read" in there somewhere?
06:18:43 <xbill> TYhe labels don't appear anywhere except as relocations.
06:18:53 <shapr> ohhhhhhh
06:19:07 <shapr> are you dynamically generating labels?
06:19:12 <shapr> and you want unique names for each label?
06:19:33 <xbill> I'm not now but it looks like a PITA and I hoped I could avoid it...
06:19:54 <xbill> but it looks like I can't.
06:19:55 <shapr> why not just have a getSafeLabel or something?
06:20:01 <xbill> Might need a counter monad.
06:20:07 <shapr> right
06:20:26 <shapr> or you could be extra-cheesy and use something like seconds since the epoch
06:20:38 <xbill> Still has a monad
06:20:45 <xbill> Probably not a good idea either
06:20:50 <shapr> hm
06:21:14 <shapr> what about using a label list?
06:21:46 <xbill> The same as a monad, just uses the extra arg or whatever
06:21:52 <xbill> Also could leak mem
06:22:12 <xbill> [0..] if it's a CAF would grow indefinitely
06:22:32 <shapr> but you only take when you need a new label name, right?
06:22:41 <xbill> I really just want to fake destructive update of a counter
06:23:40 <shapr> I can't think of anything better than a counter monad
06:23:59 <xbill> I'm also using like 4 regs, 1 address stack, 1 int stack, 1 float stack, and a heap pointer
06:24:05 <shapr> I do want to see the code when you're done with it =)
06:24:08 <xbill> which is probably horrible on x86 but I don't care
06:24:12 <shapr> if it's not commercial or something
06:24:23 <xbill> I already wrote one, I'm just ditching the old one because it sucked
06:24:31 <shapr> good reason
06:25:01 <xbill> I suspect this one might suck too though, the 4 regs is unreasonable.
06:25:08 <shapr> what's reasonable?
06:25:27 <xbill> Probably finding some way to do real register allocation =(
06:25:34 * shapr hasn't read about 386 asm since the 286 was nice hardware
06:26:25 <xbill> well, I'm basically ignoring anything > 386
06:26:44 <shapr> can you write your G-machine in such a way that your register allocation code is just a combinator?
06:27:00 <shapr> that way you could go with your current 4 register implementation and fix it later if it sucks
06:27:01 <xbill> in principle, yes
06:27:05 <shapr> in practice?
06:27:08 <xbill> well, not quite
06:27:27 <shapr> I've not yet tried the abstract via combinator bit.
06:27:30 <xbill> The 4 register thing is to sidestep codegen altogether and use what's basically overblown macro expansion.
06:28:28 <xbill> There's an easy transformation from stack machine to register machine but then floating point breaks every register allocator under the sun.
06:28:57 <xbill> ... and graph algorithms are a wee bit awkward in Haskell
06:29:43 <shapr> I haven't tried graph algorithms in Haskell yet.
06:29:47 <shapr> I think Logan did some.
06:29:49 <Heffalump> there's some clever tricks you can use
06:29:56 <Heffalump> but in general they're nasty
06:31:38 <xbill> Yeah, I've tried this a few times before.
06:31:53 <Heffalump> have you read the King and Launchbury paper?
06:32:24 <xbill> no, URL?
06:34:37 <Heffalump> http://www.dcs.gla.ac.uk/~gnik/publications.html - the third one down
06:36:14 <xbill> hmm
06:37:17 <hornby> Igloo: still around?
06:38:06 <Igloo> Yes
06:38:37 <hornby> I'm not sure what to ask even. heh
06:39:54 <shapr> I wonder if suffix trees qualify as graph algorithms
06:39:59 <xbill> well, as long as I stay away from floating point, multiplication, division, and remainder, it should be easy
06:40:54 <Heffalump> shapr: not really
06:42:23 <xbill> well, except for the fact it's 2-address code
06:42:55 <xbill> and liveness analysis
06:46:26 <Heffalump> *2*-address code?
06:47:23 <xbill> yes
06:47:29 <xbill> i386 has 2-address code
06:47:35 <xbill> e.g. 
06:47:40 <xbill> addl %eax, %ebx
06:47:47 <xbill> So everything is instantly clobbered
06:48:09 <xbill> addressing modes are ugly too
06:48:14 <Heffalump> oh, right, yeah.
06:49:44 <xbill> OTOH 
06:53:06 <xbill> one level of indirection turns it into a tree
06:54:54 <xbill> Just represent the var by (TypeName, VarNum) and descending into the dag is easy
06:57:28 <xbill> OTOH one could just generate C
06:57:47 <xbill> do like Stalin or something
06:57:53 <shapr> ghc does that
06:58:12 <xbill> I don't like it for some reason...
06:58:42 <hornby> http://abstemiousclam.port5.com/pt_in_poly.hs
06:58:52 <hornby> (It doesn't work)
06:59:00 <hornby> But it should 
06:59:03 <hornby> ha
06:59:12 <shapr> hornby: what doesn't work?
06:59:22 <hornby> shapr: my pt_in_poly function
06:59:42 <hornby> it looks neat though
06:59:47 <hornby> always returns false though
07:00:05 <xbill> if it's float it may very well
07:00:15 <xbill> try using a tolerance
07:00:27 <xbill> linear scan is probably the easiest copout
07:00:36 <hornby> linear scan?
07:00:43 <xbill> yeah
07:00:53 <hornby> but it shouldn't be float, should it? 
07:01:09 <hornby> Its got more serious issues than just type problems
07:01:12 <xbill> just maintain a bag of free registers, when you run out, pick one you don't need more or less at random, spill it, and use the reg
07:01:23 <xbill> it'll be float
07:01:28 <xbill> you're dividing
07:01:41 <hornby> oh
07:01:47 <xbill> easy approach to liveness analysis:
07:02:07 <hornby> oh damn you're right. 
07:02:26 <xbill> keep the stack depth for the various stacks and the depth at which each thing in a reg is kept floating around
07:02:37 <xbill> (1) always look in regs first for the value
07:02:53 <xbill> (2) if the stack depth goes negative, it's dead
07:03:27 <hornby> seems overly complicated? What about just
07:03:30 <Heffalump> how is that "liveness" analysis?
07:03:52 <xbill> (3) if you run out of regs, push the deepest things back onto their stacks
07:03:54 <xbill> ah
07:04:22 <xbill> it's "liveness analysis" because the underlying stack machine model keeps track of it for you
07:04:53 <Heffalump> how do you deal with branches with that model?
07:05:04 <hornby> abs(x - y) < 0.1
07:05:06 <hornby> or something? 
07:05:08 <xbill> in truth, you don't need to
07:05:45 <xbill> inter-block analysis arises as a natural consequence
07:06:48 <xbill> alternatively, you could keep track of how many things from the top of each stack are in registers in addition to stack depth
07:07:11 * Heffalump looks confused
07:07:22 <xbill> stack depth of each variable that is -- how deep the whole stack is may depend on the number of loops taken in an iteration
07:07:38 <Heffalump> ah, ok
07:08:24 <xbill> only the variables in registers actually, not all variables
07:09:22 <xbill> Now, if there were a trick for spilling and restoring the various pointers (e.g. all 3 stacks plus the heap pointer) that would be very nice
07:10:30 <xbill> ah, but %esp can be essentially dedicated to being one of 3 stack pointers, and dynamically switched, others brought in as needed, and the heap pointer brought in elsewhere
07:11:28 <xbill> Loading one of the stack pointers is just a double indirection
07:12:20 <xbill> You always need one stack pointer around so some spilling can be done, but loading doesn't matter so long as it's in a fixed location.
07:12:56 * shapr wants coffee
07:14:10 <xbill> I wonder if they could all just be multiplexed onto the same stack without tagging.
07:14:20 <xbill> ew, that would make GC painful
07:14:52 <xbill> well, unboxed stuff would be okay
07:16:58 <xbill> If I can get away with two stacks I might as well just burn %esp and %ebp
07:17:39 <xbill> but special handling of the FP stack (as usual) is necessary
07:19:00 <xbill> this still doesn't work well because there's no way to fill it in from the bottom
07:23:59 <xbill> no wait
07:24:02 <xbill> FINCSTP
07:24:30 <xbill> fill it up and FINCSTP until it's wrapped to the right place
07:25:41 <xbill> so it can sort of be filled from the bottom up, but it looks butt ugly
07:28:04 <xbill> for this the stack machine model is almost perfect, except the bloody i387 is too crippled to carry an Ethiopian ant that had been eviscerated and then freeze-dried.
07:52:43 <hornby> hm
07:53:04 <hornby> what slope does a vertical line have ? diviosn by 0 bad
08:00:18 <Heffalump> infinity.
08:00:26 <Heffalump> you could represent the slopes as angles, perhaps?
08:00:38 <Heffalump> or as a normalised vector
08:00:54 <Igloo> If you're still doing what you were doing earlier you probably want to treat it as a special case
08:01:38 <hornby> wanna see the code? its short :)
08:02:11 <hornby> abstemiousclam.port5.com/pt_in_poly.hs
08:02:15 <Igloo> I strongly suspect your problem is in an underspecified algorithm rather than the code that implements it
08:02:17 <hornby> and it works too, sort of
08:02:30 * Igloo is about to go out, anyway
08:03:01 * hornby hrms
10:42:51 <Igloo> If lists have elements then what do tuples have?
10:43:38 <Igloo> Ah, components
10:50:59 <elmex> i am scared
10:51:07 <elmex> what does [ f x | x <- xs ] do?
10:51:33 <Igloo> It's similar to a set in maths
10:51:50 <Igloo> It says "the list of things f of x where x is in xs"
10:52:54 <Igloo> Well, actually it's a bit more precise than that - the nth thing in the list will be f of the nth thing in xs. This should probably sound like a familiar prelude function to you (depending on how well you know Haskell)
10:53:47 <Igloo> (I meant "set notation" above where I said "a set")
10:55:32 <elmex> hm
10:55:36 <elmex> what is f ?
10:55:44 <Igloo> A function
10:56:06 <Igloo> f and xs are both free variables, but x is bound by the list comprehension
10:56:50 <elmex> i still dont understand...
10:57:37 <Igloo> OK, do you understand that (5 +) is a function that takes an Int to an Int?
10:58:00 * Igloo can't remember if it was you that discussion was with
10:58:25 <elmex> hm, yes, ((+) 5) produces a function which takes a int and returns a int
10:58:56 <Igloo> OK, try [ (5 +) x | x <- [1..10] ] in hugs and see if that makes it clearer
10:59:14 <Igloo> So (5 +) is f and [1..10] is xs in this example
11:00:56 <elmex> ah
11:00:57 <elmex> gotit
11:00:58 <elmex> [ t + g | t <- [1..3], g <- [1..3]]
11:02:00 <elmex> Igloo: thanks for explanation
11:02:06 <Igloo> np
11:08:30 <elmex> lol
14:10:43 * xbill peeks
14:44:55 <Psion> Does the topic actually mean "ICFP contest" entry?
14:45:21 <Heffalump> in what sense?
14:45:53 <Psion> In that sense that that is what shapr is looking for team members for....
14:47:21 <Psion> So you don't know, Heffalump? =)
15:02:28 <Heffalump> doh
15:24:14 <engstad> Greets. Is there a smart way of getting proper line-editing while runningn hugs?
15:25:08 <Igloo> Link against libreadline
15:25:41 <engstad> In Ocaml, there's supposed to be a program doing it for you, i.e.:  readl ocaml
15:25:54 * Heffalump wonders if Igloo knows anything about decent cross-platform (os/arch/haskell) support for readline in Haskell code
15:30:31 <engstad> Ah, I found it, it's called 'ledit', http://pauillac.inria.fr/~ddr/
15:38:15 <Igloo> In your own code I believe GHC has a library and wouldn't be surprised if nothing else did
15:38:55 <Igloo> I may have misunderstood his question and a web page in French isn't very enlightnening for me  :-)
19:24:51 <dan> !
