00:21:01 <julien> hi all
00:23:02 <shapr> hi!
00:36:29 <julien> playing with gvd ... Is there a debugger for Haskell ?
00:38:12 <shapr> I think so
00:40:39 <julien> should be something of great interest
00:41:03 <julien> I made ebuild files for the hugs98 for gentoo linux
00:41:12 <julien> I will do the same for ghc
01:04:48 <shapr> http://www.haskell.org/debugging/
04:19:31 <shapr> hi Vutra_ 
04:21:09 <Vutral> he
04:21:19 <shapr> what's up?
04:21:45 <Vutral> nuthing
04:21:54 <Vutral> i am embedding around
04:22:27 <shapr> embedding?
04:22:30 <Vutral> yeah
04:22:30 <shapr> nifty way of putting it
04:22:40 <Vutral> well
04:22:44 <Vutral> i like rapid development
04:22:52 <Vutral> i embed in long hurting acts
04:23:01 <Vutral> and then i can enjoy that work :>
04:23:11 * shapr grins
04:23:17 <shapr> I don't completely understand
04:23:19 <shapr> but it sounds nifty
04:23:23 <shapr> what are you embedding?
04:23:29 <Vutral> hhe
04:23:33 <Vutral> interpreters
04:23:41 <shapr> oh!
04:24:11 <Vutral> hehe
04:24:20 <Vutral> yes
04:30:02 <ski> hello all !
04:33:38 <shapr> hi ski!
04:33:39 <shapr> what's up?
04:33:55 <ski> hi shapr !
04:34:35 <ski> i just thought i'd irc a little today ..
04:34:53 <shapr> I'm banging my head on ASN1
04:35:03 <shapr> what are you doing?
04:35:20 <ski> nothing, right now.
04:35:35 <ski> (well, reading news a little, perhaps)
04:36:48 <ski> any discussion here recently ?
04:37:52 <shapr> we had some pretty good discussion a coupla days ago
04:38:04 <shapr> I had some awesome epiphanies about programming after comparing Haskell and Joy
04:38:23 <ski> epiphanies ? (don't know that word)
04:39:07 <shapr> hrm, the online dictionaries give a slightly different meaning
04:39:19 <shapr> but I've always heard it used as a name for a "eureka moment"
04:40:08 <ski> oh, well what did you discover (is Joy that forth-alike language, i think it is ?)
04:40:39 <shapr> yah, Joy is like Haskell that operates on stacks, and where space and . are switched in meaning
04:40:43 <shapr> that makes a pretty major difference
04:40:56 <shapr> in Haskell, the space char is almost an operator
04:41:00 <shapr> it means function  application
04:41:19 <shapr> but in Joy it means concatenation, we use . in Haskell
04:41:29 <shapr> and Joy operates on a stack, yes
04:41:35 <ski> yeah, but it's *syntax* (can't reduce function application to just a function :-)
04:42:02 <shapr> yah, but I suddenly realized how much of programming is just a convention
04:42:26 <shapr> so I started seeing the principles that languages are designed around
04:42:34 <ski> i made a sort-of interpreter (simple sketch, i.e.) in haskell of a forth-like language.
04:42:41 <ski> for some time ago
04:42:41 <shapr> there are basic assumptions that languages make
04:42:50 <ski> yes
04:42:51 <shapr> I just want to be able to figure out those assumptions
04:43:15 <ski> that's an interesting topic for investigation
04:43:27 <shapr> yah, you should read the logs :)
04:45:08 <ski> you mean 02.01.14, d'you ?
04:45:28 <shapr> er, I dunno
04:46:10 <ski> it seems that it's the only logged recent day, where i could find Joy mentioned..
04:46:17 <shapr> that must be it then
04:47:16 <ski> i'm gonna browse it a little while now, if you don't mind ..
04:47:29 <shapr> sure
04:54:10 <ski> okay, you seemed to have discovered that every programming language must have some primitive syntax for "getting things done", no matter if it's "function application", "function concatenation","predicate call","message passing","continuation jumping", etc ..   . Right ?
04:54:21 <shapr> right
04:56:45 <shapr> the question I have is: what are the different syntaxes? which languages use which syntax?
04:56:53 <ski> hmm, xbill said something about replacing the call stack with a queue. exactly what i have pondered a little also :-) (so it implements a scheduler)
04:56:57 <ski> eh ?
04:57:11 <ski> whad do you mean ?
04:57:31 <shapr> are there languages that combine syntaxes? (python is procedural, but has: map, filter, apply,  1st class functions, list  comprehensions, and more)
04:57:57 <ski> i think the syntax is a way to concretely (most often in text) express the basic concepts
04:58:00 <ski> hmm
04:58:41 <ski> most imperative languages are both procedural and functional (but not so much :-( )
04:59:30 <ski> so in say C (and Java,..) they've even merged procedures into functions (returning void)
05:00:41 <shapr> I'd like to see a language based around continuations
05:00:51 <shapr> since continuations are functions that don't have to return
05:01:16 <ski> now that's my idea ! but i haven't worked su much with it for a while ..
05:01:47 <ski> so real continuations is really a different concept from functions.
05:01:57 <shapr> yes it is
05:02:08 <ski> though they can be disguised as functions.
05:02:17 <shapr> functions are a subset of continuations
05:02:28 <shapr> continuations + some limits = continuations
05:02:34 <ski> as one can say that procedures can be disguised as functions returning some trivial value.
05:02:52 <ski> yes, that's one way of looking at it.
05:03:00 <shapr> er, sorry...
05:03:06 <shapr> continuations + some limits = functions
05:03:11 <shapr> I'm working at the same time
05:03:15 <shapr> this is a background task
05:03:21 <ski> ok, thought you mean't that.
05:03:29 <ski> ok
05:03:36 <shapr> yah, I did mean that :)
05:04:33 <shapr> do you know of any continuation based languages?
05:04:42 <ski> a function of type "a -> b" is more or less equivalent to a continuation of type "cont<a,cont<b>>" if you understand what i mean
05:04:45 <ski> well
05:05:57 <shapr> I think I need to read up continuation passing style
05:06:02 <ski> i have read a litlle about a language called "IO" in a paper
05:06:20 * ski tries to find that paper
05:08:44 <ski> "Advanced Programming Language Design",Raphael Finkel,Chapter 2
05:08:52 <ski> e.g. at http://cseng.aw.com/book/related/0,3833,0805311912+20,00.html
05:09:32 <ski> that's mostly all i have managed to find about IO, but i think it's syntactic sugar is worth to consider.
05:11:47 <ski> also "Categorical Structure of Continuation Passing Style",Hayo Thielecke is interesting (though i don't understand much of the advanced category theory, but the many examples in some chapters can be understood)
05:12:17 <shapr> it's a book?
05:12:30 <ski> he devises a "theoryish" notation for a continuation calculus, a bit like lambda calculus.
05:12:56 <shapr> I can't get to that aw.com url
05:12:58 <shapr> no response
05:13:03 <ski> it's a scientific paper (thesis)
05:13:16 * ski tries to find another link
05:15:10 <shapr> looks like aw.com is down
05:17:30 <ski> well, here's another link : http://www.nondot.org/sabre/Mirrored/AdvProgLangDesign/
05:17:54 <ski> Chapter 2 : Control Structures
05:19:20 <ski> i tried to use a syntax similar to Hayo Thielecke's and implement it (for the time being) as a macro in scheme, but now i think i'm a little more attracted to the IO syntax.
05:20:32 <ski> though, it was Hayo Thielecke's paper that showed me that continuations have much to do with negation in classical logic :-)
05:21:00 <shapr> that makes no connection for me at all
05:21:03 <smkl> you can implement continuations with a monad
05:21:03 <shapr> I'll have to read his paper
05:21:31 <ski> smkl : yes, the continuation monad. continuations and monads have many things in common
05:21:51 <ski> you mean read Hayo Thielecke's paper ?
05:22:39 <ski> be prepared to not understand most of it. i didn't understand very much of the advanced chapters
05:23:04 <smkl> the type for computations that return values of type a in this monad has type ~~a = (a -> _|_) -> _|_
05:23:44 <ski> if you wan't to read up on continuations, more as "from the beginning" there are other papers also ("Abstracting control" perhaps, i don't remember if it's hard to understand or not for a continuation newbie ..)
05:24:23 <ski> smkl : or you can replace _|_ by an "answer" type
05:24:52 <ski> smkl : like  data Cont a = (a -> O) -> O  for some type O
05:25:17 <ski> smkl : or parametrice it : data Cont o a = (a -> o) -> o
05:25:30 <ski> smkl : (i forgot the constructors there..)
05:25:32 <smkl> sure, i just used _|_ to make connection with logic
05:25:43 <ski> ok
05:26:30 <ski> IIRC early haskell used a dialogue-style (program is function from response-stream to request-stream)
05:26:32 <smkl> afaik you cannot define the type for _|_ in haskell anyway, except perhaps some 2nd order type
05:27:14 <ski> a dialogue-style IO system, but to make composable program part you have to do (at least simple) CPS (continuation-passing-style).
05:27:44 <ski> in that example the type Dialogue (= [Response] -> [Request]) is the answer type
05:28:02 <ski> well, how about data Bottom ?
05:28:30 <ski> and a coercion function fromBottom :: Bottom -> a
05:28:41 <smkl> i have never tried. does that work?
05:28:47 <ski> i've seen similar things in ML
05:29:43 <ski> you can define a data-type with no constructors in haskell, yes. but i'm not sure if it's going to help with a bottom type for continuations ..
05:33:02 <smkl> i don't think there would be much point in using bottom type anyway
05:34:24 <ski> not often anyway.
05:38:02 <ski> shapr : "Representing Control",Oliver Danvy and Andrzej Filinski : http://citeseer.nj.nec.com/rd/0%2C2318%2C1%2C0.25%2CDownload/http%253A%252F%252Fciteseer.nj.nec.com/compress/0/papers/cs/4415/ftp%253AzSzzSzftp.daimi.aau.dkzSzpubzSzdanvyzSzPaperszSzdanvy-filinski-mscs92.ps.gz/danvy92representing.ps
05:38:56 <ski> shapr : describes transformation from "direct style" programs to CPS (continuation-passing style) programs.
05:40:23 <ski> one thing "built-in" in both continuations and monads are sequencing, just think of the type of (>>=) :: Monad m => m a -> (a -> m b) -> m b
05:41:26 <ski> shapr : busy looking at those links ?
05:41:27 <shapr> that makes sense
05:41:54 <shapr> actually I'm trying to figure out what's wrong with this DER encoding of a CertificateChoices...
05:41:58 <shapr> but that's besides the point ;)
05:42:21 <shapr> not related to Haskell at least
05:42:50 <shapr> I will read those papers when I get home.
05:42:55 <ski> that's not to say that monads or continuations inherently can't do distributed/parallell/concurrent computing
05:43:04 <shapr> yah, that's something I thought about
05:43:23 <shapr> I asked the guy who wrote Stackless Python if he would allow me to serialize continuations
05:43:37 <ski> how d'you mean ?
05:43:38 <shapr> I figured I could then distribute them to other python VMs
05:43:54 <shapr> (there's already a distributed object directory system for python)
05:44:35 <shapr> he said it's mostly possible
05:44:50 <shapr> sadly, some parts of Stackless Python still require recursive interpreters
05:44:59 <ski> uhmm.
05:45:11 <shapr> did that make any sense at all?
05:45:12 <shapr> :)
05:45:30 <ski> i'm not sure what you mean with serialize ..
05:45:43 <shapr> save to disk, send across the network, whatever
05:46:01 <shapr> serialize = turn into a stream of bits that can be restored here or elsewhere
05:46:14 <ski> ahh, ok, now i get it ( for some reason called marshalling in O'Caml).
05:46:28 <shapr> yah, that's it
05:47:03 <ski> in O'Caml they had a little problems with marshalling first-class functions. guess continuations wouldn't be much more difficult than functions ..
05:47:20 <shapr> that sounds really interesting
05:47:34 <shapr> I've never tried pickling functions in Pytho
05:47:38 <shapr> I should try that
05:47:40 <shapr> Python even
05:48:50 <ski> function marshalling in O'Caml is only availble if a correspoding flag is set, and you can only call the marshalled function from within the same executable (hopefully running on a different machine) that sent the marshalled function (it's checked by an MD5 checksum)
05:49:10 <shapr> hm, sounds slightly scary
05:49:43 <ski> so in effect, they only send a code pointer and probably the internal closure data as well
05:49:56 <shapr> hm
05:50:19 <ski> i see no reason that this approach shouldn't work with continuations as well
05:51:03 <ski> though, it's perhaps not a very satisfying approach, but at least it works.
05:51:20 <shapr> what would be better?
05:52:19 <ski> well, i don't know. somehow being able to pass functions (and continuations) to another running executable and run it from within that. though i don't know if this is possible.
05:53:22 <ski> i seem to remember some scheme-cgi-www-program that used continuations somehow to remember where the cgi-program left off and should start over again at.
05:53:32 <shapr> yah, it's *cool*
05:53:36 <shapr> it makes much more sense
05:53:40 <shapr> for cgi
05:54:27 <ski> and the cgi-library in John Hughes arrow paper used a sort of "path" from the program path to where to continue, but it must be the same program runnning ..
05:54:42 <shapr> I haven't finished the arrow paper yet.
05:54:48 <ski> ok
05:55:11 <Heffalump> arrows are complicated, you should first get your head around monads
05:56:03 <ski> well, i think i agree that monads should be understood first, before trying to understand arrows, it's sorta the same line of though, just a bit more complex.
05:57:36 <ski> i think that continuations arose first as a "style" for structuring some functional programs. i.e. you passed a function which you normally called with the answer, but could optionally ignore, with cool control effects as result.
05:58:51 <ski> then some people got tired of having to structure most of their code in this continuation-passing-style, mostly doing nothing special with the continuation, only making code harder to read.
06:00:14 <ski> so someone came up with a special syntax (or function) used to grab to current continuation, so that one could program in a more "direct" style, and still have the availability of continuations.
06:02:01 <ski> so a transform was devised from this "direct-style" (more or less lambda-calculus + call/cc) into continuation-passing style (essentially just lambda-calculus but in that certain style)
06:02:48 <jewel> is the John Cowan mentioned on the Joy synopsis page the same one who wrote the lojban reference grammar?
06:04:58 <ski> then some looked at (pure) continuation-passing-style as not just a lambda-calculus sort-of-thing but a new way of thought about computation (see those functions never return, just call the function argument (called "continuation"), so why not just call them continuations instead, all of them ?)
06:05:32 <ski> jewel : don't know
06:07:11 <ski> jewel : well, at least he has lojban on his homepage (http://home.ccil.org/~cowan/)
06:08:36 <shapr> jewel: yah, same guy
06:08:57 <shapr> jewel: I was entertained :)
06:13:43 * ski looking at http://groups.yahoo.com/group/concatenative/
06:13:55 <shapr> oh, I hadn't seen that yet
06:14:20 <ski> mostly about joy and other concatenative langs.
06:14:45 <shapr> very nifty
06:14:58 <jewel> entertained by what?
06:15:23 <shapr> jewel: by the fact that John Cowan did the Joy implementation
06:16:42 <jewel> So he wrote the implementation, but didn't create the lang?
06:16:48 <ski> no
06:16:59 <ski> manfred van thum (or something) did.
06:17:08 <shapr> right
06:17:20 <shapr> thaum?
06:17:22 <shapr> thoom?
06:17:23 <shapr> something
06:17:51 <ski> "Manfred von Thun" (from his page, so it gotta be right)
06:18:23 <shapr> ah
06:19:22 <ski> one can implemenent a stack for concatenative language in a functional lang. in an interesting way : CPS
06:20:00 <shapr> I'd like to investigate a tiny Joy emulator in Haskell
06:20:20 <ski> emulator ? interpreter or embedding ?
06:20:38 <shapr> not sure
06:20:53 <ski> both is probably interesting.
06:21:00 <shapr> I'm not really picky either, as long as it lets me play with the ideas
06:21:37 <ski> one way is to simulate the stack with a list
06:22:09 <ski> so : dup (x:xs) = x:x:xs
06:22:13 <shapr> Joy in Haskell is more fun to think about than ASN.1
06:22:23 <ski> and drop (x:xs) = xs
06:22:37 <ski> and plus (x:y:xs) = x+y:xs
06:22:40 <ski> and so on ..
06:27:06 <shapr> I'd like to try that
06:27:18 <ski> ok
06:28:02 <shapr> when I get home :)
06:28:14 <ski> the down-side of doing this as an embedding is that haskell lists is homogenous, all the stack elements must be of same type :-(
06:28:57 <ski> in this scheme a "word" (to use forths terminology) is a function of type [a] -> [a] for some a.
06:29:00 <Heffalump> but you can just create a tagged union of all the possible types
06:29:11 <ski> yes.
06:29:27 <ski> and in an interpreter you'd do just that
06:29:29 <shapr> cheesy, but it works
06:29:55 <shapr> or maybe it's just pragmatic rather than cheesy
06:29:58 <ski> but as to play around and mix with ordinary haskell functions (i.e. embedding) this is a minus
06:30:12 <shapr> that's true
06:31:10 <ski> cuz, in an interpreter you'd probably anyway read in some text to some haskell datatype representing preograms (and possibly have a haskell datatypes for types also if you do typechecking) 
06:32:12 <ski> and then, to haskell, all data in the program has type ForthValue (or something) so then, it's not a problem that the lists (stacks) is homogenous.
06:38:57 <shapr> I suspect I'm not up to embedding a Joy system yet
06:40:23 <ski> well, my embedding was not a whole embedding of Joy just of some of the very basics (i.e. stack, concatenate, dup, drop, constant functions, plus, call/cc, etc ..)
06:48:35 <ski> so i think it's not any more Joy than Forth right now.
06:51:55 * ski reading more usenet now
06:52:25 * shapr bangs his head against ASN.1
07:02:26 <shapr> keeeraaap
07:02:40 <shapr> ASN.1 is *extremely* frustrating stuff
07:09:37 <ski> what's ASN.1 ? an assembler system ?
07:09:38 <ski> (it seems that either the irc server or my connection to it is really slow, i can't see my last comment at clogs's log yet)
07:47:54 <shapr> ski: ASN.1 is Abstract Syntax Notation One
07:48:21 <shapr> it's an EBNF style specification language for data interchange
07:48:55 <shapr> it has a thousand and one different encodings (even XML) and it's a massive pain in the ass to create and parse the specs
08:05:40 <ski> ok
09:35:43 <jewel> I like these ordered sets in Joy, does haskell have equivalent structures?
09:39:45 * shapr dunno
09:39:57 <Heffalump> what exactly is an "ordered set"? A quick google doesn't tell me.
09:40:56 <Luke_> I see that list comprehensions seem to be implemented with monads. is that implemented straightforwardly in haskell somewhere, and if so - where?
09:41:13 <Luke_> I'm hoping that by understanding list comprehensions, I can use a haskell implementation of them to understand monads :0
09:42:23 <jewel> The examples are sets like {1 3 5}, where __{5 4 2} first__ yields  2
09:42:43 <Heffalump> list comprehensions aren't implemented with monads in Haskell, as far as I know, though they are very similar in many ways
09:43:03 <Luke_> Heffalump: ah, I saw "do" and thought maybe they were just written as regular haskell code. nevermind
09:43:20 <Heffalump> lists are a monad, so you can do list comprehensions with monad syntax too
09:43:29 <Heffalump> but in Haskell 98 you lose the ability to do conditions if you do that
09:43:46 <Heffalump> so [2*x | x <- [1..5] ] translates to
09:43:51 <Heffalump> do x <- [1..5]
09:43:58 <Heffalump>    return (2*x)
09:44:15 <Heffalump> but [2*x | x <- [1..5], even x] has no simple translation
09:44:27 <Luke_> I'm just looking for a simple bit of example code that uses Monads in an understandable way, so I can see what it is..
09:44:41 <Heffalump> look for some code that uses a State monad
09:44:45 <Luke_> well, fairly simple - you can implement list comprehensions in lisp with a dozen or so lines of macro
09:44:51 <Heffalump> I generally find that simplest for introducing them
09:45:19 <Heffalump> jewel: errm, so if there's an ordering they're not really sets at all
09:46:10 <jewel> a set can be ordered
09:46:19 <jewel> it just doesn't have duplicates
09:47:42 <Heffalump> no, sets aren't ordered
09:48:01 <jewel> yeah, that's why they are called ordered sets
09:48:13 <Heffalump> but (having found some documentation on this) it seems what the first operator does is use the natural ordering on integers
09:48:26 <Heffalump> so { 5 2 3 } first is also 2
09:49:07 <jewel> yes
09:50:14 <Heffalump> right. umm.
09:51:58 <Heffalump> I can't find anything, but it wouldn't be that hard to implement a module to do it
09:57:32 <Luke_> it'd be cool if somewhere where to write in lisp/scheme an interpreter for an ultra-minimal language that supports monads
09:57:37 <Luke_> has that been done, do you know?
09:58:22 * ski back from usenet land
09:58:59 * Heffalump has no idea, sorry
09:59:11 <ski> i've made some quick macros for monads (do-notation syntax) in scheme
09:59:23 <ski> but it's no interpreter, no
09:59:34 <Heffalump> I think you really need a polymorphic type system with type constructors to support monads
10:00:33 <Luke_> ski: want to share them?
10:00:34 <ski> no
10:00:34 <ski> that's not really neccesary
10:00:39 <ski> you need a polymorphic type system or some special built-in syntax for monads (like do-syntax in haskell, though that's sugar)
10:01:09 <ski> Luke_ : sorry to say, i don't have them here at school
10:01:33 <ski> Luke_ : but it should be so hard to rewrite i think.
10:04:17 <Luke_> http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm looks good actually
10:05:11 <ski> looks, like it is starting with the basics
10:05:40 <ski> so you wan't to understand monads ?
10:06:02 <Luke_> well I'm wondering what a monad is, so basics are good :). seems like most descriptions are very mathematical, but I'm guessing very obvious explanations could be given if they assume that you already know e.g. lisp
10:06:49 <Luke_> like when people try to explain call/cc as "it's like a suspended computation, ..." to glazed-eyed people, even if those people already understand setjmp/longjmp :)
10:07:20 <ski> well, if you know at least some scheme (or lisp) you can look at http://okmij.org/ftp/Scheme/monad-in-Scheme.html .  also i can try to explain "interactively" if you wan't ..
10:07:41 <jewel> wow, these anonymous functions in Joy are cool
10:08:14 <ski> Luke_ : knowledge of lisp is *not* a prerequisity for learning monads. AFAIK lisp programmers rearely use monads.
10:09:13 <Luke_> ski: right, but given that I already understand lisp, it's probably best not to explain monads to me in terms of category theory, I mean :)
10:09:46 <ski> Luke_ : but on the other hand, monads can be used in lisp (or scheme) if one want's to. (like oleg in the given link)
10:09:49 <ski> ok :-)
10:11:19 <Luke_> I think the key to these things is to explain them to people in terms of something they already understand, but it seems like Monads are usually explained in terms that you won't understand until you've learned haskell :)
10:11:21 <ski> one good way of looking at a monadic object of, say, type "IO Char" is that it is an object representing a computation returning Char and possibly doing some other stuff peculiar to the IO monad, ok ?
10:12:40 <ski> NB : the monadic object is unevaluated/suspended, ("it has potential of doing something"), like a function closure in lisp taking no arguments (i.e. a thunk, you know it ?)
10:13:16 <Luke_> reading the oleg scheme code
10:14:02 <ski> Luke_ : are you with me at any rate, or am i just a lousy explainer (i'll try again) ?
10:14:48 <Luke_> well I already understand the "gist" of monads I think so I'm not paying that much attention :) trying to get a "concrete" understanding from some code
10:17:11 <ski> ok, you have more (specific ?) questions, just ask, k ?
10:17:18 <Luke_> yep, thanks
10:18:22 <ski> Luke_ : his letM (and letM*) macros is effectively equivalent to my "do" macro for imitating haskell's do-notation.
10:27:42 <ski> Heffalump : can't [2*x | x <- [1..5], even x] be transformed into do { x <- [1..5] ; guard (even x) ; return (2*x) } ?
10:28:34 <ski> guard is in Monads.hs i think
10:29:14 <ski> s/Monads/Monad/
10:29:20 <ski> guard :: MonadPlus a => Bool -> a ()
10:29:53 <ski> (or maybe it's fail that get called instead (?))
10:30:17 <smkl> guard x = if x then return () else mzero ?
10:30:57 <smkl> hmm, yes
10:31:38 <Heffalump> oh, so it can.
10:31:39 <Heffalump> oops.
10:31:54 <jewel> it might be interesting to try write something that can convert Joy to java bytecode
10:31:58 <ski> think so
10:31:58 <ski> but that only works for monads that support a zero, which list-monad does :)
10:32:03 <Heffalump> yeah
10:32:39 <Heffalump> gah. I could have made some of the code for my thesis nicer if I'd realised that.
10:33:38 <Heffalump> I didn't twig that return _ << foo is just foo.
10:34:22 <Heffalump> which I really should have done.
10:37:58 <ski> so older hugs variant allowed any monad to be used in a list-comprehension
10:38:04 <smkl> hmm, do { x <- foldl mplus mzero (map return [1..5]); ... }
10:38:15 <Heffalump> yeah, I know, but they cut that out of Haskell 98
10:38:56 <smkl> list comp. only works for monad+
10:39:54 <smkl> err, wait
10:42:09 <smkl> monad0 should be enough but that was removed
10:43:36 <Heffalump> yeah
10:43:59 <Heffalump> I guess they didn't want to clutter the libraries too much
10:45:19 --- topic: 'Functional Programming, that's the opposite of Dysfunctional Programming (like VB) | we be loggin' http://tunes.org/~nef/logs/haskell/ | welcome to the Haskell Dojo | jewel, julien, and shapr are up to white belt!'
10:45:19 --- topic: set by shapr on [Mon Jan 07 10:42:01 2002]
10:45:19 --- names: list (clog ski_thats shapr Heffalump ski Vutral kepler_ smkl xbill dmiles pHa jlb jewel dennisb)
10:45:25 <shapr> aha, ski has a brother
10:45:38 * ski_thats seems to have some connection problems
10:45:42 <shapr> ah
10:45:51 * ski_thats is ski
10:45:58 <shapr> I had guessed so
10:48:20 <ski> good to be back. i think they're doing some maintainence here at school, so that's probably what happened
11:03:10 <shapr> oh.
11:03:14 <shapr> monads == progn
11:03:16 <shapr> well
11:03:23 <shapr> I can understand that
11:03:47 <ski> progn ?
11:03:56 <shapr> progn in lisp
11:04:33 <shapr> (progn (defun 1) (defun 2))
11:04:46 <shapr> that assures that (defun 1) finishes before (defun 2) starts
11:04:50 <ski> well, more or less
11:05:01 <Heffalump> umm, no
11:05:06 <shapr> no?
11:05:07 <Heffalump> think laziness, for one thing
11:05:14 <ski> but progn directly execute
11:05:24 <shapr> that's true
11:05:31 <shapr> I see what you're saying
11:05:36 <Heffalump> I don't know any lisp, though
11:05:43 <ski> as opposed to monads where you can return the value given by a do-expression
11:05:49 <shapr> imho, lisp is simpler than Haskell
11:05:54 <shapr> but not nearly as nifty
11:05:58 <Heffalump> but you certainly have no guarantee that monad sequencing will ensure that the left hand argument finishes before the right hand one starts
11:06:16 <shapr> not even using bind?
11:06:25 <Heffalump> that is monad sequencing, sorry
11:06:42 <ski> Heffalump : no but the left "argument" is conceptually sequenced before the other one
11:06:55 <Heffalump> but..on the other hand..you won't be able to tell the difference in results
11:06:59 <Heffalump> ski: yeah
11:07:03 <shapr> fair enough :)
11:07:09 <ski> see "conceptually" :)
11:07:15 <shapr> close enough for government work
11:07:16 <Heffalump> :-)
11:07:19 <shapr> (as they say in Alabama)
11:07:34 <ski> heh
11:07:42 * Heffalump goes home
11:07:49 <ski> bye Heffalump !
11:09:05 * shapr waves
11:11:33 <ski> so a progn in lisp isn't exactly like do-notation.
11:11:38 <ski> agreed ?
11:12:07 <shapr> right!
11:12:16 <shapr> it's strict
11:12:21 <shapr> >>= isn't
11:12:46 <shapr> >>= just means "this thing will happen after the >>= before it, and before the >>= after it
11:12:49 <ski> >>= can be strict, but that's not the most important difference
11:13:53 <ski> a progn-expression in lisp performs some side-effects and return the value of the last expression (or does it return nil or undefined ?)
11:14:05 <ski> do i remember correct ?
11:14:18 <shapr> er, last expression
11:14:51 <ski> at least that's how begin in scheme works.
11:15:54 <ski> a do-expression in haskell produces a side-effect object (representing what side-effects it can do), and returns this as it's value
11:17:43 <ski> to actually perform the side-effects (and get the result value) you have to use (>>=) (or monadic bind like "x <- .."). in another do-expression, of course :-). so really this outer do-expression just returns an object representing what it (and it's sub computations) can do.
11:18:48 <ski> if progn or begin would be like a do-expression. it wouldn't perform side-effects right-away, but instead return a "side-effect representing object"
11:20:23 <shapr> wow
11:20:23 <ski> that's the important difference between progn and monads, IMO. that monads are "referentially transparent" (whatever that means) and progn isn't (it has effects which isn't contained in it's result value)
11:20:25 <shapr> that's smooth
11:20:37 <shapr> I get it.
11:20:43 <ski> you see how i see it ?
11:20:49 <shapr> yah, nice
11:21:52 <ski> in lisp we can't replace (progn (foo) (foo)) with (let ((foo-result (foo))) (progn foo-result foo-result)) now can we ?
11:23:08 <shapr> nope
11:23:11 <ski> but in haskell we can ! (i.e. do { foo () ; foo () } is the same as let foo_result = foo () in do { foo_result ; foo_result }
11:23:13 <shapr> fascinating
11:23:30 <ski> that's because the sid
11:23:33 <ski> oops
11:24:12 <ski> that's because the effects are effectively (pun intended) contained in the returned object (of some monadic type, say IO Char)
11:24:40 <ski> instead of being directly performed as a side-effect
11:25:20 <ski> you like it ?
11:25:57 <shapr> yah, I like it
11:26:13 <shapr> my original mental picture was right, though not as detailed as what you just said
11:26:30 <ski> ok, good.
11:26:47 <shapr> my mental picture is that monads are rings on a string
11:26:52 <shapr> and the string is the haskell program
11:26:55 <shapr> and the rings are the same size
11:27:05 <ski> ring ?
11:27:12 <shapr> so the rings can slide up or down the string, but they can't change their order on the string
11:27:16 <ski> mathematical ring ?
11:27:25 <shapr> no, literally a small circle of metal
11:27:31 <shapr> such as I wear on my finger
11:27:52 <ski> ahh, ok. not a bad mental image, i think.
11:28:40 <shapr> yah, except it doesn't include the idea that those are side effect objects
11:28:41 <ski> it's the monadic bind that effectively puts this sequencing in monads
11:28:44 <shapr> which makes some difference
11:29:45 <ski> though in the list monad, the sequencing is not so much like ordinary time sequencing (it's more like the "many worlds" interpretation of Quantum Mechanics, if you know what i mean)
11:30:17 <shapr> uh, no
11:30:23 <shapr> I know the Quantum Mechanics part
11:30:26 <shapr> but not the list monad
11:31:10 <ski> well, in the list monad there are many futures. it's sequenced, but not always one future
11:31:56 <shapr> uh
11:32:11 <ski> example : do { x <- [0..9] ; y <- [0..x] ; return (x,y) }
11:32:14 <shapr> this I gotta see
11:32:20 <shapr> oh
11:32:24 <shapr> no wait
11:32:27 <shapr> huh?
11:32:47 <ski> confused yet ?
11:33:31 <shapr> looks like a list comp to me
11:33:35 <shapr> wait...
11:33:44 <shapr> list comprehensions are list monads?
11:33:47 <ski> x <- [0..9] binds one value (*one* value) to x to be used in the computations future (like x <- getLine in IO monad)
11:33:50 <ski> yes
11:33:53 <shapr> Oh!
11:33:56 <ski> just another syntax
11:35:06 <ski> now there are many futures at this place in the code (10 direct futures to be exact)
11:35:29 <ski> so x gets bound to all 10 possible values. one for each future
11:35:49 <shapr> that's cool
11:35:53 <shapr> the Trousers of Time!
11:36:24 <ski> then y gets bound (how many futures depend on which branch we wen't at x's binding)
11:37:06 <ski> so it's like multiple clonings of the universe
11:37:12 <shapr> that's spiffy
11:37:32 <ski> you thought of list-comprehensions this way before ?
11:37:37 <shapr> no
11:37:43 <shapr> that's why it's so cool
11:39:31 <ski> but in actual (as in real) time ("meta-time") often one branch will be taken and explored and generates a result, then the computation is so to speak run backwards to the last choice in these Trousers of Time and the next branch is taken. thus all solutions is collected in a list
11:40:00 <ski> this is more or less what prolog does built-in (+ some other interesting things)
11:40:53 <shapr> interesting
11:41:24 <ski> yes, it is.
11:42:18 <ski> so the "effect" done in the list monad isn't some reading of files or something. it's time-splitting !
11:42:54 <shapr> wow, that's awesome
11:43:08 <shapr> I just explained to the #python channel that Python has monads
11:43:14 <shapr> this caused some excitement
11:43:26 <ski> heh :-)
11:43:48 <ski> yes list-comprehensions is one particular kind of monad
11:43:56 <Heffalump> ML has monads too, but they are very rarely used
11:44:54 <ski> Heffalump : i know, iv'e seen some ML-guy on comp.lang.functional saying he often uses monads (was it Markus Mottl ?)
11:45:23 <ski> Heffalump : and Clean has it, but not so often used there i think
11:45:52 <ski> then Escher has monads (it's a functional-logic language, syntax mostly stolen from haskell)
11:46:03 <shapr> never heard of it
11:46:43 <ski> it's not a big language, more or less (i think) a research language, though it's users may disagree
11:47:10 <shapr> I've often heard that Haskell is a research language
11:47:10 <Heffalump> really, any language that has higher-order functions has monads, but how practical it is to use them is a different matter
11:47:17 <Heffalump> shapr: I was about to say that :-)
11:47:31 <ski> yes, but then Escher is more so.
11:47:41 <ski> Heffalump : yes.
11:48:29 <ski> one can have monads without higher-order functions as well. in that case one can't have a bind functions so it's gotta be some syntax
11:48:40 <shapr> whether or not Haskell is used commercially or not, I like it.
11:49:00 <shapr> it's dramatically changed the way I think about programming in just a few months.
11:49:01 <ski> gotta say the same for myself :)
11:50:28 <ski> but then, it was my first functional language (though had i learned ML or Scheme first, i still think i would've liked haskell)
11:51:05 * ski though to look at #python through clog but it seems clog don't log that channel :(
11:51:32 <shapr> I think clog doesn't need to
11:52:20 <ski> no it doesn't need to. i just wanted to have a look at their reactions learning that their language also supports at least one monad
11:52:35 <shapr> brains all overs the walls ;)
11:52:51 <ski> gotta imagine that instead :)
11:54:11 <ski> the maybe monad is basically a simple exception monad
11:57:12 <ski> you know what's discussed in the #{} channel ?
11:57:24 <shapr> no
11:57:33 <shapr> but I know several people who hang out there
11:57:43 <ski> just trying to figure it out..
11:57:46 <shapr> as a Python and Haskell user, I'm not allowed to show up there ;)
11:58:03 <ski> you are not ?
11:58:41 * shapr is joking
11:58:45 <shapr> I don't use braces :)
11:59:23 <ski> ahh, it's something to do with if your particular prog.lang. uses bracers, isn't it ?
11:59:52 <ski> s/bracers/braces/
11:59:57 <shapr> I don't know, that was just a guess that was supposed to be funny
12:01:49 <ski> haha. me trying to seriously parse/infer/understand what you are saying and not getting that it was meant as funny :(
12:02:34 <ski> in one particular log here they seem to discuss patents,plunder and perhaps socialism
12:03:12 <shapr> weird
12:07:25 <ski> pardon me for not being so conversable right now, but i can't come up with much to say for the moment
12:08:44 <ski> just googling for myself on the net and seeing what i can find out about myself :)
12:10:37 <ski> i'm sorry to say i don't have any picture of myself on the net so people can't see what i look like. maybe i should try to fix some sort of homepage ...
12:25:38 <ski> well i think perhaps i should go home. i'm hungry and tired ..
12:25:53 <ski> so bye shapr and you others ..
12:26:02 * ski waves
13:13:25 <shapr> hi
13:13:35 <lodewijk> hello
13:13:41 <Heffalump> 'lo
13:27:28 <shapr> if I have an Int I want to turn into a string
13:27:40 <shapr> can I just "show iter" ?
13:31:48 <lodewijk> I think so
13:32:03 <shapr> ok, thanks
13:34:12 <shapr> hrm
13:34:19 <shapr> I'm having a type classes problem
13:34:21 <shapr> type MandelData = (Integer, Complex Double, Complex Double)
13:34:30 <shapr> instance Show MandelData where
13:34:31 <shapr>     show (iters, z, c) = "MandelData with values: Iteration Count: " ++ show iters ++ ", value of Z:" ++ show z ++ ", value of C:" ++ show c
13:34:45 <shapr>     Illegal instance declaration for `Show MandelData'
13:34:45 <shapr> 	(The instance type must be of form (T a b c)
13:34:45 <shapr> 	 where T is not a synonym, and a,b,c are distinct type variables)
13:34:45 <shapr>     In the instance declaration for `Show MandelData'
13:34:49 <shapr> what does that mean?
13:35:49 <shapr> hrm
13:35:56 <lodewijk> sorry, I haven't done anything with classes yet, I'm still fighting the type system for regular functions :|
13:36:22 <shapr> maybe it doesn't want me to do anything with pattern matching in an instance declaration?
13:36:25 <shapr> hrm
13:38:22 <Heffalump> you can't declare instances for type synonyms
13:38:27 <shapr> oh
13:38:38 <Heffalump> use newtype and a (useless) type constructor, or something
13:38:39 <shapr> how do I do show on them then?
13:38:47 <Heffalump> you don't, sadly
13:38:55 <shapr> what???
13:38:56 <shapr> no way
13:39:05 <Heffalump> either define your own showMandelData function or something and don't make use of the Show class, or do what I said above
13:39:25 <shapr> I don't know anything about newtype
13:39:27 <Heffalump> type synonyms are just shorthand (like a C #define), they don't define a new type at all
13:39:45 <Heffalump> it's like data but usually better if you only have one constructor
13:39:52 <shapr> oh
13:39:58 <shapr> and it can be 'show' ed?
13:40:22 <Heffalump> yep
13:40:48 <Heffalump> note the "usually" above, btw, there's subtle differences between data and newtype that I won't go into now
13:40:56 <shapr> oboy :)
13:41:05 <shapr> so...
13:42:00 <shapr> aha
13:42:07 <shapr> p.303 of Thompson's book
13:43:19 <shapr> hm
13:49:03 <shapr> oh, I think I get it
13:50:35 <shapr> maybe not
13:50:39 <shapr> newtype MandelData = MandelData (Integer, Complex Double, Complex Double)
13:50:43 <shapr> I think that part is right
13:50:49 <shapr> instance Show MandelData where
13:50:49 <shapr>     show (iters, z, c) = "MandelData with values: Iteration Count: " ++ show iters ++ ", value of Z:" ++ show z ++ ", value of C:" ++ show c
13:50:53 <shapr> that part isn't
13:51:14 <shapr> but I think it should be
13:52:33 <shapr> oh maybe not
13:53:21 <Heffalump> you need to put the data constructor in definitions using the type
13:53:53 <shapr> err
13:54:02 <shapr> show MandelData (iters, z, c) = ... ?
13:54:06 <shapr> like that?
13:54:08 <Heffalump> yep, with brackets done right
13:54:12 <Heffalump> (i.e. not like that :-)
13:54:34 <shapr> oh
13:54:39 <shapr> what's the right way?
13:55:31 <Heffalump> brackets around the MandelData (...)
13:56:30 <Luke_> please help! :-)
13:56:32 <Luke_> data Regexp a = Concat (Regexp a) (Regexp a)
13:56:32 <Luke_>                | Either (Regexp a) (Regexp a)
13:56:32 <Luke_>                | Series (Regexp a)
13:56:32 <Luke_>                | Token a
13:56:32 <Luke_>                  deriving (Show, Eq)
13:56:49 <Luke_> is supposed to be a regexp with Eq'able things as tokens, but its rejected with:
13:57:01 <Luke_> er, oops :) that shuold have been:
13:57:12 <Luke_> data Regexp Eq = Concat (Regexp Eq) (Regexp Eq)
13:57:12 <Luke_>                | Either (Regexp Eq) (Regexp Eq)
13:57:12 <Luke_>                | Series (Regexp Eq)
13:57:12 <Luke_>                | Token Eq
13:57:12 <Luke_>                  deriving (Show, Eq)
13:57:21 <Luke_> ERROR "/home/luke/devel/haskell/Regexp.hs":5 - Illegal left hand side in datatype definition
13:57:36 <Luke_> it works with "a", but not with "Eq". what'd I muck up?
13:57:50 <shapr> are you not able to compare them with "Regexp a" ?
13:58:13 <shapr> I would think the deriving bit would let you compare them
13:58:18 <Heffalump> try data Eq a => Regexp a ...
13:58:23 <Heffalump> with the ... as in your first version
13:58:37 <Heffalump> but I think that might be non-standard extension
13:58:51 <Heffalump> you shouldn't really need it at all, because deriving Eq won't work at all if a isn't an Eq type too
13:59:50 <Luke_> do you mean I should replace my current definition and change the first Regexp Eq to Eq a, and the rest to Regexp a ?
14:01:27 <Heffalump> I suggest you just go with your first definition
14:01:59 <shapr> Luke_: you can limit the types allowed to fit into a typing statement
14:02:12 <shapr> er, type classes
14:02:17 <Heffalump> any definition where you try to use the Eq instance on Regexp a will automatically enforce that a is an Eq too.
14:02:20 <shapr> with the => operator
14:07:23 <Luke_> ok I get it
14:07:29 <shapr> Luke_: for example, if you do ":t show"
14:07:37 <shapr> I get:
14:07:39 <shapr> Prelude> :t show
14:07:39 <shapr> show :: Show a => a -> String
14:07:57 <shapr> and the "Show a =>" part of that means that a has to be part of the Show type class
14:08:31 <Luke_> ok, not unlike an interface in java..
14:09:00 <Luke_> well maybe quite unlike, I don't know actually :)
14:09:18 <Heffalump> it's quite similar, we had a conversation about that a few days ago
14:12:00 <shapr> you may want to browse the #haskell logs sometime
14:12:16 <shapr> (I probably should)
14:15:12 <Luke_> much too lazy for that.. :)
14:15:24 <shapr> yah, same here
14:15:47 <shapr> though ski mentioned some interesting paper on using first class continuations in a language
14:15:53 <shapr> I will look up those
14:18:08 <lodewijk> how do I get an Int from a String ?
14:18:19 <shapr> fromIntegral
14:18:29 <shapr> nope :)
14:18:42 <shapr> hmm
14:19:09 <lodewijk> indeed, doesn't work :)
14:19:48 <shapr> hrm
14:19:53 <lodewijk> readFloat and readDec look interesting
14:19:54 <shapr> I think there's a readInt somewher
14:20:05 <shapr> but I thought those were for reading from stdin
14:20:35 <shapr> I'm still a white belt though
14:20:45 * lodewijk doesn't even have a belt
14:20:52 <shapr> heh
14:20:59 <shapr> I just made up the color system
14:21:09 <shapr> I should post the ratings on HaskellWiki
14:22:52 <Heffalump> there's a Read class
14:22:59 <Heffalump> I've never actually used it though :-)
14:23:01 <shapr> aha
14:23:02 <shapr> !
14:23:06 <shapr> (read "1") :: Int
14:23:08 <shapr> that works
14:23:10 <shapr> in ghci
14:23:35 <Heffalump> sounds good
14:24:40 <shapr> nifty, Read is a type class
14:24:45 <Heffalump> yep
14:24:48 <shapr> Heffalump: I'm still confused about the MandelData thing
14:24:49 <Heffalump> it would be, really
14:24:55 <Heffalump> shapr: the brackets, or what?
14:25:03 <shapr> I think "what" :)
14:25:27 <Heffalump> umm, ok, what bit of "what"? :-)
14:25:31 <shapr> ok, so the newtype line seems to be working
14:25:44 <shapr> but the instance Show MandelData is still failing
14:25:48 <lodewijk> shapr: heh, found that read out too before I switched back to this vc and saw your comment :)
14:26:00 <Heffalump> how's it failing?
14:26:06 <shapr> cool, we can all read documentation ;)
14:26:13 <shapr> that's not always true on channels like #java
14:26:21 <shapr> instance Show MandelData (iters, z, c) where
14:26:21 <shapr>     show MandelData (iters, z, c) = "MandelData with values: Iteration Count: " ++ show iters ++ ", value of Z:" ++ show z ++ ", value of C:" ++ show c
14:26:37 <shapr> I think my brackets are still whacked
14:26:42 <Heffalump> oh, get rid of the (iters, z, c) in the instance line
14:26:43 <shapr> but I'm not sure where they should be
14:26:52 <Heffalump> and put brackets around MandelData (iters, z, c) in the line below
14:27:07 <shapr> ohh!
14:27:10 <Heffalump> remember that space is an operator just like +, and it's left-associative
14:27:15 <shapr> instance Show MandelData where
14:27:15 <shapr>     show (MandelData (iters, z, c)) = "MandelData with values: Iteration Count: " ++ show iters ++ ", value of Z:" ++ show z ++ ", value of C:" ++ show c
14:27:32 <shapr> duhhh 
14:27:34 <Heffalump> so "show MandelData (iters, z, c)" is equivalent to "(show MandelData) (iters, z, c)" which is meaningless
14:27:36 <shapr> I should have thought of that
14:27:44 * shapr blushes
14:27:46 <shapr> oops
14:27:59 * Heffalump still makes that mistake, and I've been doing this for ages :-)
14:28:11 <shapr> heh
14:28:45 <shapr> so I need to do that same kind of mult-parens thing in all the places where I was using a type synonym, right?
14:28:51 <Heffalump> 'fraid so.
14:29:08 <shapr> so this:
14:29:09 <shapr> oneIter :: MandelData -> MandelData
14:29:10 <shapr> oneIter (iterNum, z, c) = (iterNum + 1, z*z+c, c)
14:29:16 <shapr> turns into this:
14:29:19 <Heffalump> it's not ideal from a general convenience point of view, but keeping a sane type system takes precedence over that in the language design
14:29:26 <shapr> oneIter (MandelData (iterNum, z, c)) = (iterNum + 1, z*z+c, c)
14:29:28 <shapr> yes?
14:29:35 <Heffalump> you need a MandelData on the right hand side too
14:29:40 <shapr> ohh
14:29:43 <shapr> ohhh I seee!
14:30:36 <shapr> ok... now let's see if that fixed the first user submitted bug in Mandelbrot.hs
14:32:32 <shapr> hmmm
14:32:40 <Luke_> this type checker is really killing me :)
14:32:49 <shapr> what happened?
14:32:57 <Heffalump> Luke_: better than runtime errors :-)
14:32:59 <Luke_> just getting lots of errors that I don't understand :)
14:33:28 <Luke_> Heffalump: at least with runtime errors I can measure my progress with printfs :)
14:33:41 <shapr> oh, I could rewrite doPoint to take an (x,y) pair
14:33:52 <shapr> and then just map it onto a list of lists
14:33:57 <shapr> that would be much more elegant
14:34:02 <shapr> I think
14:35:30 <shapr> hrm
14:35:37 <Heffalump> shapr: sounds good
14:35:42 <Heffalump> Luke_: :-)
14:35:54 <Heffalump> the runtime errors might just be weird bugs, though
14:36:01 <shapr> Heffalump: so, do you feel like you're teaching Haskell 101, yet? :)
14:36:27 <Heffalump> naah, you're much quicker than most of the students I've taught :-)
14:36:35 <Heffalump> well, some, anyway.
14:36:39 <shapr> heh!
14:37:08 <shapr> I consider that a compliment since I have no formal CS education.
14:37:51 <shapr> Luke_: yes! I fixed it!
14:37:58 <Heffalump> well, all the people I've taught are beginning CS students, actually
14:37:58 <shapr> MandelData with values: Iteration Count: 1, value of Z:(-2.0) :+ 1.0, value of C:(-2.0) :+ 1.0
14:38:01 <shapr> er
14:38:02 <shapr> Main> doPoint (0:+0) (getC 50 (0,0))
14:38:03 <shapr> MandelData with values: Iteration Count: 1, value of Z:(-2.0) :+ 1.0, value of C:(-2.0) :+ 1.0
14:38:08 <shapr> Heffalump: uhoh
14:38:09 <Heffalump> either at Bachelors or Masters level
14:38:36 <shapr> I better work harder then
14:39:02 <Heffalump> they spend a term on it, but they don't really get to the point of writing big programs
14:39:31 <Heffalump> you're approaching it rather differently, anyway (and in a way more appropriate for self-study, in my opinion)
14:39:53 <Luke_> http://www.bluetail.com/~luke/misc/Regexp.hs
14:40:09 <Luke_> anyone have time to look at that and tell me what's wrong with the type of the 'test' function (or whatever is causing the error :)
14:40:47 <Heffalump> Either 1 2 isn't a regexp
14:40:55 <Heffalump> cos 1 and 2 aren't
14:41:06 <Luke_> ohh of course
14:41:11 <Luke_> they shodl be Token 1 and Token 2 :) thanks!
14:42:20 <Heffalump> you know there's already a regexp library, btw?
14:42:43 <Heffalump> if you're doing it for fun or to learn stuff, that's cool, but if you just want the result you might be better off with that
14:44:22 <Luke_> to learn stuff
14:45:05 <shapr> Luke_: ok, v0.2 has MandelData as an instance of Show
14:45:08 * shapr cheers
14:45:16 <shapr> with much help from Heffalump ;)
14:45:47 <shapr> http://kungens.kemi.fi/~shae/Mandelbrot-0.2.hs
14:46:34 <Heffalump> not very much at all
14:46:46 <lodewijk> wow..
14:46:56 <Heffalump> all I did was told you something that's completely non-obvious (about not being able to do instances for type synonyms)
14:47:05 * shapr grins
14:47:15 <shapr> that is pretty strange
14:47:19 <shapr> I'd call that a Haskell wart
14:47:38 <shapr> or at least a non-obvious bit
14:47:39 <shapr> as you said
14:47:56 <Heffalump> yeah. There's good reasons for it to be the case.
14:48:13 <shapr> and no way to smooth over it?
14:48:18 <Heffalump> not really. one of the things about type synonyms is that they're interchangeable with the underlying type
14:48:33 <Heffalump> so if I do type Point = (Int, Int)
14:48:47 <Heffalump> then everywhere I had (Int, Int) I could have Point instead.
14:48:59 <shapr> yah, I see that
14:49:10 <Heffalump> now, suppose I defined Show for Point
14:49:32 <Heffalump> then someone else comes along and does type Complex = (Int, Int)
14:49:37 <shapr> can't you just define show for (Int, Int) ?
14:49:39 <Heffalump> and declares Show for their Complex
14:49:53 <Heffalump> shapr: yeah (and in fact it's actually already defined)
14:49:58 <shapr> oh, really?
14:50:02 <shapr> how does that work?
14:50:25 <Heffalump> read ":i Show" in hugs (not sure if it works in ghci too)
14:51:08 <Heffalump> the Prelude defines how you can show a tuple if you can show its component parts
14:51:20 <shapr> er
14:51:22 <shapr> I get:
14:51:27 <Heffalump> anyway. show for a Complex should probably do something like "5+3i" for (5,3)
14:51:31 <shapr> Main> :i Show
14:51:31 <shapr> -- Show is a class
14:51:31 <shapr> class Show a where {
14:51:31 <shapr>     showsPrec :: Int -> a -> ShowS {- has default method -};
14:51:31 <shapr>     show :: a -> String {- has default method -};
14:51:44 <Heffalump> oh, is that all?
14:51:48 <Heffalump> must be different versions of hugs
14:51:55 <shapr> this is ghci
14:51:56 <Heffalump> I also get a list of instances
14:51:59 <Heffalump> which includes:
14:52:00 <Heffalump> instance (Show a, Show b) => Show (a,b)
14:52:01 <shapr> I can start up hugs instead though
14:52:04 <Luke_> what's the operator for "not equal"?
14:52:07 <shapr> /=
14:52:08 <Heffalump> /=
14:52:20 <Heffalump> doh, slowed down by my IRC client interpreting the / first time round :-)
14:52:27 <shapr> heh
14:52:43 <shapr> ah irssi
14:53:07 <Heffalump> yupyup
14:53:14 <Heffalump> made by a Finn, IIRC?
14:53:15 <shapr> and I'm using erc.el
14:53:19 <shapr> yah, I think so
14:53:29 <shapr> IRC started in Oulu
14:53:31 * Heffalump likes it a lot
14:53:34 <shapr> which is very close to where I am now
14:54:15 <Heffalump> ocol :-)
14:54:24 <shapr> ?
14:55:04 * shapr apt-get installs wtf
14:55:22 <Luke_> so how come we don't have "tail :: [a] -> Maybe [a]" ? :)
14:55:45 <Luke_> that would have caught the error I just got
14:55:45 <Heffalump> s/ocol/cool/
14:55:49 <shapr> er, there's some interesting comments on that in the Thompson book
14:55:59 <Heffalump> Luke_: cos it's too much hassle in general, I guess
14:56:15 <Heffalump> what does Thompson say?
14:56:18 <Heffalump> (if it's short)
14:56:27 * Luke_ makes note to bring this up next time haskell people are heckling him :)
14:56:37 <Heffalump> :-)
14:56:44 <shapr> it's not short actually
14:56:50 <Heffalump> never mind then
14:56:58 <shapr> several paragraphs, then some exercisess
14:57:29 <shapr> about whether all those functions should be catching those kinds of errors themselves or not
14:57:43 <Heffalump> what did you really apt-get when you said wtf, btw?
14:57:51 <shapr> bsdgamse
14:57:55 <shapr> er, bsdgames
14:58:01 <shapr> it has the wtf binary and lookup file
14:58:14 <Luke_> Program error: {head []}
14:58:19 <Luke_> is there a way to make it more verbose? (hugs)
14:58:33 <Heffalump> shapr: ah :-)
14:58:41 <Heffalump> so apt-cache search wtf was accurate :-)
14:58:47 <shapr> yes it was
14:58:48 <shapr> :)
14:59:29 <Heffalump> Luke_: errm, not that I know of
15:00:00 <Luke_> so how do you debug runtime errors?
15:00:22 <xbill> catch
15:00:30 <xbill> and trace
15:00:42 <shapr> hi xbill!
15:00:48 <Heffalump> I think ghc might give more useful errors. I can't remember.
15:01:05 <Luke_> can you give an example of catch and trace?
15:01:15 <Luke_> (or pointer to doc)
15:01:47 * shapr looks in the Thompson book
15:02:26 <shapr> not mentioned in the index
15:02:57 <lodewijk> shapr: I've noticed that if something is in the index, the page number seems to be off a lot
15:03:15 <lodewijk> not the best CS book I've ever read.
15:03:16 <shapr> lodewijk: really? are you using the second edition?
15:03:24 <lodewijk> shapr: yes
15:03:46 <lodewijk> can't think of examples ATM though, but it's bugged me a couple of times now
15:08:08 <shapr> lodewijk: you can submit bugs on the homepage I think
15:08:10 <shapr> hi wassa!
15:08:33 <shapr> hi PragDave!
15:08:44 <PragDave> hi - wassup?
15:09:10 <shapr> we are exploring the land of referential transparency
15:09:57 <dblack> hi
15:10:02 <shapr> hi dblack!
15:11:46 <shapr> if you want to see some of the stuff that's already been discussed in here, the channel logs are usually up to the minute.
15:12:15 <Luke_> I've stopped asking my dump questions because now I've run out of type checking errors and have to deal with "real" bugs :)
15:12:26 <shapr> heh
15:12:30 * Heffalump goes to bed, night all
15:12:37 <shapr> g'night Heffalump
15:12:38 <dblack> goodnight Heffalump
15:12:49 <shapr> time for me to do the same
15:12:53 * shapr wanders off to bed
15:15:16 <Luke_> can someone tell me how to use "trace"? I'm assuming that prints entry/exit on a function?
15:15:56 <lodewijk> Luke_: in hugs?
15:15:59 <Luke_> yes
15:16:25 <lodewijk> Luke_: no, it prints a string you give it and returns the second argument you give it, which lets you stuff it just about anywhere.
15:16:43 <Luke_> ah
15:17:17 <lodewijk> Luke_: I've just been using it a couple of minutes ago. it's pretty bare-bones, even barer than printf(), but it works.
15:17:18 <Luke_> what's haskell for printf?
15:17:37 <lodewijk> Luke_: pff, don't ask me, this is my second evening hacking haskell :)
15:17:41 <Luke_> do I need to import it from somewhere?
15:17:43 <Luke_> ok :)
15:18:02 <shapr> Luke_: putStr
15:18:07 * shapr really wanders off this time
15:18:59 <lodewijk> putStr doesn't take a format argument AFAICS
15:19:34 <lodewijk> and is an IO function, which sucks. better use trace.
15:20:16 <Luke_> Main> trace
15:20:17 <Luke_> ERROR - Undefined variable "trace"
15:20:45 <lodewijk> Luke_: import Trace
15:21:47 <Luke_> can I get trace to print objects other than strings?
15:22:27 <lodewijk> Luke_: not as far as I could see, but you can use show. as in, trace (show mylist) foo
15:23:47 <Luke_> pft now I have to put a type constraint on everything I want to print? :)
15:24:17 <Luke_> have to put that on the transitive closure of the call graph from the function I wanna debug?
15:24:56 <Luke_> is there a better way?
15:25:01 * lodewijk looks up
15:25:03 <lodewijk> that went over my head
15:25:50 <lodewijk> like I said, I'm on my second evening prodding Haskell :)
15:26:01 <xbill> heh
15:26:22 <Luke_> lodewijk: I put in (trace (print foo) ...), but it complains because it can't prove that foo belongs to the Show typeclass (or something like that). so I would have to soemwhere put foo => Show or something. but if I do that, then the caller's types will be too weak, so I'll have to similarly update his constraints. and then his caller's, and so on, or so it would seem :) (I"m hoping somone will say "no it's much easier than that:" :))
15:27:19 <Luke_> xbill: what's the word - is there a better way, or are haskell guys simply not into runtime debugging? :)
15:28:47 <Luke_> is there a magic-hidden-don't-use-this type casting mechanism?
15:29:43 <lodewijk> Luke_: what is foo in that expression anyway? and don't you mean "show" instead of "print" ?
15:30:52 <Luke_> er, yes, I mean show. and 'foo' is a list of numbers (or, as the typechecker believes, "Eq a => [a]")
15:31:42 <lodewijk> Luke_: weird. I "show"ed a list of strings and that went fine.
15:32:06 <Luke_> type checker doesn't know that this is a list of numbers, it thinks it's a list of anything belonging to the Eq typeclass, or something like that
15:32:40 <Luke_> and it looks like a fair bit of work to tell it that it's really a list of integers - and I would have to undo all that when I finished debugging, becasue it's not supposed to _have to_ be a list of integers, it just happens to be in my test case ;-)
15:33:04 <Luke_> well maybe the solution is just that my program shuold only accept printable objects as input for everything :)
15:34:20 <Luke_> thanks for your help everyone! for now I will run away and write some code in a language without a type checker, and come back refreshed another time :)
15:43:56 <Luke_> ok, program working, all grudge again type checker forgiven. ;-)
