03:55:22 <shapr> y0
04:11:12 <shapr> good morning folks
04:13:48 <shapr> banho?
04:15:26 <clausen_banho> shapr: bath in portuguese
04:15:34 <shapr> oh, nifty
04:15:46 <clausen_banho> shapr: (I've been talking to ppl in pt, and sort of interrupt-and-go...)
04:19:44 <shapr> ok, I still don't understand this dropWhile and takeWhile stuff
04:19:44 <shapr> but I got dropVowels working for me
04:19:44 <shapr> here's what I used:
04:19:44 <shapr> isVowel c = elem c "aeiou"
04:19:48 <shapr> dropVowels string = filter (not . isVowel) string
04:20:51 <shapr> does takeWhile have an advantage over filter?
04:20:53 <shapr> oh
04:20:56 <shapr> lemme guess
04:21:00 <shapr> filter isn't lazy, and take is
04:21:36 <Heffalump> they're both lazy
04:21:39 <Heffalump> they do different things
04:21:54 <Heffalump> filter (>0) [2,3,-1,4,-2] will give you [2,3,4]
04:22:04 <Heffalump> takeWhile (>0) [2,3,-1,4,-2] will give you [2,3]
04:22:19 <shapr> oho!!
04:22:39 <shapr> so takeWhile *stops* when it hits the first non P ?
04:23:02 <Heffalump> yep.
04:23:24 <shapr> then this other code I wrote *did* work, I just didn't realize that was the right result
04:23:27 <shapr> aha!
04:24:57 <shapr> can I do nested where statements?
04:25:18 <shapr> oh, I can!
04:25:20 <shapr> nifty
04:25:25 <shapr> this is funny:
04:25:33 <shapr> dropVowels string = filter (not . isVowel) string where
04:25:33 <shapr> 						  isVowel c = elem c vowels where
04:25:33 <shapr> 									    vowels = "aeiou"
04:26:03 <shapr> and I'd guess the difference is the 'scope' that these things are defined in...
04:26:18 <shapr> so I can't reuse vowels in any scope other than isVowel, right?
04:26:24 * shapr tries it
04:37:28 <shapr> y0 y0
04:37:37 <shapr> I wonder if this can get any simpler:
04:37:41 <shapr> dropVowels string = filter (not . (\x -> elem x "aeiou")) string
04:37:57 <shapr> I couldn't figure out a way to get rid of some parens
04:38:05 <shapr> I'd bet I could get the not into the lambda somewhere though
04:38:59 <shapr> hrm
04:39:13 <smkl> dropVowels = filter (not . flip elem "aeiou")
04:39:23 <shapr> what's flip?
04:39:30 * shapr hits the index
04:39:36 <smkl> flip f x y = f y x
04:39:39 <shapr> oh!
04:39:41 <shapr> that's handy
04:39:56 <shapr> that's elegant!
04:40:36 <shapr> nice
04:40:38 <shapr> thanks!
04:42:26 <shapr> I'm kind of surprised that elem takes the set arg second
04:42:39 <shapr> I'd expect Haskell functions would always put the most general arg first
04:42:42 * shapr thinks
04:42:57 <clausen> shapr: yeah, it's obvious to curry it that way
04:43:03 <shapr> wait, I bet that either arg could be more general, just depends on the situation
04:43:04 <Heffalump> you'll always find situations where one way or the other is useful
04:43:07 <Heffalump> yeah.
04:45:43 <shapr> these are my observations:
04:45:52 <shapr> in general, Haskell is more concise than other languages
04:46:09 <shapr> it can even beat Perl sometimes, and that can get scary
04:46:20 <Heffalump> just wait till you try to write a program that uses a lot of global state :-)
04:46:24 <shapr> but its use of whitespace improves readability tremendously
04:46:33 <shapr> I don't do that
04:46:36 <shapr> :)
04:46:46 <Heffalump> you can do it concisely, but you have to use some complicated features to get there
04:46:48 <shapr> at least, I've always found a way around it so far
04:46:55 <Heffalump> that's good, global state is in general bad
04:46:59 <Heffalump> but it often can't be avoided
04:47:32 <shapr> hm, I haven't run into many of those situations
04:50:09 <shapr> hi mustard 
04:50:28 <mustard> ello!
04:50:32 <shapr> what's up?
04:51:41 <mustard> got that friday feeling at work - lots of Java code to re-structure so I'm dreaming of greener programming pastures
04:51:46 <shapr> heh, I understand that
04:54:41 <shapr> I'd like to see some lint tools for various languages written in Haskell
04:58:39 <shapr> hi teek 
04:58:55 <teek> hi shapr
05:00:44 <shapr> Peaker: ok, partial resolution doesn't quite work in Python
05:01:05 <shapr> in Haskell, every function that takes two args and returns one, is actually two functions
05:01:13 <Heffalump> partial resolution?
05:01:25 <clausen> AutoCurrying T
05:01:26 <shapr> yah, like (+1)
05:01:27 <clausen> TM
05:01:28 <Peaker> shapr: But that's under the hood
05:01:47 <Peaker> what is the difference in the code that uses Python currying?
05:01:51 <Peaker> (from Haskell currying)
05:01:57 <shapr> I thought currying was about changing f :: (a,b) -> c to f :: a -> b -> c ?
05:02:20 <shapr> def curry(func, *args): return lambda *rest: func(*args, *rest)
05:02:40 <clausen> that's effictively what haskell does
05:02:44 <clausen> automagically
05:02:56 <Peaker> okay, and my question was what were the Haskell advantages?
05:03:00 <shapr> yah, except that the hidden functions are actually executed
05:03:09 <shapr> which doesn't happen in that Python code
05:03:13 <Heffalump> the Haskell syntax is much more concise
05:03:20 <Peaker> shapr: they get executed
05:03:33 <Heffalump> and it has a type system so it's harder to write incorrect code
05:03:33 <clausen> I find that the strong type system catches lots of bugs
05:03:40 <clausen> Heffalump: exactly!
05:03:42 <clausen> hehe
05:03:56 <shapr> Peaker: how so?
05:03:58 <Heffalump> it's IMHO completely unrealistic to program anything with higher-order functions without a strong type system
05:04:03 <teek> isn't it called partial application ? 
05:04:06 <Peaker> clausen: and more than trivial bugs?
05:04:12 <clausen> Peaker: yes
05:04:20 <Peaker> (things you'd find about first time you unit-test your code anyways :)
05:04:31 <clausen> Peaker: it often tells you that you are thinking about the problem in the wrong way, etc.
05:04:34 <clausen> (I find)
05:04:35 <shapr> I'm not convinced that static typing is an advantage over unit-testing myself
05:04:39 <Peaker> shapr: *a,*b is actually not allowed so that's invalid Python, let me show you real code:
05:04:43 <Heffalump> you'd probably find the bugs if your unit-test did exercise the correct code path
05:04:47 <Peaker> >>> def curry(func, *args): return lambda *rest: func(*(args+rest))
05:04:49 <clausen> shapr: you find the bugs earlier
05:04:50 <Heffalump> but compile-time is much better than test-time
05:04:58 <Peaker> >>> g=curry(f, 1, 2)
05:05:04 <Peaker> >>> g(3)
05:05:05 <Peaker> 1 2 3
05:05:08 <clausen> shapr: it isn't a substitute... but rather a time-saver
05:05:10 <Peaker> (f printing given a,b,c)
05:05:13 <shapr> Heffalump, clausen: I'm not convinced, :)
05:05:15 <clausen> (you don't pursue red herrings as much)
05:05:18 <Peaker> Heffalump: why?
05:05:24 <clausen> well, I'm just saying my experience
05:05:28 <shapr> ok, same here
05:05:34 <Peaker> Heffalump: why is compile-time better to find those things?
05:05:35 <clausen> in C, I chase down lots of crappy bugs
05:05:38 <Heffalump> peaker/shapr: well, you find them earlier
05:05:39 <clausen> that I don't do in haskell
05:05:52 <Heffalump> which saves you time
05:05:55 <Peaker> Heffalump: only to encourage you to 'it compiles! lets ship it' attitude? :)  I mean, you must test it anyhow
05:06:04 <clausen> not at all
05:06:09 <clausen> it encourages you to get the design right
05:06:14 <Heffalump> peaker: yes, of course. But you still save time because you find bugs earlier.
05:06:18 <clausen> it's not just about the code "working"
05:06:28 <clausen> the type system also forces you into a certain amount of cleanliness, IHO
05:06:29 <clausen> IMHO
05:06:34 <Heffalump> yeah
05:06:53 <Peaker> Heffalump: the time you spend compiling, fixing, compiling, ... is spent on hitting enter on exception lines and fixing it in runtime, which is just as quick from my experience, or sometimes even quicker
05:07:06 <clausen> not in my experience
05:07:07 <clausen> *shrug*
05:07:15 <Heffalump> enter on exception lines?
05:07:22 <shapr> I agree with Peaker, and I suspect none of us wil change our minds here :)
05:07:26 <Heffalump> also, when you find problems during testing, how do you work out exactly where they are?
05:07:28 <Peaker> Heffalump: Just jumping to the faulty code
05:07:38 <Peaker> Heffalump: jumping to where the exception was raised
05:07:44 <Peaker> or to any of the callers of the function
05:07:52 <Heffalump> umm, what if an exception wasn't raised, but you just got bad output?
05:07:53 <clausen> so tell me:
05:08:00 <clausen> why is C easier than assembler?
05:08:05 <shapr> ahem
05:08:05 <Peaker> Heffalump: consider the time you spend typing the static typing information that is spent on writing more code in dynamic languages :)
05:08:17 <shapr> I really want to settle this "can Python really do partial resolution"
05:08:22 <clausen> hmmmm
05:08:28 <clausen> probably a red herring... don't answer that
05:08:29 <Heffalump> peaker: you don't have to type it in in Haskell, it can infer it
05:08:31 <clausen> (my q)
05:08:39 <Peaker> clausen: because of its nested-expression syntax, abstraction of stack-framing, and many other abstractions
05:08:46 <Heffalump> I only put static types in when they help me understand what a function does - it's kind of documentation
05:08:47 <shapr> augh
05:08:51 * clausen agrees
05:09:01 <clausen> also:
05:09:08 <clausen> if you try to use a function in the wrong way, you hear about it
05:09:13 <clausen> because EVERYTHING is a function
05:09:29 <clausen> this type checking, in practice, digs up more dirt, so to speak
05:09:30 <Heffalump> umm, that's not strictly true (that everything is a function)
05:09:33 <Peaker> Heffalump: ah. Okay, I believe in type inference to catch problems and optimize too, so I agree there. I just don't always like statically typing as it ends up killing polymoprhism and/or taking lots of valuable time
05:09:39 <Heffalump> if you say "x = 5" then x isn't a function
05:09:46 <clausen> yeah yeah :P
05:10:04 <Heffalump> peaker: Haskell has a decent polymorphic type system, so static typing doesn't kill polymorphism
05:10:26 <clausen> "taking lots of time" ?
05:10:39 <Heffalump> (that's a slight simplification cos there are limitations to the polymorphism, but it's basically true)
05:10:43 <shapr> the way I see it, Python is awesome and the best thing I've found yet, but it's also missing some pieces I'd like to have
05:10:46 <teek> Peaker: there are very rare cases, where Haskell's type system doesn't offer enough polymorphism. 
05:10:47 * clausen thinks haskell has more polymorphis than, say, C++ in practise
05:10:49 <Peaker> Heffalump: doesn't writing 'string' in your dropVowel code deprive that code from working on lists of objects that can equal vowel characters?
05:10:53 <shapr> so I'm willing to try Haskell to see if it works for me
05:11:12 <Heffalump> peaker: yes. But it could be written to an interface that understood "isVowel" instead, if you wanted to
05:11:24 <shapr> yah, type classes rock
05:11:30 <Heffalump> with the advantage that if you did that, then if you accidentally tried to write it to an interface that didn't, you'd know about it
05:11:38 <Heffalump> instead of getting some random result at runtime
05:11:38 <Peaker> Heffalump: but isVowel was written inside your dropVowel function, would that work?
05:11:57 <Heffalump> no, you'd have to move it somewhere else if you wanted the interface to be "isVowel"
05:12:09 <Heffalump> but if you wanted the interface to be "charOf", for example, then there'd be no problem
05:12:09 <clausen> Peaker: he's saying, that you could define a type that has a method "isVowel" (effectively)
05:12:17 <Peaker> Heffalump: that seems like a lot more work
05:12:25 <clausen> right
05:12:25 <shapr> Peaker: actually it's really nice
05:12:30 <Heffalump> peaker: two more lines
05:12:35 <clausen> but, why would you want to do it?
05:12:38 <Heffalump> or rather one more line and move the isVowel line somewhere else
05:12:39 <shapr> you can add methods to any kind of type
05:12:42 <clausen> (why would you want to make it polymorphic in this way?)
05:13:01 <Heffalump> if you didn't have the type, what would happen if you tried to run dropVowels on a list of integers?
05:13:31 <shapr> er, what would you call that type class anyway?
05:13:37 <shapr> CharExts ?
05:13:40 <Heffalump> dunno, Vowelable :-)
05:13:41 <Peaker> Heffalump: it'd drop all vowels, and leave the list as it is
05:13:53 <shapr> class CharExts Char where -- ?
05:14:09 <Heffalump> peaker: but it'd try to check if 5 == 'a', for example
05:14:21 <Peaker> Heffalump: which returns false
05:14:23 <Heffalump> do you think that should always return false, rather than just being an error?
05:14:23 <clausen> nope
05:14:28 <clausen> it depends on the isVowel implementation
05:14:32 <clausen> for each type
05:14:32 <Peaker> Heffalump: 5 and 'a' are both objects
05:14:45 <shapr> class CharExts Char where
05:14:45 <shapr>     isVowel     :: Char -> Char
05:14:45 <shapr>     isConsonant :: Char -> Char
05:14:46 <Heffalump> peaker: there's a run-time penalty for that
05:14:48 <Peaker> Heffalump: ['a', 1, '2', 'b'] will return [1, '2', 'b'],  [1,2,3] will return [1,2,3],   it makes sense in a dynamic language
05:14:53 <Heffalump> shapr: Char -> Bool
05:14:56 <clausen> but you can set the default to "False"
05:15:02 <Peaker> Heffalump: there's a runtime penalty for pure functionality :)
05:15:03 <shapr> Heffalump: oh, right, duh..
05:15:12 <clausen> (i.e. it's False for everything other than Chars immediately)
05:15:17 <clausen> (unless they override)
05:15:28 <Heffalump> clausen: but you still have to declare the interface
05:15:28 <clausen> but you still have to say each type derives...
05:15:34 <clausen> yep
05:16:08 <clausen> anyway, I see this isVowel example as REALLY ugly
05:16:08 <Heffalump> peaker: what do you mean?
05:16:27 <clausen> (WTF do you want this kind of polymorphism.  it's unnatural!)
05:16:33 <clausen> s/./?!/
05:16:36 <Heffalump> :-)
05:16:56 <Peaker> clausen: look at the dynamic lists example
05:17:31 <Peaker> clausen: It might be useful if I have a list of varying-types
05:18:05 <clausen> Peaker: why?
05:18:08 <teek> Peaker: Usually those varying types have some common property, which should be expressed as a type. Much safer that way
05:18:13 * clausen contends the opposite
05:18:14 <Peaker> Heffalump: pure functionality, as I understand it (which might be wrong :), disallows writing of some algorithms that depend on in-place mutability, and requires using alternative algorithms with far worse BigO time complexities
05:18:15 <shapr> clausen: isVowel is a random example I came up with this morning from #loty
05:18:17 <teek> as a type class
05:18:37 * clausen thinks it's ugly, and never a good idea
05:18:57 <Heffalump> peaker: yes, that's true. But the need to have only pure functions is a specific consequence of Haskell's laziness, rather than static typing.
05:19:04 <Peaker> teek: perhaps, but that costs you time and may be hard to 'formalize' without losing support of future changes
05:19:12 <clausen> Peaker: the compiler can still implement it using an in-place algorithm
05:19:16 <Heffalump> if we were talking about ML, for example, then you wouldn't have that penalty but you'd still have static typing
05:19:40 <Peaker> Heffalump: Okay, I meant to say that a performance hit is not always a factor in decisions, and always the last factor in Python decisions
05:19:41 <Heffalump> clausen: but no compiler guarantees operational semantics to that extent, so you'd have no guarantees
05:19:49 <clausen> right
05:19:53 <Peaker> clausen: converting algorithms like that would be solving the Halting Problem
05:20:00 <clausen> Peaker: in the general case
05:20:07 <clausen> Peaker: in practice, it's easier
05:20:14 <shapr> hrm, what am I doing wrong here?
05:20:17 <Peaker> clausen: how would you implement a red-black-tree?
05:20:19 <shapr> instance Char CharExts where
05:20:20 <shapr>     isVowel a   = flip elem "aeiouAEIOU"
05:20:20 <shapr>     isConsonant = flip elem $ filter (not . isVowel ['A'..'Z'] ++ ['a'..'z'] )
05:20:27 <Heffalump> actually, in practice you use mutable stuff in the IO monad when you want the better time complexity :-)
05:20:31 <clausen> Peaker: dunno... there's a book called "Purely Functional Data Structures"
05:20:38 <clausen> Peaker: I'll read that first ;)
05:20:50 * clausen has bought it... it's waiting for me in .au
05:21:09 <Heffalump> shapr: I suspect some brackets around the [ .. ] ++ [ .. ] would help
05:21:16 <shapr> oh
05:21:17 <Heffalump> clausen: Okasaki's book?
05:21:27 <clausen> Heffalump: yep
05:21:28 <teek> Okasaki's Purely Functional Data Structures is a great reading ! I enjoyed that book a lot. 
05:21:42 <Heffalump> I need to get round to reading that
05:22:26 <Heffalump> using Haskell does sometimes impose some form of algorithmic penalty, but as I've said that's because of its laziness, not the type system
05:22:35 <teek> However, it's true that there's many data structures and algorithms, which need destructive updates for simple implementation. Many graph algorithms for example. 
05:22:37 <Peaker> clausen: I am not sure of what to make of a Haskell's programmer ability to implement a red black tree, where a procedural programmer can implement it based on algorithmic listings on the web...  I mean, is Haskell a lot more difficult for low-level data structures? why wouldn't you want to combine procedural features into the language?
05:23:01 <Heffalump> procedural (i.e. mutable values) features interact badly with laziness
05:23:03 <smkl> rb tree should be quite easy to implement. and inplace and functional updates should have same complexity
05:23:04 <teek> However, in many cases, desctrutive updates can be hidden inside the algorithm. 
05:23:12 <clausen> Peaker: well, there are advantages to such "purity"
05:23:17 <clausen> Peaker: it's easier to analyse
05:23:24 <clausen> Peaker: easier for the compiler to optimize
05:23:25 <Peaker> Heffalump: don't guarantee laziness to work well when combined with side effects then
05:23:31 <clausen> Peaker: it "feels" more elegant
05:23:34 <clausen> (which is what motivates me)
05:23:41 <Peaker> clausen: the ease to optimize cancels out with the inability to do inplace changes
05:23:50 <Heffalump> peaker: by "not work well" that means "no guarantee about what will actually happen"
05:23:56 <clausen> Peaker: how do we know?
05:24:03 * clausen thinks more research...
05:24:05 <Heffalump> peaker: and Haskell is fundamentally a lazy language, it's very hard *not* to use it.
05:24:07 <smkl> rb trees can be implemented using pattern matching very elegantly
05:24:09 <clausen> Peaker: anyway, like has been already said
05:24:12 <Peaker> Heffalump: Yes, like I'd guess Python laziness modules are implemented :)
05:24:18 <clausen> Peaker: you can do RB trees, etc. easily in haskell
05:24:21 <clausen> Peaker: just, you have to use monads
05:24:36 <clausen> Peaker: (which is essentially a functional way of doing imperative programing)
05:24:41 <Heffalump> monads are essentially the way that the semantics of updatable variables in a lazy language can be defined
05:24:54 <Peaker> clausen: okay, then why did you say you didn't know?  And how would it work given that you need to make in-place changes?
05:25:32 <clausen> didn't know what?
05:25:32 <teek> look at http://www.ai.univie.ac.at/~markus/ocaml_sources/pure_fun-1.0-2/chp3.ml for an implementation of a purely functional RedBlack set in Ocaml
05:25:52 <Peaker> Heffalump: you can implement lazy evaluation in Python, but I'm not quite sure I understand why you'd want it for any expression, and not only for things like map/filter/etc
05:26:07 <Peaker> teek: Ocaml supports inplace changes though..
05:26:15 <shapr> aha
05:26:20 <shapr> instance CharExts Char where
05:26:20 <shapr>     isVowel a     = elem a "aeiouAEIOU"
05:26:20 <shapr>     isConsonant a = elem a (filter (not . flip elem "aeiouAEIOU") ['A'..'Z'] ++ ['a'..'z'])
05:26:24 <Heffalump> peaker: that module doesn't use it
05:26:33 <Peaker> clausen: didn't know how to implement a RB tree
05:26:42 <Heffalump> peaker: well, you might want it for trees as well, for example
05:26:45 <clausen> Peaker: in haskell... I did say I didn't know
05:26:51 <clausen> Peaker: I said I should "read the book"
05:26:54 <clausen> (remember?)
05:26:54 <teek> Peaker: yes, but that's a functional version
05:27:06 <shapr> arghh
05:27:08 <Peaker> clausen: yeah, but then you said: you can do RB trees, etc. easily in haskell  just, you have to use monads
05:27:10 <dennisb> Peaker: you can have pointers in haskell as well
05:27:13 <Peaker> clausen: which I find contraductory
05:27:21 <clausen> Peaker: well, it's obvious you can use monads
05:27:30 <clausen> Peaker: (which are really "non-functional" in a sense)
05:27:30 <dennisb> You have to hide them in a monad, or even use pointers that is in the IO-monad
05:27:34 <Peaker> dennisb: what are references useful for, when you might as well use a copy of the value?
05:27:40 <clausen> Peaker: however, it turns out you don't need monads
05:27:47 <clausen> anyway
05:27:49 <dennisb> Peaker: its about speed
05:27:50 <Peaker> what is a monad?
05:27:51 * clausen going back to hacking
05:28:01 <teek> gotta go 
05:28:11 <Heffalump> umm
05:28:11 <smkl> a ds that might be harder to implement in functional languages is hashtable 
05:28:14 <Peaker> dennisb: yes, but why would I want a pointer in the language level of a purely functional language
05:28:18 <shapr> aha
05:28:19 <shapr> got it
05:28:30 <shapr> ok, here it is:
05:28:35 <shapr> class CharExts a where
05:28:36 <shapr>     isVowel     :: a -> Bool
05:28:36 <shapr>     isConsonant :: a -> Bool
05:28:37 <Heffalump> a monad is an algebraic structure that amongst other things lets you encapsulate the use updatable values in a purely functional way
05:28:41 <shapr> instance CharExts Char where
05:28:41 <shapr>     isVowel a     = elem a "aeiouAEIOU"
05:28:42 <shapr>     isConsonant a = elem a (filter (not . flip elem "aeiouAEIOU") ['A'..'Z'] ++ ['a'..'z'])
05:28:45 <Peaker> smkl: or the simplest case of a hashtable, a mere array?
05:28:46 <shapr> yay! and it even works!
05:28:47 <Heffalump> s/use/use of/
05:28:50 <Peaker> smkl: (mutable one)
05:28:55 <Heffalump> shapr: cool :-)
05:29:07 <smkl> sure
05:29:12 <dennisb> Peaker: for some problems you just need pointer, and there is a pure way to add them
05:29:19 <Heffalump> shapr: why not reuse isVowel in isConsonant?
05:29:32 <shapr> Heffalump: because I couldn't figure out how to do that :)
05:29:36 <shapr> I'll try that, hang on
05:29:41 <Peaker> dennisb: I don't understand how it is possible you would need a pointer when the dereferenced object is always the same..
05:29:58 <Heffalump> one use of a pointer is for a quick equality test
05:30:03 <Peaker> dennisb: Couldn't you use a read-only-reference, or a copy of the object?
05:30:21 <Heffalump> you can check two objects are the same by comparing them, but if they're very complicated that might take a while. Comparing the two pointers can save time.
05:30:23 <dennisb> Peaker: but then the algortihms might explode in size or something
05:30:25 <Peaker> I understand performance reasons but those sound easy to implement in the compiler-level
05:30:35 <Heffalump> if they're the same the objects are the same, and if they're not, you compare the actual objects
05:30:40 <Peaker> dennisb: Okay, the compiler can simply never copy objects but only copy references
05:30:47 <dennisb> some graphalgorthims is a typical example where you really need pointers (references)
05:30:49 <Heffalump> true
05:30:57 <shapr> ok, got it
05:31:04 <shapr>     isConsonant a = elem a (filter (not . isVowel) ['A'..'Z'] ++ ['a'..'z'])
05:31:11 <Heffalump> shapr: yep :-)
05:31:16 <Peaker> Heffalump: Okay, that is obvious, but I see that as a mere implementation detail
05:31:20 <shapr> I'm so cool
05:31:25 * shapr does the nifty code dance
05:31:25 <Peaker> I don't see how "pointers" have to do with Haskell as a language
05:31:31 <shapr> w00
05:31:39 <Heffalump> they don't, much
05:31:56 <Heffalump> weren't you the one arguing earlier that having compilers do your implementation work is like solving the halting problem, btw? :-)
05:32:39 <shapr> wheee
05:32:41 <Peaker> def isConsonant(l): import string ; return l in filter(lambda x: x.lower() not in "aeiou", string.letters) :)
05:32:54 <Peaker> Heffalump: converting copying-algorithms to inplace-changes is
05:33:01 <dennisb> you can use pointers, but you typically use them in a very small part of the program, like in a function for calculating something, and from the outside the function looks like any pure function
05:33:02 <Peaker> Heffalump: copying pointers rather than objects is trivial
05:33:39 <Peaker> dennisb: Again, why isn't it a hidden implementation detail of the compilation process, and appearant at the language level?
05:34:13 <Heffalump> peaker: true
05:34:14 <smkl> with monads, it is possible to emulate the sematics of other languages in haskell. with a state monad there is state, that is where pointers or references are useful
05:34:31 <dennisb> beacause no one have solved that problem. Best so far is letting the programmer handle this
05:35:08 <dennisb> 10-15 years ago everyone tought you would never need to use pointers in a pure functional program, but state of the art changes.
05:35:12 <Heffalump> dennisb: do you have a specific example of an algorithm that requires pointers as you describe?
05:35:16 <Peaker> smkl: and how are monads implemented?
05:35:28 <dennisb> Now I believe that most people think they really are needed
05:35:38 <Peaker> dennisb: Wouldn't such optimization only require the compiler to implement object copying as pointer copying?
05:35:39 <clausen> Peaker: you should probably read stuff on www.haskell.org, and read some papers, etc.
05:35:39 <Heffalump> peaker: often by the implementation of the language, so not in Haskell itself
05:35:44 <Heffalump> but it depends on the monad
05:35:46 <dennisb> Heffalump: yes, you could use it to implement hashtables
05:36:06 <Heffalump> yeah, point :-)
05:36:07 <Peaker> Heffalump: So Haskell is not a pure functional language and already more attractive :)
05:36:17 <clausen> Peaker: it is purely functional
05:36:22 <dennisb> Peaker: how do you create a graph in memory?
05:36:22 <Peaker> clausen: not with monads..
05:36:26 <clausen> Peaker: monads are implemented in a purely functional way
05:36:34 <Heffalump> peaker: any implementer of an external module has to guarantee that the *interface* to his module will be purely functional
05:36:52 <Heffalump> you can't do IO without having an external library, for example
05:36:59 <Peaker> dennisb: An object containing copies of other objects within it will actually contain pointers to those objects in runtime, so its a graph..
05:37:25 <Peaker> clausen: how is that possible? and in that case, why: <Heffalump> peaker: often by the implementation of the language, so not in Haskell itself
05:37:28 <shapr> boy am I glad this is being logged
05:37:50 <Peaker> Heffalump: yeah, I meant non-pure beyond I/O requirements
05:38:01 <clausen> Peaker: go search google
05:38:03 <smkl> the point is that the haskell main program returns a computation. this computation is contructed in a purely functional way. anyways, referential transparency remains
05:38:12 <Heffalump> peaker: but as you yourself said, you can sometimes get better algorithmic performance with a non-pure implementation
05:38:13 <dennisb> well, then it needs to identify objects that should be the same, so it can change one of them to a pointer to the other
05:38:13 <clausen> Peaker: I'm sure the original papers do a better job of explaining than me
05:38:19 <Heffalump> but as I said, the *interface* must be pure.
05:39:27 <dennisb> to create the graph you really need references to distinct nodes so you can get hold of a special one and really point to that one
05:40:29 <smkl> getChar and getChar are the same computation, but they might return different values depending on the context
05:40:29 <Heffalump> smkl: that's why they are in the IO monad :-)
05:42:22 <Peaker> dennisb: if you guarantee objects are never copied but references are, you essentially have a graph
05:43:28 <dennisb> well, it can be hard to move pointers after you create it.
05:44:04 <dennisb> for creating I agree with you
05:44:18 <dennisb> there are for example algoritms where you reverse pointers in a graph
05:45:39 <dennisb> you really want to do that in place, and have a guarantee that it is fast, because the algorithm depends on that the pointer updating is O(1)
05:46:13 * Heffalump --> lunch and a meeting and stuff, bye
05:46:25 * shapr waves to Heffalump 
05:54:34 <dennisb> Pointers are not dangerous, even functional programmers can use them. We just don't need them that often because we have polymorphi and higher order functions
05:59:59 <dennisb> And for the examples where you have a list with different kind of elements. Well, that doesn't happen to often, and if it does we would just have to put them in a tagged list. Even in a untyped language you need to know the type of the element anyway if you ever want to use it. But in an untyped language typically every value have a tag saying what type it is so it can generate runtime errors when something is wrong.
06:00:40 <shapr> actually, in Python you don't necessarily have to know the type of what you're working on...
06:00:54 <shapr> it has a very nifty thing that I'm not sure there's a name for..
06:01:07 <shapr> where you say "this function expects a X-like object"
06:01:14 <dennisb> like the classes in haskell, i guess
06:01:16 <shapr> for example, a file-like object
06:01:19 <shapr> yah, that kind of thing
06:01:48 <shapr> in Haskell you'd write func :: File a => a -> b
06:01:58 <shapr> and that's how almost everything in Python works
06:03:27 <shapr> so func might be doing something like "func fileobjs = map read fileobjs"
06:04:05 <dennisb> yes
06:04:12 <shapr> and those fileobjs could be actual file objects, strings acting as fileobjs (StringIO), arrays of whatever that just happen to have a read method, etc etc
06:04:58 <shapr> so you can get NameErrors at runtime if one of those guys doesn't have a read method
06:05:05 <Peaker> in Python it doesn't care that the type IS something, only that it has some attribute
06:05:05 <dennisb> that is the essence of classes and objects. in haskell or any language
06:05:14 <shapr> truly
06:05:38 <Heffalump> Peaker: that's how Haskell type classes work too
06:05:44 <dennisb> Peaker: yes, that is what we use classes for in haskell
06:05:47 * Heffalump is eating lunch and not really here, honestguv
06:07:39 <shapr> re jewel 
06:07:47 <jewel> hi
06:07:54 <shapr> what's up?
06:07:54 <jewel> building contractors cut the power!
06:07:59 <shapr> whoa, suckage
06:08:08 * shapr hands the discipline stick to jewel
06:08:10 <jewel> but the idiots did it while we were away at lunch
06:08:10 <shapr> go get 'em!
06:08:16 <jewel> instead of allowing us some downtime
06:08:22 <shapr> idjits
06:50:23 <shapr> hrm
07:53:31 <shapr> wheee
08:07:21 <shapr> re
08:43:49 <dmiles> xbill?
08:43:58 <xbill> you rang?
08:44:05 <dmiles> i am taking the plunge into Mercury today
08:44:21 <dmiles> i have 8 hrs to try to see how long it will be to port my App
08:44:38 <dmiles> how much Mercury have you used?
08:45:11 <dmiles> i just made a sample toy program
08:45:31 <dmiles> but i need to understand the type and 'mode' decls
08:45:53 <xbill> dmiles: shoot
08:46:01 <dmiles> what is happing is its finding every atom in my system..
08:46:16 <xbill> what kind of toy program?
08:46:30 <dmiles> and saying.. one sec.
08:46:31 <dmiles> estit.m:943:   error: undefined symbol `OrganOrTissueProcess/0'.
08:46:31 <dmiles> testit.m:943: In clause for predicate `testit:holds/2':
08:46:31 <dmiles> testit.m:943:   in argument 2 of clause head:
08:46:31 <dmiles> testit.m:943:   in argument 2 of functor `./2':
08:46:31 <dmiles> testit.m:943:   in argument 2 of functor `./2':
08:46:42 <dmiles> its an medical expert system
08:47:01 <xbill> :- import_module list. 
08:47:11 <dmiles> ah.. first :)
08:47:46 <dmiles> ok restaritng to give you next error
08:48:46 <xbill> sure =)
08:48:54 <dmiles> shouldy i :- pred holds(term,list).
08:49:12 <dmiles> fyi: :- import_module term.
08:49:33 <dmiles> holds(instance, [zzsk(zzsk309267Fn, [_G1903]), 'ColorProperty']):-holds(attribute, [_G1903, 'Polychromatic']).
08:49:42 <dmiles> thats wwhat a data stament looks like
08:49:53 <dmiles> oops well that on is a rule
08:52:10 <dmiles> xbill: i have 4571 warnings :) i dont know if there are errors in bwetween
08:52:35 <dmiles> so... will cat to file
08:53:13 <dmiles> testit.m:407: In definition of predicate `testit:holds'/2:
08:53:13 <dmiles> testit.m:407:   error: undefined type `list'/
08:53:32 <dmiles> testit.m:001:   warning: modules `list' and `term'
08:53:32 <dmiles> testit.m:001:   are imported in the interface, but are not
08:53:32 <dmiles> testit.m:001:   used in the interface.
08:54:03 <dmiles> wow 1000's of less errors now
08:54:41 <dmiles> list_struct or something i need
08:56:40 <xbill> list(T) 
08:56:53 <xbill> list is a type constructor it needs an argument
08:59:34 <dmiles> ok .. i see
09:03:14 <shapr> wheeee
09:07:05 <dmiles> wli: thank you .. no errors now
09:07:40 * shapr bounces frivolously
09:07:47 <dmiles> oops i lie
09:07:49 <dmiles> testit.m:2470:   type error: type of argument does not match its expected type;
09:07:49 <dmiles> testit.m:2470:   argument has overloaded actual/expected types {
09:07:49 <dmiles> testit.m:2470:     pred(T, (list:list(T)), (list:list(T)))/(term:term((term:generic))), pred(T, (list:list(T)))/(term:term((term:generic)))
09:07:49 <dmiles> testit.m:2470:   }.
09:08:40 <dmiles> oopps and testit.m:2475:   error: undefined symbol `zzsk309260Fn/0'.
09:09:04 <xbill> what are the compile options?
09:09:43 <xbill> dmiles what's on line 2470 or thereabouts?
09:10:00 <dmiles> http://216.39.172.56/_/engine/testit.m
09:10:38 <dmiles> holds(instance, [zzsk(zzsk309161Fn, [_G1903]), 'BodyPart']):-holds(instance, [_G1903, 'BodyMotion']).
09:11:06 <dmiles> i used zzsk?????Fn for Skolems
09:11:55 <dmiles> http://216.39.172.56/_/engine/testit.err
09:12:37 <dmiles> i know i am abusing mercury.. this is just a little demo to myslef to see that it can handle insane amnount of data
09:12:58 <dmiles> and leanr what is basic to getting things to compile :)
09:14:45 <shapr> Skolems?
09:14:48 <shapr> nifty word
09:15:00 <shapr> suggest skeletal golem to me
09:15:40 <dmiles> hehe.. skolems a gensyms used to represent things
09:16:09 <dmiles> skeletal smoglum
09:16:36 <dmiles> skeletal golem :) cute
09:16:53 <xbill> dmiles: best to send it to the Mercuy list
09:17:00 <shapr> smoglum
09:17:04 <shapr> another nifty word
09:17:10 <shapr> smoky gollum
09:17:12 <dmiles> xbill: you mean i did veverything rigt?
09:17:40 <dmiles> xbill: it seems like such a newbie thing
09:17:48 <xbill> dmiles: I don't know what you did wrong
09:18:02 <dmiles> so it 'looks' right then?
09:18:06 <xbill> but I don't know what's in your source
09:18:19 <xbill> oh testit.m is there
09:18:23 <dmiles> you saw the soruce rigth?>
09:18:51 <dmiles> i have wered urls.. i know
09:18:56 <xbill> I'm looking now
09:20:32 <xbill> dmiles: you *definitely* want to get on the Mercury list... those guys would love to make your stuff work with their compiler (or so I'd think) and they'll probably know what goes wrong
09:21:06 <xbill> okay it's a repeated thing
09:21:16 <dmiles> but it looks like i at least covered my types right?
09:21:36 <xbill> yeah there's a mode problem for the more than once in the scope though
09:21:48 <xbill> or osmething
09:21:55 <dmiles> what is undetermined mode in or out?
09:22:23 <dmiles> the manulaul only ussing themn randomly never describes them
09:22:43 <xbill> dmiles: yeah, the problem is you're using uo 
09:22:50 <xbill> uo means it can only appear once
09:22:51 <dmiles> i would like to see examlpes of pred declarartrions.. i had to snoop thru modules to see them
09:23:12 <xbill> http://holomorphy.com/~wli/dcg/dcg.m
09:23:20 <dmiles> how can i say foo(?,?) ?]
09:23:42 <xbill> what?
09:24:09 <dmiles> means in or out
09:24:24 <xbill> you have to declare multiple modes separately
09:24:31 <dmiles> means (+,-),(-,-),(+,+),(-,+)
09:24:54 <dmiles> so four decls that ar in/out
09:24:56 <xbill> yeah
09:25:07 <xbill> Mercury doesn't want you to do that =(
09:25:34 <xbill> does dcg.m help at all?
09:25:35 <dmiles> i know it dont.. but i want to see if it can hadle the abuses :)
09:25:46 <dmiles> yes dcg.m does .. i can see exampoles
09:25:56 <xbill> does it still compile and run?
09:26:09 <dmiles> one sec.. reload that page
09:26:55 <dmiles> so far seo good.. no eorrros yet
09:27:25 <dmiles> ok millions of errros now
09:27:37 <xbill> millions of errors on dcg.m?
09:27:41 <dmiles> testit.m:091:   error: undefined symbol `SubjectiveAssessmentProperty/0'.
09:27:46 <xbill> or testit.m?
09:27:53 <dmiles> nope in dgc.m .. i'll download and try
09:27:57 <dmiles> testit.m
09:28:10 <dmiles> it wants every dataatom declared?
09:28:23 <xbill> yeah
09:28:34 <dmiles> there is 60,000 terms in our KB
09:28:36 <xbill> I'm assuming this is automaticlaly generated =)
09:28:56 <dmiles> yeah i can decalre each what does the decl look like?
09:29:06 <dmiles> (i gan genrate whatever it needs)
09:29:44 <xbill> actually --infer-types might help...
09:30:09 <dmiles> can i sert up a compiler switch in a source file like that?
09:30:10 <shapr> this channel rocks
09:30:26 <shapr> only place where 50% of the conversation is over my head
09:30:27 <shapr> I love it.
09:30:33 <dmiles> shapr, becasue we are working?
09:30:45 <dmiles> ah .. cool *wink*
09:30:46 <shapr> that too :)
09:30:49 <shapr> you guys *do* stuff
09:32:04 <xbill> /msg #haskell did --infer-types help?
09:32:45 <xbill> hrm I'm not 100% convinced that's the syntax for weird variable names like that
09:33:04 <dmiles> yes yay it did so far
09:33:07 <dmiles> :)
09:33:19 <dmiles> you can reload trhe .err file at any time 
09:33:34 <dmiles>  mmc --infer-types testit > testit.err 2>&1
09:33:54 <dmiles> oh poo
09:33:59 <dmiles> i need the .m ?
09:34:15 <dmiles> simnce there is another w/o .m :)
09:34:31 <xbill> the other without the .m, is it executable? =)
09:34:48 <dmiles> nope its the dump i create the .m with
09:34:53 <dmiles> :(
09:35:02 <dmiles> soon tho
09:35:19 <xbill> oh
09:35:29 <xbill> be careful it will overwrite that thing
09:35:47 <dmiles> oh n/p 
09:35:53 <dmiles> http://216.39.172.56/_/engine/testit.err <-looking better?
09:36:37 <xbill> I don't know change the mode kill the warning you're getting megabytes of warnings
09:37:03 <dmiles> i can fix the wraing be sucking out th e_'s
09:37:06 <dmiles> one sec
09:37:37 <xbill> okay
09:38:08 <dmiles> err well i though it would
09:38:15 <dmiles> i use single variables 
09:38:19 <dmiles> reload
09:38:44 <dmiles> how do i rtemove singleton warnings ?
09:38:48 <xbill> still too many warnings
09:38:52 <dmiles> ok one sec
09:39:02 <xbill> you're reusing something defined by uo twice in the same scope
09:39:05 <dmiles> oi am going to search for switch
09:39:26 <dmiles> uo.. i thought thats fixed
09:39:33 <dmiles> i chaing tio in,out
09:40:44 <xbill> okay
09:41:07 <dmiles> okay wantings fixed
09:41:13 <dmiles> err warnings
09:41:15 <dmiles> reload :)
09:41:30 <xbill> Hrm I'm not sure you need the backticks
09:41:47 <xbill> are those atoms or real logical variables?
09:42:01 <dmiles> lofgical variable (the G66666)
09:42:09 <dmiles> they are universals
09:42:28 <dmiles> meaning any value could fall ther for unification
09:42:38 <dmiles> example is..
09:42:57 <dmiles> heart(X):-humasn_heart(Name,X)
09:43:04 <dmiles> Name gould be any humasn
09:43:24 <dmiles> Name could be any human 
09:43:37 <xbill> I think you have to do universals differently ... very differently.
09:43:40 <dmiles> sdo if i had 10 people with hearts heqart(X) should return 10 tuimes
09:44:10 <dmiles> yeah.. you see i am creating a blind crash cousre here
09:44:26 <dmiles> i read a bit.. for a couple hours
09:44:45 <xbill> type universal ---> subjectiveAssessmentProperty ; NormativeProperty ; ... 
09:45:00 <dmiles> oh those.. those are Atoms
09:45:09 <dmiles> the G666 are the only unversials
09:45:32 <xbill> you have to declare an atom as a discriminated union basically
09:45:35 <dmiles> but your saying i shgould declare the atoms as well
09:45:43 <dmiles> ok.. cool
09:45:53 <dmiles> i actually have types and subtyope
09:46:13 <dmiles> but i dind tknow if i could tell merc that
09:46:25 <xbill> the universals I don't believe you're having trouble with
09:47:00 <xbill> Smooth and TextureProperty and so on are having trouble
09:47:06 <dmiles> its my billions of undeclared atoms?
09:47:22 <xbill> it looks like it
09:47:35 <dmiles> ifer type i was hoping :)
09:47:38 <xbill> instance subclass and contraryProperty also need to be declared.
09:47:39 <dmiles> err infer
09:47:53 <dmiles> well they are random user words 
09:48:05 <dmiles> but i see what your saying..
09:48:17 <dmiles> dolds/2 is like a genric prolog interopretor
09:48:21 <dmiles> err holds/2
09:48:41 <dmiles> and the data inside is what i am trying to process
09:48:56 <dmiles> so maybe i need losser types in my :-pred ?
09:49:03 <dmiles> err looser
09:49:16 <dmiles> what if all these where strings?
09:49:30 <dmiles> i would loose speed .. :)
09:49:35 <xbill> hrm, it might be easier if they were strings... it's faster if they're atoms though
09:49:50 <xbill> string processing is slow no matter what
09:49:54 <dmiles> yeah.. so ok i'll can make a list of atoms..
09:50:07 <dmiles> and dio a :-type for each
09:50:17 <dmiles> and just call thenm atom ?
09:50:43 <dmiles> with the sk6666Fn whhat could i call them?
09:50:48 <xbill> you don't want a :- type for each
09:51:04 <dmiles> just one ype with a list?
09:51:10 <xbill> you want one big :- type and each thing a case in the :- type
09:51:23 <dmiles> ok that will take me about 5 minutes to generate
09:51:30 <xbill> like :- type ---> foo ; bar ; snoo ...
09:51:37 <dmiles> ok one sec P:)
09:52:08 * dmiles uses mad SWI-Prolog skills to generate the list
09:52:25 * xbill =)
09:52:50 <dmiles> should put them on one line ort 
09:52:55 <dmiles> :-type atom -->
09:52:57 <dmiles> foo
09:53:00 <dmiles> eerr
09:53:03 <dmiles> foo,
09:53:05 <dmiles> bar,
09:53:09 <dmiles> blah.
09:53:18 <xbill> no the separator is ;
09:53:28 <dmiles> ah good thing you said that
09:53:36 <xbill> heh
09:54:30 <xbill> :- type expr ---> in dcg.m should help
10:00:25 <xbill> dmiles: whatever the results of your experiment for optimizing things is I'm sure the Mercury guys would love to hear of the results
10:02:26 <xbill> dmiles: also you may hit bottlenecks further down the toolchain like the compiler and/or executable format
10:03:43 <xbill> er  C compiler
10:04:00 <dmiles> yeah.. is there a way to tay in mercury like interpr4etor?
10:04:26 <dmiles> since i know i hvsae to hit C code
10:13:23 <xbill> nope
10:19:30 <dmiles> rrm i tghought :- type atom --> zzsk964310Fn ;  subsumedExternalConcept ;
10:19:39 <dmiles> well witl perios at end
10:19:50 <xbill> that's wha it should be
10:19:57 <xbill> is that not working?
10:24:20 <xbill> is it not working?
10:24:58 <dmiles> gettimg beeter :)
10:25:08 <dmiles> i need --- 's :)
10:25:23 <shapr> sex?
10:25:40 * shapr tries to think of other three letter words
10:25:43 <shapr> luv ?
10:25:48 <shapr> fud?
10:25:59 <dmiles> hehe 
10:26:18 <dmiles> must be able top be prulaized as well
10:26:25 <shapr> oh right
10:26:37 <dmiles> wli: hrrm some of the keeywrks mean things to it
10:27:04 <shapr> bud ?
10:27:10 <shapr> buds
10:27:13 <shapr> that would work
10:27:26 <shapr> ok, I have no idea
10:29:13 <dmiles> wow wli,, new types of errs
10:29:35 <dmiles> shapr:)
10:29:38 <xbill> what errors?
10:29:39 <dmiles> buds fine
10:29:47 <dmiles> testit.m:091: In clause for predicate `testit:holds/2':
10:29:47 <dmiles> testit.m:091:   in argument 1 of clause head:
10:29:47 <dmiles> testit.m:091:   type error in unification of variable `HeadVar__1'
10:29:57 <dmiles> no more undefine constants tho :)
10:30:03 <xbill> heh
10:30:15 <dmiles> 14 list of constants
10:30:18 <dmiles> err 14k
10:30:45 <dmiles> http://216.39.172.56/_/engine/testit.[m|err]
10:31:11 <dmiles> is instance/subclass reserved?
10:31:20 <dmiles> or at at least insrtance?
10:32:01 <xbill> no
10:32:04 <dmiles> i had to remove and,or,=>,<=>,instance from my type list
10:32:27 <dmiles> hrrm i mgiht add 'instance' back
10:32:40 <xbill> some of the names are used by the libraries
10:32:55 <dmiles> testit.m:019: Syntax error at token 'instance': unexpected token at start of (sub)term.
10:33:25 <dmiles> opk fixed
10:33:29 <dmiles> (instance)
10:33:39 <dmiles> i parend it
10:34:06 <xbill> 2.2MB of errors
10:34:36 <dmiles> thats alot better huh?
10:34:44 <dmiles> hehe
10:34:55 <dmiles> wait tho
10:34:57 <dmiles> i think..
10:35:05 <xbill> some of them are reserved by the term module
10:35:23 <xbill> no
10:35:40 <xbill> you say that holds() takes an arg of type term and pass it an atom
10:36:02 <dmiles> but isnt atom subclass of term?
10:36:11 <xbill> no
10:36:15 <dmiles> i can make sure its always an atom of variable thio
10:36:25 <dmiles> iok .. i'll fix that type
10:37:17 <dmiles> ok fixed
10:37:22 <dmiles> regend the err file
10:37:51 <xbill> down to 422KB
10:38:29 <dmiles> heh
10:38:40 <xbill> what's the type signature for error?
10:38:43 <dmiles> :- pred holds(atom,list(T)).
10:38:45 <xbill> for holds()
10:38:57 <xbill> try holds(atom, list(atom)).
10:40:11 <dmiles> holds(domain, [deathTime, 2, 'TimePosition']).
10:40:18 <dmiles> testit.m:126: In clause for predicate `testit:holds/2':
10:40:18 <dmiles> testit.m:126:   in argument 2 of clause head:
10:40:18 <dmiles> testit.m:126:   in argument 2 of functor `./2':
10:40:18 <dmiles> testit.m:126:   in argument 1 of functor `./2':
10:40:18 <dmiles> testit.m:126:   type error in unification of argument
10:40:20 <dmiles> testit.m:126:   and constant `2'.
10:40:22 <dmiles> testit.m:126:   argument has type `(testit:atom)',
10:40:24 <dmiles> testit.m:126:   constant `2' has type `int'.
10:40:47 <xbill> define a case in the atom type like intatom(int)
10:40:59 <xbill> and wrap the integer constants with intatom()
10:41:16 <dmiles> hrrm good idea
10:41:28 <xbill> well it's required =)
10:43:48 <nefph> ok lets go over types real quick
10:43:54 <xbill> 85KB =)
10:44:13 <xbill> looks like you're still putting naked integers in there
10:44:38 <xbill> you need to put the constructor intatom() around the integer constants in the rule heads
10:45:23 <nefph> grrm coonection
10:45:30 <nefph> lets go over my tpyes real quick
10:45:37 <nefph> i was dead
10:45:59 <nefph> i have Numbers,Atoms,sk666Fn,doDaoFn
10:46:17 <xbill> okay
10:46:20 <nefph> so i'll make a list of my tpes in the top of the file
10:46:34 <nefph> then point to iot for you
10:46:41 <xbill> you need to wrap the integers 
10:54:45 <dmiles> heel
10:54:49 <dmiles> hello
10:55:08 <dmiles> ok 20 second lag
10:55:17 <xbill> re
10:55:25 <xbill> hey, did you wrap the integers?
10:55:44 <dmiles> i see that i need more typing
10:55:51 <dmiles> let me show you
10:55:56 <xbill> you need to wrap the integers
10:56:02 <dmiles> Anything = wff ; AtomOrVar  ; atomint  ; reifyConst
10:56:02 <dmiles> wff = holds(AtomOrVar,ListOfAnything)
10:56:02 <dmiles> reifyConst = zzsk(Atom,ListOfAnything) ; fn(AtomOrVar,ListOfAnything)
10:56:02 <dmiles> AtomOrVar = Atom ; Var
10:56:02 <dmiles> ListOfAnything = list of Anything
10:56:06 <dmiles> i may as well do it now
10:56:14 <dmiles> i hvaer a very set type and syntax
10:56:28 <dmiles> i am ussing your dcg.m to make one.. one sec
10:56:40 <dmiles> otherwsie we are shooting in the dark
10:56:58 <xbill> atomint(int)
10:56:59 <dmiles> since i have very strict types i know aboput but maybe need to tell merc L:)
10:57:06 <dmiles> yes that is parrt of it
10:57:07 <xbill> heh
10:57:36 <dmiles> :- type nonreifiable ---> atomint(int)
10:58:14 <dmiles> :- type reifiable ---> atom ; term_entiy.
10:58:24 <xbill> hrm
10:59:32 <dmiles> :- type alltypes --> nonreifiable ; reifiable .
11:00:10 <dmiles> ok here we are
11:00:11 <dmiles> :- type alltypes --> nonreifiable ; reifiable .
11:00:12 <dmiles> :- type nonreifiable ---> atomint(int).
11:00:12 <dmiles> :- type reifiable ---> atom ; term_entity.
11:00:12 <dmiles> :- term_entity ---> fn(atom,list(alltypes)) ; sk(atom,list(alltypes)). 
11:00:31 <xbill> okay
11:03:32 <dmiles> what would a ','(foo,foo) bwe?
11:03:40 <dmiles> is that a 'term' ?
11:04:21 <dmiles> i i should defuine a stricter type
11:04:28 <dmiles> (since i can)
11:04:49 <dmiles> one sec
11:05:56 <xbill> like a pair?
11:06:11 <xbill> pair syntax is {T1,T2}
11:08:50 <dmiles> yeah i am defencing the type logicalsentence
11:09:00 <dmiles> :- type alltypes --> nonreifiable ; reifiable ; logicalsentence .
11:09:00 <dmiles> :- type nonlogical --> nonreifiable ; reifiable.
11:09:00 <dmiles> :- type allsimple --> atom ; atomint(int) .
11:09:00 <dmiles> :- type nonreifiable ---> atomint(int).
11:09:00 <dmiles> :- type reifiable ---> atom ; term_entity.
11:09:01 <dmiles> :- type term_entity ---> zzfn(atom,list(nonlogical)) ; zzsk(atom,list(nonlogical)). 
11:09:03 <dmiles> :- type logicalsentence---> logicaltuple.
11:09:05 <dmiles> :- type logicaltuple ---> holds(atom, list(nonlogical)) ; not_holds(atom, list(nonlogical)) ; equal(nonlogical,nonlogical) ; not_equal(nonlogical,nonlogical).
11:10:39 <nefph> see topline of http://216.39.172.56/_/engine/testit.m
11:10:43 <nefph> see hold/2 is very generic
11:10:45 <nefph> so i have 3 basic typs..
11:10:53 <nefph> logicalsentence, reifiable, nonreifiable
11:11:55 <nefph> ok reload
11:12:09 <nefph> see the parts right below main
11:13:02 <nefph> :- pred holds(atom, list(alltypes)).
11:13:03 <nefph> :- pred not_holds(atom, list(alltypes)).
11:13:03 <nefph> :- pred equal(nonlogical,nonlogical).
11:13:03 <nefph> :- pred not_equal(nonlogical,nonlogical).
11:13:03 <nefph> :- pred entails(logicalsentence,logicalsentence).
11:13:03 <nefph> :- pred not_entails(logicalsentence,logicalsentence).
11:14:18 <nefph> i am goig to chuck out the file a bit :)
11:14:22 <nefph> make it smaller
11:14:29 <nefph> just having the structres i need
11:14:41 <nefph> like one of easch kind
11:19:31 <dmiles> ok wli , i rediuced the prblem size
11:19:35 <dmiles> like the file size
11:19:42 <dmiles> so its easier :)
11:19:52 <dmiles> like at the .m and .err file now
11:19:57 <dmiles> did some typingh
11:20:09 <dmiles> they are both tiny now
11:20:21 <dmiles> my connection sucks
11:20:47 <dmiles> i keep dropingh
11:20:47 <dmiles> lesss then 400 lines
11:20:47 <dmiles> for the .m
11:27:31 <nefph> oh its all wrapping
11:27:37 <nefph> i see now
11:27:45 <nefph> i cant just subtpye
11:28:01 <nefph> coorect?
11:28:05 <nefph>  <dmiles> like at the .m and .err file now are less then 400
11:28:21 <nefph> i get bumped off every few minute
11:28:31 <nefph> i havent seen a response if you gave one :)
11:28:43 <nefph> like now i a may no be here
11:55:43 <dmiles> man my connection sucks
11:55:45 <dmiles> can anyone here me?
11:55:47 <dmiles> err hear
12:05:10 <dmiles> xbill
12:05:17 <dmiles> i have the problems vbery simplified now
12:05:33 <dmiles> http://216.39.172.56/_/engine/testit.err nicer and small
12:05:40 <dmiles> http://216.39.172.56/_/engine/testit.m nioce and small
12:06:20 <dmiles> only eleven errors
13:03:18 <dmiles> xbill
13:03:38 <dmiles> you here.. think i got the problems down to sanity
13:03:48 <dmiles> before i was asking allot L(
13:03:50 <dmiles> :)
13:04:39 <dmiles> holds(time, [_G298, _G301]):-holds(holdsDuring, [_G301, holds(_G316, [_G319, _G298])]), holds(instance, [_G319, 'Physical']), holds(instance, [_G298, 'Physical']).
13:04:50 <dmiles> thats gives error:
13:05:01 <dmiles> testit.m:441: In clause for predicate `testit:holds/2':
13:05:01 <dmiles> testit.m:441:   in argument 2 of call to predicate `holds/2':
13:05:01 <dmiles> testit.m:441:   in argument 2 of functor `./2':
13:05:01 <dmiles> testit.m:441:   in argument 1 of functor `./2':
13:05:01 <dmiles> testit.m:441:   type error in unification of argument
13:05:02 <dmiles> testit.m:441:   and functor `holds/2'.
13:05:04 <dmiles> testit.m:441:   argument has type `(testit:alltypes)',
13:05:06 <dmiles> testit.m:441:   functor `holds/2' has type 
13:05:08 <dmiles> testit.m:441:   `holds((testit:alltypes), (list:list((testit:alltypes)))) :: (pred)'.
13:07:14 <dmiles> [_G298, _G301] i guess does not match list:list((testit:alltypes))
14:00:34 <skullface> whats functional programming and how is it diff. from C/Java programming langauges?? 
14:13:18 <nodie> hi
14:15:15 <nodie> what is the advantages of monads?
14:33:00 <shapr> that was odd
14:33:05 <shapr> and I even missed it
14:34:18 <shapr> hi again :)
14:34:27 <tmoertel> howdy, again!
14:35:41 <tmoertel> anyone here use Functional MetaPost?
14:42:40 <nodie> hi again
15:00:03 <shapr> hi
15:00:12 <shapr> tmoertel: don't you post to the haskell list?
15:00:40 <tmoertel> every once and a while
15:00:59 <shapr> hm, your name sounds familiar
15:01:04 * shapr looks at his archives
15:02:28 <shapr> nodie: functional programming is different from procedural programming in that the entire evaluation model is more like a mathematical equation rather than like a set of steps happening in order
15:03:01 <shapr> monads are a safe way of representing a computation in a language which does not allow side effects in code
15:03:31 * shapr tries to remember what he was working on
15:04:01 <nodie> like Object Oriented programming?
15:04:23 <shapr> no, that's an entirely different story.
15:04:39 <nodie> yes
15:04:42 <nodie> i use haskell
15:04:50 <tmoertel> one might say that it's an orthogonal story (see, e.g., Dylan)
15:05:55 <nodie> i want to say that monad hide code like objects make...
15:06:24 <shapr> hrm, I don't think I'd say that.
15:07:00 <shapr> the 'spirit' behind the original idea of objects was to package a collection of data and the code that works on that data, behind a set interface
15:07:20 <shapr> so objects are more about abstraction from implementation
15:07:31 <shapr> ya know, maybe that does work :)
15:10:51 <xbill> dmiles: still there?
15:13:15 <dmiles> yes hi
15:13:27 <dmiles> you see the error page?
15:13:36 <dmiles> i almost have it down
15:13:51 <dmiles> when you say my nick it fashies for me
15:13:57 <shapr> flashes?
15:13:59 <dmiles> err flashes
15:14:04 <dmiles> that yes
15:14:08 <shapr> heh :)
15:14:28 <shapr> dmiles: what's your native language?
15:14:38 <dmiles> newspeak
15:14:38 <shapr> you told me this before, but I forgot :(
15:14:42 <shapr> HA!
15:14:47 * shapr falls over laughing
15:14:49 <dmiles> i never had oine
15:15:16 <dmiles> even see blue lagoon?
15:15:24 <shapr> er, no, I don't think so
15:15:44 <dmiles> my parents were hippies that lived on a remote desert inland until i was 5
15:15:55 <dmiles> and my father was deaf
15:16:01 <shapr> wow, cool!
15:16:26 <dmiles> but in person my grammer is not as bad.. i just got a new keyboard last week
15:16:33 <shapr> oh, what kind of keyboard?
15:16:36 <shapr> kinesis or maltron?
15:16:53 <dmiles> i whent from a large MS naturla keyboard to this timy tiny one
15:16:59 <shapr> oh
15:17:14 <dmiles> it had too much coffee and cigarets.. stopped working
15:17:22 <nodie> do you compile hugs?
15:17:36 <shapr> dmiles: hah :)
15:17:44 <shapr> nodie: no, I used DebianLinux
15:17:48 <shapr> er, "use"
15:18:52 <nodie> i don't know how to say to compile I have readline... it's horrible to use hugs without readline
15:19:15 <shapr> use it from within emacs? ;)
15:19:23 <shapr> are you compiling on *nix?
15:20:04 <nodie> yes
15:20:12 <nodie> from emacs?
15:20:14 <nodie> hummm
15:20:15 <shapr> try doing ./configure --with-readline
15:20:17 <nodie> i use emacs..
15:20:25 <shapr> M-x haskell-mode ;)
15:20:39 <shapr> M-x turn-on-haskell-hugs
15:20:45 <nodie> i write --with-readline but configure don't detected it
15:20:59 <nodie> i'd to download haskell mode...
15:21:13 <shapr> you may have to do --with-readline=/usr/lib/$MYREADLINELOCATION
15:21:23 * shapr loves metasyntactic variables
15:22:42 <nodie> that's not
15:22:48 <nodie> i'll prove it
15:23:07 <shapr> ?
15:23:14 <shapr> really?
15:23:15 <shapr> go for it!
15:36:29 <xbill> dmiles: how did the -> Mercury thing go?
15:38:05 <dmiles> dowen to 11 errors
15:39:09 <dmiles>  holds(time, [_G298, _G301]):-holds(holdsDuring, [_G301, holds(_G316, [_G319, _G298])]), holds(instance, [_G319, 'Physical']), holds(instance, [_G298, 'Physical']).
15:39:17 <dmiles> [13:07] <dmiles> testit.m:441: In clause for predicate `testit:holds/2':
15:39:18 <dmiles> [13:07] <dmiles> testit.m:441:   in argument 2 of call to predicate `holds/2':
15:39:18 <dmiles> [13:07] <dmiles> testit.m:441:   in argument 2 of functor `./2':
15:39:18 <dmiles> [13:07] <dmiles> testit.m:441:   in argument 1 of functor `./2':
15:39:18 <dmiles> [13:07] <dmiles> testit.m:441:   type error in unification of argument
15:39:18 <dmiles> [13:07] <dmiles> testit.m:441:   and functor `holds/2'.
15:39:20 <dmiles> [13:07] <dmiles> testit.m:441:   argument has type `(testit:alltypes)',
15:39:22 <dmiles> [13:07] <dmiles> testit.m:441:   functor `holds/2' has type 
15:39:24 <dmiles> [13:07] <dmiles> testit.m:441:   `holds((testit:alltypes), (list:list((testit:alltypes)))) :: (pred)'.
15:39:26 <dmiles> [13:09] <dmiles> [_G298, _G301] i guess does not match list:list((testit:alltypes))
15:40:15 <nodie> (is this prolog?)
15:47:25 <dmiles> Mercury
15:49:29 <xbill> dmiles: how far are you now?
15:49:51 <dmiles> i sort of started basck in SWI-mode until i could ask you what was up
15:49:58 <dmiles> i simplified the program and the problems
15:50:11 <dmiles> http://216.39.172.56/_/engine/testit.m http://216.39.172.56/_/engine/testit.err
15:50:17 <dmiles> much smaller fuiles now
15:50:52 <dmiles> [_G298, _G301] doess not match  list:list((testit:alltypes)) ?
15:51:45 <xbill> oic
15:57:53 <xbill> hrm well I'm still sort of working .. hang on
16:04:26 <dmiles> n/p i am now addfing color to my types in the rule output code
16:04:40 <dmiles> so each type is wrapped
16:05:05 <dmiles> preds(instance),numerical(55)
16:06:13 <dmiles> and variable possitions that require a certin type is holds(preds(X),...)
16:06:33 <dmiles> also removing the list types
16:06:55 <dmiles> and making the list a verttor like [A,V] -> argv(A,V)
16:07:20 <dmiles> [a,b,c] -> argv(a,b,c)
16:08:02 <dmiles> that way its creates a virtual hash based on the arity of the relatyion
16:08:26 <dmiles> argv/2 arv/3.. etc
16:22:12 <xbill> heh
16:44:14 <xbill> crap I didn't see anything
18:05:17 <dmiles> it ok my work with mercury has really inspired me to explore better typing in the specialization of rules
18:06:03 <dmiles> myt rule output format is getting more contstrained ev3ery hour
18:07:02 <xbill> dmiles: heh, does it compile yet?
18:07:24 <dmiles> i left it at the 11 rules.. and working on typing the output form 
18:07:31 <dmiles> err 11 errors
18:07:47 <dmiles> so i am not ussing lists and each varible will have type wrappers
18:08:25 <dmiles> what i am doing is only moving both the SWI-Prolog and Mercury version forwasrd
18:09:17 <xbill> nice
18:09:23 <dmiles> may sound wierd, but i might just have SwI output the .m file then switch over to mercury ofr Querytime
18:09:43 <xbill> what are you hoping to see from Mercury in all this?
18:10:00 <dmiles> faster specialized version of the database
18:10:12 <dmiles> with Tabling (loop checking)
18:10:16 <xbill> hrm cool
18:10:34 <dmiles> if it wasnt for some of the rules looping to infinitum swi would have worked
18:10:43 <xbill> oh?
18:10:48 <dmiles> i hate ussing time/space/backchain constaints
18:10:56 <dmiles> its wrong for a user to have to decide that
18:11:23 <dmiles> in SWI i can set timeout for query.. backchain depth etc.. 
18:11:52 <dmiles> but thats just casue i am looping
18:12:05 <xbill> Mercury has termination analysis
18:12:17 <dmiles> Rgith, thats the most important feature
18:12:29 <dmiles> i thought it had a good contraint librayry.. but it doesnt
18:12:38 <dmiles> but its ok..
18:12:53 <dmiles> you can add in contraint by wrapping types
18:13:08 <xbill> hrm
18:13:11 <dmiles> human(X) dog(X) .. etc
18:13:32 <dmiles> human(X) wont unify with dog(X)
18:13:48 <dmiles> thats what ui mean by sontraint
18:13:53 <dmiles> err contraint
18:14:11 <dmiles> its all about overloading the vbasic operation of =
18:14:32 <dmiles> if i said that dog was a subclass of animal..
18:14:33 <xbill> aha
18:14:58 <dmiles> and so was humun... then a predicate with the typer breaths*(animal(X),air)
18:15:25 <dmiles> then that would alow dog(fido) human(jeff) to inify
18:15:43 <dmiles> but i wound not want just X...
18:16:00 <dmiles> i would want th ewhole term dog(fido) human(jeff)
18:16:21 <dmiles> vs fido,jeff
18:16:49 <dmiles> so one wouild voerload =- to..
18:17:18 <dmiles> animal(dog(X)) =  dog(X).
18:17:31 <dmiles> animal(human(X)) = human(X).
18:18:04 <dmiles> mercury and other prologs dont have that
18:18:22 <dmiles> since =.. is such a basic operation
18:18:26 <dmiles> err =
18:19:38 <xbill> huh?
18:19:45 <dmiles> but i know that i am going to end up writing my own version of myeqequals.. ;( and every chain (forward/backward) is going to have to call it
18:20:07 <dmiles> well in basic prolog.. 
18:20:14 <dmiles> you have =/2
18:20:28 <dmiles> which all of prolog is buiult i8on top of
18:21:00 <dmiles> it defines how your reader envisions your :- rules
18:21:01 <xbill> right...
18:21:19 <dmiles> a([X|Y],X,Y).
18:21:58 <dmiles> means.. a([X|Y],XX,YY):-X=XX,Y=YY.
18:22:30 <dmiles> so it i wanted to do this..
18:22:54 <dmiles> a([human(X)],X,Y)
18:23:31 <dmiles> a([human(X)],animal(human(joe)),Y)
18:24:01 <dmiles> and have Joe pop out of X
18:24:07 <xbill> CLP?
18:24:14 <dmiles> i would be redifining =/2
18:24:19 <dmiles> correct
18:24:23 <xbill> oic
18:24:27 <dmiles> attriburted atoms and variables
18:25:01 <dmiles> there is no clean way to show attrribrtes
18:25:13 <dmiles> except maybe a set of arribs
18:25:27 <dmiles> [human,mammal,joe]
18:25:50 <dmiles> then you are constanly seeing if things intersect
18:26:04 <dmiles> ijnstead of uiunification
18:26:19 <dmiles> very slow
18:26:32 <dmiles> eclipse.. suposidly does this
18:26:42 <dmiles> and was meant to do it fast
18:27:07 <dmiles> CLP is overly brandished by prdeclaritive interpetoirs
18:27:25 <dmiles> they often mean types :)
18:27:30 <xbill> what's eclipse?
18:27:46 <dmiles> its a really bassass CLP system.. hard to get..
18:28:25 <dmiles> http://www-icparc.doc.ic.ac.uk/eclipse/
18:28:30 <xbill> explains why I've not heard of it yet
18:29:27 <dmiles> i got my copy with extensive FTP searching in people home dirs :)
18:30:13 <dmiles> November 26, 2001 
18:30:23 <dmiles> they are very up to date
18:30:33 <dmiles> it is the best allk around i hear
18:30:56 <dmiles> http://www-icparc.doc.ic.ac.uk/eclipse/features.html
18:32:06 <dmiles> ECLiPSe programs can execute in or-parallel on shared-memory multiprocessor hardware (this functionality is currently not actively maintained because of other priorities). 
18:32:38 <dmiles> The system is designed to impose no unnecessary limits on programs and data. E.g. there is no limit, other than the available memory, on the number or length of atoms and strings, the arity of functors, the code size, number of procedures, complexity of clauses or stack sizes. 
18:33:14 <dmiles> and what *I* need...
18:33:15 <dmiles> The attributed variable data type is the key to many extensions to the basic Logic Programming language. The system calls user-definable event handlers when it encounters attributed variables in certain contexts, e.g. unification. 
18:33:58 <dmiles> howver i dont see claim for termination
18:36:11 <xbill> what claim for termination?
18:36:54 <dmiles> for the ablity to see if rules can come to a termination
18:37:15 <dmiles> termination analysis
18:37:47 <dmiles> otherwsie i would be on it in a second
18:41:21 <xbill> oic
18:41:39 <dmiles> nice system eh?
18:43:52 <xbill> yes
18:44:31 <dmiles> my worjk wasnt cionvinced it would be ok for some reason
18:44:39 <dmiles> ywet they are letting me try mercury
18:45:02 <xbill> who knows?
18:45:23 <xbill> but hey, if you get to throw the Mercury guys a bone by using it in a real application... all the better =)
18:45:53 <dmiles> yeah :)
18:46:32 <xbill> that and Mercury's reputedly a speed demon =)
18:46:57 <dmiles> i am going to work all weekend at getting mercury to work for me
18:47:19 <dmiles> this evening is dedicated to the output file format being as infomative as possible
18:48:38 <Vutral> cool
18:49:10 <dmiles> Therre was a test that was run between B-prolog and mercury that B-Prolog beat it..
18:49:20 <dmiles> so i tried 'B' for a while
18:49:33 <dmiles> the implemntor even added two predicatyes for me..
18:49:39 <dmiles> but man its very unstable
18:49:52 <xbill> I've never heard of B-prolog
18:50:12 <dmiles> dont worry about it.. :) its cool becasue thwe autyhor is accesssavble
18:50:18 <dmiles> he even called me a couple times
18:50:37 <dmiles> but certain normal things you expect dont work
18:51:01 <dmiles> like ther is no I/O .. uits based on calling into Java JNI
18:51:10 <dmiles> thats what got me on the Java/Prolog kick
18:51:46 <dmiles> but once i added a java interface to swi.. i couldnt gain anyrthing from 'B'
18:52:21 <dmiles> http://www.probp.com/ <- to see it if your interested
18:52:38 <dmiles> but its about as good as gnu-prolog
18:52:48 <dmiles> which to me is too tiny
18:53:08 <dmiles> does neat stuff that any prolog system should do as a baseline
18:53:28 <dmiles> but no real incentives
18:55:32 <xbill> er gnuprolog ...??
18:55:47 <xbill> (last I recall gprolog wasn't that hot)
18:58:16 <dmiles> yeah :(
19:00:56 <xbill> mercury's machine model is pretty cool though
19:01:39 <xbill> shame they're tied down to a shitty code generator (gcc).
19:03:33 <dmiles> yeah i am wondering how much time between the user assertion into the DB and before its ready to answer rthe query will be
19:07:10 <xbill> Shoot I don't know how to guess
19:08:29 <dmiles> well the amount of time i inkvoe mmc etc until its loaded and linkjed
19:08:42 <dmiles> i am not too worried right this miunute
20:05:16 * xbill hacks the kernel.
20:06:03 <Vutra_> wow wow wow
20:06:06 <Vutra_> xbill :>
20:06:13 <Vutra_> you old hacker ;)
20:08:55 * xbill shrugs
20:14:25 <Vutra_> hehe
20:14:43 <Vutra_> hrm
20:14:48 <Vutra_> if this is opposite of vb
20:14:58 <Vutra_> do you turn around brackets ?
20:15:21 <Vutra_> ;sub bla bla") ("
20:15:22 <Vutra_> :>
20:37:58 <xbill> uh
20:38:08 <xbill> Haskell is nothing like vb
20:38:18 <xbill> what's a good haskell program?
20:38:30 <xbill> http://holomorphy.com/~wli/grid/GInterp.hs
20:40:23 <Vutra_> looks similar to python but only at the beginning
20:40:26 <Vutra_> :>
20:40:46 <xbill> can you compile and run it and see what it does?
20:40:57 <Vutra_> sure
20:41:03 <Vutra_> its python
20:41:26 <Vutra_> well
20:41:30 <Vutra_> i will lay down now
20:41:32 <Vutra_> bbl
20:41:46 <xbill> er, wtf? where is python in any of this?
20:42:04 <Vutra_> import
20:42:05 <Vutra_> :>
20:42:10 <Vutra_> well java has that too
20:42:14 <Vutra_> ;)
20:42:19 <Vutra_> bbl
20:53:18 <xbill> blah
