00:06:11 * yusri is off to work
00:06:20 <yusri> tks, ski
00:06:25 <ski> ok, bye yusri !
00:17:34 * Heffalump wonders if ski ever sleeps
00:18:41 <ski> hmm, i'm think i should go home and sleep in some minutes, just reading a little about refactoring and adaptive and aspect programming (monads and aspects are related, right ?)
00:19:47 <Heffalump> they are?
00:25:01 <ski> well, with monads one can take certain things scattered throughout code (such as explicit state passing) and define it in one place, and then use the monad operations in standard monad way. i you discover that you need more things, perhaps exceptions or a name supply or nondeterminism, just change the monad definition and the "primitive" monad operations (add the new ones) and just change the places in the code using the monad that conceptually n
00:25:32 <ski> instead of having to change all the code that explicitely does whatever the monad should do
00:25:40 <Heffalump> I guess
00:26:03 <Heffalump> but aspect-oriented programming tries to be a lot more general than that, I think
00:26:22 <ski> but, i don't know very much about aspect-oriented programming. so this is just a feeling i've got of a similarity.
00:27:34 <ski> yes, i suppose it's more general. but the point is that monads (or arrows, etc , other combinator libraries) can be used to accomplish certain AOP tasks, you know what i mean ?
00:27:41 <Heffalump> yeah
00:27:46 <ski> ok
00:30:56 <ski> but, now i'm really tired so i'll give up for today and go home to sleep
00:31:11 * ski says bye !
00:39:28 <discobob> hmm, is anyone else using the SOE sources with Hugs98 for windows?
01:27:45 <discobob> Yurik: do you use Hugs on Windows?
01:28:02 <Yurik> discobob nope, I use GHC
01:28:38 <discobob> dang
02:23:09 <jemfinch> python regex isn't anymore tedious than perl/ruby's, it's just not syntactically sugared.
02:24:03 <jemfinch> (and note that ruby doesn't even have first class functions, and thus no closures)
03:09:39 <Yurik> shapr hi
03:09:50 <shapr> hi Yurik, what's up?
03:10:31 <Yurik> shapr fine, thanks :-)
03:14:07 <shapr> have you had any further thoughts on the A/ES server?
03:17:55 <Yurik> E/AS :-) and not server :-))) But I have, of course. We're currently resolving some issue to go ahead :-)
03:17:55 <Yurik> If you interested, you may track our convesation at #eas, on this irc net.
03:17:55 <Yurik> s/issue/issues/
03:18:20 <Heffalump> E/AS?
03:19:07 <Yurik> E/AS stands for Enterprise / Automation System, an opensource project to create framework for enterprise automation needs
03:19:58 <Heffalump> erm, right
04:59:45 <Yurik> guys, what is Concurrent Haskell?
05:00:13 <Heffalump> Haskell with primitives (in the IO monad) to support threads and signalling between them
05:00:16 <Heffalump> [I think]
05:00:44 <shapr> I thought Concurrent was what we use, and Paralell was PVM support added?
05:01:03 <Heffalump> I don't think Concurrent stuff is Haskell '98, though I could be wrong
05:01:27 <Heffalump> as in it's not in the Haskell '98 libraries, not that it doesn't satisfy the language spec
05:01:43 <Heffalump> but all this is my impressions, not the gospel truth
05:04:01 <Yurik> I see concurrent lib in GHC, does it conforms to Concurrent Haskell now?
05:04:09 <Heffalump> I'm sure GHC does
05:04:18 <Heffalump> not sure about other Haskell compilers/interpreters, that's all
05:04:18 <jemfinch> Heffalump: you mentioned that functions over type classes use dictionaries, right?
05:04:24 <Heffalump> jemfinch: yes
05:04:40 <jemfinch> Heffalump: how are those dictionaries implemented?  I haven't seen any O(1) hashtable implementations in Haskell.
05:04:42 <Heffalump> (or, to be precise, what shapr said: that functions which are polymorphic in a type class constrained variable do)
05:04:59 <Heffalump> jemfinch: no idea
05:05:03 <Heffalump> read the GHC source :-)
05:05:19 <shapr> eh? what I said?
05:05:38 <jemfinch> does Haskell provide mutable arrays?
05:05:40 <jemfinch> shapr: I think he meant ski :)
05:05:50 <shapr> oh
05:05:52 <shapr> whew
05:06:05 <Heffalump> oops, sorry, I did :-)
05:06:17 <Heffalump> jemfinch: GHC does, can't remember if it's in the standard libraries
05:07:36 <jemfinch> Heffalump: does the mutation have to be put in a monad?
05:08:16 <Heffalump> jemfinch: yep, either the IO monad or (possibly) the ST monad
05:08:22 <jemfinch> the ST monad?
05:08:26 <Heffalump> State
05:08:30 <jemfinch> ah, ok.
05:08:34 * jemfinch doesn't know Haskell, actually.
05:08:51 <Heffalump> GHC has a built-in one with some nice implementation characteristics (but if you use it your code won't be Haskell 98)
05:12:27 * jemfinch might have to look into monads in the future.
05:12:37 <shapr> monads are nifty
05:12:39 <jemfinch> Haskell is interesting, but I'm a bit leery of the lazy evaluation.
05:12:53 <shapr> lazy evaluation rocks!
05:13:08 <shapr> plus you can always force strict evaluation with seq
05:13:26 <jemfinch> shapr: why does it rock?
05:15:13 <shapr> at the simplest end of life, it lets you used stuff like [1..]
05:15:27 <shapr> so you can make an infinite sequence that's a recursively built list
05:15:36 <shapr> and the list is only calculated as you need it
05:17:37 <Logan> You don't have to worry about structuring your code to support functions that generate data intermittently.
05:18:17 <jemfinch> Logan: explain that :)
05:18:58 <Logan> Well, under lazy evaluation, all you have to do is write a function that generates a list of answers...
05:19:14 <Logan> That generation will only occur as needed, but you don't have to worry about dealing with that explicitly.
05:19:28 <Logan> Whereas in a strict language, you have to support that sort of data access explicitly if you want it.
05:19:33 <shapr> yah, in python terms, *everything* is xreadlines and xmap
05:21:20 <Logan> In other words, in a strict language, you'd have to explicitly code the overhead of maintaining state, so you know what the _next_ data you should generate would be.
05:22:16 <Logan> I think it also makes it so that the order of evaluation matters not at all (does order matter in all strict languages, even if they're functional?).
05:30:26 <Igloo> If sideeffects are not possible then the order only affects runtime and termination
05:52:38 <Yurik> btw, guys is there the good way to read/write binary files? (ghc)
05:54:36 <Igloo> readFile and writeFile?
05:55:08 <Igloo> I think that some functions take an option to specify it's a binary file but you'd have to check the report for that
05:57:05 <Yurik> it's in prelude?
05:57:23 <Igloo> Think so
06:05:28 <Heffalump> I thought binary files are a known problem
06:07:53 <Igloo> IWW?
06:08:47 <Heffalump> IWW?
06:08:53 <Heffalump> oh, in what way
06:08:59 <Heffalump> errm. I've seen stuff on the mailing list. ICBW.
06:09:14 <LoganClass> I thought I saw something about making it easy to read bits at a time (as opposed to bytes).
06:09:17 <shapr> inter continental ballistic whale?
06:09:21 <LoganClass> I doubt there's a problem with just reading raw bytes.
06:09:21 <shapr> ICBW?
06:09:33 <LoganClass> It could be worse.
06:09:38 <Heffalump> I could be wrong.
06:09:48 <LoganClass> I can't breathe water.
06:09:50 <LoganClass> Later.
06:09:52 <Heffalump> :-)
06:10:09 <Heffalump> someone should teach clog to do explanations
06:10:37 <shapr> well, my irc client has some cool tricks that can help
06:11:10 <shapr> currently, EmacsWiki:EmacsNiftyTricks is a valid url, and I can hit enter on it, and it calls browse-url.el, and drops my browser to the correct page on the wiki
06:11:25 <shapr> the other possibility is that purl.org/wiki/haskell/ will get approved by the guy I submitted it to
06:11:32 <shapr> and then we can use it as a valid web address
06:16:46 * Heffalump reads about purls
06:17:03 <Heffalump> given how cheap domains are now, using them for http redirects seems unnecessary
06:17:19 <Heffalump> cos you can get a domain and be pretty certain you'll be able to keep it for ever
06:25:43 <Yurik> what exactly readFile and writeFile does?
06:28:13 <Yurik> seems that found
06:29:08 <Yurik> "All I/O functions defined here are character oriented"
06:29:10 <Yurik> :-(
06:33:50 <dennisb> Yurik: you might want: http://www.haskell.org/ghc/docs/latest/set/sec-ioexts.html#AEN12992
06:36:16 <Yurik> dennisb thanks. when I can read more about it (examples, for example)? I'm a newbie in Haskell..
06:37:52 <dennisb> okay, well most files are character oriented, what is the problem?
06:38:17 <Yurik> dennisb I need to work with binary ones
06:40:32 <dennisb> well, in unix it's probably the same otherwise the function openFileEx is what you need instead of openFile that are in the haskell 98 standard
06:42:19 <Yurik> so, I should use openFileEx  to open file.. right? and what should I to read/write/seek?
06:42:24 <dennisb> as far as I know it's only using win32 where it makes a difference between binary or textmode on files (in the old days I guess it was more systems)
06:42:43 <dennisb> http://www.haskell.org/onlinelibrary/io.html
06:42:49 <dennisb> (normal IO functions)
06:43:32 <dennisb> hPutChar, hGetChar, hSeek
06:44:52 <Yurik> will hPutChat and hGetChar work with byte-values?
06:48:16 <Yurik> moreover, there is no way to put and get numbers?
06:50:11 <Yurik> (for example)
06:51:52 <dennisb> I dont think so, you have to convert
06:52:56 <dennisb> but it is easy to write a small function that reads 4 bytes and constructs a number or something
06:53:15 <Yurik> but it will be probably very slow, eh?
06:54:35 <dennisb> well, there is functions  hGetBuf, but I don't think it worth it
06:54:56 <dennisb> and slow, it is going to be bufferd input anyway, so it's not going to be that slow
06:55:20 <Yurik> yes, I found hGetBufBA
06:55:29 <Yurik> may be it is better than hGetBuf?
06:56:00 <dennisb> I don't know.
06:56:06 <Yurik> is hPutBuf operates on any kind of data?
06:56:12 <Yurik> I mean numeric at least
06:57:03 <dennisb> No, if you want to convert to an Integer in haskell you still need to convert. You could use other types, like 32 bit words or something
06:57:49 <dennisb> Integer in haskell is arbitrary big numbers, it's not going to be a 1 to 1 map against the value in a file anyway
06:58:00 <Yurik> Int32?
06:58:37 <dennisb> and then you have all the issues with little and big endian data, if you ask me, just do a simple solution first and see if it is fast enough
06:59:08 <Yurik> btw, ghc says ghc: can't find module `IOExts'. ghc-pkg -l says that lang package is installed. What might be the problem?
06:59:47 <dennisb> -package lang
06:59:59 <Yurik> thanks :-)
07:00:05 <shapr> -package plain-brown
07:00:33 <Heffalump> what's in that then? :-)
07:00:45 <shapr> none of your business ;)
07:00:48 * shapr is joking
07:01:06 <shapr> it at least implies that it holds some kind of vice
07:03:51 <Heffalump> :-)
07:04:30 <Yurik> so how should I use hPutBuf to write Int32?
07:05:05 <dennisb> Yurik: I don't know. I would just read 4 characters and put together
07:05:22 <Heffalump> he wants to write...
07:05:25 <Heffalump> just use show
07:05:29 <dennisb> But i'm sure it can be done in some way with...
07:05:30 <dennisb> aha
07:05:50 <dennisb> but he wants to write it binary? show converts to a ascii-string
07:05:56 <Heffalump> oh, sorry
07:06:12 <Heffalump> split it up into bytes and use chr, then?
07:06:40 <dennisb> that is what I would do, if it is to slow I would start looking for faster solutions
07:07:49 <Heffalump> hmm.
07:07:51 <Heffalump> IOExts> :t hPutBuf
07:07:51 <Heffalump> forall a.
07:07:51 <Heffalump> PrelIOBase.Handle
07:07:51 <Heffalump> -> PrelPtr.Ptr a -> PrelBase.Int -> PrelIOBase.IO PrelBase.Int
07:07:55 <dennisb> it is still going to be buffered so you don't send it one byte at a time to disk anyway
07:07:56 <Yurik> hPutBuf fh (300 :: Int32) 0
07:08:07 <Yurik> Main.hs:9:
07:08:08 <Yurik> Couldn't match `Int32' against `PrelPtr.Ptr a'
07:08:09 <Yurik> Expected type: Int32
07:08:10 <Yurik> Inferred type: PrelPtr.Ptr a
07:08:11 <Yurik> In an expression with a type signature: 300 :: Int32
07:08:12 <Yurik> In the second argument of `hPutBuf', namely `(300 :: Int32)'
07:08:15 * dennisb have never used hPutBuf
07:08:24 <Yurik> Where can be my mistake?
07:08:28 <Yurik> :)
07:08:33 <Heffalump> you need to create a PrelPtr.Ptr
07:08:36 <Heffalump> I'm not sure how to do that
07:11:03 <dennisb> me neitherm and for just a small integer it's probably not that much faster (if any)
07:12:01 <Heffalump> that much faster than using hPutChr?
07:12:25 <dennisb> I think the idea with these functions is if you need to write ab image or something that you have in memory to a file.
07:12:26 <dennisb> ops
07:13:12 <dennisb> yes, I think hPutChar is probably going to be fast
07:14:01 <Igloo> ISTR seeing PackedString mentioned for efficient IO, but I don't know what functions exist for manipulating them
07:14:46 <Yurik> well, if use hPutChar, how can I convert Int32 to list of chars?
07:15:29 <dennisb> Igloo: there is a lot of functions in http://www.haskell.org/ghc/docs/latest/set/packedstring.html
07:16:25 <dennisb> Yurik: some div and mod perhaps
07:18:26 <dennisb> I would write two small function readInt32 :: IO Int32 and writeInt :: Int32 -> IO ()
07:18:33 <dennisb> writeInt32 even
07:19:03 <dennisb> Is it Int32 or Word32?
07:19:21 <Yurik> Int32, probably
07:20:14 <dennisb> well and I forgot the file handles :-)
07:23:21 <dennisb> an alternative to the div and mod is to use the Bits module and do some shifts and ands.
07:31:49 <Yurik> btw, may be the best way will be write this part of code in C?
07:32:26 <dennisb> Yurik: no, I think it is easy to the conversion
07:32:43 <dennisb> should fit on a single line i think
07:32:53 <Yurik> dennisb but in speed may be C will be faster... 
07:33:11 <dennisb> maybe
07:33:35 <dennisb> I don't know what you are trying to do so what do I know about that
07:33:58 <Yurik> I plan to develop specialized database (non relational)
07:34:32 <Yurik> specialized to store trees
07:44:27 <shapr> cool, two Heffalumps
07:45:29 <dennisb> Yurik: to do really fast databases you might want to use C for the most lowlevel parts
07:45:48 <Yurik> dennisb yes, I think so, too... 
07:45:50 <Heffalum1> sorry, the old one is on my old IP address :-)
07:45:53 <Heffalum1> which I can't use any more
07:46:11 <Yurik> dennisb so initially I want (probably) use C for I/O
07:46:25 <dennisb> Yurik: I converted an Word32 to a 4 byte string that can be outputed, and it became:
07:46:28 <dennisb> f :: Word32 -> [Char]
07:46:28 <dennisb> f n = [b 24 n, b 16 n, b 8 n, b 0 n]
07:46:28 <dennisb>    where b i n = chr $ fromEnum $ (n `shiftR` i) .&. 255
07:46:56 <dennisb> Or I wrote a function that convert
07:46:59 <Yurik> thanks :-)
07:47:16 <dennisb> but there is overhead, and even if the disks are slow it is still overhead
07:48:40 <Yurik> is there any good tutorial of writing C libs for Haskell?
07:49:12 <dennisb> Not really, there is examples of how you call C from haskell, that is usually not so hard
07:49:23 <dennisb> calling haskell from C is harder
07:49:42 <dennisb> but we are short on good tutorials
07:50:48 <dennisb> but normal C-functions with simple types as input and output is just a matter of telling the compiler that they exist and what type
07:52:04 * dennisb thinks it is fun, but have to leave for a while
07:52:43 * shapr waves
09:08:37 <Yurik> re
09:09:36 <shapr> re Yurik!
09:09:44 <Yurik> re
09:29:56 * Heffalump reappears with fixed DNS
10:17:52 <Logan> Bleh, forgot to open my window before I left.
10:57:55 <Logan> What would be a good, concise way to specify a permutation function in haskell?
10:58:02 <Logan> I have one, but I think it's more verbose than it needs to be. :P
10:58:30 <Heffalump> specify, or implement?
10:59:12 <Heffalump> from memory, something like
10:59:20 <Heffalump> inserts :: a -> [a] -> [[a]]
10:59:24 <Heffalump> inserts a [] = [a]
11:00:01 <Heffalump> inserts a bs@(b:bs') = (a:bs):inserts a bs'
11:00:15 <Heffalump> perms :: [a] -> [[a]]
11:00:19 <Heffalump> perms [] = [[]]
11:00:26 <Heffalump> perms (a:as) = insert a (perms as)
11:00:54 <Igloo_> I think this works: p [] = [[]]; p (x:xs) = concat [zipWith (\a b -> a ++ [x] ++ b) (inits ys) (tails ys) | ys <- p xs]
11:01:41 <Heffalump> it ought to. I think mine is nicer :-p
11:01:44 <Logan> Heffalump: I think I did it like you.
11:01:55 <Igloo_> Min is less verbose, though  :-)
11:01:59 <Heffalump> true
11:02:03 <Logan> Yes, Igloo_ answers my question. :P
11:02:09 <Heffalump> hmph.
11:02:11 * Heffalump sulks
11:02:16 <Logan> permute :: [a] -> [[a]]
11:02:17 <Logan> permute [] = []
11:02:17 <Logan> permute [a] = [[a]]
11:02:17 <Logan> permute (x:xs') = permute' [] x xs'
11:02:17 <Logan> permute' :: [a] -> a -> [a] -> [[a]]
11:02:19 <Logan> permute' before x [] = map (x:) $ permute before
11:02:22 <Logan> permute' before x after@(a:after')
11:02:23 <Logan>     =   
11:02:26 <Logan>         (map (x:) $ permute (before ++ after)) ++ permute' (before ++ [x]) a after'
11:02:48 <Igloo_> It has a certain elegance, anyway. although (\a b -> a ++ [x] ++ b) is a bit clumsy
11:03:08 <Logan> I was just curious, noticed in my programming languages textbook today (which has a few pages devoted to haskell) a statement about using list comprehensions to generate permutations (among other things).
11:03:30 <Logan> And was wondering if there were some elegant, simple method that I wasn't thinking of.
11:03:49 <Logan> Now that I understand Igloo_'s method, I sorta like it. :P
11:05:03 <Logan> Except mine gives the permutations in lexicographical order (if the order of the initial list defines the ordering of the elements).
11:09:21 <Logan> How about a convex hull algorithm? :P
11:25:49 <Logan> I keep forgetting how precedence goes in haskell...
11:25:59 <Logan> Is f a + b equivalent to f (a + b) or (f a) + b ?
11:29:37 <Igloo> (f a) + b
11:31:17 <Logan> That's what I thought was more likely, but I wasn't sure.
11:31:45 <Logan> Does anything have higher precedence than function application?
11:32:06 <Heffalump> no
11:32:10 <Heffalump> well, not that I can think of
11:32:27 <Igloo> Parentheses
11:32:30 <Logan> That should save some parentheses from my code. *grin*
11:32:38 <Logan> Heh, I don't typically think of parentheses as operators.
11:32:50 <Heffalump> they aren't
11:33:02 <Heffalump> not according to any sensible definition of operator, anyway
12:03:38 <Logan> Here's a good question...
12:03:44 <Logan> I have a list of points.
12:04:03 <Logan> I'd like to do something sorta like a fold that just sums up the length of the distances between each adjacent pair of points in the list.
12:04:18 <Logan> Any concise way of specifying this?
12:10:56 * Logan wonders what is wrong with this:
12:10:57 <Logan> dist :: Point -> Point -> Double
12:10:57 <Logan> dist = sqrt . dist2
12:11:54 <Heffalump> how about sum (zipWith dist points (tl points))
12:12:37 <Logan> tl?
12:13:10 <Heffalump> umm, tail, sorry
12:14:00 <Logan> Seems like it might work.  I didn't think of it as a zipping problem at all.
12:14:05 <Logan> How about my function composition problem there?
12:14:18 <Logan> dist2 :: Point -> Point -> Double
12:14:23 <Logan> Why can't I define dist as sqrt . dist2 ?
12:15:00 <Heffalump> wrong number of arguments
12:15:24 <Heffalump> . is for functions that take one argument
12:15:48 <Logan> Didn't realize the number of arguments mattered at all.
12:15:55 <Heffalump> look at the definition of .
12:15:58 <Heffalump> it has to matter
12:16:07 <Heffalump> otherwise the effect of . would be ambiguous
12:16:20 <Logan> I suppose it could be.
12:17:34 <Heffalump> not could, would
12:24:45 <Logan> I suck at coding geometric stuff. :P
12:59:43 <Logan> My convex hull algorithm finally works!
13:00:00 <Logan> That's probably the most interesting algorithm I've implemented in haskell so far. :P
13:00:14 <Heffalump> cool :-)
13:00:48 <Logan> And I think it's reasonably efficient too.
14:16:13 <Yurik> anybody alive?
14:16:37 <Logan> Yep.
14:17:00 <Yurik> How can I map using function that return another than list element type?
14:17:15 <Yurik> function is hPutChar
14:17:27 <Logan> You want to apply hPutChar to every element in a list?
14:17:43 <Yurik> yep
14:17:44 <Logan> That's a good question, because I was wondering that myself. :P
14:17:56 <Yurik> or I should use hPutStr?
14:18:11 <Logan> That would solve the problem but not answer the more general question. :P
14:18:38 <Yurik> yeah, it should solve, but the problem is interesting for me :-)
14:19:09 <Logan> I've been running into it several times, processing elements of lists (that aren't just Char lists) for output.
14:22:24 <Igloo> sequence_ it afterwards
14:25:24 <Yurik> does list comprehension function should return elements of the type exact to source list element's type?
14:26:16 <Igloo> No, it returns the type of the left of the |
14:26:50 <Yurik>   f :: Word32 -> [Char] 
14:27:01 <Yurik>     hPutStr fh map(f)[1..32323]    
14:27:13 <Yurik> gives me:
14:27:14 <Yurik>    Couldn't match `IO ()' against `t -> t1'
14:27:14 <Yurik>     Probable cause: `hPutStr' is applied to too many arguments in the call
14:27:16 <Yurik>     In a 'do' expression pattern binding:
14:28:25 <Yurik> I changes hPutStr string to
14:28:34 <Yurik> hPutStr fh (map(f)[1..32323])
14:28:40 <Yurik> but anyway it gives an error
14:28:50 <Yurik> Couldn't match `Char' against `[Char]'
14:40:23 * Yurik is out to smoke
14:45:35 * Yurik is back
14:49:17 <Logan> hPutStr fh map(f)[1..32323] does not do what you want.
14:49:25 <Logan> You want hPutStr fh (map(f)[1..32323])
14:49:35 <Logan> Or hPutStr fh $ map(f)[1..32323] for short.
14:49:54 <Yurik> hPutStr fh (map(f)[1..32323]) doesn't work, too
14:50:03 <Logan> What error does it give?
14:50:19 <Logan> Oh.
14:50:27 <Logan> The result of the map is [[Char]]
14:50:31 <Yurik>  Couldn't match `Char' against `[Char]'
14:50:37 <Logan> What do you want it to do?
14:51:18 <Yurik> I want to apply f on every element of [1..32323], f returns [Char], and pass it to hPutStr
14:52:00 <Logan> You'll have to fold the [[Char]] into a [Char], or map hPutStr onto the [[Char]]
14:52:21 <Yurik> how can I fold [[Char]] to [Char]?
14:55:41 <Logan> One way is: foldl (++) "" list
14:55:54 <Logan> That just concatenates all the elements of list into one big list.
14:56:07 <Logan> Might not be the fastest thing in the world, though.
14:56:10 <Igloo> As does concat
14:56:27 <Logan> Oh, didn't realize there was a concat function.
14:56:55 <Yurik> it works but very slow
14:58:09 * xbill foldl (++) [] is just concat no?
14:58:53 <Igloo> We've done that  :-)
14:59:00 <Logan> I'm not sure if map (\x -> hPutStr fh $ f x) [1..32323] would work.
14:59:12 <Logan> Seems likve I've tried something like that before and failed. :P
14:59:21 <Logan> Especially since it doesn't really make sense.
14:59:31 <Igloo> You'd need sequence_ $ on the front as I said earlier
14:59:36 <dennisb> Yurik: how do you run it? hugs?
14:59:46 * Logan should look up that "sequence_" think.
14:59:48 <Logan> thing
14:59:56 <Yurik> dennisb ghc
15:00:04 <dennisb> good
15:00:10 <Logan> Ah, it's in the tutorial.
15:00:28 <Logan> Heh, I've been doing everything the sequence_ way all along (just not generalized like sequence_ is).
15:00:30 <Logan> Silly me.
15:00:43 <Yurik> so is there any way to speed up?
15:01:19 <nodie> hi
15:01:35 <Yurik> it is painfully slow now :-(
15:01:43 <Logan> Which way are you doing it?
15:02:08 <Yurik>  hPutStr fh (foldl (++)""(map(f)[1..10000])) 
15:02:18 <Logan> Yeah, that way is doomed to be slow.
15:02:25 <Logan> Do what Igloo said...
15:02:32 <Logan> sequence_ $ map (\x -> hPutStr fh $ f x) [1..32323]
15:03:05 <Yurik> oh, it is much more faster! :-)
15:03:29 <Igloo> foldr (++) "" ought to be much faster
15:03:41 <Igloo> Being O(n) rhather than O(n^2)
15:04:10 * Igloo checks - yup, concat uses foldr
15:04:20 <Logan> It turns out sequence_ $ map ((hPutStr fh) . f) [1..32323] is equivalent.
15:04:33 <Logan> I'm still folding my brian around the concept of folding.
15:04:40 <xbill> easy
15:04:49 <Logan> It's simple, but I'm not used to thinking about it.
15:04:53 <Yurik> me is testing on ~12Mb of data output
15:05:50 <Yurik> real1m5.625s
15:06:13 * Yurik is thinking, is it fast or slow to write 12mb of data in ~1min
15:06:32 <Logan> Depends on your OS and hardware. :P
15:06:50 <Logan> On my computer, I can write probably 50 times that much data in a minute.
15:06:52 <Yurik> Linux 2.4 running on Celeron-533
15:07:08 <Logan> I know a few days ago I witnessed C code generating 400 MB of data and saving to a file in 30 seconds.
15:08:51 <Logan> What is your definition of f?  I'd like to try benchmarking it myself. :P
15:09:35 <Yurik>   f :: Word32 -> [Char]                                                           f n = [b 24 n, b 16 n, b 8 n, b 0 n]                                                   where b i n = chr $ fromEnum $ (n `shiftR` i) .&. 255  
15:10:01 <Igloo> Are you using optimisation OOI?
15:10:32 <Logan> Hmm, where is shiftR defined?
15:10:40 <Igloo> Bits
15:11:19 <Yurik> OOI?
15:11:50 <Igloo> Out Of Interest
15:12:00 <Logan> Word32?
15:12:06 <Yurik> Yes, Word32
15:12:20 <Yurik> It is not my function, it is dennisb function :-)
15:12:25 <Logan> Where is Word32 defined?
15:12:29 <Yurik> Word
15:13:59 <Yurik> So is it possible to optimize f?
15:14:27 <Igloo> I mean with -O2
15:15:14 * Yurik is timing with -O2
15:15:18 <Logan> Yeah, code without -O is pretty slow.
15:15:25 <Igloo> OK
15:15:36 <xbill> Bits
15:15:38 <Yurik> is 2 a maximum level of an optimization in ghc/
15:15:40 <Yurik> is 2 a maximum level of an optimization in ghc?
15:16:01 <Yurik> the same result
15:16:42 <Logan> real    0m4.815s
15:16:58 <Yurik> Logan and what is the size of generated file?
15:17:06 <Logan> 12582912
15:17:23 <Logan> Linux, XP 1700+
15:17:31 <Yurik> 1700+ :-)
15:17:34 <Logan> None of this is actually goign to the hard drive, I bet (just being buffered).
15:18:23 <Yurik> what kind of buffering have you used?
15:19:30 <Logan> Just referring to the OS's filesystem.
15:19:56 <Logan> I'm sure 12 MB is smaller than the buffer allocated by the kernel for that device.
15:21:07 <Yurik> so, no kind of buffering you used?
15:21:15 <Logan> I just used the code you gave me. :P
15:21:25 <Yurik> heh :-)
15:21:28 <Logan> Though I didn't use hPutStr, just regular putStr and redirection to a file.
15:21:56 <Yurik> anyway, how should I set up buffering with hSetBuffering?
15:22:34 <Logan> It was actually a little slower with hPutStr.
15:22:36 <Logan> I don't know.
15:22:55 <Yurik> No instance for (Num (Maybe Int))
15:23:08 <Yurik> while I'm trying to ... $ BlockBuffering 4096096
15:23:41 <Logan> You have to use Just.
15:23:48 <Logan> BlockBuffering $ Just 4096096
15:24:06 <Yurik> oh, ok
15:24:15 <Yurik> I'm trying with Nothing now
15:24:15 <Logan> That's the first instance of optional parameters in haskell I've seen.  Didn't know you could do that with Maybe.
15:24:30 <Yurik> it's faster!
15:24:38 <Logan> That's probably same as NoBuffering.
15:24:54 <Yurik> 26 sec
15:26:05 <Yurik> with ~4Mb buffer it works 26 seconds, too
15:26:09 <Logan> 6 seconds with either buffer mode.
15:26:30 <xbill> what are we buffering?
15:26:37 <Logan> Woah, really slow with NoBuffering. :P
15:26:49 <Logan> So setting BlockBuffering to Nothing probably does something else. :P
15:27:09 <Yurik> yes, it made program working faster in ~4 times :-)
15:27:11 <Logan> This is really really slow.
15:27:22 <Logan> It still hasn't finished.
15:27:50 <Yurik> 24 sec now with Nothing
15:28:14 <Logan> I guess it's doing an explicit flush for each call of hPutStr?
15:28:25 <Logan> real    2m0.056s
15:28:36 <Logan> That's a 20x difference.
15:28:57 <Yurik> hSetBuffering fh  $ BlockBuffering Nothing 
15:29:10 <Yurik> 0m24.801s
15:31:01 <Yurik> 0m26.811s with ~4Mb buffer
15:31:35 <Igloo> Nothing is default IIRC
15:31:43 <Yurik> may be :-)
15:33:32 <Yurik> and is there any way to optimize f? :-)
15:34:01 <Igloo> I'm not sure of the GHC internals
15:34:21 <Logan> It'd be nice to get directly at a memory representation of a word. :P
15:34:28 <Yurik> :-))
15:34:38 <Igloo> I can't see an obvious way for you to make it easier for GHC to optimise it, though. You can drop the .&. 255 from the last one of course
15:34:42 <Logan> I wonder if there's work being done on libraries to address that already.
15:34:49 <Igloo> Try profiling it
15:35:10 <Igloo> Logan: In what way does Word32 not give you that?
15:37:19 <Logan> Igloo: Constructing the sequence of bytes that represent the word explicitly seems to be wasteful, unless the compiler can somehow tell that that's what you're doing and optimize it out.
15:37:37 <Logan> In C you'd just cast it to a char * and be done with it. :P
15:38:01 <Igloo> If you want a bytes then use Word8...
15:38:27 <Yurik> but I need numbers more than 8bit
15:38:29 <Yurik> :-)
15:38:44 * Yurik is out for 10 minutes
15:39:51 <Igloo> Oh, ISWYM. That would have to do the shifting and masking anyway, although a library functin would be convenient
15:40:26 <Logan> Well, if you could link a function to some sort of native code, it'd be pretty efficient.
15:40:39 <Logan> Since you just take the internal representation and cast it into a character array.
15:50:41 * PragDave is away: dinner
15:53:45 * Yurik is back
15:59:35 <dennisb> Yurik: I have been reading a little about Storable and Marshaling and this function might help:
15:59:39 <dennisb> hPutWord32 h w = withObject w (\buf -> hPutBuf h buf (sizeOf w))
15:59:59 <dennisb> You need modules Storable and MarshalUtils
16:00:37 <dennisb> it writes one Word at a time without conversion to bytes
16:01:26 <dennisb> the documentation on the ghc web-page seems to be old
16:01:29 <Yurik> is it possible to write a list of Words in the same manner?
16:02:22 <dennisb> maybe no a list, you have to put it in an array first
16:02:41 <dennisb> a list in haskell is a linked list in memory
16:03:25 <dennisb> withArray takes a list of elements, and creates an array for you (it looks like, i have not tried)
16:03:56 <dennisb> (also, the functions have change names, so the doc is a bit off :-)
16:04:08 <Yurik> where withObject and sizeof are defined?
16:04:21 <dennisb> Storable and MarshalUtils
16:05:37 <Yurik> can you provide me with a variant for the list, I'm feeling myself stupid a bit :-)
16:05:40 <Yurik> ?
16:06:10 <dennisb> well, I cant find the withArray just now, they have probably moved it...
16:08:24 <Observer> Hi! Can anyone tell me how to import a module that is not under std? I've tried IArray and GHC could'nt find it :(
16:08:39 <dennisb> -package lang
16:08:44 <dennisb> or some other package
16:08:57 <Observer> You mean -package IArray ?
16:09:06 <dennisb> probably -package lang
16:09:23 <Observer> Oh, yes - the directory, right?
16:10:10 <Observer> Yes. That did it. Thank you!
16:10:42 <Yurik> dennisb I used your hPutWord32 in the manner similar to previous, 14 sec now
16:11:48 <dennisb> something like this:
16:11:49 <dennisb> hPutWords32 h ws = withArray ws (\buf ->
16:11:50 <dennisb>    hPutBuf h buf (sizeOf (1::Word32) * length ws))
16:12:00 <dennisb> but I don't like the length and stuff
16:12:24 <dennisb> also, it's probably not a good idea to convert a 12M linked list into an array just to write it to a file..
16:12:40 <Yurik> dennisb thanks :) btw, previous hPutWords32 can write no only Word32 and it is great :-)
16:12:57 <Yurik> dennisb I've tried your previous function with Word64 and it works in the same time!
16:13:04 <dennisb> but if one have some structs of resonable size it might be a good idea
16:13:26 <dennisb> it should work with every storable type
16:14:07 <dennisb> well, i'm getting to bed, god night
16:15:03 <Yurik> btw, and what is the best way to read it quickly? :-)
16:18:26 <Yurik> or there is no analogue way to read Storables?
16:24:48 * xbill chuckles
16:29:31 <Yurik> dennisb are you here?
16:31:50 <dennisb> i'm back but I'm really getting to bed :-)
16:31:59 <dennisb> of course you can read
16:32:00 <Yurik> pity :-(
16:32:04 <Yurik> hiw can I read?
16:32:22 <Yurik> how can use smthing to do it in "proper" way? hGetBuf? but how? :)
16:32:23 <dennisb> alloc memory, do  hGetBuf
16:33:01 <Yurik> dennisb how can I allock memory?
16:33:04 <Yurik> dennisb how can I alloc memory?
16:33:17 <dennisb> then you do peekElemOff in the memory to get something of the right type
16:33:36 <dennisb> you could use slurpFile that allocs enough for the whole file
16:33:49 <Yurik> can you provide me with very simple example? :-))))
16:34:28 <dennisb> well, not tonight
16:34:40 <dennisb> it's 1.30 and I have to get up tomorrow :-)
16:34:41 <Yurik> ok, good night :)
16:34:47 <Yurik> Wed Jan 30 02:34:45 EET 2002
16:34:48 <Yurik> :-)
16:34:50 <dennisb> but i'm sure xbill can help
16:35:05 <dennisb> this is really c-programming in disguise
16:35:12 <dennisb> (however that is spelled)
16:35:46 <dennisb> (not saying that xbill is not an expert using haskell)
16:36:41 <Yurik> xbill are you here?
16:36:45 * dennisb is gone *poff*
16:37:49 <Yurik> I have
16:37:50 <Yurik>  hPutStorable h v = withObject v (\buf -> hPutBuf h buf (sizeOf v)) 
16:37:51 <Yurik>        hPutStorableL h l = sequence_ $ map (\x -> hPutStorable h x) l
16:37:53 <Yurik> defined
16:38:14 <Yurik> can I make Read functions (at least analgoue for the first Put) in the similar manner?
17:12:24 <Yurik> How can I cast from Ptr to, say, Word32?
17:12:24 <Yurik> 
17:22:31 <Yurik> anybody alive?
18:03:02 <Yurik> dudes, is somebody awake here? ;)
18:03:13 * shapr is trying to sleep
18:03:29 <shapr> you have a question I can help you with?
18:03:47 <Yurik> yes, I have a question :-)
18:04:01 <Yurik>       hGetStorable h s = do                                                                           gdata <- mallocBytes s                                                          hGetBuf h gdata s                                                               return gdata                                  
18:04:15 <Yurik> How can I get data from gdata returned?
18:05:05 <Yurik> gdata is Ptr a
18:05:14 <shapr> I dunno that :)
18:05:16 <shapr> sorry
18:05:20 <Yurik> pity :-(
18:05:36 <shapr> I'd help investigate, but I'm about to fall over asleep
18:05:43 <Yurik> Wed Jan 30 04:05:41 EET 2002
18:05:53 <shapr> yah, exactly
18:06:09 <Yurik> it's strange, but I'm not sleepy :-\ hm 
18:06:12 <shapr> I am
18:06:15 <Yurik> :-))
18:06:27 <shapr> but I got some cool programming done, so I'm happy
18:06:34 <Yurik> hehe, I envy you
18:07:03 <Yurik> I'm trying to get a good portion of hacking haskell code, but stalled on this issue :-( :-)
18:07:11 <shapr> :(
18:07:24 * shapr goes ahead and falls into bed
18:07:27 <shapr> g'nite
18:07:30 <Yurik> g'nite
18:42:32 * PragDave is back (gone 02:51:52)
19:05:37 * Yurik is back
19:05:42 <Yurik> anybody alive, dudes?
19:05:45 <yusri> me
19:06:02 <Yurik> yusri are you experienced in Haskell?
19:06:05 <zorb> yep
19:06:10 <Yurik> can you consult me?
19:06:17 <zorb> uh.
19:06:18 <yusri> no, I'm not =)
19:06:42 <Yurik> I have
19:06:43 <Yurik>       hGetStorable h s = do                                                                           gdata <- mallocBytes s                                                          hGetBuf h gdata s                                                               return gdata  
19:06:50 <zorb> Yurik, my guess is I may be experienced enough to answer your question :)
19:07:07 * yusri nods at zorb
19:07:12 <Yurik> that returns gdata (Ptr) and I want to get it back to usual Storable (in my case it is Word32)
19:07:39 <zorb> me retreats!
19:07:41 <Yurik> or I want some correction on this function to make it better :-)
19:07:44 * zorb rahter
19:08:33 <zorb> well, I always wanted to learn deeper knowledge about some of this stuff.
19:09:23 <zorb> btw, next type you past that you might consider using {statment;statment;etc} format.
19:09:30 <zorb> s/past/paste/
19:09:44 <zorb> or rather paste anything like that.
19:13:43 * xbill wonders what?
19:13:52 <xbill> Ptr stuff?
19:14:04 <Yurik> xbill yep
19:14:20 <Yurik> xbill currently I'm trying to deref via StablePtr but got no success :-(
19:15:35 <Yurik> castPtrToStablePtr :: Ptr ()      -> StablePtr a
19:15:43 <Yurik> deRefStablePtr     :: StablePtr a -> IO a
19:16:13 <Yurik> and trying to say (returned-from-deRef :: Word32) and it fails at compilation
19:16:31 <zorb> Yurik: does this has something to do with wanting to read C binary 32 bit words ultimately?
19:16:47 <zorb> or your attempt at using Storable and StablePtr etc?
19:17:06 * zorb scaned through the logs.
19:17:10 <Yurik> zorb no, I do not use C, only Haskell; but yep I want to read 32 bit words
19:17:36 <zorb> eh. whatever you want to call 'em
19:17:47 <zorb> alright.
19:17:47 <Yurik> xbill no ideas?
19:19:09 <zorb> file:///C:/ghc/ghc-5.02.1/doc/user-guide/sec-marshalutils.html apparently if anybody else wants to tackle this.
19:19:12 <zorb> oops
19:19:26 <zorb> ok thats not it :)
19:19:43 * zorb forgot that was a local file
19:20:05 <Yurik> zorb :-)
19:20:10 <Yurik> I read it recently
19:21:52 <Yurik> so... any ideas, guys?
19:22:15 <zorb> not yet.
19:27:36 <Yurik> if deRef returns IO a, can 'a' be extracted?
19:28:04 <zorb> y<-deRef .... ?
19:28:27 <zorb> within a do construct
19:28:29 <Yurik> y is 'IO a' at this moment... :-(
19:30:00 <zorb> Prelude> let x = do {print "whooo"; return 3} in do {y <- x; print y}
19:30:01 <zorb> "whooo"
19:30:01 <zorb> 3
19:30:30 <zorb> that answer your question? :)
19:30:34 <Yurik> but it is return 3, and I return deRef now
19:30:53 <Yurik>  return $ deRefStablePtr $ castPtrToStablePtr gdata
19:32:03 <Yurik> and it is 'IO a'. Does this 'a' contains dereferenced value? 
19:32:25 <zorb> as far as I understand the IO monad, yes.
19:32:35 <Yurik> how can I access 'a'?
19:33:05 <zorb> take a look at my example again.
19:33:45 * Yurik is looking again.. heh, missed 'in'...
19:38:27 <zorb> hmm.. what's going on?
19:39:33 <Yurik> trying to apply it
19:40:47 <zorb> ok, deRefStablePtr and friends are in... ?
19:40:56 <zorb> (module wise)
19:41:18 <Yurik> StablePtr
19:41:23 <Yurik> and Ptr
19:52:23 * Yurik is back
19:53:58 <Yurik> so, any ideas? :-))
19:54:24 <Yurik> (how to apply it to my case?)
19:55:40 <Yurik> pHa_ hi
20:03:06 <zorb> well, i just messed with peeking an poking at a value... but I havent manipulated it in bytes yet..
20:06:03 <Yurik> I've tried to peek too, but got no results :-(
20:06:12 <zorb> alrighty.
20:06:57 <zorb> say you've got um all these modules imported.
20:07:04 <zorb> >import MarshalUtils
20:07:05 <zorb> >import MarshalAlloc
20:07:05 <zorb> >import Word
20:07:05 <zorb> >import StablePtr
20:07:05 <zorb> >import Storable
20:07:28 <zorb> im not sure that all are needed for this little exercise.
20:08:11 <zorb> you can allocate a value with new
20:08:34 <zorb> and then peek an poke at it basically.
20:09:59 <Yurik> i'll try
20:10:06 * xbill oohs
20:10:11 <xbill> MarshalUtils
20:11:05 <Yurik> xbill can you suggest something else? What will be the best way to read Storable from file and pass it back?
20:16:17 <xbill> no idea 
20:16:27 <xbill> haskell didn't have it when last I wrote in it
20:31:40 <zorb> hmmm. something to think about i guess.
20:32:04 <Yurik> yeah...
20:32:21 <zorb> >main = do x<-new(3::Word32);
20:32:22 <zorb> >          y<-peek x;
20:32:22 <zorb> >          print y
20:32:22 <zorb> >          (z :: Word8) <-peekByteOff ((castPtr x) ::Ptr Word8) 2;
20:32:22 <zorb> >          print z
20:32:31 <zorb> I did get that to work.
20:32:48 <zorb> dont know why z had to have a type.
20:33:41 <zorb> x, newptr to Word32
20:33:58 <Yurik> will it work with hGetBuf?..
20:34:42 <zorb> you'll have to remind me of where that is as well :(
20:35:00 <zorb> hGetBuf
20:35:17 <zorb> then i can get the type information I need.
20:35:44 <zorb> (cause frankly this'll be the first time i've ever used hGetBuf)
20:37:37 <zorb> nevermind. found it.
20:37:44 <zorb> IOExts
20:41:17 * Yurik feels him very stupid
20:41:49 * xbill ?
20:41:57 * Yurik feels himself very stupid
20:44:14 <zorb> no.
20:44:47 * Yurik reads more docs
20:46:58 * zorb feels like puking.
20:47:15 <zorb> in the docs they mention type of hGetBuf as..
20:47:49 <zorb> (let me find it..!)
20:47:55 <Yurik> IO Int
20:48:06 * xbill sighs.
20:48:14 <zorb>  hGetBuf       :: Handle -> Addr -> Int -> IO Int
20:48:19 <Yurik> I suppose that hGetBuf writes read data to Addr
20:48:32 <zorb> but the real meaning of Addr is Ptr a
20:48:36 <Yurik> Int is as size to read, IO Int - IO and actual number of elements read
20:48:41 <zorb> unless I missed something.
20:48:46 <Yurik> yep, Addr is Ptr a
20:49:49 <zorb> ok, looks like we're very close.
20:50:30 <Yurik> yepp... but see. I have function hGetStorable f s (where f is file handle, s is size to read, right?)
20:50:35 <zorb> ah.
20:50:43 <Yurik> hGetStorable is my own func
20:51:09 <Yurik> and I would like it to read data and return it to me...
20:51:31 <zorb> let me write up something real (well, not to fast) quick.
20:51:52 <zorb> yeah
20:51:58 <Yurik> I tried to do something like this:
20:51:59 <Yurik>       hGetStorable h s = do                                                                           gdata <- new s                                                                  hGetBuf h gdata s                                                               return gdata    
20:52:16 <Yurik> sorry for the formatting, i'm too lazy to edit it :-)
20:52:21 <Yurik> :-))
20:52:23 <zorb> heh
20:52:33 <Yurik> I just changed mallocBytes to new
20:52:33 <zorb> so what does it complain?
20:52:48 <Yurik> it compiles, but I can't compile another module that use it
20:53:09 <zorb> ok..
20:53:22 <zorb> so lets go through this step by step.
20:53:32 <zorb> um.
20:54:22 <zorb> what is the error from your attempt to compiler another module that uses it.?
20:54:27 <Yurik> Couldn't match `Word32' against `Int'
20:54:33 <zorb> bingo.
20:54:38 <Yurik> In the second argument of `hGetStorable', namely `(4 :: Word32)'
20:55:03 <zorb> um...
20:56:35 <zorb> have you tried loading the module from ghci and :type(ing) hGetStorable?
20:57:07 <Yurik> nope
20:58:41 * zorb ponders . o O (I would have thought hGetStorable would be polymorphic in s.. but what if somehow it isnt?)
20:59:09 <Yurik> it should return Ptr a
21:02:38 <zorb> Main> :type hGetStorable
21:02:39 <zorb> PrelIOBase.Handle -> Int -> IO (Ptr Int)
21:02:44 <zorb> hmmm. nope
21:04:38 <zorb> doh!
21:04:51 <zorb> no wonder.
21:05:22 <zorb> ;hGetBuf h gdata s  <-notice the last argument.
21:05:34 <zorb> what you need is ah...
21:05:39 <Yurik> is it size?
21:05:48 <zorb> i found a sizeOf function somewhere.
21:06:08 <zorb> (perhaps sizeOf gdata or something??)
21:06:23 <Yurik> how should I initialize gdata?
21:07:42 <zorb> hGetBuf x ptrthingy num .... it reads from handle x into whatever is refered by ptrthingy num bytes (from my guestimation)
21:08:14 <Yurik> but we ought to initialize ptrthingy, right?
21:09:20 <zorb> well, yeah. thats what you do with new.
21:10:00 <zorb> (btw, before i forget, that thing with new might need deallocation, but we'll hold that off until later.)
21:10:11 <Yurik> what arguments should be supplied to new?
21:10:41 <zorb> well, something of whatever type you want.
21:11:17 <zorb> a default value I guess.
21:11:45 <Yurik> and what should I do to get the value?
21:11:48 * xbill sighs.
21:12:14 <Yurik> return buf returns pointer..
21:12:36 <zorb> >hGetStorable h s = do gdata <- new s ;hGetBuf h gdata (sizeOf gdata) ; return gdata  
21:14:04 <Yurik> can you show an example usage of hGetStorable?
21:14:25 <zorb> xbill, I hate to say this but right now you are probably in better financial position than me so quit sighing :)
21:15:07 <zorb> hmmm.
21:15:24 <Yurik> I use
21:15:25 <Yurik>   dat <- hGetStorable fh (4 :: Word32) 
21:15:34 <zorb> that looks tood.
21:15:34 <Yurik> hPutStorable fh dat 
21:15:37 <zorb> good rather.
21:15:55 <zorb> yeah!
21:15:55 <Yurik> and that puts not the value that should be, but seems that address
21:16:38 <zorb> hmm. so lets look at hPutStorable
21:17:21 <zorb> (I dont believe you pasted that function)
21:17:28 <zorb> of yours
21:17:42 <Yurik> hPutStorable works (I tested it) but I can show it, course:
21:17:57 <Yurik> hPutStorable h v = withObject v (\buf -> hPutBuf h buf (sizeOf v))
21:19:13 * zorb wonders why withObject was used.
21:19:41 <zorb> excuse me. why you used withObject.
21:19:42 <Yurik> for the performance needs :-) It is a function suggested by dennisb 
21:19:50 <zorb> ah cool then :)
21:21:09 <zorb> hmm.
21:21:38 <Yurik> I can dcc send you a zip file with my two modules and let you compare source and dest files...
21:22:02 <zorb> alright.
21:22:50 <Yurik> just run and compare source journal with dest journal.1 :-)
21:27:01 <Yurik> zorb have you got it?
21:28:41 <zorb> yeah, jsut cleaning thigns up a bit (dos machine ya know?)
21:29:32 * xbill chuckles
21:34:15 <zorb> alright..
21:34:36 <zorb> I decided to do away with withObject whatever and a typing error came up..
21:34:50 <zorb> then i look at your code and it has...
21:35:07 <zorb> hPutStorable fh (255 :: Word32)
21:35:19 <zorb> but that needs to be a Ptr Word32 !
21:35:44 <zorb> so to modify your code a bit...
21:37:00 <zorb> and look at results..
21:37:13 * zorb tries to remember what results should be!
21:37:54 <Yurik> No instance for (Num (Ptr Word32))
21:38:16 * zorb scratches head.
21:38:23 <zorb> i didnt have that problem.
21:38:26 <zorb> but um..
21:38:38 <Yurik> hPutStorable fh (255 :: Ptr Word32)
21:38:39 <Yurik> right?
21:38:44 <zorb> nope.
21:39:09 <zorb> i did q<-new (255::Word32)
21:39:17 <zorb> then hPutStorable fh q
21:40:15 <Yurik> values are different :-)
21:40:33 <Yurik> or I need to change more?
21:41:01 <zorb> well, did you redo hPutStorable?
21:41:36 <zorb> right now im rewriting main so that i may "peek" at the value gotten from the journal file.
21:41:49 <zorb> (or adding a line or two rather)
21:42:25 * xbill chuckles
21:42:42 <Yurik> well, when you really get it working, can you send it back to me? to be in right synch :-)
21:43:19 <zorb> sure
21:44:57 * Yurik is out for 5 minutes...
21:45:46 <zorb> hee!
21:49:00 * zorb cancels sending files realizing they're in dos format... converting back to unix
21:49:42 <xbill> DOS blows
21:50:01 * Yurik is back
21:50:21 <juhp> what are you guys up to?
21:50:27 * juhp curious
21:50:35 <Yurik> juhp hi
21:50:35 <xbill> Nuking Redmond, WA
21:50:40 <zorb> reading and writing raw binary data.
21:50:48 <juhp> xbill: ;)
21:50:53 <zorb> but they pay SPJ!
21:51:01 <Yurik> zorb so, you have something to send me back? :-)
21:51:03 <juhp> ;)
21:51:08 <zorb> yeah jsut a sec
21:51:14 <xbill> Redmond delenda est
21:51:43 <zorb> oh right.
21:51:49 <juhp> binary IO?
21:51:51 <juhp> what for?
21:51:59 <Yurik> juhp I need it :)
21:52:32 * Yurik is drinking mineral water...
21:53:40 * zorb coughs to Yurik
21:53:43 <juhp> for a secret project? :)
21:53:53 <Yurik> Connection refused
21:53:57 <zorb> grrr.
21:54:11 <Yurik> can you send it by mail? yrashk@telcos.net.ua :-)
21:54:24 <zorb> ok.
21:54:29 <Yurik> juhp nope, for the public opensource project :-)
21:55:31 <juhp> Yurik: cool
21:56:04 * Yurik is wondering why simple binary I/O is not a regular part of Haskell
21:56:14 <juhp> not trying to be nosy, was just wondering what you're planning to do with it?
21:56:26 <Yurik> juhp with binary I/O?
21:57:16 <Yurik> juhp just fill system's elementary operations journal. it is an important point of the system
21:58:00 <juhp> is it a DB?
21:58:29 <Yurik> juhp kind of, probably..
21:58:34 * zorb ponders how long it'll take to get there.
21:58:46 <xbill> a while
21:59:07 <zorb> heh. i meant the email :)
21:59:09 <Yurik> zorb got it
22:00:20 <Yurik> hm, works :-)
22:00:29 * zorb cheers
22:00:41 <Yurik> zorb thank you, dude! :-))
22:00:58 <zorb> no prob.
22:01:12 <Yurik> zorb btw, will it be possible to hGetStorable list of numbers? :-)
22:01:24 <Yurik> zorb It got ~6 hours to get this working :-)
22:01:59 <Yurik> zorb just get [Word32], right?
22:02:06 <Yurik> zorb of certain size
22:02:12 <zorb> hmm?
22:03:05 <Yurik> kinda dat <- hGetStorable fh ([1..100] :: [Word32])
22:03:06 <Yurik> eh?
22:03:37 <zorb> probably something like your hPutstorableL
22:04:09 <zorb> except ah..
22:04:44 <zorb> hmm.
22:05:58 <zorb> anyway, you might want something more lower level to get a whole batch of them.
22:07:37 <zorb> like use hGetBuf to read some integer multiple of 4 (or sizeOf whatever) into some memory pre-allocated. etc.
22:07:50 * zorb goes back into the manual
22:09:43 <zorb> ah, you could perhaps use mallocBytes and give the right type somewhere.
22:09:50 <zorb> im thinking of..
22:10:28 <zorb> oh wait i think i thought of another function that might be better suited
22:13:16 * zorb imagines his head contracting some weird form hydrocephilitis and exploding all over his room.
22:13:57 <zorb> to much information for one night and I need to sleep :)
22:15:07 <zorb> (eh water on the brain causing brain to explode or something what the gist of my strange joke but i probably misnamed the disease or something)
22:16:30 <zorb> hmm noone here.
22:17:23 <zorb> ok then. later channel. Yurik, hope you figure out some more binary IO stuff for me to read in the logs tomorrow :)
22:18:44 <Yurik> yes, it seems more complex. I hope I willn't need this
22:18:44 * Yurik needs to remove few stains from the table... coffee... juice :-)
22:18:44 * Yurik used charwoman to do it :-)
22:18:44 * Yurik is too lazy
22:19:00 * Yurik is out for few minutes...
22:20:28 <Yurik> re
22:20:37 <Yurik> connection was broked. probably I missed something?
22:42:42 <dennisb> god morning
22:44:04 <dennisb> I see you have been busy all night!
22:55:49 <dennisb> Yurik: Something like this is probably what you want:
22:55:53 <dennisb> hGetStorable h = do
22:55:53 <dennisb>    v <- malloc
22:55:53 <dennisb>    hGetBuf h v (sizeOf v)
22:55:53 <dennisb>    res <- peek v
22:55:53 <dennisb>    free v
22:55:54 <dennisb>    return res
22:56:14 * xbill whoas
22:56:42 <dennisb> But the alloc and free does not sound optimal. If you can read a whole record or something you can do one malloc and then peek with an offset
22:58:23 <Yurik> dennisb re
22:58:27 <dennisb> The type of the function is:
22:58:30 <dennisb> hGetStorable :: (Storable a) => Handle -> IO a
22:59:12 <dennisb> and don't say you can't do imperative programming in haskell :-)
22:59:23 <Yurik> dennisb re
23:00:34 * xbill I'd rather stick to functional programming with bananas, lenses, envelopes, and barbed wire.
23:00:55 * dennisb have read that paper
23:14:26 * Yurik is back
23:28:27 <Yurik> how can I construct a list of new(<Num> :: <Type>) values?
23:28:32 <Yurik> new is from MarshalUtils
23:33:00 <dennisb> I think you need to learn about IO in general. do-notation and such. Do you know what the type (IO Int) is?
23:33:43 <Yurik> Well, nope :-)
23:33:50 <dennisb> and how you can sequence operations
23:34:23 <dennisb> well, that is what you should start looking at, read a little about the normal IO system. And the rest will be much easier
23:34:38 <Yurik> where is a good article(s) on this issue?
23:35:07 <dennisb> an IO Int is a type for an expression that is an action, when you start the action it will do something with the IO and return an Int
23:35:30 <dennisb> Yurik: I don't know directly, any haskell book should have a chapter or two
23:35:44 <dennisb> but i'm sure there is something to be found from www.haskell.org
23:36:36 <dennisb> (the word action is not something that is defined in haskell, it's just a way to explain)
23:36:47 <juhp> Yurik: had you read "The Gentle Introduction to Haskell"?
23:36:53 <Yurik> juhp yep
23:36:59 <Yurik> juhp but may be forgot something
23:37:01 <juhp> thought so
23:37:24 <juhp> it does cover some IO, but not in so much detail
23:37:57 <Yurik> well,
23:38:00 <Yurik> q <- [new (1 :: Word32), new (2 :: Word32)]
23:38:11 <Yurik> It says that it infers [t1] but I passed IO t
23:38:37 <juhp> there are some nice lectures by SJP: "Tackling the Akward Squad" 
23:38:44 <Yurik> I don't understand why :-)
23:40:27 <juhp> (on IO, threads and one more topic, what was it?)
23:41:01 <juhp> Yurik: why do you want to do that?
23:41:16 <Yurik> juhp I want to construct a list of values to be written :-)
23:43:36 <juhp> what's wrong with [1,2] :: [Word32]
23:43:37 <juhp> ?
23:43:59 <Yurik> zorb made it so
23:44:55 <Yurik> I can easily return to the previous, that have used just [1,2] lists
23:45:18 <juhp> without the code it's hard to help, but basically what dennisb says
23:45:33 <Yurik> but I don't know how to write Get functions in this case..
23:46:17 <dennisb> You already have functions for reading and writing values in the class Storable
23:46:56 <dennisb> if you want to write 5 Word32's then call hPutStorable 5 times
23:47:15 <Yurik> I have yours hPutStorableL :-)
23:47:25 <dennisb> if you hava a list to store, you traverse the list and writes every value
23:47:32 <dennisb> yes
23:48:08 <dennisb> if you want to read a list you have to know the length (or read to EOF) and read as many times and put it in a list
23:49:23 <Yurik>       hPutStorable h v = withObject v (\buf -> hPutBuf h buf (sizeOf v))              hPutStorableL h l = sequence_ $ map (\x -> hPutStorable h x) l   
23:49:36 <Yurik> that is what I have now :-)
23:50:26 <dennisb> But you must become familiar with IO a, and such. It is not going to work very well otherwise. It's not that hard, but it helps to read about it since it's not the normal imperative view
23:50:41 <Yurik> well, I suppose I pester you. Sorry, I'll try to do it by myself...
23:50:43 <dennisb> yes, the problem with the list version is that you don't know the length of the list
23:51:00 <dennisb> no problem, I just cant solve every part :-)
23:51:22 <dennisb> when you want to read the list back from the file, how do you know where the end of the list is?
23:51:37 <Yurik> dennisb let assume we know the length of list
23:52:09 <Yurik> dennisb so get function for list will have an agrument (length)
23:52:11 <dennisb> so you might store the length in the file or something. But the function that reads a list needs to know hom many elements
23:52:18 <dennisb> how even
23:52:20 <Yurik> dennisb but, anyway, I want to read even one value, and can't
23:52:27 * xbill sighs.
23:52:35 <Yurik> I'll store, it is not a problem now
23:52:36 <dennisb> hGetStorable :: (Storable a) => Handle -> IO a
23:52:36 <dennisb> hGetStorable h = do
23:52:36 <dennisb>    v <- malloc
23:52:36 <dennisb>    hGetBuf h v (sizeOf v)
23:52:36 <dennisb>    res <- peek v
23:52:37 <dennisb>    free v
23:52:39 <dennisb>    return res
23:52:43 <dennisb> this reads one value
23:53:19 <dennisb> main = do
23:53:19 <dennisb>   h <- openFile "bar" ReadMode
23:53:19 <dennisb>   w <- hGetStorable2 h
23:53:19 <dennisb>   print (w::Word32)
23:53:19 <dennisb>   return ()
23:53:38 <dennisb> hGetStorable
23:53:42 <dennisb> not hGetStorable2
23:54:04 <dennisb> I rewrote hGetStorable just for fun
23:54:10 <dennisb> createWith :: Storable a => (Ptr a -> IO a) -> IO a
23:54:10 <dennisb> createWith f = do 
23:54:10 <dennisb>    v <- malloc
23:54:10 <dennisb>    res <- f v
23:54:10 <dennisb>    free v
23:54:11 <dennisb>    return res
23:54:12 <dennisb> hGetStorable2 :: (Storable a) => Handle -> IO a
23:54:15 <dennisb> hGetStorable2 h = createWith (\buf -> hGetBuf h buf (sizeOf buf) >> peek buf)
23:54:38 <dennisb> to match the PutStorable that uses withObject
23:55:33 <Yurik> and
23:55:34 <Yurik>   return res
23:55:34 <Yurik> right?
23:55:42 <dennisb> where ?
23:56:02 <dennisb> I think what I write should work, but there might be something forgotten
23:57:56 <Yurik> well, so it will read one value, right?
23:58:00 <dennisb> yes
23:58:13 <dennisb> of type Word32
23:58:25 <dennisb> (the main example above)
