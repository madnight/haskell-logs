02:59:49 <jewel> if YouSay = "Vb sucks" then youwrong = true
03:01:32 <xbill> what's good about vb?
03:03:02 <shapr> vb is easy to make GUIs with
03:03:13 <shapr> the language is not conducive to good programming habits though
04:24:34 <jewel> The type system scares me
04:25:54 * jewel wonders what a good project would be for a yellow belt
04:34:09 <shapr> oh, good question
04:34:15 <shapr> hey, we need to come up with a system for belt colors
04:34:18 <shapr> or I need to ):
04:34:20 <shapr> :)
04:34:24 <shapr> oops, mis-smile
04:35:50 <shapr> ok...
04:36:03 <shapr> white belt is where you get any kind of program to work in Haskell, even helloworld
04:36:20 <shapr> yellow belt is where you write a small program of your own and it works
04:36:28 <shapr> I guess my Mandelbrot.hs is sufficient
04:36:42 <jewel> Well then you'll have to change the topic
04:36:46 <shapr> yah, I agree
04:36:54 <jewel> What's a good project for orange then?
04:37:10 --- topic: set to 'Functional Programming, that's the opposite of Dysfunctional Programming (like VB) | we be loggin' http://tunes.org/~nef/logs/haskell/ | welcome to the Haskell Dojo | jewel and julien are up to white belt! shapr is up to yellow belt!' by shapr
04:37:13 <shapr> oh
04:37:14 <shapr> hmm
04:37:19 <shapr> are you up to yellow belt also?
04:37:54 <shapr> btw
04:37:58 <shapr> what are all the belts?
04:38:07 <shapr> white, yellow, orange, ... black
04:38:16 <Heffalump> isn't your Mandelbrot.hs fairly complicated, in the way it uses type classes and stuff?
04:38:22 <shapr> er, hm.
04:38:25 <shapr> yah, now it is
04:38:28 <shapr> it wasn't before
04:38:50 <shapr> I added type class support because Luke wanted to Show a MandelData
04:38:59 <shapr> that might qualify as orange belt... maybe
04:40:04 <shapr> I'd say creating your own datatypes and using typeclasses could be called orange belt
04:40:35 <shapr> but in that case I'd say being proficient with one of several things could be sufficient
04:40:39 <shapr> not just typeclasses
04:43:02 <shapr> I guess Monad proficiency would be black belt :)
04:43:14 <shapr> and input/output proficiency would be brown belt
04:43:20 <shapr> or whatever is below black
04:43:52 <shapr> is the haskell wiki down?
04:44:15 <Heffalump> there's quite a bit more complicated stuff than Monads, but once you've got to that stage you're doing pretty well generally
04:44:30 <shapr> like arrows?
04:44:44 <shapr> monads as brown belt then? and arrows as black belt?
04:44:59 <Heffalump> arrows are fairly specialised, they're not in common use yet
04:45:09 <shapr> oh
04:45:23 <shapr> what's more complicated than Monads and less than arrows?
04:45:29 <jewel> yeah I think I'm yellow belt too
04:45:37 <Heffalump> I reckon Monads for black belt makes sense; you just have to recognise that there's more stuff you can learn once you get to Black belt
04:45:47 <Heffalump> but in a sense your "apprenticeship" is over
04:45:48 <jewel> It depends on the system, but you usually have about 10 kyu
04:46:00 --- topic: set to 'Functional Programming, that's the opposite of Dysfunctional Programming (like VB) | we be loggin' http://tunes.org/~nef/logs/haskell/ | welcome to the Haskell Dojo | julien is up to white belt! jewel and shapr are up to yellow belt!' by shapr
04:46:28 <jewel> white, yellow, orange, green, blue, brown, black is common (with purple and variations on each belt making up the rest)
04:46:42 <shapr> cool, sounds like a good system to go with.
04:47:08 <jewel> Are you going to make a wiki page for the gradings?
04:47:11 <shapr> yup
04:47:15 <shapr> if I can get to the haskell wiki
04:47:33 <shapr> can you?
04:47:48 <shapr> I can't seem to get to sf.net either
04:47:49 <shapr> :(
04:48:08 <shapr> I may need to restart gnome
04:49:12 <jewel> me neither
04:50:12 <jewel> working now
04:50:42 * shapr goes back to working also
05:07:56 <shapr> http://haskell.org/wiki/wiki?HaskellIrcChannel
05:07:58 <shapr> ok, it's up
05:22:50 <Heffalump> you might want to have datatype and type aliases as Orange, and type classes as green
05:23:20 <shapr> Heffalump: it's wiki, change it ;)
05:23:36 <shapr> I opine that you know better than I do
05:24:44 <jewel> what are datatype and type aliases, what would be an example of their use?
05:26:33 <shapr> I just added some to Mandelbrot-0.2.hs
05:27:31 <shapr> http://kungens.kemi.fi/~shae/Mandelbrot-0.2.hs
05:28:26 <shapr> see the line of code that has "instance" in it
05:29:31 <shapr> haskell type classes are much like Java Interfaces
05:30:15 <shapr> some examples are Eq (for equality testing) Ord (ordered types) and Show (for getting a text represenation of a type)
05:33:49 <shapr> last week Luke_ tried to play with Mandelbrot interactively, but the type alias MandelData was not an instance of Show
05:38:11 <jewel> Ok, that's not hard
05:38:19 <jewel> I thought your mandelbrot used a GUI
05:39:11 <shapr> nah, I wish :)
05:40:56 <shapr> I'd like to use gtk, but debian doesn't have it by default, and building ghc with gtk support is not simple
05:46:15 <jewel> it can't be dynamically linked?
05:46:45 <shapr> hi LoganH 
05:46:48 <LoganH> Hello.
05:46:49 <shapr> jewel: I don't know.
05:46:55 <shapr> I'd like to though.
05:46:56 <LoganH> I'm trying to learn haskell.
05:47:08 <shapr> you've come to the right place.
05:47:12 <shapr> this and #loty
05:47:13 <LoganH> How might I transform a string containing whitespace-delimited integers to a list of integers?
05:47:41 <shapr> er, readInt ?
05:48:02 <shapr> I think it's read("1") :: Int
05:48:07 <shapr> or something really close to that
05:48:18 <shapr> you'll probably want to split the string first
05:49:05 <shapr> if you want to join a group of people who are learning Haskell: http://pragmaticprogrammer.com/loty
05:49:06 <LoganH> Yeah, the splitting is what I don't know how to do (easily).
05:49:08 <shapr> check that website
05:49:27 <shapr> one of the Prelude's List functions does that simply
05:49:31 <jewel> luckily splitting has been well discussed :-)
05:49:38 <shapr> yah, very well discussed
05:49:47 <shapr> I wrote one, PragDave wrote one,
05:49:52 <shapr> and there's one in the standard lib
05:50:12 <LoganH> I guess I chose a good year to learn Haskell.
05:50:14 <shapr> http://haskell.org/onlinelibrary/
05:50:17 <shapr> I agree!
05:50:44 <LoganH> The documentation on haskell.org has little in the way of examples, and I can only glean so much about what a function does by the types it operates on and returns.
05:50:52 <shapr> if you check the List module of the onlinelibrary, you'll see many useful things
05:50:58 <shapr> yah, I agree with you there
05:51:14 <shapr> there's also YetAnotherHaskellTutorial starting up at the same time
05:51:52 <shapr> the #loty and YAHT people are going to work together, and hopefully end up with an excellent tutorial, and some programmers with excellent knowledge of Haskell
05:52:42 <LoganH> I thought a good way to dive in and learn it is to try some simple problems from ACM contests (where you're normally expected to solve it in C).
05:52:49 <jewel> an unfoldr there
05:52:55 <LoganH> I find the solving part is sometimes very nice, but the I/O I can't do yet.
05:53:11 <shapr> yah, IO is challenging because of referential transparency
05:54:02 <shapr> hey jewel, I emailed the LL1 guy about Joy, and he said that FP is very powerful, but that he finds Haskell too difficult to "grok"
05:54:10 <shapr> I replied and told him about #loty ;)
05:54:41 <jewel> hehe
05:55:55 <shapr> I can understand that it's more fun and easier to learn stuff with others, but I don't think anything is too complicated or too esoteric to learn.
05:57:11 <jewel> It's purely a matter of changing old habits and thinking a bit differently
05:57:34 <shapr> yah, I agree
05:58:33 <shapr> he also said what you figured out about that thread, that they would like to give optimization information to the compiler in the source
05:59:40 <jewel> I didn't say that
05:59:42 <LoganH> Where has this splitting "been well discussed"?
05:59:54 <jewel> heh, just locally
06:00:02 <LoganH> No archive for me to look at? :P
06:00:08 <shapr> yes, there is :)
06:00:16 <shapr> the channel topic has the url for logging
06:00:33 <LoganH> Good point.
06:01:00 <shapr> I don't know which day had the splitting discussion
06:02:27 * Heffalump reappears
06:02:35 * shapr gasps
06:02:41 <LoganH> Was it referred to as the splitting discussion?
06:02:43 <Heffalump> and edits the page as suggested :-)
06:03:27 <jewel> which channel was it?
06:04:03 <shapr> I think part or all of it was here on #haskell
06:04:11 <shapr> oh wait
06:04:16 <shapr> maybe it happened on #loty
06:04:22 <shapr> in which case, it wasn't logged :(
06:06:23 <LoganH> I found a little discussion.
06:06:26 <LoganH> wget + grep :P
06:06:55 <shapr> good method
06:08:21 <LoganH> Now I know to look in PreludeList, which has a lot of stuff I didn't notice before.
06:09:47 <shapr> yah, it's handy
06:09:55 <shapr> we have all kinds of good advice here.
06:11:23 <jewel> I have the #loty from friday till now
06:11:48 <shapr> oh, good
06:12:02 <shapr> I should ask nef to get clog over there
06:13:47 <jewel> LoganH: you want it? there's a lot of idle chatter in there too
06:14:19 * shapr is the primary guilty party in that case ;)
06:20:08 <LoganH> jewel: Sure.
06:20:25 <LoganH> How do I make a non-IO something into an IO something?
06:20:46 <shapr> you should ask one of the black belts about that.
06:20:53 <Heffalump> return
06:21:16 <LoganH> Like, I have an Int and an IO [Int], and I want to add that Int to the head of that IO [Int]
06:21:31 <Heffalump> f x ioxs = do xs <- ioxs
06:21:39 <LoganH> So like return x : y ?
06:21:40 <Heffalump>               return (x:xs)
06:22:04 <Heffalump> does that make sense?
06:22:08 <LoganH> Yeah.
06:22:28 <LoganH> Is there a more concice way of doing it?
06:22:32 <Heffalump> umm
06:22:54 <Heffalump> possibly, but do you want your code to be readable?
06:23:09 <shapr> LoganH: are you a former Perl programmer? ;)
06:23:19 <LoganH> Sometimes... :P
06:23:23 <shapr> aha!
06:23:58 <LoganH> This would be easier if I knew how to just temporarily hold a value in a variable. :P
06:24:10 <Heffalump> that's what the "xs <- ioxs" does, roughly
06:24:22 <Heffalump> liftM (x:) ioxs
06:24:29 <Heffalump> is more concise, btw
06:24:47 <shapr> and looks scary
06:24:48 <Heffalump> but you'll need to "import Monad"
06:24:58 <Heffalump> shapr: hence my comment about "more readable" above :-)
06:25:13 <Heffalump> shapr: actually, if you read the definition of liftM it's just a more general form of my code above
06:25:27 <shapr> yah, I've heard about lifting
06:25:31 <Heffalump> so it's not really scary, but it does require a bit more knowledge of the library (I had to go and look it up first myself)
06:25:33 <LoganH> liftM takes an x and lifts it into a monad? :P
06:25:33 <shapr> I'm still not sure why you need to...
06:25:54 <Heffalump> LoganH: no, it takes a function from as to bs and lifts it into a function from monad as to monad bs.
06:26:01 <Heffalump> if that makes sense
06:26:02 <shapr> oh
06:26:07 <shapr> that does make sense
06:26:18 <shapr> it's a 2nd order ... whatever you call it
06:26:21 <shapr> like map
06:26:23 <Heffalump> yeah
06:26:27 <Heffalump> exactly
06:26:32 * shapr tries to remember the name of those things
06:26:41 <Heffalump> in fact, liftM on the list monad is precisely map.
06:26:52 <Heffalump> 2nd order function?
06:26:54 <shapr> aha!
06:26:56 <shapr> that's the word
06:26:58 <Heffalump> though it's not, it's third order
06:27:06 <shapr> yah, makes sense
06:27:12 <Heffalump> well, depending on how you define order, but by the definition I generally use it is
06:27:25 <shapr> map is 2nd order, because it takes a function
06:27:25 <Heffalump> values (6, "foo") etc are first-order
06:27:38 <shapr> liftM takes a function and turns it into a Monadizer
06:27:42 <Heffalump> functions that take only first-order things as parameters are second-order
06:27:57 <Heffalump> functions that take only first or second-order things as parameters are third-order. Etc.
06:28:00 * shapr avoids the Monadic tribes of graduate students roaming the halls of the CS building
06:28:05 <Heffalump> but other people's definitions of order might vary
06:28:12 <shapr> er
06:28:20 <shapr> so why is liftM third-order then?
06:28:29 <Heffalump> cos (a -> b) is second-order
06:28:58 <shapr> oh, so map is 3rd order?
06:29:00 <Heffalump> yep.
06:29:04 <Heffalump> by my definition
06:29:08 <shapr> ok, I got it.
06:29:19 <Heffalump> (which is common in the literature of the subject of my thesis, but might not be elsewhere)
06:29:24 <shapr> treerec in Joy is fourth order then
06:29:40 <Heffalump> if you say so :-)
06:29:46 <shapr> according to your definition
06:29:59 <Heffalump> well, I don't know what it is, so I can't agree or disagree
06:29:59 <shapr> because it requires something like map as one of its args
06:30:03 <Heffalump> right
06:36:46 <LoganH> Heh, I just realized that lazy evaluation is my friend. :P
06:36:57 <Heffalump> as always :-)
06:41:58 <LoganH> So why loty, as opposed to lotm?
06:44:19 <dblack_> LoganH: loty is based on some advice given in 'the pragmatic programmer', namely that programmers should learn at least one new language a year
06:44:21 <shapr> have you read "The Pragmatic Programmer" ?
06:47:01 * LoganH shakes his head.
06:47:14 <shapr> it's very much worth reading
06:47:17 <shapr> it's in my top two books.
06:47:37 <shapr> I don't know whether I'd recommend it over SICP, but then, I'm not sure I'd recommend SICP over it...
06:47:44 <jewel> who wrote it?
06:48:07 <shapr> Dave Thomas and Andy ... someone
06:48:16 <dblack_> Hunt
06:48:18 <shapr> right
06:48:33 <shapr> it's a great book.
06:48:56 <shapr> content-wise, 50% of it is just about managing any kind of projects
06:49:15 <shapr> my fiancee has been a project manager in several european projects, and she likes the book too.
06:49:24 <shapr> the other 50% don't interest her at all.
06:49:34 <shapr> in fact, PragDave is the Dave Thomas we just spoke of.
06:50:02 <jewel> ah
06:50:12 * PragDave 's ears were burning
06:50:14 <shapr> PragDave: my fiancee wants me to tell you that about 50% of PP is excellent advice for anyone managing projects.
06:50:26 <shapr> she's managed several european projects.
06:50:44 <shapr> she says the other 50% is just geeky stuff
06:50:46 * shapr grins
06:51:00 <dblack_> shapr: there's the pragmatic half, and the programming half :-)
06:51:06 <shapr> right, exactly.
06:51:14 * PragDave signs dblack as his agent
06:51:19 <shapr> happily, this means that she and I can read the book together.
06:51:23 <dblack_> PragDave: think you can afford me?
06:51:28 <shapr> I consider that a great benefit.
06:51:36 <shapr> Beatrice doesn't really want to read Haskell books with me.
06:51:43 * PragDave fires dblack on consideration of the financial side
06:51:46 <shapr> even if she did buy them for me as presents.
06:52:05 <shapr> wow, that's life in the fast lane dblack
06:52:09 * dblack_ sues PragDave for 5 times what would have been his salary
06:52:29 * PragDave pays
06:52:34 * shapr laughs
06:53:15 <PragDave> shapr: we're actually looking at putting together some kind of workshop or course for managers 
06:53:24 <shapr> I think this would be wise.
06:53:29 <PragDave> along the lines of "How To Herd Cats"
06:53:38 <shapr> *exactly* !!
06:54:40 <PragDave> i think many managers fail to realize just how to help developers do their jobs
06:54:47 <PragDave> they view is as carrot and stick
06:54:59 <PragDave> while it's really opportunity and cost
06:55:07 <chad> yea, as if developers *don't want* to work. ;)
06:55:30 <PragDave> so we're doing somethig about setting up an environment where developers and projects can flourish
06:55:33 <jewel> some negative reviews on amazon
06:55:44 <dblack_> count yourself lucky if management even wants to help you do your job...
06:57:10 <dblack_> ignore my three dots
06:57:14 <dblack_> ignore the negative reviews on amazon
06:57:34 <PragDave> jewel: of?
06:57:42 <jewel> your book, on amazon.co.uk
06:58:20 <PragDave> oh - there's that really quite hurtful one at the top over there "Garden Variety Programming" or somesuch
06:58:56 <jewel> yeah
07:00:07 <PragDave> some folks come to books with a particular expectation. If the bok doesn;t match, then it fails them.
07:00:47 <dblack_> jewel: and another thing....
07:01:01 <dblack_> note that the people who liked it (of that small sample of reviews) are the ones who used it for something
07:01:15 <dblack_> the people who didn't are doing a kind of literary-history take on it, or something
07:01:50 <jewel> yes, comparing it to their favourite book
07:03:37 <PragDave> jewel: if you're an experienced developer who stays on top of modern practices, then the book probably won't tell you much you don't know
07:03:54 <jewel> You'll be surprise at what other titles you've authored: http://www.amazon.co.uk/exec/obidos/Author=Thomas%2C%20Davis/026-0863672-4490001
07:05:28 <LoganH> I can never get patterns to work the way I want...
07:05:41 <LoganH> I have:
07:05:42 <LoganH> output                      :: [Cell] -> [Cell] -> IO ()
07:05:47 <LoganH> output [oc:orest] [c:rest]  = do
07:05:48 <LoganH>                                 putStrLn ("Cell data in " ++ (show oc) ++ " " ++ (getResult c))
07:05:48 <LoganH>                                 output orest rest
07:05:55 <LoganH> Is that not correct?
07:06:54 <Heffalump> no
07:06:57 <PragDave> i'm new to this, but try it without the '[]'s 
07:07:03 <Heffalump> yeah, use ( ) instead of [ ]
07:07:15 <Heffalump> : is a constructor that gives you a list
07:07:36 <Heffalump> so you don't need the [ ] - that ends up giving you a list of lists
07:07:37 <jewel> : is an infix operator?
07:07:41 <Heffalump> yep.
07:07:42 <LoganH> Oh.
07:07:56 <LoganH> Much better now. (:
07:07:57 <LoganH> Thanks.
07:10:03 <shapr> PragDave: I've worked in Birmingham, Alabama; Seattle, Washington; and Tornio, Finland. I think your book rocks, and I haven't met any developer who did *not* need to read it.
07:10:20 <jewel> oh yes, that's what I was getting at, shapr should write a review
07:10:25 <shapr> heh :)
07:10:46 <shapr> yah, I will.
07:11:19 <shapr> I think my nifty/sucks meter is pretty accurate, and I rate tPP neck-and-neck with SICP.
07:11:52 <Heffalump> what is SICP?
07:11:58 <Heffalump> (having failed to find it in scrollback)
07:12:15 <shapr> Structure and Interpretation of Computer Programs by Ablesson, Sussman, and Sussman
07:12:23 <Heffalump> ah
07:12:46 <shapr> have you read it?
07:12:56 <Heffalump> nope
07:13:01 <shapr> you should
07:13:13 * jewel finishes his SQL Server service pack download and prepares to go over the top
07:13:13 <Heffalump> I'm an academic, I don't go in for practical things like that :-p
07:13:29 <shapr> SICP is both academic and practical.
07:13:33 <Heffalump> though actually I'm currently thinking about whether to take a software development job
07:13:54 <shapr> Heffalump: no! not the red pill!
07:14:00 <shapr> er, blue pill?
07:14:06 <shapr> crap I can't remember which was which.
07:14:23 <Heffalump> red was what he took, IIRC
07:14:28 <shapr> oh
07:14:34 <shapr> then I said it correctly.
07:14:51 <Heffalump> :-)
07:15:05 <jewel> Keanu Reeves is a wizard programmer
07:15:13 * shapr blinks
07:15:17 <shapr> er, really?
07:15:21 <jewel> not!
07:15:26 * shapr grins
07:16:00 <shapr> speaking of which, the only show/movie I've seen that has *good* geek graphics is DarkAngel
07:23:05 <LoganH> What's the simplest way to sort integers in descending order?
07:23:52 <shapr> sort ?
07:24:07 <shapr> just guessing from looking at the List module
07:24:11 <Heffalump> sortBy probably
07:24:15 <Heffalump> cos he wants reverse order
07:24:23 <Heffalump> or reverse . sort , but that'll be less efficient
07:24:58 <Heffalump> sortBy (flip compare)
07:25:00 <Heffalump> should do the job
07:25:12 <PragDave> shapr: thank's very kind of you (sorry - I'm on a non net-connected box most of today)
07:25:18 <LoganH> Didn't know I had to import List.
07:25:45 <LoganH> That works perfectly, thanks.
07:26:14 <shapr> jewel: so, did you charge the enemy successfully?
07:26:21 <Heffalump> do you see why? (I don't like just providing canned answers without explaining why they work)
07:27:09 <jewel> no, still rebooting the machine
07:27:24 <shapr> I'm still trying to figure out the correct DER encoding of an IMPLICITly tagged [0] SET in ASN.1
07:27:28 <LoganH> Yes.
07:27:35 <Heffalump> cool
07:27:58 <LoganH> (flip compare) is the comparison operator for the sort operation, the flip just makes the comparator give opposite answers.
07:28:23 <LoganH> Not that I knew any of that before I saw the example (shows the value of having lots of nice small examples around :P)
07:28:44 <LoganH> I saw a neat project, someone providing implementations for everything that's in the Perl Cookbook in various languages (Haskell being one of them)...
07:28:56 <shapr> that would be cool
07:28:59 <LoganH> The only bad thing is that it's worthless, because all those problems are kind of perl specific, and all the solutions are very perlish.
07:29:13 <LoganH> So there's a big helper library for Haskell that contains all these functions that provide perl-like routines.
07:29:17 <LoganH> You can't really learn much from it.
07:29:28 <LoganH> I think a more basic cookbook would be really n ice.
07:30:23 <shapr> yah, I agree.
07:30:47 <shapr> I tried to create a Haskell User Submitted Libraries project on sourceforge, I haven't heard whether it's been approved or not.
07:31:10 <shapr> when it's up, I'd like for it to be a central repository for useful libs
07:31:27 <chad> are there any regex libs for haskell?  (or should i just throw that paradigm away?)
07:31:35 <shapr> yah, there are
07:31:48 <shapr> rumor has it they're very nice
07:31:51 <shapr> I haven't tried them
07:32:16 <shapr> if only I could persaude my boss to let me prototype in Haskell :)
07:33:52 <LoganH> Heh, it only took me 4 hours, but I got this simple ACM problem implemented, complete with proper I/O. :P
07:34:04 <shapr> cool!
07:34:15 <LoganH> And I even did the algorithmic part functionally. :P
07:34:27 <Heffalump> :-)
07:34:38 <LoganH> Though that was the easy part.
07:35:06 <Heffalump> btw flip compare works by swapping the arguments to compare, not by taking the opposite value of the result (I'm not sure which of the two you meant above)
07:35:18 <LoganH> Ok, that makes more sense. :P
07:35:25 <LoganH> (that flip woudl be more general like that)
07:35:26 <jewel> what was the problem?
07:35:44 <LoganH> Problem G from the '98 ACM ICPC...
07:35:55 <LoganH> Basically, you're given a sequence of spreadsheet commands...
07:36:14 <LoganH> Each command is either a list of rows to delete, a list of rows to insert (that is, positions to insert new rows), or two cells to exchange.
07:36:30 <LoganH> Then after that you're given a list of cells, and you're supposed to output their locations after all the commands are applied.
07:36:35 <LoganH> It really lends itself to a functional solution. :P
07:36:58 <jewel> url?
07:37:48 <Heffalump> http://icpc.baylor.edu/past/default.htm seems to have a list of past contests
07:38:07 <Heffalump> http://icpc.baylor.edu/past/icpc98/Finals/Report/Problems/Problems98.pdf is the specific set of problems
07:38:07 <LoganH> Oops, my mistake, it was '97
07:38:08 <LoganH> http://icpc.baylor.edu/past/icpc97/Finals/ProblemsF97.pdf
07:38:19 <Heffalump> ah :-)
07:39:46 <LoganH> I should try a problem that calls for some sort of data structure now.
07:39:51 <LoganH> Like A.
07:40:12 <Heffalump> yeah, I was thinking A would be an ideal candidate
07:40:33 <LoganH> Yeah, basically a tree of records, and some tree modifying routines.
07:40:47 * jewel curses microsoft for shipping buggy software
07:41:06 <LoganH> DAG of records, rather.
07:41:09 <jewel> The 50 MB service pack indeed fixed our obscure problem
07:42:00 <shapr> wow
07:42:09 <shapr> apt-get upgrade ;)
07:42:15 <LoganH> dist-upgrade
07:42:25 <LoganH> I love apt.
07:42:46 <LoganH> The whole notion of "shipping" or a "release" of an OS is foreign to me now. :P
07:43:17 <shapr> well, dist-upgrade isn't a good idea unless you're really going from potato to sid or something
07:43:52 <LoganH> What in Haskell has similar functionality to associative arrays?
07:47:00 <xbill> FiniteMap
07:47:02 <Heffalump> shapr: it's quite often needed to cope with package changes in woody, IME
07:52:20 <shapr> I use sid
07:53:00 <Heffalump> I'd guess the same would apply when someone reorganises packages there
07:53:12 <shapr> probably so
07:53:14 <Heffalump> it did when woody was unstable too, IIRC
07:53:48 <LoganH> What provides FiniteMap?
07:53:50 <shapr> but I haven't done a dist-upgrade since I went from potato to sid
07:54:09 <xbill> LoganH: FiniteMap
07:54:42 <Heffalump> shapr: have you had to install certain packages manually?
07:55:14 <Heffalump> loganH: see Manuel Chakravarty's stuff
07:55:25 <Heffalump> I think it's in GHC too, but I just use his version all over
07:56:24 <LoganH> No, I haven't.
07:56:28 <LoganH> I'm using GHC.
07:56:47 <xbill> It's in ghc
07:58:04 <shapr> Heffalump: yah, I've done that
07:59:24 <Heffalump> shapr: ah, ok, I generally just do dist-upgrade to avoid that hassle :-)
08:00:10 <LoganH> Do I have to import something to get these FiniteMap functions?
08:01:26 <Heffalump> have you found the module? just import it, if so
08:01:56 <LoganH> I can't tell what the name would be.
08:02:47 <Heffalump> run ghc with -syslib data
08:02:52 <Heffalump> then import FiniteMap should work
08:03:52 * Heffalump isn't quite sure how to work out the module interface without downloading the GHC source, though...
08:03:58 <Heffalump> or at least hslibs
08:04:04 <LoganH> Ahhh.
08:04:23 <Heffalump> if you look in /usr/lib/ghc-5.00.2/imports/
08:04:32 <Heffalump> (replace 5.00.2 with whatever you have installed)
08:04:37 <LoganH> That took care of it.
08:04:45 <Heffalump> then you'll see a bunch of subdirectories each of which has some hi files
08:04:45 <LoganH> It added several packages I didn't have before.
08:05:11 <LoganH> Yeah, I saw FiniteMap.hi in imports/data.
08:05:30 <Heffalump> -syslib is the way to get at those subdirectories
08:05:38 <Heffalump> there is a packages mechanism too, but I haven't really looked at that
08:05:48 <Heffalump> so I can't tell you how it works :-)
08:06:07 <shapr> I do :set -package data
08:06:12 <shapr> that gives me access to lots more stuff
08:06:30 <LoganH> I wonder if there's a file I can edit that does all this by default.
08:06:53 <Heffalump> strace ghci and see what files it reads? :-)
08:07:04 <shapr> or read the documentation?
08:07:17 <shapr> apt-get -uf install ghc5-doc
08:08:44 <Heffalump> that's no fun
08:09:18 <LoganH> ~/.ghci :P
08:09:55 <shapr> ah
08:09:56 <LoganH> ghc-5.02: panic! (the `impossible' happened, GHC version 5.02):
08:09:58 <LoganH> Haha.
08:10:10 <Heffalump> lol
08:10:17 <Heffalump> try upgrading to 5.02.2, then report a bug
08:10:30 <LoganH> I think I accidentally modified a file.
08:10:58 <LoganH> Yep.
08:13:11 <chad> anyone mind if I post some code that's giving me problems?
08:13:33 <shapr> go for it!
08:13:37 <chad> type Validator = Validations -> Validations 
08:13:37 <chad> validate :: (Validations,Validator) -> Validations
08:13:37 <chad> validate (tups,func) = [ (x,y) | (x,y) <-tups, (func(x) == y)]
08:13:53 <chad> throws:
08:13:53 <chad> ERROR "Challenge.hs":24 - Type error in application 
08:13:53 <chad> *** Expression     : func x 
08:13:53 <chad> *** Term           : x
08:13:53 <chad> *** Type           : [Char]
08:13:53 <chad> *** Does not match : [([Char],[Char])]
08:14:24 * chad is a little deeper into Haskell on this one than his capabilities safely allow him to be
08:15:24 <dblack_> chad: i'm really guessing... but maybe func x instead of func(x) ?
08:15:24 <Heffalump> try leaving out the type signature for validate
08:15:36 <Heffalump> dblack: they're equivalent
08:15:50 <Heffalump> chad: see what type it infers (with hugs or ghci or something)
08:15:57 <Heffalump> then see what type you should have written
08:16:00 * dblack_ is multitasking and should shut up :-)
08:16:13 * shapr is semitasking
08:16:14 <chad> how do i do that, heffalump?  i'm in hugs.  is it :type?
08:16:22 <shapr> semitasking = doing several things, all of them badly
08:16:26 <shapr> like windows 3.x
08:16:33 <Heffalump> chad: yep
08:16:41 <Heffalump> shapr: me too :(
08:17:09 <chad> validate :: Eq a => ([(b,a)],b -> a) -> [(b,a)]
08:17:28 <chad> now I just have to figure out what that means :)
08:17:38 <chad> I'm not familiar with the "Eq a" stuff yet.
08:18:29 <Heffalump> Eq a just says that the "a"s can be tested for equality
08:18:38 <shapr> bah, I'm going home.
08:18:45 <chad> ok, thanks
08:19:32 <Heffalump> basically its giving your function a more general type than you would have written
08:19:41 <Heffalump> s/its/it's
08:19:43 <Heffalump> /
08:21:08 <Heffalump> btw ":t" is a shorthand for ":type"
08:21:14 <chad> ok
08:28:07 <LoganH> What does a custom compare function look like?
08:29:31 <Heffalump> read compare in the Prelude
08:30:07 <Heffalump> if you define an instance of class Ord for something, you'll actually get compare for free
08:30:13 <Heffalump> if you just define <=, that is
08:30:28 <Heffalump> alternatively define compare and you might get a more efficient implementation
08:34:26 <LoganH> I haven't gotten into comprehending instances and classes and all that in Haskell yet. :P
08:35:26 <Heffalump> you'll have to to define compare, unfortunately
08:35:53 <Heffalump> you could just define a function with a different name of type (a -> a -> Ordering)
08:35:59 <Heffalump> again, look in Prelude.hs for that
08:49:35 <LoganH> How would I test if a string contains a particular character?
08:50:53 <Heffalump> a string is just a list of characters
08:51:59 * LoganH nods.
08:52:09 <LoganH> How does one typically check for existance of a value in a list?
08:52:18 <LoganH> (short of writing a simple boolean function)
08:53:09 <Heffalump> I think you might need to write the simple boolean function
08:53:25 <Heffalump> note that using sectioned operators, said boolean function is just (=='c')
08:54:05 <Heffalump> oh, no, turns out that the "elem" function exists in the Prelude
08:54:12 <LoganH> Oh yeah.
08:54:14 <LoganH> I forgot about that.
08:54:17 <LoganH> 'c' `elem` str
08:54:22 <Heffalump> yep.
08:54:30 * Heffalump ought to have remembered that :-)
09:03:39 <LoganH> How does Maybe work?
09:06:18 <LoganH> Maybe it's time for me to get some sleep. :P
09:06:27 <Heffalump> Maybe is just a datatype
09:06:44 <Heffalump> it's used when there might or might not be a result
09:07:54 <LoganH>     Couldn't match `Char' against `Maybe elt'
09:07:55 <LoganH>         Expected type: key -> Char
09:07:55 <LoganH>         Inferred type: key -> Maybe elt
09:11:31 <Heffalump> ok, so you're getting a result that might or might not have something in it, and trying to assume that there always will be something in it
09:12:57 <LoganH> Yeah.
09:13:02 <LoganH> And it's a pretty safe assumption.
09:13:07 <Heffalump> ok, then use fromJust, IIRC
09:13:32 <Heffalump> looks like you'll need to import Maybe
09:14:17 <LoganH> Ok, now I have to figure out how to use this with map...
09:14:23 <LoganH> map (lookupFM morsecode) word
09:14:25 <LoganH> is what I have.
09:14:34 <LoganH> But lookupFM returns the Maybe value.
09:15:37 <Heffalump> look at function composition
09:21:04 <shapr> so... did I miss anything?
09:21:30 <Heffalump> not a huge amount, just me helping LoganH with some stuff
09:24:27 <LoganH> Heffalump: Thanks for all the help.
09:24:33 <LoganH> I need some sleep now.
09:25:21 <Heffalump> good night :-)
09:25:26 <Heffalump> what timezone are you in?
09:25:38 <LoganH> EST
09:26:03 <Heffalump> getting your sleeping cycle that screwed takes some doing :-)
09:26:26 <Heffalump> the last time I managed it was playing Civ III over Christmas
09:26:33 <LoganH> I find it pretty easy to do.
09:26:40 <LoganH> It's harder not to do it, in fact.
09:26:59 <Heffalump> people tend to expect to see me in work sometime between 9 and 5
09:27:11 <LoganH> Last week I was alternating 3 hours of sleep one night followed by 12 hours of sleep the next (I have stuff I have to get up for every other day).
09:27:32 <LoganH> This is my way of self-adjusting so that this week won't be as bad. :P
09:27:34 <LoganH> Good night.
09:27:51 * shapr waves
10:14:54 <MrCode> hello
10:15:06 <chad> hi :)
10:16:12 <Heffalump> 'lo
10:17:32 <MrCode> hey Heffalump, I'm one of those Ruby guys taking part in the LotY project
10:18:21 <MrCode> I was wondering what the "Haskeller's" opinion was on learning some Lambda Calculus to help in understanding the functional programming paradigm
10:20:16 <MrCode> ?
10:21:12 <Heffalump> umm, you don't really need to learn most of the theoretical aspects of the lambda calculus
10:21:22 <Heffalump> if any, really
10:21:25 <MrCode> OK
10:21:43 <Heffalump> knowing that Haskell is based on this really simple language that just has abstraction and application is perhaps useful
10:22:24 <MrCode> OK
10:23:15 <MrCode> I have some other Haskell related questions
10:23:41 <MrCode> what is the significance of the "Gofer" module in the Hugs demo directory?
10:23:49 <MrCode> where does that name come from?
10:24:25 <Heffalump> Gofer is a predecessor of Hugs
10:24:34 <MrCode> OIC
10:24:36 <MrCode> that makes sense
10:24:41 <MrCode> I figured it was something like that
10:24:42 <Heffalump> it was for a language quite similar to Haskell
10:24:52 <MrCode> OK
10:24:59 <Heffalump> Hugs actually stands for "Haskell users gofer system"
10:25:14 <MrCode> so in that module they just add some functions from Gofer's Prelude
10:25:22 <MrCode> ahhh...now there is some trivia
10:25:33 <MrCode> I was wondering that too
10:26:55 <chad> what an educational #haskell session!
10:27:40 <MrCode> heh
10:27:46 <Heffalump> :-)
10:28:22 <MrCode> why can't you define functions on Hugs' command line?
10:28:58 <Heffalump> I don't think there's any intrinsic reason, it's just a feature that's not there
10:29:10 <MrCode> OK
10:29:35 <MrCode> so generally you just :e <aFile> to create functions, then :l <aFile> and then test your functions in hugs
10:29:39 <MrCode> ?
10:30:03 <Heffalump> personally, I edit stuff in a separate window
10:30:10 <MrCode> sure
10:30:18 <MrCode> what editor do you use?
10:30:23 <Heffalump> emacs
10:30:27 <MrCode> OK
10:30:28 <Heffalump> well, xemacs
10:30:31 <MrCode> sure
10:30:40 <Heffalump> oh, :r is faster than :l foo after the first time you do the :l
10:30:46 <MrCode> I use VIM...wasn't sure if you had any Haskell related VIM tricks
10:30:55 <Heffalump> no, but a friend probably does
10:30:57 <MrCode> OK, I will use :r then
10:31:13 <MrCode> also, where are the files you :e stored?
10:31:27 <Heffalump> umm, no idea. Probably the current working directory
10:31:55 <MrCode> hehe, OK
10:32:08 <Heffalump> you know there's syntax highlighting for Haskell in VIM?
10:32:18 <MrCode> yeah
10:32:37 <MrCode> but for some reason the lhs highlighting seems broken (at least on my install)
10:32:58 <Heffalump> are you using the lhaskell highlighting for that?
10:33:16 <MrCode> yeah
10:33:30 <MrCode> it has problems loading the hs highlighting, which I guess it uses
10:33:46 <MrCode> but that is a VIM problem, not a Haskell one :)
10:34:18 <MrCode> so have you made any big programs in Hskl
10:36:00 <Heffalump> one of ~5000 lines, not all written by me
10:36:02 <MrCode> where Hskl = Haskell (for the lazy typist)
10:36:11 <MrCode> OK
10:37:02 <Heffalump> [18:34] <Igloo> What exactly is he doing?
10:37:02 <Heffalump> [18:35] <Igloo> :set syntax=lhaskell   :syntax on   should work
10:37:32 <Heffalump> I just pasted your two lines :-)
10:37:33 <Igloo> Hello
10:38:29 <Heffalump> 'lo
10:38:39 * Heffalump pokes MrCode for signs of life
10:38:51 <MrCode> it is just some stupid error in the lhaskell.vim file
10:38:55 <MrCode> I need to fix it
10:39:59 <MrCode> VIM rule: if version < 600 EXCLUDES version 6
10:40:20 <MrCode> actually wait...
10:40:31 <MrCode> yes that is right
10:40:50 <MrCode> but that should not be the problem in this case
10:42:37 <MrCode> well the point is that the lhaskell.vim file does not work right in VIM 6.0
10:42:46 <MrCode> even though it includes a check for version 6
10:44:07 <Igloo> What do you get when you md5sum lhaskell.vim and haskell.vim?
10:44:23 <MrCode> let's see
10:44:33 <MrCode> well I've modified lhaskell.vim now
10:44:41 <MrCode> the problem is just this line:
10:44:57 <MrCode>   source syntax/haskell.vim
10:45:12 <MrCode> which is what it does for version >= 600
10:45:18 <Igloo> I have this
10:45:19 <Igloo> if version < 600
10:45:19 <Igloo>   source <sfile>:p:h/haskell.vim
10:45:19 <Igloo> else
10:45:19 <Igloo>   source $VIMRUNTIME/syntax/haskell.vim
10:45:19 <Igloo> endif
10:45:35 <Igloo> (after let b:hs_literate_comments=1)
10:45:35 <MrCode> that makes sense
10:45:40 <MrCode> yeah
10:45:53 <MrCode> somewhere on my system the $VIMRUNTIME part was lost
10:45:56 <MrCode> no clue why
10:46:44 <MrCode> OK that fixed it
10:46:45 <MrCode> thanks
10:46:48 <Igloo> I *might* have added that actually
10:46:54 <MrCode> heh
10:47:06 <MrCode> you must have
10:47:37 <MrCode> you could email the maintainer, John Williams
10:47:54 <MrCode> or I could ;)
10:48:41 <Igloo> Yeah, I meant to take a proper look at it but never quite got round to it
10:48:47 <MrCode> do you also have an error with vim.vim?
10:48:51 <MrCode> line 462?
10:49:04 <MrCode> where there is an &lt; where there probably should be <
10:49:13 <MrCode> actually I think I changed that one so you prolly don't
10:49:32 <Igloo> I don't now, I can't remember if I fixed it before or not
10:49:46 <Igloo> I suspect vim.vim is one that is likely to be quickly spotted, though
10:50:16 <MrCode> yeah...I think I downloaded a fancier version with Ruby highlighting support...and stupid IE turned the < into &lt;
10:50:28 <MrCode> I have Winblows on this laptop
10:50:29 <MrCode> for work
10:50:30 <MrCode> heh
10:50:35 <Igloo> :-)
10:50:42 <Heffalump> IE did *WHAT*?
10:51:01 <MrCode> try saving a text file without .txt at the end as a text file in IE
10:51:04 <Heffalump> YM it tried to render something that was presumably text/plain as HTML?
10:51:08 <MrCode> it turns it into HTML
10:51:21 <MrCode> hehe
10:51:30 * MrCode suspects Heffalump is being sarcastic
10:51:32 <MrCode> hehe
10:52:47 <MrCode> so what is your opinion on the best Haskell book?
10:53:06 <Igloo> IFP by Bird is the only one I have seen
10:53:11 <Heffalump> likewise
10:53:28 <Igloo> And given I was lectured by him there may have been bias in his recommendation of it  :-)
10:53:44 <Igloo> But from what I've seen on the lists it does seem to be well respected
10:54:11 <MrCode> OK
10:54:26 <MrCode> so it introduces Func Programming using Haskell?
10:54:37 <Igloo> Yup
10:54:42 <Igloo> The second edition does
10:55:45 <MrCode> IC
10:56:07 <MrCode> the other ppl in the "LotY" thing are reading the Thompson and Hudak books
10:56:24 <Igloo> Oh, right, you're one of them
10:56:59 <MrCode> yeah...I'm outta the country at the moment though so I am relying on the net
10:57:04 <Heffalump> hmm, yes, that is broken. (having just experimented with IE and content types)
10:57:13 <MrCode> thank you :)
10:57:16 * Igloo goes to get dressed and cook and stuff
10:57:19 <MrCode> told yah
10:57:22 <Heffalump> :-p
10:57:49 <Heffalump> though you do get an option to choose to save it in another format
10:58:02 <MrCode> but in my opinion the Haskall stuff to be found on the net leaves a bit to be desired :)
10:58:11 <MrCode> too academic
10:58:12 <MrCode> heh
10:58:20 <Heffalump> it's mostly used in academia
10:58:28 <MrCode> yeah I figured that
10:58:41 <Heffalump> both Igloo and myself are academics, essentially
10:58:43 <Heffalump> for example
10:58:47 * MrCode and his friends in the LotY are trying to change that
10:58:49 <MrCode> well maybe
10:58:57 <MrCode> sure
10:59:00 <Heffalump> I was about to say you lot seem like a good chance of changing that
10:59:02 <Heffalump> :-)
10:59:16 <MrCode> yeah we are very pragmatic
10:59:24 <MrCode> Pragmatic Programmers to be exact
10:59:35 <MrCode> since that book inspired the LotY project :)
10:59:51 <shapr> cool, new people!
10:59:54 <MrCode> though I personally so have some academic interests as well
10:59:55 <Heffalump> are people likely to try to write decent sized programs to do real tasks in Haskell?
11:00:02 <MrCode> always like to expand my mind and all
11:00:16 <shapr> I'm likely to write stuff in Haskell
11:00:17 <MrCode> Heffalump: yes quite likely
11:00:39 <Heffalump> cool.
11:00:58 <Heffalump> I suspect you'll run into some problems with the interfaces and stuff, so it'll be interesting to see how it goes
11:01:12 <shapr> graphical user interfaces?
11:01:17 <MrCode> interfaces?
11:01:23 <Heffalump> interfaces to other stuff
11:01:28 <Heffalump> like using external libraries
11:01:37 <MrCode> ah yes...hmmm
11:01:40 <Heffalump> cos there's not that many that have had Haskell interfaces written
11:01:43 <MrCode> that is always an issue
11:02:15 <Heffalump> and it's a bit of a job, since the types and stuff have to be translated
11:02:41 <shapr> does Haskell have SWIG-like programs?
11:02:45 <Heffalump> SWIG?
11:03:17 <MrCode> it automatically generates glue code for libraries for several higher level languages
11:03:20 <shapr> swig.org
11:03:28 <shapr> simple wrapper and interface generator
11:03:38 <shapr> perl, python, lua, at least I think
11:03:43 <shapr> possibly ruby
11:03:58 <Heffalump> umm, I'm not actually sure
11:04:10 <MrCode> Ruby yes
11:04:17 <Heffalump> the FFI (foreign function interface) stuff keeps changing and I never really know what it does
11:04:22 <MrCode> I've never used it though
11:04:26 <MrCode> don't code in C much ;)
11:51:20 <MrCode> well good talking to you guys...I'll see you around
11:55:35 <jsw> Wrote a fastCGI interface using greencard.  Found it to be really nice.
12:03:33 <Heffalump> fastCGI?
12:11:35 <shapr> persistent cgi interpreter == fast cgi
12:12:26 <chad> it's a protocol and implementation for having long-running processes sit behind a web server and handle CGI-ish requests.
12:12:38 <shapr> right
12:12:39 <shapr> what he said
12:12:44 <chad> saves on process startup costs....
12:13:01 <chad> and allows the developer on the back end to do things like database connection pooling and other various caching-ish things.
12:14:36 * shapr considers playing tribes2
12:14:43 <shapr> hm, do I shoot people, or do I write code...
12:14:49 <jsw> sorry, attention elsewhere
12:14:56 <chad> heh
12:15:00 <shapr> hi jsw, do you have any of your code online?
12:15:10 <jsw> no, not yet
12:15:31 <shapr> I sent an email to a guy at britishairways.com who's doing ASN.1 encoding and decoding with Haskell
12:15:32 <jsw> not sure what terms I want to distribute yet
12:15:46 <shapr> he says he'll probably have a webpage and some code online in a week
12:19:31 <Heffalump> Dominic Steinitz?
12:20:28 <shapr> that sounds like him
12:20:49 <Heffalump> he posts to the Haskell list
12:21:02 <shapr> yah, that's where his name went past
12:35:20 <shapr> bah, I'll shoot people
12:39:25 <chad> ?
12:39:39 <chad> But, why shapr?  "I don't like mondays."
13:27:52 <shapr> whee
14:00:43 <shapr> hey, where can I find docs on operators like $, !, $!, etc?
14:03:04 <Heffalump> umm, wdym by docs?
14:03:08 * Heffalump tries to remember what ! does
14:04:10 <shapr> it's something about strict evaluation.
14:05:05 <Heffalump> that's $!
14:05:20 <shapr> watch your language ;)
14:05:24 * shapr snickers
14:05:25 <Heffalump> $ is like the space that is function application, but it has very low precedence
14:05:26 <Heffalump> :-p
14:05:40 <shapr> yah, I just figured that out
14:05:51 <shapr> section 6.2 of the report
14:06:05 <shapr> f $ g $ h x  =  f (g (h x))
14:06:15 <Heffalump> $! is like $ but forces its argument to head-normal form first (IIRC)
14:06:28 <shapr> f $! x   =  x `seq` f x
14:06:49 <shapr> er
14:06:56 <shapr> it looks like it's the opposite of $
14:07:12 <Heffalump> umm, I'm not sure what its precedence is
14:07:34 <shapr> same as $
14:07:37 <shapr> the lowest
14:07:52 <shapr> $,$!,`seq` are all at zero
14:07:55 <Heffalump> ok
14:08:15 <Heffalump> so a `seq` b eventually evaluates to whatever b does.
14:08:31 <Heffalump> But how a `seq` b differs from b is that it first forces a to head-normal form, *then* evaluates b.
14:08:50 <shapr> er, the docs say that seq forces evaluation to get rid of unnecessary laziness
14:09:47 <Heffalump> right
14:35:22 <shapr> anyone know if haskell runs on more than windows and linux?
14:36:12 <Heffalump> solaris
14:36:15 <Heffalump> freebsd
14:36:21 <shapr> ok, non-unixy?
14:36:25 <shapr> for example...
14:36:33 <Heffalump> like?
14:36:37 <shapr> could I get a binary for an ARM9 running SymbianOS?
14:36:54 <Heffalump> I'd be amazed if you could for ghc
14:36:59 <Heffalump> you might be able to compile hugs yourself
14:37:12 <shapr> hm
14:37:18 <shapr> well, it seems that ghc can output C code
14:37:30 <shapr> or am I confused?
14:37:42 <Heffalump> yes, it can
14:37:49 <Heffalump> that's the way it gets ported, using the "hc" boot files
14:37:52 <shapr> hm
14:37:55 <Heffalump> but it's not exactly easy to actually do it
14:38:04 <shapr> hm
14:38:13 <Heffalump> (I've been trying to get a recent ghc to work on Intel Solaris for a while without luck)
14:39:25 <shapr> did you ask on the ghc-users list?
14:39:53 <Heffalump> nope
14:39:55 <Heffalump> I probably should
14:40:32 <shapr> it'd probably make your life easier
14:41:08 <shapr> wow cooool
14:41:13 <Heffalump> I haven't been trying that hard
14:41:16 <shapr> ghc has macros of some flavor
14:41:24 <shapr> you can do rewrite rules in the source
14:41:26 <Heffalump> errm, they are done with cpp.
14:41:30 <Heffalump> oh, that's slightly different
14:41:36 <Heffalump> it's not exactly macros
14:45:07 <shapr> hi Dave
14:45:13 <PragDave> hi there
14:46:11 * shapr tries to figure out if the debian ghc5 package has concurrent haskell support
14:46:30 * PragDave looks on in awe
14:46:39 <xbill> yes
14:46:45 <shapr> oh, that's coool
14:46:53 <shapr> I have thirty machines at work that aren't doing anything
14:47:06 <shapr> I bet I can make pretty fractals really quickly
14:50:48 * shapr laughs at haskell docs
14:51:06 <shapr> whoever wrote these docs was bored and looking for excitement
14:51:13 <jemfinch> shapr: so you're liking haskell?
14:51:17 <shapr> or maybe an avid reader of PTerry Pratchett
14:51:24 <shapr> heck yeah, haskell is nifty
14:51:27 <shapr> I like Joy also
14:51:33 <shapr> but haskell is reallly cool
14:51:49 * jemfinch is getting enamoured with SML lately.
14:51:50 <shapr> jemfinch: what about you?
14:51:53 <shapr> ah
14:52:04 * Heffalump has been losing his temper with SML lately
14:52:17 <jemfinch> Haskell programmers generally know Functional Programming better than any other set of programmers, so that's why I'm here.
14:52:20 <Heffalump> but functors are nice
14:52:40 <shapr> I really *like* functional programming.
14:52:52 <jemfinch> Heffalump: what's making you lose your temper with SML?
14:52:52 <shapr> and I'm finding out that most programmers don't understand FP in the least
14:53:03 <Heffalump> the syntax. It's horrible.
14:53:06 <Heffalump> And the lack of type classes.
14:53:14 <jemfinch> shapr: no, they don't -- most think that Lisp/Scheme are the end-all-be-all of FP, and they're not even close to *real* functional programming.
14:53:37 <jemfinch> Heffalump: I'm coming from O'Caml, so I'm used to the syntax.  And I'm not quite sure if I like type classes :)
14:53:52 <Heffalump> do you like equality types? :-)
14:54:02 <Heffalump> I dislike O'Caml too, but I haven't used it for ages
14:55:03 * jemfinch goes to do laundry and read Greek.
14:55:12 <shapr> yah, I've realized that Lisp/Scheme flavors are halfway between FP and procedural
14:55:24 <jemfinch> shapr: they're far too focused on mutation.
14:56:25 <shapr> yah I agree
14:56:44 <jemfinch> I like Haskell/ML's focus on immutable data structures.
14:58:15 <jemfinch> Heffalump: the main reason I'm becoming enamoured with SML is because (a) a lot of research goes on in it, (b) it's not so hard to do imperative stuff.
14:58:36 <jemfinch> for instance, there's an SML compiler that does *compile-time* garbage collection.
14:59:16 <Heffalump> which one?
14:59:21 <shapr> I don't think imperative stuff is so hard in Haskell
14:59:26 <Heffalump> quite a bit of research goes on in Haskell
14:59:31 <Heffalump> shapr: it is, really
14:59:54 <Heffalump> it can be done, but it doesn't fit as nicely with the language as it does in ML
14:59:56 <Heffalump> it can't
15:00:30 <jemfinch> SML also has first class continuations, which I haven't had a chance to work with yet, and want to play around with :)
15:00:59 * Heffalump doesn't really grok continuations properly
15:01:05 <jemfinch> me neither, not yet :)
15:01:19 <jemfinch> but they're hella-powerful.
15:01:38 <Heffalump> I would have thought Haskell could handle them nicely given that there's a monad of continuations, though
15:02:12 * jemfinch has to go.
15:02:15 <Igloo> Heffalump: Recent ghc releases have had problems with porting, see my messages on one of the ghc lists. 5.02 may be better but I haven't seen hc files appear yet and don't really have time right now to prod it anyway
15:02:28 <Heffalump> igloo: oh, ok
15:02:39 <Heffalump> I shouldn't have wasted my time then :-)
15:03:09 <shapr> I want to play with first class continuations
15:03:24 <shapr> I wish Stackless Python would get moving
15:03:34 <shapr> I understand continuations well enough to use them in Python at least
15:03:40 <shapr> dunno what I'd do with them in Haskell
15:07:00 <shapr> btw, has anyone noticed that stack-based functional programming languages appear much like some of the library manipulation decks in Magic : The Gathering?
15:07:09 <shapr> or was that comment way off-topic?
15:07:39 * Heffalump has never played it, sorry :-)
15:07:49 <shapr> it's way too addictive anyway
15:07:51 <shapr> don't try it
15:10:15 * Heffalump stomps on a bug he found while trying to track down a different bug he found while trying to track down the bug he found trying to track down a bug someone pointed out on Monday
15:10:31 <Heffalump> where Monday = a week ago
15:19:33 <jemfinch> shapr: stackless python is pretty much dead, I think.
15:24:52 <shapr> jemfinch: nah, it's been reborn as of two days ago
15:25:09 <jemfinch> really?
15:25:10 <jemfinch> stackless.com?
15:25:49 <shapr> yup
15:26:39 <jemfinch> it looks the same as it always has...
15:27:25 <shapr> the cvs repository is up as of yesterday
15:27:40 <shapr> I don't know how much of it has made it to the website, but the mailing lists are alive
15:28:24 <jemfinch> the license on stackless sux0rs.
15:28:39 <shapr> what is the license?
15:29:01 <jemfinch> same as python, with one additional clause: "This code can't be integrated into Python unless it *becomes* Python"
15:29:32 <jemfinch> apparently he did some significant amount of optimization, and didn't want them stealing that without putting continuations into Python like he had them implemented.
15:30:38 <jemfinch> adding first-class continuations should make a language *slower*, but he got an 8% speed improvement in windows.
15:30:46 <jemfinch> so he did a lot more than just add continuations.
15:34:26 * jemfinch leaves again.
15:39:56 <xbill> if you ask Andy Appel continuations and heap allocation are the way everything should be.
15:44:24 * Igloo looks at FOLDOC
15:44:35 <Igloo> So what's the great advantage of it?
15:45:05 <Igloo> It seems most unnatural to me
15:47:18 <Igloo> Hmmm, I should go to bed
15:52:41 <shapr> continuations are much more flexible and powerful than functions, because functions are a subset of continuations
15:52:48 * shapr looks up Andy Appel
15:56:15 <shapr> wow, he's prolific
15:56:24 <xbill> yes
15:56:43 <xbill> *AND* he thinks heap allocation is cheap
15:57:18 <shapr> that means nothing to me
15:57:23 <shapr> I don't have enough context
15:57:37 <shapr> is he right?
15:57:57 <xbill> I don't buy his argument.
23:47:47 <shapr> hi juhp!
23:48:53 <juhp> hi there!
23:48:58 <juhp> how's it going?
23:49:22 <juhp> have an annoying problem with popenhs
23:55:27 <shapr> it's going well
23:55:32 <shapr> I don't know anything about popenhs
23:55:48 <shapr> but maybe if you describe your problem to me, then it will suddenly become clear to you?
