02:58:05 <shapr> hi again
02:58:30 <shapr> anyone awake who has a clue about the ST monad?
03:08:25 <djul> only part one
03:08:35 <shapr> heh
03:08:38 <shapr> hi djul 
03:09:24 <shapr> hey djul, have you linked djul to jewel?
03:11:31 <jewel> it is just my alternate nick when the other is used (when servers die)
03:12:13 <ski> hi
03:13:37 <ski> anyone asked about ST monad ?
03:19:53 <ski> not much talk here now, it seems
03:30:00 <jewel> shapr asked
03:30:35 <ski> i saw that on the log on tunes, which i just discovered
03:30:48 <ski> nice thing
03:31:11 <ski> read a little recorded from #compilers
03:39:14 <shapr> arg, which package has ord and chr|
03:39:44 * shapr tries to figure where ord went
03:39:53 <ski> aren't ord in Prelude
03:40:14 <shapr> probly so, but I can't seem to use it in ghci
03:40:22 <shapr> do I need to import a module in my code?
03:40:38 <ski> i'll start up ghci and look
03:42:17 <ski> i seem to recall that hugs has conflated some things into Prelude that don't actually belong there, let's see if i can find ghci's Prelude
03:42:21 * shapr tries :set -module text
03:42:37 <shapr> er, that should be -package
03:43:36 <ski> doesn't seem to work
03:44:04 <shapr> hrm
03:44:08 <shapr> I wonder where it went
03:44:11 <shapr> I saw ord and chr last night
03:44:32 <shapr> hi again ski!
03:44:37 <ski> i'm not so used with ghci, have it only at school
03:44:49 <shapr> can you use ord and chr in hugs?
03:45:02 <ski> well, now you recognised me. hi shapr !
03:45:43 <shapr> oh, I have to ask if you know John Hughes.... isn't he the guy who came up with the idea of arrows, and is teaching at chalmers?
03:46:14 <shapr> jewel: you can link djul to jewel and use both
03:46:19 <ski> (well i tried to install ghc at my brothers computer, hasn't got the time to try on my own,ghci seemed to work, but not ghc. i don't have cygnus, but i have djgpp, maybe cygnus is required)
03:46:34 <shapr> I don't think so
03:46:41 <shapr> but then I use linux, I don't really know
03:46:55 <ski> shapr : yes, i can use ord and chr in hugs
03:47:16 <shapr> hm, weird
03:48:46 <ski> shapr : yes i have met John Hughes and talked with him a little (cool !!), there are talks here in a research group many thursdays, but anyone interested is welcome, so i attend sometimes :-)
03:49:18 <shapr> wow, awesome
03:49:33 <ski> i ought to have install linux a long time ago, but i'm so lazy ;-(
03:49:37 <shapr> I must show up sometime and listen to some of the talks
03:50:15 <shapr> I wish ghci had a dir() function like the Python interpreter
03:51:51 <ski> do so, if you have the opportunity (of course there are various speakers at different meetings (it's called multi meetings, because it's a metting attended by research figures from many of the research groups here (functional, formal method, ...)))
03:52:27 <shapr> I'd really like to hear John Hughes speak
03:52:41 <shapr> are the talks often in English?
03:53:58 <ski> most often, i seem to recall (i think John can speak at least some swedish but sometimes there are attendants from other countries there (or studying persons at chalmers from other countries))
03:54:45 * shapr finds chr in PrelBase
03:54:51 <shapr> seems I should be able to find it in ghci then
03:55:19 <ski> hugs' Prelude seem to be divided in sections : {Prelude},{PreludeRatio},{PreludeList}
03:55:51 <shapr> it's also part of Char
03:55:54 <shapr> hmmm
03:55:59 <ski> PrelBase ... , that could be it. but shouldn't it be automatically imported
03:56:38 * shapr grumbles
03:56:45 <shapr> how do I cast an Integer to an Int again?
03:57:04 <shapr> I found out I can import Char, and then call Char.chr
03:57:06 <ski> isn't it fromInteger ?
03:57:22 * shapr tries that
03:58:08 <shapr> oh
03:58:09 <shapr> cool!
03:58:23 <ski> what ?
03:58:28 <shapr> it works
03:58:43 <ski> how to import Char in ghci, me not understand ?
03:58:47 <shapr> but I have an error in my program somewhere...
03:58:58 <shapr> I did "module Main where import Char"
03:59:03 <shapr> then later I called Char.ord
03:59:07 <shapr> dunno why that works 
03:59:13 <ski> oh, of course you imported it in  your source file
03:59:24 <shapr> it also works in ghci
03:59:29 <shapr> :set -package Char
03:59:33 <shapr> Char.ord 
03:59:33 <ski> i tried both :l Char and :s -package Char in ghci
03:59:43 <shapr> still didn't work?
03:59:47 <ski> unknown package name: Char
03:59:51 <shapr> whoa, werd
03:59:52 <shapr> weird
04:00:06 <shapr> maybe the debian package has some extras installed?
04:00:39 <ski> maybe, or maybe the libraries aren't correctly configures at school, but i wonder ?
04:01:07 <shapr> I dunno
04:01:13 <shapr> there's probably a sensible answer
04:01:16 <shapr> I just don't know it
04:01:20 <shapr> gotta reboot, brb
04:14:49 <bsh> hey
04:14:54 <ski> hello bsh
04:16:47 <ski> we talk more for a few minutes ago, but shapr had to reboot his computer
04:17:02 <bsh> ah ok ;) .. what is haskell exactly?
04:17:10 * dmiles is back (gone -23:54:44) mIRC xxxScript
04:17:37 <ski> oh, haskell is an interesting (IMO) functional programming language
04:18:24 <bsh> ok.. is there an official site I can get some information about it from?
04:19:07 <ski> it's main features distinguishing it from other functional PLs is monads,purity and laziness
04:19:24 <ski> well http:/www.haskell.org is a good place to start
04:19:50 <bsh> oh ok.. :p
04:19:54 <ski> also un usenet : comp.lang.functional (amongst other functional PLs)
04:20:16 <clausen> there seems to be a few mailing lists (that go way over my head)
04:20:22 * clausen really should do some reading!
04:20:28 <ski> and wiki : http://www.haskell.org/wiki/wiki
04:20:52 <bsh> ok, thanks.. i've been looking into alot of PL development lately
04:21:24 <ski> yes, i've looked at some history of it somewhere on www.haskell.org but iv'e not participated myself (yet atleast)
04:21:49 <bsh> ok.. What languages can you code in?
04:22:03 <ski> and of course at least this IRC channel :-)
04:23:02 <bsh> ;)
04:23:13 <ski> so if you have any direct questions right away, we could try to answer them right now, if you want to/have time/... that is
04:23:49 <bsh> What language is haskell developed in?
04:24:48 <ski> me ? well i can code in PB-100F BASIC, C64 BASIC, 6502 Assembler, C, Java, Haskell and a little Scheme (+Lisp) and ML (SML+OCaml), that's it i believe
04:25:29 <bsh> Cool.. I'm just into C .. I know a little BASIC
04:25:40 <ski> well many more or less developed PLs have a tendancy to prefer being developed it itself
04:26:22 <ski> so one haskell compiler, GHC, is coded in haskell, but Hugs, the haskell fast-cycle interpreter is coded in C
04:26:44 <bsh> ok
04:27:41 <ski> well C is good in it's own way for certain tasks (and if you accept the design decisions), though it has some warts and new ideas have been developed since C was invented
04:28:38 <bsh> Yeah.. i've been working on an interpreter ... not a very good one - but yeah
04:28:40 <ski> BASIC some say isn't a real progemming language, firstly there aren't one BASIC but many many dialects
04:29:01 <bsh> Yeah true
04:29:45 <ski> and also libraries are hard in BASIC, and i consider them important. BASIC (more or less original) lacks any uniform way of calling functions/procedures
04:30:11 <ski> interpreter written in what language, for what language ?
04:30:32 <bsh> I wrote it in C... it was more of a personal language I was writing..
04:31:26 <ski> is it a interpreter for C or for any other lang (or own invented) ? (curious)
04:31:32 <ski> ok
04:32:11 <bsh> own invented :p
04:32:33 <ski> (i forgot, i know a little 680x0 assembler also, nice assembler)
04:33:01 <bsh> I also know a little C++.. just dont normally use it
04:33:02 <ski> what type of language (imperative, i presume ?)
04:34:11 <bsh> yeah, imperative
04:34:19 <ski> well, i took a C/C++ course some years ago, and learned not C and not C++ but some weird mixing of concept. since then i have managed to learn C properly on my own, C++ i only know a little
04:35:00 <bsh> yeah.. All C/C++ i know i've taught myself.. I'm also into Linux/*bsd administration
04:36:38 <ski> you'd like to elaborate on the language and interpreter a little, or you'd rather talk about haskell or functional programming (FP) or connected ?
04:37:53 <bsh> Well the language I was writing was much like GWBASIC
04:40:38 <ski> any user-defined functions/procedures ?
04:41:20 <bsh> nope, not yet implemented
04:42:11 <ski> good luck (you also have to decide whether to support recursion or not there)
04:42:20 <clausen> bsh: you might find the "Dragon Book TM" inspiring / helpful
04:42:39 <bsh> clausen: interesting.. thanks
04:42:48 <clausen> bsh: the real name of the book is
04:42:56 * clausen googles
04:43:06 <bsh> hehe :p
04:43:21 <clausen> well, it's by Aho, Sethi and Uhlman
04:43:26 <clausen> that I remember (spelling?)
04:43:29 <ski> iv'e heard that book name, but i'm not sure of what written in it
04:43:52 <bsh> i'm on holidays at the moment.. I live in Sydney, Australia - Im in Western Australia right now.. 
04:44:27 * clausen lives in Melbourne / Australia
04:44:31 * clausen in Curitiba / Brazil ATM
04:44:45 <ski> okeydokey, so you are from "down under"
04:44:50 <bsh> Ah cool.. i've never been to Melbourne 
04:45:12 <ski> ski lives in Gothenburg / Sweden
04:45:18 <clausen> http://www.amazon.com/exec/obidos/ASIN/0201100886/ref%3Dnosim/pineapplesoftonl/002-4289326-7069634
04:45:21 <bsh> ah ok ;)
04:45:25 <bsh> clausen: thanks
04:45:56 <bsh> clausen: why are you in Brazil?
04:46:07 <clausen> bsh: holiday
04:46:12 <clausen> bsh: I used to work for a .br company
04:46:16 <ski> ahh, it's about compilers :-)
04:46:20 <clausen> bsh: but, now I'm just meeting friends
04:46:21 <bsh> ah ok
04:46:32 <clausen> anyway, dragon book is mainly about:
04:46:41 <clausen> lots of research about parsing
04:46:48 <clausen> (lexical analysis, different types of parsers, etc.)
04:46:52 <clausen> and lots of practical advice too
04:46:59 <clausen> but lots of cool theory :)
04:47:01 <clausen> (really cute!)
04:47:14 <bsh> clausen: cool :)
04:47:20 <clausen> and also, stuff about code generation, optimizing code, etc.
04:47:42 <ski> clausen : iv'e got one compiler book : Compiler implementation in ML
04:47:53 <bsh> Have you ever looked into OS development?
04:48:03 <clausen> bsh: yes
04:48:28 * clausen maintains GNU Parted, and has to talk lots to Linux kernel people...
04:48:44 <ski> bsh : not seriously, just surfed and looked at some pages a little (e.g. tunes)
04:49:07 <clausen> (and hurd people)
04:49:16 * clausen also read a few books
04:49:26 <bsh> clausen: cool.. I've been looking into a fair bit of OS development
04:49:40 * clausen would like to go back to compilers
04:49:43 <clausen> (haskell!)
04:49:43 <ski> shapr : iv'e saved some (perhaps trivial) replies for you but, i think i wait a little with them
04:49:48 <clausen> ghc looks rather heavy
04:49:48 <shapr> ok :)
04:49:53 <shapr> ghc is nifty
04:49:53 * clausen will need a lot of time to understand it
04:50:10 <clausen> and I'm stil spending lots of time on Parted
04:50:16 <clausen> (grrr, it's hard to decide what to DO with life!@)
04:50:23 <shapr> program!
04:50:24 <shapr> write code!
04:50:38 <shapr> imho, code is second only to women ;)
04:50:39 <ski> absolutely !
04:50:39 <clausen> shapr: yeah, but there's always another thing to write on parted
04:50:47 <shapr> and sleep is way down the list %-D
04:50:48 <clausen> hehe
04:50:57 * clausen can't program when he's tired
04:51:04 <shapr> I can, though not very well
04:51:10 <bsh> hehe :p
04:51:18 <ski> he
04:52:26 <ski> do you dream about code or coding or coding problems sometimes ?
04:52:54 <ski> i do. often weird abstract dreams ;-)
04:53:04 * clausen dreams about code
04:53:07 <clausen> particular when hacking compilers
04:53:11 <clausen> particularly
04:53:12 <shapr> yah I dream about symbols lots
04:53:26 <shapr> I have programming dreams all the time
04:53:52 <shapr> but it's usually stuff like a chess board that I can place pictographs on to represent a programming problem
04:54:08 <ski> sometimess it seems that i reason about a problem in sleep, but when i awake most of it's gone/forgotten and the rest don't often make sense
04:54:25 <shapr> or sometimes rosewood colums, rails, and blue marbles that form a physical model of a process
04:55:14 <shapr> has everyone here seen the movie named memento?
04:55:21 <shapr> that's a programmer's movie in my opinion
04:55:38 <clausen> yep
04:55:40 <ski> well, i ought to try to remember dreams more, but it's difficult, especcially if you have irregular sleeping habits and are not accustomed of recalling dreams, bwahaa
04:55:44 <clausen> shapr: I agree 100%
04:55:53 * clausen thought: that's me!
04:55:57 <shapr> ski: keep a notebook and a pen next to your bed
04:55:57 * clausen has a terrible memory
04:56:36 <ski> i have succeeded with that thrice i think, have to recall/remember to try it more often
04:56:39 <shapr> last night I dreamed about using Monads to sequence actions in Tribes2 %-O
04:56:47 <shapr> that was weird
04:56:50 <ski> cool
04:57:58 <ski> often i at least try to mnemonically induce my (hypothetical ?) sub-conscious to recall dreams and perhaps even have lucid dreams
04:59:42 <ski> where a lucid dream is defined as a dream where you are aware that you are dreaming when you are dreming. this often means that you can willfully control and change your dream (and fly , etc ...)
05:02:17 * jewel dreamt about creating a StarCraft type game where players can write their own ai logic for each of the unit types
05:02:39 <ski> i've had (at least one for sure) such dream, but it only lasted half a minute or something, the damn thing is unstable ! like balancing on an edge, if you get too emotionally involved (yess, i've finally succeeded) then you most often cause yourself to awake, to the other extreme lies the danger of losing lucidity and the dream becomes an ordinary dream again (with you non-lucid following your act role in the dream)
05:04:17 <ski> hmmm, iv'e thought of some type of game where one should be able to define "procedures" for common actions and combining them, perhaps even tune their own ai so that they don't have to comman all detailed actions explicitely
05:04:34 <shapr> yah, that kind of thought goes through my head really often
05:04:50 <shapr> the first "dark reign" had a good chunk of that ability
05:05:04 <ski> (sorry for rambling about lucid dreaming so much, but the concept makes me excited)
05:05:10 <shapr> you could set pursuit, heal, and reaction
05:05:12 <shapr> no worries
05:05:20 <shapr> I've had lucid dreams myself
05:05:36 <shapr> it's easy for me to do lucid dreaming because I always know I'm dreaming
05:05:56 <ski> what type of game is dark reign ? strategy ? real-time ?
05:05:57 <shapr> but usually I try to follow the role so I can listen to what my subconscious is saying
05:06:08 <shapr> yup, dark reign is real time strategy
05:06:14 <shapr> it's a bit older
05:06:21 <shapr> I ran it on my p90 with no problem
05:07:09 <shapr> mindrover takes that idea to the other extreme
05:07:20 <shapr> you can only program your unit
05:07:29 <ski> okeydokey
05:07:36 <shapr> you get to build it out of components and wire them all together, it's quite nifty
05:07:56 <ski> interesting
05:08:04 <shapr> yah, and I got the linux version of course ;)
05:08:27 <ski> good, good
05:08:45 <shapr> personally I'd like to write a 'life' game that lets you build your own automata
05:09:07 <ski> hmm, that shouldn't perhaps be to hard
05:09:15 <shapr> that way you'd end up with more 'memetic' programming, rather than just scripting existing units only
05:09:58 <shapr> mindrover gives you some small ability to do the same thing
05:10:19 <shapr> in some parts of it, your two robots are on one team, playing soccer against another team
05:10:37 <shapr> and one of the components is a radio that sends a range of integers to your team
05:11:10 <ski> shapr : all your dreams (at least recalled ones) are more or less lucid. envy,envy ;-)
05:11:51 <ski> the integers denote what ?
05:12:20 <shapr> whatever you want them to denote
05:12:25 <shapr> you just receive an integer
05:12:43 <shapr> you can use it to change modes from offense to defense or whatever
05:12:46 <ski> ahh, so you can decode it in each unit, building an own mini-protocol ?
05:12:52 <shapr> right
05:13:21 <shapr> I haven't built a team yet, but my first thoughts were to use it to switch from offense to defense
05:13:43 <shapr> I had also considered passing some info about enemy location that way
05:14:09 <ski> so the orders arn't directly automagically transferred to the units at "run time", you have to distribute it over some channel (the radio integer stream), interesting idea
05:14:52 <shapr> psst, try the mindrover demo... http://www.lokigames.com/
05:14:58 * shapr pretends to be a drug dealer
05:15:02 <shapr> the demo is free ;)
05:15:26 <ski> thanks
05:16:01 <shapr> mindrover is good because it's a really fun game that has a deterministic ending
05:16:19 <shapr> aka, you can get over it, you don't stay addicted
05:16:23 <shapr> oh, about the ST monad...
05:16:45 <ski> well, what about it ? speak up, man !
05:16:51 <shapr> I recently read the paper about arrows
05:16:59 <shapr> and in there he shows this:
05:17:00 <ski> yes ?
05:17:03 <shapr> tick :: STRef Int Int
05:17:04 <shapr> tick = readSTRef >>= \n ->
05:17:04 <shapr>        writeSTRef (n + 1) >>= \() ->
05:17:04 <shapr>        return n
05:17:17 <shapr> well, he uses StateMonad in place of STRef
05:17:21 <shapr> and he uses fetch and save
05:17:38 <shapr> how can I turn the proto code he used into working code?
05:18:47 <ski> well, in the "real" ST monad the type of tick would be ST s Int or something similar, i think
05:19:30 <ski> his monad "STRef" seems here to only contain a single state (variable), in this case of type Int (STRef *Int* Int)
05:19:41 <shapr> he actually just calls it StateMonad
05:19:45 <shapr> I was trying to make it real
05:19:52 <shapr> so I put in STRef
05:19:57 <ski> and his read and write seems to have type :
05:20:06 <ski> readSTRef :: STRef s s
05:20:20 <ski> writeSTRef :: s -> STRef s ()
05:20:59 <ski> ok StateMonad (whatever :), that sound like a more familiar/convetional name for such a single state monad
05:21:46 <shapr> which module has ST?
05:21:48 <ski> but in the ST monad in hugs (i'm almost sure this is correct for GHC too, and perhaps for nhc and hbc (i don't know))
05:22:03 <ski> these operations have type :
05:22:24 <ski> newSTRef :: a -> ST s (STRef s a))
05:22:43 <ski> readSTRef :: STRef s a -> ST s a
05:23:02 <ski> writeSTRef :: STRef s a -> a -> ST s ()
05:23:08 <ski> that's it i think
05:24:05 <ski> which module has ST? well in hugs it's ST (or LazyST if you want lazy state)
05:24:25 <shapr> tick :: ST s Int
05:24:25 <shapr> tick = readSTRef >>= \n ->
05:24:25 <shapr>        writeSTRef (n + 1) >>= \() ->
05:24:25 <shapr>        return n
05:24:31 <shapr> hm, still has compile problems
05:24:41 <ski> of course i forgot the most important ST function :
05:24:44 <shapr>     Couldn't match `ST s' against `(->) (STRef s1 a)'
05:24:44 <shapr> 	Expected type: ST s a1
05:24:44 <shapr> 	Inferred type: STRef s1 a -> ST s1 a
05:24:44 <shapr>     In the first argument of `(>>=)', namely `readSTRef'
05:24:44 <shapr>     In the definition of `tick':
05:24:44 <shapr> 	readSTRef >>= (\ n -> (writeSTRef (... + 1)) >>= (\ () -> ...))
05:24:49 * shapr does a minor flood
05:25:04 <ski> runST :: (forall s . ST s a) -> a
05:25:58 <ski> well writeSTRef takes an STRef as an argument also (readSTRef too)
05:26:13 <shapr> what's the equivalent for ST ?
05:26:15 <ski> you have to create it with newSTRef
05:26:24 <shapr> oh..
05:27:37 <ski> if it's supposed to be a "global" STRef you can use unsafePerformIO (horror !!), John Hughes had a talk about ways to overcome this for a while ago
05:28:16 <ski> or you can make it a parameter to tick (or define tick as a local function in a where/let where you already have called newSTRef)
05:29:08 <ski> i think a parameter to tick would be nice in this case (so it can tick any Int STRef-Box you point it at)
05:29:58 <ski> but perhaps you are only going to use one box anyway so perhaps some of the other ways are better in your case
05:30:26 <ski> let's say you choose to make the STRef a parameter to tick
05:30:45 <ski> then tick might perhaps be defined as follows :
05:31:02 <ski> tick :: STRef s Int -> ST s Int
05:31:18 <ski> tick ref = readSTRef ref >>= \n -
05:31:32 <ski> (should be > at end of previous line)
05:31:55 <ski>            writeSTRef ref (n + 1) >>= \() ->
05:32:03 <ski>            return n
05:32:18 <ski> does that work ?
05:32:38 * shapr tries it
05:33:26 <ski> in other cases tick wouldn't have a ref parameter, but ref would be defined at toplevel (with unsafePerformIO) or in an enclosing context (innner definition)
05:34:02 <shapr> what's up with unsafePerformIO?
05:34:14 <shapr> I keep hearing about it, but I have no idea what's unsafe
05:34:17 <ski> maybe iv'e confused things a bit : it may be that the unsafePerformIO option only works with IORef and not STRef, not sure :-(
05:34:33 * shapr has negative clue
05:34:51 <ski> well the type of it is :
05:35:01 <ski> unsafePerformIO :: IO a -> a
05:35:48 <ski> one way to look at the IO type is as if it had been defined as (i think GHC does something like this)
05:36:07 <ski> newtype IO a = IO (World -> (a,World))
05:36:46 <ski> where a value of type World represents the state of the entire outside world (including filesystem,graphics, etc ...)
05:37:26 <shapr> hm
05:37:31 <shapr> that almost makes sense to me
05:37:52 <ski> (the only crux is that values of type World shouldn't be duplicated or discarded, otherwise we'd have to discard the nice efficient implementation of World as side-effects on the outside world)
05:38:14 <ski> so essentially unsafePerformIO has this type :
05:38:30 <ski> unsafePerformIO :: (World -> (a,World)) -> a
05:39:03 <shapr> oh
05:39:25 <ski> so it gets a functionm invents a new World, sends it to the function, recieves the pair of the result, and the possibly updated world, and discards the new world and returns the result
05:39:39 <ski> it breaks referential transparency
05:40:06 <shapr> I'm still not clear on referential transparency
05:40:09 <ski> with it's help you can call side-effecting code from within "non-sideeffecting pure code"
05:40:16 <shapr> intuitively I understand it, but not all its implications
05:40:28 <ski> say you define :
05:41:04 <ski> foo :: () -> Char
05:41:19 <ski> foo () = unsafePerformIO getChar
05:41:35 <ski> then foo () isn't the same as foo () !!
05:42:37 <ski> (we have to make it a function, in this case by adding a dummy unit argument, because otherwise it would be evaluated once and then cached (it's lazy !))
05:42:57 <ski> (i.e if it's defined at toplevel)
05:43:34 <shapr> right, I understand that
05:43:36 <shapr> BUT
05:43:48 <shapr> why does wrapping it in a Monad suddenly make everything ok??
05:43:55 <shapr> and why do you say "lifted" into a Monad?
05:44:27 <ski> in some cases one can defined a library more efficiently with side-effects than without, but the libraries interface to the outside is pure, only local side-effects doesn't harm any body (if it's not detectable from outside)
05:44:41 <shapr> the only thing I can think of is that Monad means "safely functional, plus a side effect we're safely hiding"
05:45:24 <ski> because calling a (pure) function returning some IO type doesn't perform any side-effects (as opposed to e.g. C)
05:46:06 <ski> it only return an object (call it encapsulated-side-effect or side-effect-object if you wish)
05:46:17 <ski> an object that represents an action
05:46:36 <shapr> oh
05:46:48 <ski> then >>= and >> combines two objects representing actions to a combined object
05:46:52 <shapr> so how do get rid of that object and just get the result?
05:47:04 <shapr> yah, >>= makes me think of rings on a string
05:47:14 <ski> you define main to be of an IO type (maybe only IO () is permitted)
05:47:39 <shapr> eg. all parts of a haskell program have unknown order of resolution except the guys with >>= between them
05:47:54 <shapr> they require that one happens after another
05:48:08 <ski> then conceptually the pure functions calculate the final (main) side-effect object which then magically (by the ren-time system) gets executed and side-effects performed
05:49:16 <ski> yes >>= and >> sequences the side-effects (so they are not indeterministic)
05:49:28 <shapr> but only relative to each other
05:49:37 <ski> yes
05:49:38 <shapr> which still allows the Haskell implemenation a lot of leeway
05:49:56 <shapr> nifty
05:50:11 <ski> yes, it the "as if" rule, if it behaves as it should, another implementation is allowed
05:50:35 <clausen> I thought it was monad composition
05:50:41 <clausen> i.e. one function takes the world
05:50:44 <clausen> and returns a world
05:50:47 <clausen> which the second function uses
05:50:50 <clausen> and returns another world
05:50:52 <clausen> i.e.
05:51:03 <ski> so in practice the pure and side-effecting calculations/computations are done intermixed with each other (and possibly parallell on such architectures)
05:51:09 <clausen> type Monad :: World -> World
05:51:25 <clausen> (data?)
05:51:31 <clausen> (my haskell rather rusty...)
05:51:44 <ski> a computation can both affect the global world state and return a result
05:51:55 <clausen> right
05:52:04 <ski> newtype IO a = IO (World -> (a,World))
05:52:12 <ski> (or data is well too)
05:52:16 <shapr> ok, so your definition of tick worked, but I can't figure what to with newSTRef
05:52:35 <clausen> anyway, doesn't this define a strict ordering?
05:52:40 <ski> well, how are you trying to use tick in the program ?
05:52:44 <clausen> s/ordering/order/
05:52:49 <clausen> of evaluation?
05:52:50 <shapr> anyway at all :)
05:53:57 <ski> clausen : you mean strict ordering of side-effects (but the "as if"- rule can sometimes apply here to think of disjoint state-parts of the world as filesystem and graphics can safely
05:54:32 <ski> (can often safely change actual execution order, they are commutative)
05:54:58 <shapr> ski: can you show me code that would create an STRef and then a function to increment its state?
05:55:32 <clausen> ski: but, aren't they operating in the sae world, anyway?
05:55:41 <clausen> (does haskell have a way of separating worlds?)
05:55:47 <ski> well, if you have some main test function (say main or test), use newSTRef in that one to create a new (initialized) box and pass it to tick, und so weiter
05:55:50 * clausen has a dogey M key
05:56:19 <clausen> I guess I should just read more
05:56:57 <ski> clausen : well if they don't affect one another (security breach : the graphics affect humans which affect file-systems ;-)
05:57:18 <clausen> ski: but, how does HASKELL do it?
05:57:55 <clausen> ski: indeed: the file was successfully copied
05:58:37 <ski> clausen : it should be no problem it think (Clean does something like this, i think. Clean is lazy and has typeclasses like haskell. but it has an explicit (not hidden if present at all) World type, because, their type-system can express that some values are linear, i.e. can't be used twice, can't be discarded in any way
05:59:06 <clausen> basically the problem is:
05:59:09 <clausen> main is a monad
05:59:16 <ski> poor ski trying to have two conversations at the same time ;-)
05:59:18 <clausen> how do you join two monads of different worlds?
05:59:23 <clausen> (s/join/compose/)
05:59:25 <clausen> hehe
05:59:48 * shapr humorously guesses: zipWith (++) [monad1,monad2]
05:59:49 <ski> wait a minute, so i can read thru what you are saying, please :-)
06:00:53 <clausen> data World = (part1, part2, part3) ...?
06:01:02 <clausen> and only "use" part1?
06:01:46 <clausen> (actually, you could make a list, and allocate states from the world)
06:01:51 * shapr is able to have many irc conversations and work at the same time
06:01:54 <ski> clausen : main is just magically executed at top-level execution,one can then of course speculate about the philosphical implications of this, and the meaning of two communicating haskell programs with one main each ...
06:02:24 <clausen> ski: well, imagine trying to do:
06:02:47 <clausen> ski: copy_file >>= paint "file arrived"
06:02:52 <ski> data World = *(*Part1,*Part2,*Part3)
06:03:10 <clausen> ski: (copy file1 file2) >>= (paint "file arrived")
06:03:11 <clausen> or whatever
06:03:15 * clausen forgets the notation
06:03:15 <ski> shapr : lucky you
06:03:26 <clausen> what does * mean?
06:03:43 <clausen> anyway, the two different monads
06:03:47 <clausen> are from different worlds
06:03:57 <clausen> (the FS world, and the graphics world)
06:04:01 <ski> well it's clean notation of saying that the type must be used linearly
06:04:24 <clausen> linearly?
06:05:24 <ski> a linear value is one that must be named (used) exactly once, no more, no less (bindings don't count as using but getting)
06:06:02 <clausen> interesting
06:06:11 <ski> it's built-in in Clean's type-system (based on linear logic developed by Girard)
06:06:12 <clausen> strange to put that in a type system
06:07:15 <clausen> anyway, it isn't linear...
06:07:19 <ski> yeah, it can be seen as a little strange, mercury (a logic-proglang with functions) has a mode system, and a think they have incorporated linearity into the mode system instead ..
06:07:22 <clausen> ooops
06:07:24 <clausen> each part isn't linear
06:07:28 <clausen> it may not be accessed at all
06:07:31 <clausen> (eg: no graphics!)
06:07:34 <clausen> hmmm
06:07:45 <clausen> maybe there's an implicit graphics nop?
06:07:47 <ski> whaddya mean, the parts no linear ??
06:08:01 <clausen> mercury is from my uni :)
06:08:12 <ski> both the tuple and it's part is linear
06:08:19 * clausen agrees now
06:08:41 <clausen> well
06:08:48 <clausen> it's easy to implement that way
06:08:55 <clausen> (have a "noop" that "touches" all items)
06:08:58 <ski> hmm, i'm not totally sure about mercury though, it was some time ago i looked upon it, and i may remember wrongly 
06:09:02 <clausen> ooops
06:09:04 <clausen> no, doesn't work
06:09:17 <clausen> no, definitely NOT linear
06:09:24 <clausen> imagine:
06:10:00 <ski> shapr : combining different monads into one unified is a not so simple subject, unfortunately
06:10:19 <clausen> paint :: World -> World
06:10:25 <clausen> copy :: World -> World
06:10:30 <clausen> (for argument's sake)
06:10:56 <clausen> and we have paint >>= copy
06:11:08 <clausen> eeek
06:11:10 <ski> copy . paint
06:11:23 <clausen> ski: yes
06:11:30 <clausen> I'm not really understanding linearity at all
06:11:34 <clausen> anyway
06:11:58 <clausen> (copy . paint) (initGraphics, initFS)
06:12:50 <ski> but some people appareantly have introduced monads in clean anyway, linear type-system can handle state and IO but nondeterminism and Maybe, e.g. , they can still use monads for
06:12:58 <clausen> = copy ([touched initGraphics], [untouched initFS])
06:13:15 <clausen> ski: are there any good URLs?
06:13:27 <ski> or use monads for state and io too, to they don't have to explicitely pass around the world state or local state
06:13:29 <clausen> ski: or do I have to wait till I go back to uni to read journals...?
06:14:41 <clausen> better:
06:14:48 <clausen> imagine just copy (initGraphics, initFS)
06:14:50 <ski> i think there are some good URL, iv'e learned about it by reading the web and Postscript files on it, on my own (and playing a little with Clean)
06:14:54 <clausen> does initGraphics every get "used"?
06:16:02 <ski> i think the toplevel "start-point" in clean should be named Start
06:16:18 <ski> and either just have a pure printable type (like [Int])
06:16:31 <ski> or should have type *World -> *World
06:16:45 <clausen> is that important?
06:16:53 <ski> so the initial run-time system will provide the initial world for it
06:17:23 <clausen> that's just a bureaucratic detail, right?
06:17:35 <clausen> I mean, the whole point of monads is to be able to control execution order
06:17:39 <clausen> in a functional framework
06:17:40 <clausen> (right?)
06:17:48 <ski> i.e. no initGraphics or initFS (for heavens sake, one could create 1000 GB's worth of file-system that way :-)
06:17:49 <clausen> s/execution/evaluation/
06:17:53 <ski> yes
06:18:00 <clausen> initGraphics is just a constant
06:18:18 <clausen> ("representing the initial graphics world state")
06:18:33 <ski> ok, but i'm not sure if the type-system supports linear toplevel constants
06:19:27 <ski> that would mean that the constant could only be used(named) once and after that the name is used up. but again that may be what Clean does
06:20:10 <clausen> so, you reckon clean is good for learning this stuff?
06:20:29 <ski> shapr : have patience, i will answer your inquire about STRef's soon
06:20:38 <shapr> no worries, I'm not in a hurry
06:20:45 <clausen> ski: don't worry about me... I'll google ;)
06:21:25 <ski> well, i suppose so. there are some small research logic langauges that are linear too (typed of course !),i think the name of one of them was Lolli
06:21:54 <ski> Lolli is named after the linear function type constructor which looks like a lollipop :-)
06:22:03 <clausen> hehe
06:22:19 <shapr> ?
06:22:24 <ski> ? ?
06:22:33 <shapr> what's that look like?
06:22:49 <ski> -o
06:22:49 <shapr> does it have a character representation? O-- maybe?
06:22:51 <shapr> oh!
06:22:56 <shapr> ok
06:22:58 <clausen> @- ?
06:23:04 <shapr> *-
06:23:14 <shapr> /\_
06:23:17 <shapr> \/
06:23:21 <shapr> oops
06:23:24 <ski> a -o b is the type of linear functions taking an a and giving an b
06:23:42 <ski> (i forget if the function itself was linear or not)
06:24:41 <ski> in linear logic, theorems are a resource, you can't just prove something, and the carelessy use thay proff many times later as a lemma (or not use it at all)
06:24:56 <ski> an example theorem might be "i have a pizza"
06:25:42 <ski> an example non-linear implication (the implication/function is not linear) is "if i have a pizza => i am not hungry"
06:26:05 <ski> so the conclusion is "i am not hungry"
06:26:31 <ski> but now we can't eat the cake (pizza, sorry) and have it too, can we ?
06:27:17 <ski> so the first theorem is used. if we wan't to use it once more we have to prove it again (i.e. buy or steal or bake a pizza)
06:27:28 <shapr> makes sense
06:29:43 <ski> by the curry-howard isomorphism theorems correspond to types and proofs to programs, and voila we have a linear programming language
06:30:18 <ski> somewhat clear ?
06:30:47 <clausen> this is very surreal
06:30:49 * clausen likes it :)
06:31:05 <ski> it quite interesting, yes ;)
06:32:06 <ski> lets, look back and see what shapr asked ...
06:32:43 <clausen> I don't think my buffer is big enough
06:32:47 <clausen> cut&paste?
06:32:51 <ski> ok, you wanted an example of using tick, didn't you ?
06:32:54 <shapr> yah!
06:32:59 <clausen> ah
06:33:01 <clausen> hehe
06:33:06 <ski> (i cheated and looked at http://tunes.org/~nef/logs/haskell/02.01.09)
06:33:10 <shapr> hopefully I can later expand an example into understanding
06:33:37 <ski> ok lets see..
06:33:49 <ski> here comes :
06:33:51 <shapr> I tried to figure out Monads last night
06:33:59 <ski> test :: [Int]
06:34:06 <ski> test = runST test'
06:34:22 <ski> test' :: ST s [Int]
06:34:44 <ski> (pardon me for using do notation here)
06:35:00 <shapr> no worries
06:35:05 <ski> test' = do counter <- newSTRef 0
06:35:07 <shapr> is foo' do notation?
06:35:58 <ski>            a <- tick counter
06:36:06 <ski>            b <- tick counter
06:36:16 <ski>            c <- readSTRef counter
06:36:24 <ski>            d <- readSTRef counter
06:36:33 <ski>            writeSTRef counter 42
06:36:40 <ski>            e <- readSTRef counter
06:36:47 <ski>            return [a,b,c,d,e]
06:37:11 <ski> the "do-notation" is syntactic sugar for >>= and >>
06:37:16 <ski> you know it ?
06:37:32 <shapr> somewhat
06:37:49 <ski> (test' is just test with a prime, i.e. almost test (another variable name))
06:38:29 <ski> i can write it in core >>= and >> also if you wish ..
06:38:58 <ski> wan't explanation of test' or youv'e got it ?
06:39:47 <ski> shapr : you said you tried to figure out Monads, you mean this ST monad stuff ?
06:40:20 <ski> (i hope now that tick and tick' is type-correct)
06:42:26 <ski> if you know any imperative language with explicit pointers, counter is like a pointer pointing to a box (and the pointer gets passed to tick to it ticks that particular box pointed to)
06:42:53 <ski> (i.e. C is such a language, Pascal and Ada too, methinks)
06:44:17 <ski> anybody still here (problems with smelting this code for your stomach ? ) ?
06:44:51 <ski> hello ?
06:45:26 <ski> ski feels lone and sorry for himself ;->
06:46:29 * clausen still here
06:47:11 <ski> ok, shapr is propably trying the code out or something ...
06:47:54 <ski> me forgot how to make those nice "* name msg" thingies, please tell ski.
06:48:08 <clausen> /me thinks
06:48:11 * clausen thinks
06:48:56 <shapr> sorry, I got distracted by work
06:49:04 <ski> fine, now i also can *-name-msg on IRC (if i recall it to next time, better write it down until i learns it)
06:49:22 * shapr tries out the code
06:50:08 <ski> does it typecheck ?
06:50:33 <ski> clausen_lotr : is lotr a surname ?
06:50:45 <clausen_lotr> lord of the rings
06:51:06 <ski> ok, should have recognised that.
06:51:33 <smkl> is lord of the rings a title like count, duke, etc. ?
06:51:46 <shapr> wow
06:52:30 <ski> well, it's the name of the trilogy by John Roald Reuel Tolkien, in these times cinemized as 3 movies.
06:52:41 <shapr> I'm surprised that in "counter <- newSTRef 0; a <- tick counter" a is zero
06:53:36 <ski> well, if you look at tick, you'll see that it first reads n from the box and then writes (n+1) to the box and then returns _n_, i.e. the value before the update
06:53:42 <ski> change this if you like
06:54:19 * shapr tries to hack tick into do notation
06:54:51 <ski> (i.e to return n+1 or make a local say m = n+1 and both update with m and return m (shared laziness))
06:55:14 <shapr> argh
06:55:14 <ski> should be easy to make into do notation
06:55:18 <shapr> I don't understand do notation well enough
06:55:43 <shapr> I cleaned up http://kungens.kemi.fi/~shae/Hsh.hs only because dennisb helped so much :)
06:55:44 <ski> tell, if you want a more detailed look at the correspondance between do-notation and plain ole >>= and >>
06:55:57 <shapr> yes please!
06:56:09 <shapr> or I could just read "Craft of.." more when I get home
06:56:40 <ski> do { x <- <foo> ; <bar> }  ===  <foo> >>= \x -> <bar>
06:57:05 <ski> do { <foo> ; <bar> } === <foo> >> <bar>
06:57:25 <ski> where <bar> can of course be many "statements"
06:57:31 <shapr> hmm
06:57:35 * shapr tries that on tick
06:57:54 <ski> you can also use a let (with out "in") as a "statement" :
06:58:26 <ski> do { let <bindings> ; <bar> } === let <bindings> in do { <bar> }
06:58:56 <shapr> uhhh
06:59:13 <ski> (oops : previos <bar>s (except last one) should be  do { <bar> } )
06:59:14 <shapr> oh
06:59:44 * shapr blinks
07:00:01 * ski says well ?
07:00:14 <shapr> tick ref = do n <- readSTRef ref
07:00:14 <shapr> 	      () <- writeSTRef ref (n + 1)
07:00:14 <shapr> 	      return n
07:00:18 <shapr> and it works!
07:00:19 <shapr> yay!
07:00:35 * shapr looks for opportunities to use "let" in tick
07:00:51 <shapr> oh, let is for local definitions
07:01:08 <ski> the () <- ... is unneccesary, as with >> if you dont want the returned result, just write ... instead (in this case writeSTRef ref (n + 1) )
07:01:57 <shapr> oh cool
07:02:03 <shapr> spiffy
07:02:12 <ski> if we couldn't use let in that way in do-notation, we'd had to do : do { <foo> ... ; let <bindings> in do { <bar> ... } }
07:02:30 <ski> with nested do-s, irritating right-ward drift
07:02:55 <shapr> I don't understand the difference, but that's because I haven't used let much
07:03:36 <ski> let is useful when you want/need internal names for something and can't make a toplevel or where definition
07:04:52 <ski> i.e. names for pure values. the x <- computaion_returning_monad_type can of course be used for internal names for results from monad computations
07:05:01 <shapr> I didn't know there were occassions in which let is allowed but where isn't allowed
07:05:33 <ski> (don't misunderstand me here : let can be useful both in monadic and non-monadic code)
07:05:45 <shapr> yah, I've used it myself
07:05:49 <shapr> especially in elisp ;)
07:06:00 <ski> where is only allowed after a definition (top-level or internal)
07:06:21 <shapr> oh
07:06:23 <shapr> I see
07:07:20 <ski> speaking of lisps, iv'e written a where macro in scheme because if you have many bindings it can be hard to see where to continue,where is better in this respect (but that scheme-macro-where could of-course be used anywhere like let)
07:08:15 <ski> every definition line for a function can have it's own where (one can't have a where for all pattern definitions of a function)
07:08:15 <shapr> I haven't used Scheme much, sadly :(
07:08:35 <ski> and, where-bound values can be used in guards :-
07:08:39 <ski> :-)
07:09:16 <ski> i think scheme it interesting mostly because of continuations and macros
07:09:24 <shapr> yah, continuations rock
07:09:38 <shapr> Python had a chance to have first class continuations ~ 1 year ago
07:09:52 <shapr> but Guido (the author) chose not to
07:09:56 <ski> i am trying to make a sane pattern-matching macro in scheme, iv'e got it partly working
07:10:07 <shapr> can I play with continuations in Haskell?
07:10:45 <ski> i was under the impression that Stackless Python also implemented continuations
07:12:07 <ski> iv'e asked myself the same thing many times, but primitive continuations can interfere with laziness and produce weird results, as well as destroying referential transparency
07:12:31 <ski> but one can have them like one can have side-effects encapsulated in a monad
07:12:38 <shapr> I see
07:12:44 <ski> it's even possible to define a continuation monad
07:12:53 <shapr> yah, Stackless has continuations, but it's not going to be in the base python
07:13:16 <ski> SML, the New Jersey implementation also has continuations (typed !!), so i play with that sometimes too
07:13:22 <shapr> nifty
07:13:25 <shapr> I'll have to try that
07:13:42 <ski> ok, that's what Guido was deciding about. now i understand
07:13:44 <shapr> Haskell >>= Prolog though
07:13:52 <shapr> ;)
07:13:57 <ski> howdyya mean ?
07:14:06 <shapr> Haskell >>= Prolog >>= any other computer language
07:14:16 <shapr> I've decided to learn logic programming after Haskell
07:14:28 <ski> you mean inter-language calling ?
07:14:35 <ski> ahh, ok.
07:14:46 <shapr> nah, I mean that I won't learn SML until after a logic programming language
07:16:08 <ski> Mercury seems worthwhile (and efficient) to also learn if one wan't to look at LP (logig prog.) (i've only looked at it a little, but it has static types). Ordinary Prolog might perhaps be better to start with anyway.
07:16:22 <ski> ok.
07:16:39 <shapr> I still haven't decided which of those two I'll learn, but I'll worry about it when I get there
07:17:34 <ski> SML is mostly like haskell, but : no laziness, type classes, on the plus side : powerful modules and functors (and cont. in SML/NJ) (and objectoriented functional prog in O'Caml)
07:18:49 <shapr> hm, interesting
07:20:17 <ski> one interesting thing : in a strict language (i.e. SML/NJ or Scheme) with continuations and at least one global state variable, one can embed any monad into the language !!
07:20:37 <shapr> huh?
07:21:01 <ski> e.g.  runNonDet ( 2 * (choose 3 4) )  ==> [6,8]
07:22:24 <ski> choose takes two argument and "returns them both" as if it was only returning one value, then * takes 2 and this value (really 2 values 3,4) and gives the value (values : 6,8), then runNonDet just extracts all possible values in a list
07:22:48 <ski> choose :: a -> a -> a
07:23:21 <ski> so the underlying monad M a is [a] but this is hidden : it just looks like an a
07:24:17 <shapr> that's waaaaay over my head
07:25:05 <ski> (imperative) newbies to haskell often complain that they can't write "length getLine" but instead "do { l <- getLine ; return (length l) }", this would sort of cure this problem in a strict language (not haskell)
07:25:30 <ski> well, i don't understand it very much either, but it's cool man !
07:25:35 <shapr> heh
07:25:37 <shapr> I believe you :)
07:26:06 <ski> things like this i have read i various research papers for fun
07:26:29 <ski> like you read about arrows by John Hughes
07:29:09 <ski> well, just one thing about arrows, late in his paper he discusses a CGI arrow that has a function that get response string from the user and return it to the program. but actually that function shuts down the whole program and generated a html page and then starts up again when the user submits info and restarts from where it left off : amazing
07:29:52 <shapr> I haven't gotten past the part of the arrows paper where he talks about monads
07:29:58 <shapr> I just don't grok them yet
07:30:07 <ski> but i better stop talking about these things right now. have you any more plans for your program with tick ?
07:31:01 <ski> it took some time for me to grok monads, well one don't have to grok them to use them practically, but i wanted to understand them.
07:31:39 <shapr> yah, same here
07:31:58 <shapr> I'll be able to play with the tick program again later tonite, but I have to do useful work now 
07:32:07 <ski> especially if one want to experiment with own monads
07:32:19 <ski> ok, you'll go soon ?
07:32:26 <shapr> no, I'll be here but silent :)
07:32:35 <shapr> I go home in about an hour
07:33:11 <ski> ok, before that : you said something about a dir() function in Python and wanted it in ghci, right ?
07:33:24 <shapr> right
07:33:32 <shapr> you know of such a thing?
07:33:41 <ski> no. what does it do ?
07:34:18 <shapr> in python, if I've done "import string" I can do dir() and I see string, and I can do "type(string)" and I get type Module
07:34:22 <shapr> and I can do x = 1
07:34:30 <ski> (one more thing i thought of previously : can't you use ord instead of Char.ord if you have imported Char ?)
07:34:33 <shapr> and dir() will then show "string, x"
07:34:48 <shapr> ski: I *should* be able to ,but ghci didn't let me
07:35:45 <ski> like :b in hugs, no ?
07:36:22 <shapr> I dunno, never tried it
07:36:47 <ski> it doesn't seem to work with ghci, though.
07:37:51 <ski> well, i think i'll go silent now, if noone call for my attention, i won't leave right now, though
07:38:08 <shapr> ok, thanks much for your help!
07:38:34 <ski> the pleasure is on my side :-)
07:38:53 * ski takes a deep breath
08:57:40 <ski> goodby, shapr. see you some other day
09:22:24 <ski> i'll quit now
10:56:40 <shapr> hi!
11:03:44 <shapr> bye...
13:54:25 <shapr> hi kepler 
14:00:28 <kepler> hi
14:00:46 <shapr> what's up?
14:00:59 <kepler> not much
14:01:18 <shapr> written any haskell code lately?
14:01:19 <kepler> you mentioned the other day that you hadn't seen me in here before...  that's strange, because I'm here all the time :)
14:01:36 <shapr> maybe I haven't spoken to you much...
14:01:47 <kepler> I am an intermediate haskell person...  I am trying to design and implement a language of my own
14:01:57 <kepler> I am implementing in haskell
14:02:34 <shapr> oh cool, do you have a prototype online?
14:02:51 <kepler> no prototype, it is hard to implement things! :)
14:03:51 <kepler> are you an experienced haskeller?
14:04:29 <shapr> no, I'm just a beginner
