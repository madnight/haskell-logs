00:02:02 <shapr> hi jlb 
00:02:12 <jlb> Hi shapr, how goes?
00:02:21 <shapr> pretty well, how are you?
00:03:00 <jlb> Not too bad. Haven't had much chance to play w/ Haskell recently. :)
00:03:54 * Yurik is thinking to switch from Erlang to Haskell in his current project
00:04:53 * Yurik haven't decided yet
00:08:07 <Yurik> probably will
00:08:56 <juhp> Yurik: can you tell us about it?
00:10:17 <shapr> yah, what kind of project is it?
00:10:28 <Yurik> juhp I'm the current coordinator of an E/AS project that is aimed to create an opensource framework for enterprise automation needs
00:10:49 <shapr> what's E/AS?
00:11:03 <shapr> Enterprise/Application Server?
00:11:07 <Yurik> shapr Enterprise / Automation System
00:11:24 <shapr> aha
00:11:28 <shapr> I guessed well :)
00:11:37 <Yurik> we're trying to attain a next-generation solution for an enterprise management
00:12:29 <shapr> what does that mean in programmer terms?
00:12:29 <juhp> sounds interesting
00:12:32 <juhp> are you being sponsored to do this?
00:12:44 <shapr> yah, good question
00:12:50 <juhp> i don't know much about E/AS
00:13:20 <Yurik> juhp we are sponsored only a little - hosting and part of time spent by one of our participants
00:13:51 <juhp> ok, just curious
00:14:06 <juhp> what kind of things are you planning to do?
00:14:10 <Yurik> shapr well, in programmer terms? we're assemblying various substances in the common object tree; where objects are built in delegation manner
00:15:18 <Yurik> juhp it depends on the projection of the view. At low level, we'll develop the system that will "run" objects; the another part is a huge object tree of pre-packaged objects that should be useful for the custom solution development
00:16:32 <Yurik> shapr I guess you know what delegation is (prototypical objects, shared behavour are the keywords ;)
00:17:09 <shapr> yup
00:17:22 <shapr> I wish Self had a non-SPARC version
00:17:39 <Yurik> shapr Yep, it is partially inspired by Self :-)
00:17:49 <Yurik> shapr and Henry Lieberman's publication :-)
00:17:59 <Yurik> shapr and my and collegaues ideas 
00:18:09 <Yurik> s/by/from/
00:18:13 <shapr> Lieberman I don't know
00:18:17 <shapr> I'll have to read up on him
00:18:36 <shapr> I *do* think that separate class and object trees is non-orthogonal
00:18:41 <shapr> but most people disagree with me
00:18:58 * Yurik even dislikes class-based OOP
00:19:40 <Yurik> Well, Lieberam just wrote good article about sharing the behaviour, nothing special
00:19:48 <Yurik> s/Lieberam/Lieberman/
00:19:48 <shapr> I don't have enough experience with anything else to give a good opnion
00:20:08 <shapr> I've used Python and Java for commercial development
00:20:22 <Yurik> shapr me too (Python and Java)
00:20:38 <shapr> but never any functional languages
00:20:48 <shapr> Haskell seems to have incredible potential
00:20:54 <Yurik> but now I'd like to use functional programming and studied for few of them
00:21:25 <juhp> btw Yurik, have you looked at hs-corba and jvm-bridge?
00:21:32 <Yurik> juhp nope yet
00:21:41 <Yurik> juhp what for? :-)
00:21:42 <shapr> yah, functional programming seems to be far more orthogonal because of referential transparency, and higher-order functions as basic principles
00:21:56 <juhp> but you're aware of them  I guess
00:22:30 <Yurik> juhp may be just to make external bridges in E/AS
00:22:56 <Yurik> juhp internal development will be programmed in Erlang or Haskell; probably Haskell
00:23:03 <juhp> Yurik: just thought they seemed vaguely related to what you're doing
00:23:19 <juhp> haskell is nice :)
00:23:40 <Yurik> juhp yep, nicer than Erlang; but lacks of few interesting Erlang features :-)
00:23:56 <juhp> hmmm
00:24:14 <juhp> like distributed processes?
00:24:21 <shapr> Erlang has a large corporation behind it, and distributed processes
00:24:36 <Yurik> just like hot code replacement, huge reliability and distributed process (the most important thing, I guess)
00:24:48 <shapr> but Haskell has more smart people at the top, and Concurrent Haskell
00:25:26 <Yurik> afair, Erlang had no HOF at the start :-)
00:25:37 <shapr> oh, I didn't know that.
00:25:59 <juhp> "HOF"?
00:26:00 <shapr> I think I'd like to learn Erlang, but it's on my list after Haskell, Joy, and Mercury
00:26:04 <shapr> higher-order-functions
00:26:05 <Yurik> High Order Functions
00:26:19 <juhp> ah, those...
00:26:29 <Yurik> but now erlang has HOF
00:26:58 <Yurik> but it requires interpreter to be supplied with program to run it :-(
00:27:11 <shapr> I didn't know that
00:28:14 <Yurik> I guess Haskell is suitable for large software systems, right?
00:29:34 <Yurik> Of course, not bloatwared, but structured and designed in reasonable way
00:32:22 <shapr> I think so
00:32:32 <Yurik> good
00:32:35 <shapr> you should decide for yourself of course :)
00:33:07 <Heffalump> there's not really very many major software systems written with it, though
00:33:10 <Yurik> my experiments says so :-)
00:33:28 <Yurik> of course, small experimets :-)
00:34:05 <shapr> Heffalump: what major systems do you know of?
00:34:18 <Heffalump> in fact, I only know of GHC and the project at Durham on natural language
00:35:10 <shapr> well, ya gotta start somewhere
00:36:54 * Yurik is thinking...
00:40:18 * shapr is sleeping on his keyboard
00:40:24 * Yurik likes Haskell... but what developers will say?..
00:40:35 <juhp> ;)
00:40:47 <shapr> if the developers can use Erlang, I think they will be okay with Haskell
00:40:53 <Yurik> shapr your face will be in squares :]
00:40:59 <shapr> heh, yes it will
00:41:02 <Yurik> shapr yeah, probably :-)
00:41:27 <juhp> give them "A Gentle Introduction to Haskell"!
00:42:06 <shapr> and maybe we can test them out on the Haskell tutorial as well
00:42:14 <Yurik> juhp yes, quite good tutorial, I used it :-)
00:42:36 <shapr> there's a second tutorial starting up
00:43:50 <Yurik> great :)
00:44:18 <juhp> there is?
00:44:40 <shapr> yes
00:44:46 <juhp> do you mean loty thing?
00:44:55 <shapr> yah, that one
00:45:00 <shapr> well, kind of
00:45:04 <juhp>            ^the
00:45:06 <shapr> I have set up a mailing list for discussions about the new tutorial.
00:45:07 <shapr> If you are interested in participating, please subscribe to the list
00:45:07 <shapr> by sending email to the following address:
00:45:07 <shapr>     htut2-subscribe@moertel.com
00:45:13 <shapr> that's from Tom Moertel
00:45:38 <juhp> ok, thanks
00:45:48 <shapr> reason is that I personally thought the Haskell Tutorial was too hard, even the gentle introduction
00:45:59 <shapr> for me it was more like a rock to the head =)
00:46:22 <shapr> but I think that's because I have almost zero functional programming experience
00:46:53 * Yurik studied Haskell basics after Ocaml and Erlang :-)
00:47:02 <shapr> I have a friend on #emacs who would like to learn Haskell, but he's blind, and so he can't buy a book
00:47:09 <shapr> there aren't any Haskell books in braille
00:48:33 <shapr> so I asked for a tutorial that starts with the assumption that I am a procedural programmer only.
00:50:59 <juhp> there must be browsers for blind people
00:51:08 <shapr> there are
00:51:45 <shapr> it seemed to me that the gentle introduction was not gentle enough
00:53:12 <shapr> so I figured something needed to be available that was easier to start with, that filled in more of the basics that might be missing
00:53:39 <shapr> happily, several other people on the haskell list agreed, now we have a new tutorial project! yay!
00:56:05 <shapr> Dmitry from britishairways.com sent me the ASN.1 code he wrote, it's *nice*
00:56:10 <shapr> very elegant
00:56:29 <shapr> er, dominic
00:56:30 <shapr> sorry :)
00:58:12 <shapr> Yurik: what kind of functionality should be in an A/ES server?
00:58:31 <shapr> ahem, E/AS
00:59:10 <Yurik> shapr we have no server in the usual meaning :-)
00:59:15 <shapr> oh
00:59:27 * shapr googles
01:01:34 <Yurik> E/AS is designed as a distributed object system; with plenty repositories that could be started
01:03:43 <Yurik> if you're interested, you can visit www.openeas.org and download current snapshot of the definitive specification (please note that it will be restructured and rewritten in some places soon). Also it is incomplete now :-)
01:06:33 <shapr> hey, this has some similarities to stuff I've thought of recently
01:07:18 <shapr> though I came up with different features, and a different system from the same problem
01:12:00 <shapr> I noticed that taxis here are expensive, but if you get four people in one taxi, it's cheaper than a bus ticket, and a lot more convenient
01:12:55 <shapr> I thought of a software system in which people could arrange to go somewhere at a certain time
01:13:36 <shapr> if enough people started using the system, you'd get something between taxis and buses
01:46:56 <shapr> hi jemfinch_ 
01:50:47 <shapr> hi jewel!!
02:02:55 <jewel> mornin
02:03:14 <shapr> what's up?
02:05:17 <jewel> writing reports for our clients
02:05:24 <jewel> to prove that we've done work 
02:05:26 <jewel> :-)
03:34:16 <cuelebre> hi !
03:35:10 <Heffalump> hi
03:36:48 <Mhadi> Lo
03:37:02 <shapr> hi
03:37:04 <shapr> what's up?
03:37:40 <shapr> Mhadi: are you an experienced haskeller? or are you learning Haskell?
03:37:57 <Mhadi> i got a question about patterns... i'm starting to learn haskell
03:39:00 <Mhadi> is it possible to use pattern on Strings like this foo :: String -> Int \n foo (begin:'f':
03:39:13 <Mhadi> soz.. that was incomplete
03:39:32 <Mhadi> is it possible to use pattern on Strings like this foo :: String -> Int \n foo (begin:'f':'o':'o':end) foo begin + foo end
03:39:49 <Heffalump> umm
03:40:01 <Heffalump> definitions need an = *somewhere*
03:40:34 <Mhadi> ah, yes, ...) = foo begin + foo end
03:40:57 <Mhadi> i know it doesn't work that way
03:41:26 <Mhadi> but i need it like this but don't know the correct syntax
03:42:26 <Mhadi> foo (begin:'f':'o':'o':end)  = foo [front] + foo end  <- this i can load in hugs but doesnt work....
03:42:43 <Mhadi> s/front/begin
03:43:30 <Heffalump> umm, do you have any other cases for foo?
03:43:47 <Mhadi> yeah
03:43:58 <Mhadi> the provblem is that begin and end need to be Strings
03:44:19 <Heffalump> you can't do that with pattern matching, sorry
03:44:39 <Mhadi> hmm
03:45:04 <Mhadi> it would have been great to write my programm that way :-(
03:45:39 <Heffalump> pattern matching needs to be deterministic - either it fails or only returns one result
03:45:57 <Heffalump> but if "foo" was in your string multiple times, there'd be more than one possible result
03:46:19 <Mhadi> ah
03:46:26 <Heffalump> [the precise reason is slightly more subtle, but that's what it comes down to in this case]
03:47:17 <Heffalump> what is the intended behaviour if "foo" does occur multiple times?
03:47:51 <Mhadi> hmm, it could do anything...
03:48:53 <Mhadi> it's a simple trainee task that doesn't need to handle 'special situations'
03:55:24 * shapr reads up on S and K combinators
03:56:17 <Logan> Whew, I'm hungry!
03:57:01 <shapr> me too
03:57:17 <Logan> Fortunately I'm finally awake at a time when a few places are open. :P
03:58:01 <Mhadi> btw is there any easier style to write 'f':'o':'o':end (f.e. like "foo":end)?
04:00:48 <Logan> I think "foo":end would work if end where a list of lists of chars. :P
04:01:15 <Mhadi> lol
04:02:19 <Logan> So if you don't care about whitespace in the string, and are actually looking for the word foo instead of the substring foo, what I said might be useful.
04:02:24 <Logan> But it's probably not. :P
04:03:06 <Mhadi> i'll try to remember :)
04:03:49 <Logan> I'd just do: foo str = if length str > 2 then if take 3 str == "foo" then foo (drop 3 str) else foo (tail str)
04:03:52 <Logan> Or osmething like that.
04:03:58 <Logan> I left out the trailing else, but you get the idea.
04:05:29 <Igloo> You can do   s | take 3 s == "foo"
04:05:42 <Mhadi> i'm  a real haskell newbie so i don't understand it completely...and i may only use patterns...
04:06:19 <Logan> You could use three functions that work together, the first one calls the second one on tail str if the head is 'f', the second one calls the third one when it sees 'o', etc.... :P
04:06:52 <Logan> Doesn't allow any sort of reuse, though, if you ever want to do the same thing with a string other than "foo"
04:07:21 <Mhadi> and max 50 declarations for the whole programm... and the strings arent that short as foo is
04:07:50 <Logan> Ok, so you want an arbitrary function that does something if "foo" is a substring of the string?
04:07:57 <Logan> Or do you just want to detect that case?
04:08:02 <Logan> Or do something every time the substring foo is encountered?
04:08:23 <Mhadi> i need to convert written Numbers in Ints
04:08:43 <Logan> Would the read function work?
04:09:21 <Mhadi> i have to implement it only with patterns... that's the task
04:09:36 <Logan> I don't really know what that means. :P
04:09:46 <Logan> Patterns don't do anything but direct program flow, I guess.
04:11:49 <Mhadi> hmm, i have to use patterns to distinguish the different cases and * / + to create the Int
04:13:41 <Logan> Hmm... here's how I'd interpret the problem...
04:13:47 <Logan> You use a pattern to take the head character.
04:13:50 <Logan> Then check if it is a digit.
04:14:11 <Logan> Hmm, you have to chedck two digits ahead, though.
04:14:40 <Mhadi> i need to convert "hundred" in 100 and so on...
04:18:36 <Mhadi> are there any wildmarks for pattern matching?
04:21:02 <Logan> There's _
04:21:30 <Logan> If you split the string up into a list of words, you can do what you want.
04:22:01 <Logan> You're translating a text description of a number to an Int, I take it?
04:22:09 <Mhadi> yes
04:22:21 <Logan> Ok, I would use the words function to split a string into a list of strings.
04:22:25 <Logan> THen you can do pattern matching on strings.
04:22:33 <Logan> Like ("hundred":x)
04:23:08 <Mhadi> i dunno the words function and so i may not use it
04:24:02 <Logan> You can't use functions from the prelude?
04:24:45 <Mhadi> i can but i'm not allowed to
04:25:03 <Logan> Sounds like a dumb project to me, then. :P
04:25:19 <Logan> You could easily write your own words function.
04:26:09 <Mhadi> i may only use 50 declarations... and i have to write the program only to learn pattern matching
04:26:31 <Logan> I'm glad I'm not learning haskell in class. :P
04:26:41 <Mhadi> hehe
04:30:34 <shapr> me too
04:31:06 <Logan> It's going to suck when I have to start implementing things in particular languages for programming languages.
04:31:13 <shapr> why?
04:31:32 <Logan> Well, if this professor does the same thing he did back in comparative languages, the first project will have to be done in pascal.
04:31:36 <Logan> That's bad enough. :P
04:31:40 <shapr> aieee
04:31:42 <shapr> I see your point
04:32:04 <Logan> It's fun when the languages are new to me.
04:32:17 <Logan> But I think that, at best, only one project this semester will be in a language I haven't used.
04:32:35 <Logan> Hmm, maybe none at all.
04:32:39 <shapr> which language?
04:32:50 <Logan> There might be one in Standard ML.
04:32:53 <Logan> But I'm not sure.
04:33:34 <Logan> Hmm, last year it seems there was just a scheme and a prolog project.
04:35:17 <Logan> Today
04:35:18 <Logan> Mostly sunny and warm. Near record highs 63 to 68. Southwest wind 5 to 10 mph.
04:35:21 <Logan> Jesus!
04:35:59 <Logan> Right now it's below freezing, though.
04:36:02 * Logan walks to get some food.
05:01:03 * shapr sings
05:01:41 * Logan needs some music.
09:39:00 <shapr> wheeee
09:44:42 <Heffalump> splat
09:46:27 <shapr> oof
09:46:33 <shapr> gotta be careful of those landings
09:58:26 <shapr> hi Shanoss 
09:58:29 <shapr> what's up?
09:58:34 <Shanoss> hi
09:58:58 * shapr blinks
09:59:01 * shapr shrugs
10:12:04 * Logan needs to learn how to do exceptions.
10:13:10 <Mhadi> lo
10:13:32 <shapr> hiya
10:13:35 * shapr gets silly
10:13:40 <Logan> Hmm, to implement some sort of exception mechanism, do I have to use a monad?
10:13:44 <shapr> Haskellachu! Kick in the Monads attack!!
10:14:59 <Heffalump> logan: think so
10:15:05 <Logan> Hmm.
10:15:16 <Logan> Oh, I could just use Maybe.
10:15:20 <Heffalump> (I'm not sure about the imprecise exceptions stuff, but normal exceptions certainly don't really work outside a Monad)
10:15:22 <Heffalump> yeah
10:15:23 <shapr> are you sure? =)
10:15:27 <Logan> I suppose it's there for just this purpose. :P
10:15:29 <Heffalump> (in fact that's actually a Monad too :-)
10:15:35 * Logan nods.
10:15:39 * shapr thinks Maybe jokes are silly but funny
10:15:39 <Logan> A monad I don't have to implement. :P
10:15:40 <Heffalump> logan: not exactly, but that's one of the purposes :-)
10:15:42 <Logan> Or really understand.
10:16:43 <Heffalump> true
10:16:53 <Heffalump> have a go at writing stuff in do syntax though
10:16:59 <Heffalump> it'll make it easier if you later want something more complex
10:17:32 <Logan> I have written stuff in do syntax.
10:17:43 <Logan> I find it a pain because I don't understand completely what I can do.
10:17:57 <shapr> programming by coincidence does suck
10:17:59 <Logan> But I manage to do IO. :P
10:18:22 * Logan uses [[[Char]]]
10:18:44 <shapr> Haskellachu! brackets attack!
10:19:11 <Igloo> Is it really a [[[Char]]] or a [[String]]?
10:19:31 <shapr> Lispachu! parentheses attack!
10:19:31 <Logan> What's the difference? :P
10:20:37 <Igloo> ['a'..'z'] is a list of characters but "the alphabet" is a string
10:21:13 <Igloo> It's a difference from a human PoV - sensible type signatures make it easier to understand
10:21:20 <Logan> Sure.
10:21:28 <Logan> I'm actually calling it a [[Cell]], but Cell is just a String. :P
10:21:35 <Igloo> :-)
10:21:40 <Heffalump> String is a type synonym, so it's always really [[[Char]]]
10:21:47 <Heffalump> so :-p to you.
10:22:03 <Logan> 17 C now.
10:22:10 <Logan> That's why I said [[[Char]]]! :P
10:22:26 <Heffalump> but Igloo's point is correct, and yours is even more correct.
10:22:55 <Logan> Haha, I'm more correct than Igloo!
10:23:35 <Igloo> Only in Heffalump's opinion  :-)
10:24:10 <Heffalump> which is clearly important to Igloo, as he consults it frequently :-p
10:26:50 <Igloo> I could point out that the last 2 times it hasn't been very fruitful  :-)
10:26:51 <Logan> Haha.
10:27:00 <Igloo> (and carefully not mention that most of the time it is)
10:27:25 <Heffalump> well, s/most/some/
10:27:47 * shapr bounces around happily
10:27:53 <Heffalump> shapr: got something working?
10:28:04 <shapr> er, no
10:28:11 <Igloo> :-)
10:28:12 <shapr> but I feel happy anyway.
10:30:53 <Logan> Easy question:  How do I convert 'A'..'Z' to 0..25 ?
10:31:07 <shapr> chr or ord
10:31:10 <shapr> I forget which
10:31:16 <Logan> Makes sense.
10:31:19 <Logan> I'm guessing ord.
10:31:26 <shapr> you may have to do "import Char" and then Char.ord
10:31:41 <Heffalump> if you do import Char then you can just use ord
10:31:47 <Heffalump> if you do import qualified Char then you need Char.ord
10:32:00 <Heffalump> (assuming it *is* in Char, ISTR it being in the Prelude anyway)
10:36:11 <Logan> It's Char.ord
10:54:23 <Logan> The thing I hate about most non-C languages is the lack of printf. :P
10:54:42 <Logan> How might I output an int right-aligned with a field width of 7?
10:54:56 <Logan> (besides doing a show and padding it on the left to make it 7 characters in length, which isn't too hard to do)
10:55:07 <Logan> I guess this can go in my Logan module. :P
10:55:11 <Heffalump> I suspect that might be easiest
10:56:38 * Logan nods.
10:57:01 <Logan> I would do well with a generic function for padding a string to be a certain length (with left or right alignment).
10:57:05 <Logan> And it's so easy to write in haskell.
10:57:12 <Logan> take n $ repeat ' '
10:57:13 <Logan> *grin*
10:57:27 <Igloo> == replicate n ' '
10:57:29 <Logan> Actually, I think there's a function in the p...
10:57:30 <Logan> Yeah. :P
10:57:52 <Logan> I love lazy evaluation.
10:57:56 <shapr> me too!!
10:58:31 <Logan> Time for some food, bbl.
12:44:47 <ski> Hello all again !
12:45:28 <ski> No discussion right now ? :(
12:45:46 <Logan> Doesn't seem to be.
12:45:56 <Logan> I was the last one to talk and that was almost two hours ago.
12:47:40 <ski> It seems you were discussing chr,ord and alphabet, lists and a little lazy evaluation then, right ?
12:49:42 <ski> And a little exceptions, monads and Maybe and IO and do-syntax.
12:50:54 <Logan> Yeah.
12:50:59 <Logan> And then I went to eat. :P
12:52:12 <ski> So if you have anything to ask/comment/talk about, i'll gladly try to contribute to a discussion.
12:53:00 <ski> I'm not sure if i've seen you here before. Are you relatively new here ?
12:54:13 <ski> I haven't been here for a long time, and i'm often here irregularily.
13:00:37 * xbill chuckles at the triple of combinators.
13:01:02 <ski> xbill : what combinators ?
13:01:07 <Logan> Yeah, I've only been here a week or so.
13:01:15 <Logan> What exactly is a combinator?
13:01:43 <ski> Ok, iv'e been here some month or so, but not most of the time :(
13:01:51 <ski> A combinator ?
13:02:14 <ski> I don't know what xbill was talking about, but ..
13:02:17 <xbill> S, K, and I combinators
13:03:20 <ski> a combinator is a function which you combines some data or program pieces to larger pieces. Like map,filter,foldr, etc e.g. in haskell.
13:04:34 <ski> xbill : aha, the S, K, I combinators. but I can be defined as S K K (or S K x for any x), so it needen't be a triple.
13:07:01 <Heffalump> it just makes programs using them even longer :-)
13:08:56 <ski> they're (SKI ... i.e) theoretically interesting. i.e. one can program without variables. and i think combinator graph reduction is an implementation form for lazily pure functional languages.
13:09:39 <ski> they behave a bit like an environment monad (data Env e a = Env (e -> a))
13:13:42 <ski> higher-order functions is most often used as (more mundane example) of combinators. I.e instead of explicitely setting up a (usually) loop (imperative style or recursive style), you make some small functions for manipulating just a piece or case of the data/problem and then pass them to the combinator and let it do the job once and for all of building the correct kind of control structure (e.g. loop).
13:20:02 <dennisb> actually, you just need one combinator (usually called X) to express all the others
13:20:26 <Heffalump> what is that as a lambda-term?
13:20:32 <ski> hmm, is that really possible ? (iv'e tried a little but not succeeded :( )
13:20:54 <dennisb> I don't know right away, but it should not be so hard to figure out
13:21:15 <dennisb> S = X (X X)   and K = (X X) X, or the other way around
13:21:24 <ski> it needs to duplicate some argument to it (for constructing S) and to ignore some other argument (to implement K)
13:22:11 <Heffalump> X = \x.xKSK
13:22:17 <Heffalump> (from google)
13:22:17 <ski> maybe one can solve that equation system in a way similar to other equation systems ??
13:23:11 <ski> Heffalump : X = \x.((x K) S) K  ? is that what you mean ?
13:23:17 <dennisb> yes
13:23:34 <ski> lemme see ..
13:23:42 <Heffalump> ski: lambda-calculus is like most FP, it associates to the left
13:23:45 <Heffalump> so yes
13:24:05 <Heffalump> sorry, application associates to the left and lambda-abstraction to the right
13:25:12 <ski> XX = X X = (\x.x K S K) (\x.x K S K) = (\x.x K S K) K S K = K K S K S K =
13:25:43 <ski> K K S K = K K  (is this correct)
13:26:45 <Heffalump> looks right
13:27:20 <ski> Heffalump : i was a little confused because of no juxta-position space inbetween
13:27:46 <Heffalump> ski: ah, ok, it's standard to leave it out in lambda-calculus cos everything is one letter anyway
13:28:26 <ski> so X (X X) = X XX = X (K K) = (\x.x K S K) (K K) = K K K S K = K S K = S
13:28:32 <Heffalump> yep
13:28:51 <ski> and (X X) X = XX X = (K K) X = K K = K
13:28:55 <Heffalump> yep
13:29:05 <ski> goood, this really work :)
13:29:13 <Heffalump> :-)
13:29:23 * ski is happy to have learned a new thing
13:29:45 <dennisb> except the last step where the K K should be removed
13:29:46 <Heffalump> right, now translate Y = (\x.xx)(\x.xx) into X
13:29:54 <Heffalump> oh, yes, sorry
13:30:07 <Heffalump> [that is Y and not W isn't it?]
13:30:34 * dennisb is leaving for the night
13:30:36 <dennisb> bye
13:30:45 <ski> Heffalump : most often when i write lambda-calculus terms i don't just use one-letter-names, but instead one-letter-and-zero-or-more-alphanumerics
13:30:51 <ski> bye dennisb
13:30:57 <Heffalump> right
13:31:16 <ski> thats omega (big one) !
13:32:17 <ski> ooops, yes it should have been  ... = (K K) X = K  of course. thanks for correcting my mistake.
13:35:14 <ski> so w (little omega sometimes) = \x.x x = S I I (doesn't everybody know this :-P) = S (S K _) (S K _) (where _ can be anything) =
13:36:15 <ski> = X (X X) (X (X X) (X X X) X) (X (X X) (X X X))  correct ?
13:36:36 <ski> so Omega (big one) = w w = X (X X) (X (X X) (X X X) X) (X (X X) (X X X)) (X (X X) (X (X X) (X X X) X) (X (X X) (X X X)))  correct ?
13:38:51 <ski> oops, detected mistake : w is of course X (X X) (X (X X) (X X X) X) (X (X X) (X X X) *X*)
13:38:58 <Heffalump> yep, about to say that :-)
13:39:18 <Heffalump> hmm, it's shorter than I thought it would be
13:39:31 <ski> so Omega becomes X (X X) (X (X X) (X X X) X) (X (X X) (X X X) X) (X (X X) (X (X X) (X X X) X) (X (X X) (X X X) X))
13:40:20 <Heffalump> all that to get recursion, and you can't even *do* anything with it :-)
13:40:35 <ski> it's perhaps possible to optimise/shorten a bit more if one know the perhaps applying simplifications (like I = S K x for any x (here i choosed X))
13:41:09 <ski> though, Heffalump, this is Omega, not Y. shall we make a try at Y also ?
13:41:42 <Heffalump> go on then :-)
13:41:52 <ski> which one ? the normal order or applicative order version (normal order is smaller)
13:42:12 <Heffalump> Y = \w.(\x.wxx)(\x.wxx)
13:42:15 <Heffalump> is the one I'm think of
13:42:54 * Heffalump has forgotten what normal order and applicative order are, let alone how they affect how you write recursion combinators
13:44:11 <ski> normal order is more or less equivalent to lazy (at least for this discussion) and applicative order corresponds to strict language
13:44:36 <Heffalump> normal order is outermost without the graph reduction and applicative is innermost, then?
13:44:57 <ski> normal order Y don't work in strict language so we have to make a little more complicated (and a little less general), because of no laziness
13:45:16 <ski> yea, more ore less, i seem to recall.
13:45:58 <Heffalump> hmm, my knowledge is this rusty when I work in academia, I wonder what it'll be like if/when I leave :-)
13:46:13 <ski> so your Y = \w.(\x.wxx)(\x.wxx) is normal order
13:46:17 <Heffalump> yep
13:46:25 <Heffalump> it'd break rather badly in innermost :-)
13:46:38 <ski> no, oops it should be \w.(\x.w(xx))(\x.w(xx))
13:47:16 <Heffalump> oh yes, duh.
13:47:35 <ski> though i am used to write Y as \f.(\g.f (g g))(\g.f (g g)) or just simply \f.(\t.t t)(\g.f (g g))
13:47:53 <Heffalump> well, the latter is slightly simpler
13:48:18 <ski> shall we try with the last one to tranform it into S,K and I and then subsequently into X ?
13:48:25 * Heffalump fails to remember the translation rules into SK too
13:48:58 <ski> well \t.t t is just S I I (i.e. w or little omega)
13:49:42 <ski> g g becomes S (K g) (K g), right ?
13:51:06 <Heffalump> ummm
13:52:00 <Heffalump> \g.f(gg) = S(\g.f)(\g.gg) = S(Kf)(SII)
13:52:03 <Heffalump> I think
13:52:59 <ski> and then f (g g) = f (S (K g) (K g)) = S (K f) (S (S (K S) (S (K K) (K g))) (S (K K) (K g)))  yuurgh how fast it grows :(
13:53:19 <ski> lemme se what you wrote ..
13:53:38 <Heffalump> oh, starting at the wrong end anyway
13:53:40 * Heffalump starts from the outside
13:53:51 <Heffalump> (what I wrote is right but it doesn't help hugely)
13:54:44 <Heffalump> oh, it might
13:54:44 <ski> doesn't it help ? it looks much better (shorter) than my attempt
13:55:05 * Heffalump is cheating by using the translation rules in http://www.ioccc.org/1998/fanf.hint
13:55:20 <Heffalump> (which are the standard ones)
13:55:34 <ski> hmm, perhaps not, because mine does thread f down while you hadn't started that yet ..
13:55:57 <Heffalump> \f.(\t.tt)(\g.f(gg)) = S(\f.\t.tt)(\f.\g.f(gg))
13:57:25 <Heffalump> \f.\t.tt = \f.SII = S(\f.SI)(\f.I) = S(SSI)(KI)
13:57:29 <ski> this would be much easier if we could use C and B (and had an X to implement C,B,K,S with)
13:58:52 <Heffalump> \f.\g.f(gg) = \f.S(Kf)(SII) = S(\f.S(Kf))(\f.SII) = S(S(\f.S)(\f.Kf))(S(SSI)(KI))
13:59:07 <Heffalump> oops
13:59:14 <Heffalump> oh, unoops
13:59:40 <Heffalump> = S(S(KS)(S(KK)(SI)))(S(SSI)(KI))
14:00:14 <Heffalump> so Y = S(S(SSI)(KI))(S((S(KS)(S(KK)(SI)))(S(SSI)(KI)))
14:00:20 <Heffalump> how's that look?
14:00:56 * Heffalump decides to check it
14:02:10 <Heffalump> and realises that doing so automatically might be tricky
14:02:15 <ski> hmm is S(\f.SI)(\f.I) really S(SSI)(KI), lemme see ..  isn't \f.SI = S(KS)(KI) and not SSI ?
14:02:43 <Heffalump> oops. yes.
14:02:47 <ski> looking at the rest now.
14:03:16 <ski> ( so \f.\t.tt = S(S(KS)(KI))(KI) and not S(SSI)(KI) )
14:03:26 <Heffalump> yeah, and two bits end up wrong in my answer
14:04:03 <Heffalump> Y = S(S(S(KS)(KI))(KI))(S((S(KS)(S(KK)(SI)))(S(S(KS)(KI))(KI)))
14:08:40 <ski> likewise, isn't \f.Kf = S(KK)I /= S(KK)(SI))  (in \f.\g.f(gg) = ...) ?
14:09:26 <Heffalump> yes.
14:09:41 <Heffalump> see why I need to check this? (/me distracted writing a short Haskell program to do this)
14:11:07 <ski> and isn't \f.SII = S(S(KS)(KI))(KI) /= S(SSI)(KI)  (in same derivation) ?
14:11:54 <Heffalump> yes, I corrected that when you pointed out my original error
14:12:01 <Heffalump> [22:03] <Heffalump> yeah, and two bits end up wrong in my answer
14:13:38 <ski> so that makes \f.\g.f(gg) = \f.S(Kf)(SII) = S(\f.S(Kf))(\f.SII) = S(S(KS)(S(KK)I))(S(S(KS)(KI))(KI))  right ?
14:13:57 <ski> ok, heard ya.
14:14:54 * ski have played a little with compiling lambda-calc. into SKI calc some time ago. e.g. it can be expressed as a fold on the lambda-tree
14:15:23 <ski> (implemented in haskell i.e.)
14:15:30 <Heffalump> I think that looks right
14:16:02 <ski> so that makes Y = S(S(SSI)(KI))(S(S(KS)(S(KK)I))(S(S(KS)(KI))(KI)))  right ?
14:17:48 <Heffalump> umm, I think you've missed out one of your corrections
14:17:55 <ski> using optimisations S(KS)(KI) = K(SI) and then S(K(SI))(KI) = K(SII)
14:18:12 <ski> very possible
14:18:19 <Heffalump> oh, maybe not then
14:18:32 <ski> lemme double-check again
14:24:02 <ski> yes, we had determined that \f.\t.tt = S(S(KS)(KI))(KI) /= S(SSI)(KI) and now i go on using the wrong result anyway !
14:24:16 * ski feels stupid/silly/tired ;-)
14:24:39 <Heffalump> you made rather less mistakes than me :-)
14:24:55 <Heffalump> I can't even get my 15 line innermost evaluator to work right
14:26:53 <ski> ok, Y = S(S(S(KS)(KI))(KI))(S(S(KS)(S(KK)I))(S(S(KS)(KI))(KI)))  is it fully correct now ?
14:27:20 <Heffalump> I can't see anything obviously wrong.
14:28:10 * Heffalump decides that he can't get de Bruijn implementation right quickly and stops, on the grounds that doing something productive would be more useful
14:28:22 <ski> pHa : we are currently just playing with high theoretical subjects right now. this is not ordinary haskell programming, so don't let this scare you off, if you are interested in the haskell programming language :-)
14:29:28 <ski> but, Heffalump, isn't SKI compilation veery productive and practical ;-)  (irony,..)
14:29:48 <Heffalump> :-p
14:29:52 <ski> lets try the optimisations now, ok ?
14:31:51 <ski> first S(Ka)(Kb) = K(ab) so that gives S(KS)(KI) = K(SI) so Y = S(S(K(SI))(KI))(S(S(KS)(S(KK)I))(S(K(SI))(KI))) right ?
14:33:25 <ski> and now S(K(SI))(KI) = K(SII) so Y = S(K(SII))(S(S(KS)(S(KK)I))(K(SII))) right ?
14:34:49 <Heffalump> I think so
14:35:22 <ski> and S(Ka)I = a so Y = S(K(SII))(S(S(KS)K)(K(SII))) right ?
14:36:10 <Heffalump> ok
14:36:50 <ski> hmm, i can't see anymore obvous optimisations, can you ?
14:37:18 <Heffalump> no, but I wouldn't have seen yours either
14:38:49 <ski> well, right now i cheated a little because those optimisations were mentioned on that URL or yours (though i've thought them out on myselves a while ago, i remember at least one or two more which i don't remember now ;-) )
14:38:55 <Heffalump> oh, ok :-)
14:40:20 <ski> so shall we try to X it now (with S = X(XX) , K = XXX and I = X(XX)(XXX)X )
14:40:43 * Heffalump is checking it by conversion back to lambda and beta-reduction atm
14:41:22 <ski> (me better write down what we've worked out so i dont forget it (it a file i mean))
14:42:06 <Heffalump> it'll be logged
14:42:12 <Heffalump> ok, I believe it
14:42:23 * Heffalump impressed
14:43:55 <Heffalump> right, going to X sounds good
14:44:58 <Heffalump> Y = X(XX)(K(SII))(S(S(KS)K)(K(SII)))
14:45:00 * Heffalump does it slowly
14:45:29 <Heffalump> Y = X(XX)(XXX(X(XX)II))(S(S(XXXS)(XXX))(XXX(SII)))
14:46:21 <Heffalump> Y = X(XX)(XXX(X(XX)(X(XX)(XXX)X)(X(XX)(XXX)X)))(S(S(XXXS)(XXX)))(XXX(S(X(XX)(XXX)X)(X(XX)(XXX)X)))))
14:46:37 <ski> i know, but just so i have the results concisely
14:46:45 * ski back from writing in an editor
14:46:47 <Heffalump> Y = X(XX)(XXX(X(XX)(X(XX)(XXX)X)(X(XX)(XXX)X)))(X(XX)(X(XX)(XXX(X(XX))(XXX)))(XXX(X(XX)(X(XX)(XXX)X)(X(XX)(XXX)X)))))
14:47:03 <Heffalump> know any good rewrite rules for X? :-)
14:48:23 <ski> this looks correct to me
14:48:52 <Heffalump> there should be 58 Xs
14:48:54 * Heffalump counts
14:48:55 <ski> no, cuz i've not had much time yet with playing with it ;-(
14:49:21 <Heffalump> 58. cool.
14:50:49 <ski> (by rewrite rules you mean optimisations, or did i understand you incorrectly ?)
14:50:54 <Heffalump> yes, I do
14:51:07 <Heffalump> X = S(S(SI(KK))(KS))(KK) I think
14:51:17 <Heffalump> I somehow doubt that'll help though
14:52:11 * Heffalump thinks bed calls
14:52:39 <ski> ok, so we had a little fun, hadn't we ?
14:52:46 <Heffalump> yep :-)
14:53:01 <Heffalump> "X(XX)(XXX(X(XX)(X(XX)(XXX)X)(X(XX)(XXX)X)))(X(XX)(X(XX)(XXX(X(XX))(XXX)))(XXX(X(XX)(X(XX)(XXX)X)(X(XX)(XXX)X)))))" - that fundamental of computation
14:53:10 <ski> (+hard thinking and error finding+correction)
14:53:22 <ski> ;-) ;-) ;-)
14:53:57 <ski> but i would like an X-like combinator that could easily express B and C
14:54:11 * Heffalump decides not to set it as the topic
14:56:18 <ski> so that every variable don't have to be distributed everywhere and then just be cancelled/killed (coldly :) by K, though perhaps that can be accomplished also by those optimisations.  but as you say, we probably shouldn't try to do it exactly now.  'nuff variable-less programming for the day !
14:58:28 <ski> so, Heffalump, you'll leave us (me, at least) now ?  well, nice dreams for you !
14:58:41 <Heffalump> thank you :-)
15:00:40 <ski> well "awaaay with you, beggar !!" ;-P  (citation from the Baldurs Gate  RPG Game)
15:01:38 * ski thinks that a lot of the sayings in "Baldurs Gate" sounds very funny
15:02:57 <ski> anybody played that game ? (well, i haven't. but 3 of my brothers has, so i know some things from it by heart by now :-)
15:06:47 * ski is also a little tired (flamsy ?) now
15:43:19 <Logan> This program ended up being 180 lines.  Bad coding style on my part. ):
15:43:36 <ski> what program ?
15:48:58 <Logan> ACM programming contest problem.
15:49:15 <ski> what was the problem ?
15:56:56 <Logan> First problem from the '92 international contest.  A very trivial one. :P
15:57:28 <ski> care to tell what it was, or at least give a link ?
15:57:38 <Logan> I'm lazy. :P
15:57:47 <Logan> http://www.acm.inf.ethz.ch/ProblemSetArchive/A_FINALS/1992/prob_a.html
15:57:58 <Logan> Forgot I still had it in my browser. :P
15:58:21 <ski> so you leave to me to explicitely force that lazy pointer, eh ? ;)
15:58:41 <Logan> I'm just too tired to think at the moment. *grin*
16:01:52 <ski> ahh, it's a spreadsheet program.
16:02:06 <ski> (reading the page)
16:03:45 <Logan> It's really just some simple parsing/evaluation and detection of cycles in a directed graph.
16:04:26 <ski> but it *is* a spreadsheet (although a simple one)
16:06:00 <Logan> I may do the convex hull one next (http://www.acm.inf.ethz.ch/ProblemSetArchive/A_FINALS/1992/prob_d.html).
16:07:04 <ski> i'm a little interested in the underlying idea of interactive spreadsheets : that when some input is changed, only what depends on that input has to be recomputed (this is what i though FP was a little like/about before learning FP when another person tried to explain a little :)
16:08:38 <ski> i think it's called "interactive algoritms" (IIRC)
16:10:01 <ski> e.g. a sorting algorithm may only have to reexecute some of the sorting for part of the input, rather than all of it, when a small part of the input is changed
16:12:28 * zorb wonders how complex it would really be. in theory it doesnt seem to bad.
16:12:39 <ski> this is a little like trying to see what happens to a (boolean logic) circuit when some inputs change value (though each part is sort of computed all the time, the conceptualization concentrates on the changed parts and what these affect
16:14:24 <ski> zorb : i'm not sure. i think i for a while ago saw some ML program implementing this kind of thing, perhaps on comp.lang.functional or comp.lang.ml, but i've lost the link :-( . and i can't seem to find it again now :(
16:15:02 <zorb> there's something like that in sicp i've been meaning to figure out if i could translate it into purely functional haskell (without use of IO or ST)
16:15:53 <ski> zorb : however, i seem to recall that that particular library used time stamps and state in some way. i'm interested if something more or less equivalent could be accomplished "purely", e.g. by monads or arrows. but i'm not sure of where to start ... :(
16:16:07 <ski> exactly !
16:16:41 <ski> in sicp, you say .. ?
16:16:59 <zorb> well, the boolean circuit business.
16:17:03 * ski tries to find SICP again (for the bazillionth time ?)
16:17:03 <zorb> err.
16:17:17 <zorb> use the web :)
16:18:14 <zorb> http://mitpress.mit.edu/sicp/full-text/book/book.html
16:20:02 <zorb> http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_%_sec_3.3.4 is actually what im talking about.
16:20:35 <ski> found it at : http://www-mitpress.mit.edu/sicp/ and http://www.amazon.com/exec/obidos/ISBN%3D0262011530/northtexaslinuxuA/102-7236953-9692930
16:21:06 <ski> ah, you already gave the URLs and i didn't notice before now :)
16:22:01 <ski> (yes, i used the web. i.e. google)
16:22:53 <zorb> google rules.
16:23:01 <ski> hmm, does this implementation refrain from recomputing results non-dependant from the input change ?
16:23:18 <ski> and does it use state or not ?
16:23:30 <zorb> it definitely uses state
16:23:33 <ski> (i guess i have to look for myself)
16:24:32 <zorb> state can be handled with function composition.
16:24:35 <ski> for what i know, i think it shouldn't be much harder to generalize from boolean-valued input and output to any first-class value
16:25:22 <ski> yes, or sometimes more nicely with monads or arrows (or specially designed combinators/program structure style)
16:27:44 <ski> hmm, it looks like, from a quick glance, that they represent the "value-nodes" (value resting places) as a value slot and a list of actions to be called whenever the value is changed (updated).
16:28:51 <ski> one sometimes avaiable optimisation is of course to check if the new value is the same (or in some sense equivalent value) as the old one. in that case, we'd save even more work.
16:29:05 <zorb> yeah, and they have an "agenda" thing which applies those actions (and i suppose what the next list of actions are to be)
16:30:17 <zorb> this was a part of the book I only read and didnt really do much of the exercises :)
16:31:19 <ski> sidenote : when i first understood that state could be passed though a function composition, i got so excited that i had to write an interpreter for a very small imperative language in a purely functional language (haskell), so the main interpreter function used a fold on the statement list to pipe through the state !! :-)
16:31:40 <ski> hmm
16:31:46 <zorb> hehe
16:33:44 <ski> i have thought a little if it would be possible to write such programs in a more "direct" style (cuz i presume that the actions on a value-node has to be provided as thunks (functions), right ?). such that one would capture the continuation of the read of a value-node and add that continuation to the action list.
16:35:57 <ski> the only problem (quite huge though) is that if we use the primitive continuations (as was the intention, instead of a continuation-stylish function), then only one of the actions in the list will get executed, cuz a real (primitive) continuation never returns, so the other actions will not be done :(
16:36:41 <ski> though this could perhaps be solved by spawning one thread for every action continuation in the action list
16:37:33 <ski> or it might be solved by using delimited continuations (aka shift/reset) (though you probably havn't heard of those, or have you ?)
16:38:04 <zorb> this talk of continuations is a bit over my head.  I do remember reading from one of those monad paper that "continuations" are actually a form of monad.
16:38:29 <zorb> so i really didnt concern myself with them much.
16:39:13 <zorb> I know (vaguely) what a continuation is...
16:39:46 <ski> one another potential problem is in synchronizing these parallell computations (so that e.g. some computation has two changed inputs, so we wan't it to wait until both inputs are reevaluated, instead of evaluating anew once for the first changed input and once for the second input)
16:41:15 <ski> yes, continuations, they're a favorive topic of mine :) :) :)  well, i can't say i know them inside out (at least yet) but i think them very much interesting
16:42:53 <ski> in this case i envisioned that one might write something like "... (get-value some-value-node) ..." instead of "(get-value some-value-node (lambda (the-value) ...))"
16:42:53 <zorb> yeah, i remember reading about some pretty powerfull looking expressions using them.
16:43:21 <zorb> ah
16:43:24 <ski> (in a lispy syntax that is)
16:44:00 <zorb> let me see if i can find that document.
16:45:45 <ski> i.e. i wan't it to somehow freeze the computation that wants the value and store it in the action list, but still be able to write it as under the delusion of getting the result directly once instead of being called every time the value changes, cuz i though that that would be easier to write,read and understand, you know what i mean ?
16:46:16 <ski> yes one can make a continuation monad
16:47:56 <zorb> so instead of x = val you want x = (\y -> ....)
16:48:57 <zorb> or ummm.
16:49:21 <zorb> I think i need my cardboard wookie :)
16:49:47 * ski back from small web excursion
16:50:16 * zorb pretends to write to somebody in notepad.
16:51:23 <ski> we discussed continuations a little at http://tunes.org/~nef/logs/haskell/02.01.16 . i think i tried to give a short summary of how continuations emerged historically beginning with "<ski> i think that continuations" in the text, if ya wanna look at it.
16:51:33 <ski> heh
16:51:44 <ski> no
16:52:18 <ski> instead of foo x (\y -> ...y...) i want ...(foo x)... , see ?
16:52:35 <ski> (cardboard wookie ?)
16:53:06 <zorb> it's also explained in that log somewhere :)
16:53:19 <ski> zorb : what document ? the one about continuations could be seen as a monad ?
16:55:32 <zorb> my guess is it was "comprehending monads"
16:55:34 <zorb> yeah
16:56:13 <zorb> but that document doesn't have the common haskellish "bind" definition.
16:56:59 <ski> this thing with associating actions with imperative variable is quite interesting. if one wan't to retain imperative variables but get more sophisticated stuff, this might be a way forward (i think the language e (www.erights.org i think) used "promises" which are asynchronous stand-ins for the not-yet returned value from another thread, and that you can tell things to do when the promise gets fullfilled (the valued "returned"), whenever that mig
16:57:44 * zorb nods
16:58:02 <zorb> however I didn't see your full statement.
16:58:13 <zorb> it ended.. "whenever that mig"
16:59:11 <ski> aha, that paper. i think i have at least skimmed it.
16:59:44 <ski> on my side it was "whenever that might be in time)"
17:01:36 <ski> (though i tried to write a little longer at first but there was some buffer maximum met i guess in this commandline irc program i am using right now (a little irritating is that one only see the last LINELEN character that one has written and the arrow keys don't work :( ))
17:02:46 <ski> a monad can be defined by the type and unit (=return) and bind (~=extend) and also by the type and unit and join and map, yes.
17:04:37 <ski> so unit,bind and unit,join,map are interdefinable (and the corresponding 3 and 7 monad laws are interprovable)
17:05:49 <ski> well, i probably shouldn't scare you away with continuations if ya aren't very interested in it now ...
17:06:03 <zorb> heh
17:07:44 <ski> hmm, i don't know but perhaps a sorting algorithm is a bad choice for trying to make interactive, cuz if you change one input to something else, the new input might be placed by the sort anywhere in the sorted sequence (depending of course on how big it is relatively), but i don't know.
17:09:13 <ski> hmm, can you come up with some not-so complicated problem that could be leaveraged (leveraged ?) noticably by making it interactive ?
17:09:37 * zorb ponders
17:10:11 <zorb> well, duh, obviously compilation systems :)
17:11:52 <ski> i think it has to be some sort of divide-and-conquer algorithm that doesn't do much to combine the results of the subcomputations (so that they can be shared from previous evaluation instead of constructed anew)
17:12:15 <ski> hmm, that was an interesting idea :)
17:13:04 <zorb> yeah, and its also been made a.k.a. makefiles with dependencies, etc.
17:13:22 <ski> just imagine an IDE where the IDE diffs the new version and the the old version of the code (or build up diff info interactively when editing) and then only recompiling the changed parts !! :-)
17:14:52 * zorb thinks vc++ .net or earlier does that :/
17:15:07 <ski> yes, modularizing a program into compilation units to be compiled separately and then a makefile utility with dependecies could of course be considered an interactive algorithm of sorts. thanks for pointing that out to me :)
17:15:25 <ski> aha
17:16:14 <ski> well, i'm not sure i like vc++ (but i haven't used it so it's prejudice in my case, perhaps correct or not, i don't know)
17:17:01 <zorb> I just remember some advert.  I've never used vc++
17:17:07 <ski> ok
17:19:11 <ski> i recall some small examples with delimited continuations where they used a looks-like-we-get-the-value-directy method but instead that computation wanting the value was abstracted (i.e. made into a function/continuation) and passed on to other parts of the program for later resumption of the computation
17:20:40 <ski> thats where i got the idea of "direct" style interactive algorithms, i think. though i have mostly thought about interactive algorithms myself so i don't know much about what methods are used to implement interactive algorithms (maybe i should start looking again)
17:20:43 <yusri> haskell newbie question: what's the best method for serializing haskell data for persistence?  Is there something similar to python's 'pickle?'
17:20:51 <yusri> oh, and 'hi' =)
17:22:24 <ski> yusri : hi !  and is 'pickle' in python a method for more or less marking data such that they are persistant or is it a marshalling (serializing) process for explicitely writing data to files or anything else ?
17:22:48 <yusri> marshalling
17:23:36 <yusri> pickle.dump(obj, io) for serializing, pickle.load(io) to load the object back in
17:24:25 <yusri> I'm working through the thompson book right now, and it's just a question that occured to me
17:25:00 <ski> ok. well i'm not very familiar with marshalling. what i know about it in haskell is that i don't recall much in that way at all :( (maybe there are marshalling libraries, but i don't know about them). though i hear that O'Caml has good marshalling (even functions can be marshalled (with some restrictions))
17:25:56 <yusri> hmmm- I'l like to save a large list (an example of a library checkout/return database) for persistence-
17:26:26 <yusri> As I'm used to imperative programming, I'm not used to the 'variables have one value' concept
17:26:46 <yusri> Although I can definitely appreciate the concept now =)
17:27:24 <ski> well, in principle i think that it should not be much technical problem in writing a Marshalling class in haskell with corresponding methods for dump and load. it is very possible that ghc (a haskell compiler) has a marshalling library but i haven't worked much with ghc at all (lest it's extensions) :(
17:27:58 <ski> ok (catching up with waht you are saying right now)
17:28:01 <yusri> right- I'm hugs-bound anyhow, trying to understand. ;)
17:29:10 <zorb> does pickle have any OS specific file locking mechanism activated by it?
17:30:11 <yusri> I
17:30:14 <yusri> ---
17:30:16 <yusri> I'm not sure
17:30:29 <yusri> I haven't looked much inside the pickle module, I'm afraid
17:30:39 <ski> the 'variables have one value' concept can be considered a central idea of functional programming, and it simplifies a lot so that one can use higher-order functions much more extensively (though one still can in imperative languages with real function closures and higher-order functions, though one has to know what one is doing if one is mutating the data through a higher-order (library, say) function)
17:30:45 <yusri> But- I think it's basically os-independent
17:31:47 <ski> but for a Marshalling class i think one would use the IO monad so the file system state isn't a problem i think (it looks more or less "imperative")
17:31:59 <yusri> I don't see any caveat in the documentation- so if it locks, I'd guess it works universally
17:32:34 <yusri> Yes- i have yet to look into, let along understand monads- but I'll note that for later ;)
17:32:44 <yusri> s/g/e
17:33:22 <yusri> I'm actually in the middle of list comprehensions right now, which I find amazingly useful
17:33:26 <zorb> yusri: don't bother.. i was trying to figure out how persistance has anything to do with what I think it is.
17:33:26 <ski> you mean locking a file so that only the same program invocation (or later invocation or coworking program) can access the data ?
17:33:54 <yusri> ski : if you're asking me, yes
17:34:11 <zorb> ski: something like that. actually I thinking about locking ranges within the file.
17:34:24 <yusri> ahhh
17:34:53 <ski> yusri : one does not have to understand monads very much to be able to use the IO monad, though of course it helps, and enables more sophisticated use perhaps
17:35:27 * zorb agrees with ski about IO monad
17:35:48 <yusri> hmm- ok.  I might read ahead and see if I can get it
17:36:12 <ski> yusri : list comprehensions  can actually be considered a monad so we some days ago found out that python also has at least on monad :)
17:36:54 <ski> ah,ok (about locking ranges)
17:37:09 <yusri> well, i was talking about haskell list comprehensions- i don't think python has anything remotely similar
17:37:45 <yusri> I'm lauding haskell right now- I finished lauding python a long time ago ;)
17:38:00 <jemfinch_> python programmers turn to functional programming at an increasingly shocking rate.
17:38:19 <zorb> ah, ok, it appears file locking has nothing to do with pickling... (http://www.python.org/doc/current/lib/module-pickle.html)
17:38:33 <yusri> well, I'm a python programmer turned ruby programmer part-time turned haskell programmer
17:38:38 <zorb> or persistance rather.
17:38:47 <yusri> and python programmers turn to ruby at an alarming rate as well
17:39:09 <yusri> I'm part of the LotY group learning haskell currently
17:39:10 <zorb> oh but oh...
17:39:43 <zorb> (the data persists after program execution.. i see).
17:39:47 <zorb> silly me.
17:39:54 <yusri> zorb : =)
17:40:01 <jemfinch_> yusri: oh no, why ruby?
17:40:29 <yusri> are you asking as a functional programmer, or someone concerned for python's well-being?
17:40:46 <jemfinch_> I'm asking as the anti-ruby :)
17:40:50 <yusri> ah
17:41:03 <yusri> ruby is more OOP than python- that's what appealed to me.
17:41:04 <ski> yusri : at http://tunes.org/~nef/logs/haskell/02.01.16 shapr seemed to indicate that python (perhaps the latest version) has list comprehansions. perhaps he only meant stackless python, i'm not sure (search the text at the link for "#python" to see for yourself)
17:41:19 <jemfinch_> yusri: you know that python 2.2 has no type/class distinction anymore, right?
17:41:48 <jemfinch_> ski: python has list comprehensions, but they're ugly and unneeded.
17:41:53 <yusri> Yes, i did run across that
17:41:56 * jemfinch_ dislikes python list comprehensions.
17:42:10 <yusri> but, really, my felling towards ruby is greatly syntax-based
17:42:19 <yusri> I'm a linguist by trade, you see
17:42:33 <yusri> s/ll/el/
17:43:07 <yusri> ski : Well, shapr is the expert =)  He's a far better programmer than I, especially when it comes to python.
17:43:18 <ski> jemfinch_,yusri : yes i seem to have noticed that also (the interest from python and perhaps also ruby programmers into functional programming and haskell. well at least both python and haskell have layout syntax rules
17:43:57 <yusri> I would say ruby and haskell are about flexible to the same degree
17:44:05 <yusri> python is not flexible.
17:44:54 <yusri> ruby is not perlish in terms of layout, ski- it follows the 'clause per line' concept, generally
17:45:19 <ski> jemfinch_ : ok i know not very much python (unfortunately perhaps ?) so i don't know how they (list comprehansions) looks like in python. i only took shaprs word for it.
17:46:54 <ski> yusri : he said thay it caused some ashtonishment at the #python channel when he explained that python has monads (well one at least)
17:47:02 <yusri> jemfinch_: Well, they're only as ugly as normal python code
17:47:20 <yusri> ski : I'm sure it did =)
17:47:51 <ski> yusri : ok, don't know very much about ruby except it's OOP and scripting
17:48:16 <yusri> jemfinch_: And 'unnecessary' does not mean the same thing as 'not nice,' does it?
17:48:49 <yusri> ski : Well, that's only slightly less than I know about Haskell ;)  
17:50:09 <ski> yusri : ok, fine :) hopefully we'll learn more different styles and attitudes of programming both of us.
17:51:01 <yusri> ski : Yes, I hope so- that's why I'm learning haskell in the first place- and so far I find the process quite enlightening
17:52:12 <ski> yusri : i think it's always (?) fun to learn new approaches to solving problems.
17:53:02 <ski> (yusri : what's the LotY group, anyway ?)
17:54:07 <yusri> Language of the Year: http://www.pragmaticprogrammer.com/loty/index.html
17:54:40 <yusri> I think there's over 100 people signed up to the mailing list, though it's unclear hoe many are really participating
17:55:22 <yusri> ski: PragDave (in the chan) is a member of that group- shapr is also a leading member.
17:55:23 <zorb> how active is the list, yusri?
17:55:31 <yusri> fairly
17:55:41 <yusri> we're also in the #loty chan
17:56:15 <yusri> you're welcome to pop over and answer questions whenever you'd like :)
17:56:57 <yusri> it's fairly quiet in there now- i think it's more active during US day hours.
17:57:09 <ski> yusri : seems like an interesting language, but i already know much haskell currently so perhaps (if i recall it) i could participate in learning a new language another year ? (if i manage to draw forth 'nuff interest converted to action)
17:57:09 * zorb nods
17:57:57 <yusri> of course
17:59:32 <ski> yusri : i might perhaps soon visit in to other channels here at this irc server, the whole irc thing is quite new to me, so it wasn't a long time ago i got writing for my first time irc in this groups
18:00:44 * ski notes the #loty channel in a file
18:02:06 * yusri nods
18:03:13 <yusri> ski: and thanks for that python list comprehension url; I'll be able to put that to good use.
18:03:38 <ski> yusri : whaddya mean ?
18:04:26 <yusri> ski : I'm working on a python project that I could use that in, thanks.-- I was unaware of the form.
18:04:52 <yusri> (thanking shapr, by proxy)
18:04:54 <ski> yusri : ok
18:11:30 <ski> aha : in http://www.haskell.org/aboutHaskell.html reachable from that LotY link they also compare functional languages with spreadsheets !  so even if most ordinary functional programming isn't quit like spreadsheets, there is some similarity of concept and thus perhaps functional languages could be used with some easy to express spread-sheet-like interactive algorithms (recomputing only the parts dependant on changed input), perhaps as a library
18:12:29 <yusri> yes, I've heard that comparison quite a bit
18:12:39 <ski> so my initial intuition about FP when i didn't know it and just tried to imagine what it would be like when i heard a simple try for explanation of FP wasn't so wrong after all :)
18:12:48 <ski> ok
18:13:51 <ski> so, where are the interactive algorithm libraries for haskell, do i have to figure it out and write it myself ? (though i've seen an ML such library)
18:18:36 * zorb does not know
18:18:57 * ski doesn't either
18:24:40 <zorb> later *
18:24:54 <ski> ok bye zorb
18:25:18 * ski goes to find something to drink,brb
19:12:50 <yusri> I have a question... hmmm...
19:12:59 <ski> ok ?
19:13:23 <yusri> is there a way to write a recursive equation in math?
19:13:27 * ski reading on www.pragmaticprogrammer.com right now
19:13:37 <ski> why not ?
19:13:40 <yusri> as in regions n = regions (n-1) + n
19:13:55 <ski> think of how the fibonacci function is defined
19:14:13 <yusri> right, i can understand it in haskell- no problem
19:14:21 <ski> or the limit of a recursive set definition that crops up sometimes
19:14:24 <yusri> but is there some type of mathematic notation for that?
19:14:48 <ski> well i think that often one write like this :
19:15:27 <ski> the fibonacci number sequence a0,a1,a2,a3,a4 is defined as follows :
19:15:31 <ski> a0 = 0
19:15:34 <ski> a1 = 1
19:16:09 <ski> an+2 = an+1 + an                (provided n >= 0)
19:16:55 <ski> where of course the n and n+1 and n+2 are written in small and a little below to the right of a in this case (index, it's called)
19:17:21 <yusri> right, an+x = an+(x-1) + an
19:17:36 <yusri> ah yes
19:18:10 <ski> yes
19:18:20 <yusri> had forgotten all about math indices until I met haskell =)
19:19:08 <ski> if one has a recursive (e.g. set) definition : S = f(S) where f is some transformation/function on sets
19:19:44 <ski> then one might try to solve this by reading this as Sn+1 = f(Sn) and setting S0 to some initial set
19:20:53 <ski> and then one interate (as this usually is called in math) the function f over the set until the set is equal to the last one (or sufficiently similar, think newton-rapson root finding)
19:21:04 <ski> you see ?
19:22:00 <ski> guards are also in a form present in math think about how the abs functions (stripping negative sign of a number might be defined in math)
19:22:40 <ski> s/number/number)/  and  s/math)/math/
19:24:00 <ski> though in most ordinary math, it's not a so much focussed method or practice (recursion, i.e.) than in functional programming
19:24:18 <ski> ok ?
19:24:54 <yusri> right
19:25:13 <yusri> thanks =)
19:26:19 <ski> this business of using a function and an initial value to generate an (whole number-)indexed sequence of objects (most often numbers) is what is called iteration in math, IIUC.
19:28:22 <ski> in the fibonacci case a number just don't depend only on it's precedent but earlier numbers also, this is a generalisation (dependance on potentially all previous and the index). but it still generates a linear sequence of numbers so it's still called iteration
19:29:26 <ski> if you compare with a e.g. haskell function for adding all numbers in a tree, then the recursion doesn't in the same way generate a linear sequence so it's no longer iteration
19:29:42 <yusri> aha- I've discovered testing to be very important in haskell
19:29:56 <yusri> something I've noticed to only a limited degree in imperative programming
19:30:46 <ski> so iteration is (mostly) for linear things (at least linear order of computation) whereas more general recursion can express more complicated computations
19:31:00 <ski> aha.
19:31:16 <ski> testing in what way ?
19:31:40 <ski> for pattern-matching selecting which case/function line ?
19:32:03 <yusri> proofing, for one
19:32:03 <ski> or more general testing of some property of data to determine what to do ?
19:32:16 <ski> i'm not sure what you mean ..
19:32:21 <yusri> proofing mathematical functions, for one
19:33:17 <yusri> testing that all instances of a specific type (in math's case, Int, etc) function for a given function
19:33:31 <ski> ah, you mean like more easily seeing that a functions does what it should and one can more easily _see_ the properties and restrictions that the function has ?
19:33:54 <yusri> yes
19:35:07 <ski> i suppose this is because (to use an old slogan) "progamming more what the result should be than how to compute it" ?
19:35:31 <yusri> exactly
19:36:56 <ski> so that the result isn't so much hidden in internal bookkeeping index variables in for-loops and while-loop tests, but instead, in some way at least, try to "express what the result is"
19:38:03 <ski> i'm a student at gu (gothenburg's university) which shares many courses and teachers with chalmers ditto. so in a way i'm at chalmers, yes.
19:38:17 <yusri> ah
19:38:24 <ski> (BTW : how do you do that *yusri* thing on irc ?)
19:39:06 <ski> we use chalmers computer system, for one thing. (mostly Sparc boxes running Solaris)
19:40:17 * xbill sighs.
19:40:24 <xbill> Turner's combinators are cool
19:40:50 <yusri> xbill : point me to them, pls =)
19:43:12 <ski> xbill : C,B and friends ?
19:43:35 <ski> xbill : and probably Y also ?
19:44:26 <yusri> I think I'm going to create a list: "Things I've learned from Haskell"
19:44:51 <yusri> so far, I have "that list comprehensions are a Good Thing"
19:45:33 <ski> could be a nice thing to do/have/read (espessially for newbies (?)).
19:47:17 <ski> i'm not totally convinced on that particular matter, but that's perhaps because i'm for some reason ittitated by that set construction in mathematics, which in turn, may be because i'm not totally fond of set's in math and their usage.
19:47:29 <ski> s/tt/rr/
19:48:14 <ski> at least i think that "pattern matching are a good thing" for many problems 
19:48:50 <ski> and probably also guards and multiple defining equations should be counted in that, no ?
19:49:14 <ski> (s/good thing/Good Thing/ !)
19:49:57 <xbill> pattern matching is largely a syntactic convenience -- but it's nice
19:51:12 <ski> hmm, (shallow) pattern matching can be more or less easily employed in OOP (defining equations correspond to particular implementations for virtual methods)
19:51:14 <yusri> right- guards as well
19:51:33 <yusri> I really like them, syntactically.
19:51:57 <ski> xbill : yes, but i was thinking pragmatically here. i.e. in ease of coding and more (textual) clarity
19:53:16 <ski> i've even though up a pattern-matching syntax (and hopefully semantics) for (an extension to C). not that i think that it's probable to ever be implemented, or better still, incorporated into the C standard
19:53:47 <ski> yusri : i agree
19:55:13 <ski> (continuing with p.m. in OOP : ) but deep pattern matching is harder to do in OOP (a typecase can perhaps help, but it's not really OOP, what i've heard)
19:55:40 <ski> (deep pattern matching is with nested patterns)
19:55:55 <ski> does this seem ok ?
19:57:22 <ski> xbill : (re-querying) is Turner's combinators C,B,etc. (i don't remember exactly) ?
19:57:50 <ski> hmm, can we perhaps think of more things to put on that list ..
20:00:15 <yusri> recursion, i think, is far easier in haskell than in IP
20:00:57 <ski> well, in C, e.g., is recursion really so hard ?
20:00:58 <yusri> or, rather, defining the exceptions during recursion are
20:01:10 <yusri> ie: for special cases- zero, etc
20:01:27 <yusri> No clue- C is anathema to me
20:01:29 <yusri> ;)
20:01:53 <yusri> I'm Cless, except for a bit of rare extension programming.
20:02:58 <ski> isn't it more like being a generally disapproved way of solving problems that can be solved otherwise (this is of course connected to how costly a function/procedure call is (it used to be quite expensive in some implementations), as well as whether tail-call optimisation is implemented (correctly/at all))
20:03:51 <ski> it may very well be possible.
20:04:46 <ski> (i.e. special cases). BTW do you mean "normal" (base) cases or "exceptional"/"erroreouneus" cases ?
20:04:58 <yusri> the last
20:04:58 <ski> ok.
20:05:46 <ski> then i definitely agree, but isn't this true of any language lacking some kind of exceptions or equivalent ?
20:07:30 * ski thinks it's very hard to write "bullet-proof" C code when calling miscellaneous numeric or string functions that may encounter errors that have to be checked,propagated and handled in the right place.
20:07:48 <xbill> SML and ocaml have exceptions .. I don't see why Haskell can't
20:08:13 <ski> i think it's an head-ache to do that fully correctly.
20:08:48 <yusri> aside question: if there a non-arity-specific version of 'zip'?
20:09:19 <Heffalump> xbill: It's easy to do exceptions if you use a monad. If you don't, what call chain do you pass the exception through?
20:09:49 <ski> xbill : well exceptions in a monad in haskell is not intrinsically difficult, say in IO or Maybe or ...,but to be able to raise exceptions in "pure" code and then catch them at least in "imperative" code is probably more what we'd like, no ?
20:11:23 <ski> yusri : i think there has been one or a couple of implementations. i think one used type classes to do the trick (also somewhat printf-like beasts can be constructed with sophisticated use (abuse ?) of type classes)
20:11:44 <yusri> actually... related:
20:12:04 <yusri> how do you define a function saying 'any number of params'
20:12:29 <yusri> as in *x for some IP langs
20:12:32 <yusri> is that possible?
20:12:57 <ski> Heffalump : yes, the non-defined order of lazy evaluation complicates the dinamic context to which the exception should be passed through when raised in pure code
20:13:05 <ski> s/dinamic/dynamic/
20:13:58 <Heffalump> ski: yeah, though catching it in imperative code sounds feasible; /me looks at Simon PJ's paper on exceptions
20:14:13 <xbill> well you can just follow the unwinding of the stack for implementation... the typesafety etc. concerns may not be addressible
20:15:11 <ski> yusri : yes that's possible with type classes. i have written a function "list" that takes any number of parameters (of the same type) and collects them into a list. though there are ambiguity problems that sometimes must be solved with an explicit typing of the expression (like (list 1 2 3 :: [Int])
20:16:00 <ski> Heffalump : yes, i think that is what i referred to. if i'm not mistaken, at least ghc supports it.
20:16:26 <ski> xbill : how do you mean ?
20:17:57 <ski> hmmm, i usually have to think and try some about, every time i investigate that idea/method. i could run up hugs and try to remember how it wen't if you want ...
20:18:23 <yusri> only if you have time/inclination
20:18:28 <ski> (last responding to yusri, about an example of such a type class)
20:19:01 <ski> well, now that you ask, i think i'll at least try a little while, ok ?
20:21:37 <yusri> tks :)
20:23:00 <ski> (yusri : tks = ?)
20:25:53 <Heffalump> "thanks" probably
20:26:16 <ski> yes
20:35:28 <ski> ok.
20:35:38 <ski> well, it's now at http://www.mdstud.chalmers.se/~md9slj/VarArgFun.hs
20:36:02 <ski> but you probably want me to describe it here also, yes ?
20:37:01 * xbill sighs.
20:37:24 <ski> xbill : a good or bad sigh or what ?
20:38:06 <ski> or perhaps my putting it up on the 'net is sufficient ?
20:38:47 <ski> (it can be improved in some ways, yes. and also use more explaining comments, i think)
20:39:21 <Heffalump> if you want to hard-code VarArgList with a specific type, the fundep/multi-parameter type class is unnecessary so it's Haskell 98, right?
20:40:25 <ski> hmm, i think that multi-parameter type class is nessesary to make a connection between the function's type and the resulting list elements type
20:40:49 <Heffalump> IM you could just replace a with Char throughout, then it wouldn't be needed as a parameter
20:40:59 <ski> but the functional-dependency could probably be ridden of.
20:41:31 <ski> hmm, aha, now i see what you mean. yes that is possible.
20:42:30 <ski> (this implementation gets the list in reversed order from writing, hence "rev_list", an improvement would be to return a correct-order-list)
20:42:35 <Heffalump> oh, instance VarArgList [Char]
20:42:37 <Heffalump> isn't Haskell 98
20:43:41 <Heffalump> can you explain the logic behind giving a type class a kind, btw?
20:43:43 <ski> hmm, maybe it isn't. it's that annoying restrictions about the form of the types in contexts in value typings,instance and class definitions, is it ?
20:44:22 <ski> one could of course do something like newtype ReallyAString = RAS [Char]
20:44:31 <ski> and instance that thing
20:44:57 <ski> then we have the annoying problem of converting between [Char] and ReallyAString :(
20:46:25 <ski> (hmm, i probably should have made a comment in the source that it isn't fully Haskell 98)
20:46:58 <Heffalump> hmm. I don't understand fundeps properly. Why is "VarArgList [Char] Char" an illegal constraint?
20:47:13 <ski> well, what do you think. it at least get the job done more or less, no ?
20:47:23 <ski> is it ?
20:47:57 --- topic: 'Functional Programming, that's the opposite of Dysfunctional Programming (like VB) | we be loggin' http://tunes.org/~nef/logs/haskell/ | welcome to the Haskell Dojo | julien is up to white belt! jewel and shapr are up to green belt!'
20:47:57 --- topic: set by shapr on [Fri Jan 25 17:44:16 2002]
20:47:57 --- names: list (clog pHa ski Heffalump smkl cuelebre jemfinch_ dennisb jlb juhp yusri PragDave Logan dmiles Igloo xbill)
20:48:23 <Heffalump> I've change list_acc to append at the end and renamed rev_list to list
20:48:38 <Heffalump> VarArgFun> list "ab" :: VarArgList [Char] Char => [Char]
20:48:38 <Heffalump> ERROR - Constraints are not consistent with functional dependency
20:48:38 <Heffalump> *** Constraint       : VarArgList [Char] [Char]
20:48:38 <Heffalump> *** And constraint   : VarArgList [Char] Char
20:48:38 <Heffalump> *** For class        : VarArgList a b
20:48:41 <Heffalump> *** Break dependency : a -> b
20:49:02 <Heffalump> or the same error if I do:
20:49:08 <Heffalump> VarArgFun> list "ab" :: [Char]
20:49:27 <Heffalump> but it's just cos I was being stupid, list shouldn't take a string
20:49:31 <ski> how do you apped at end ? (as++[a]) , no ?
20:49:42 <Heffalump> yeah, just trying to work out how to do it efficiently now
20:50:04 <Heffalump> so I was being silly, but I don't understand the error message
20:50:18 <ski> lemme try ..
20:52:39 <ski> hmm, well at least list "ab" :: [Char] is clearly wrong
20:52:56 <ski> it should be list "ab" :: [[Char]] or list "ab" :: [String] of course
20:52:57 <Heffalump> yeah
20:53:12 <Heffalump> I didn't intend that, I intended list_acc "ab"
20:53:23 <ski> what did you type to get the original error (before list "ab" :: [Char])
20:53:35 <Heffalump> list "ab"
20:53:42 <Heffalump> which gives unresolved overloading, predictably enough
20:54:02 <ski> list_acc "ab" :: [Char] seems to work here ..
20:54:07 <Heffalump> yes
20:54:17 <Heffalump> I was asking about what the error message means, not why I got it
20:54:31 <Heffalump> s/why I got it/why I got one/
20:54:52 <ski> well, list "ab" gives at my hugs prompt :
20:54:56 <ski> ERROR - Unresolved overloading
20:54:56 <ski> *** Type       : VarArgList a [Char] => a
20:54:56 <ski> *** Expression : list "ab"
20:55:05 <Heffalump> yes, that's what I said
20:55:27 <Heffalump> what does list "ab" :: [Char] give, and what does that error mean if it's the one I got?
20:55:44 <ski> ok, this means that it has figured out that the elements of the list are to be of type [Char] (2nd arg of the class)
20:56:37 <ski> but, it don't know if you wan't a list immediately, or if it should construct a curried functions that takes 1 or more [Char] as arguments before returning the [[Char]]
20:57:10 <Heffalump> I understand the "Unresolved overloading" error
20:57:10 <ski> so list "ab" could mean list "ab" :: [Char] -> [Char] -> [[Char]]
20:57:23 <ski> i.e. a function taking 2 more strings
20:57:25 <ski> ok
20:57:26 <Heffalump> I don't understand the "Constraints are not consistent with functional dependency" error
20:58:05 <ski> you mean what you get (i too) with : list "ab" :: [Char] ?
20:58:10 <ski> ERROR - Constraints are not consistent with functional dependency
20:58:10 <ski> *** Constraint       : VarArgList [Char] [Char]
20:58:10 <ski> *** And constraint   : VarArgList [Char] Char
20:58:10 <ski> *** For class        : VarArgList a b
20:58:10 <ski> *** Break dependency : a -> b
20:58:11 <Heffalump> yes.
20:58:22 <Heffalump> oh.
20:58:25 <ski> hmm, lets see if we can decipher it..
20:58:26 <Heffalump> I get it, actually
20:58:43 <Heffalump> a fundep a -> b means that a must uniquely determine b.
20:58:50 <ski> yes
20:58:57 <Heffalump> so obviously having two constraints with the same a and different bs is invalid.
20:58:58 <Heffalump> right.
20:59:08 <ski> right.
20:59:36 <ski> so it knows that [[Char]] is a possible result, now [Char] can't also be
20:59:52 * Heffalump gets back to trying to find a better way to do in-order lists (current best bet is putting a reverse in the [a] instance implementation of list_acc ..)
21:00:01 <Heffalump> yeah, I realise how it got the constraints
21:00:03 <ski> i'll try and see what happend if remove the dependency..
21:00:29 <ski> it fails on reloading the module, saying :
21:00:33 <ski> ERROR VarArgFunB.hs:18 - Ambiguous type signature in type declaration
21:00:33 <ski> *** ambiguous type : VarArgList a b => a
21:00:34 <ski> *** assigned to    : list
21:00:39 <Heffalump> yep
21:00:42 <Heffalump> make sense
21:01:47 <ski> a quick and dirty way to solve this without dependecies might be to make list_acc :: ([a],f) -> f
21:02:28 <ski> essentially a dummy result to remove the ambiguity. though i'm not sure if exactly that solves it in this case. and it's still annoying and ugly.
21:03:57 <Heffalump> http://munchkin.comlab.ox.ac.uk/~ganesh/VarArgFun.hs uses cat-elimination vaguely sanely to produce a forwards list, btw
21:04:08 <ski> but the problems with explicit typing of the result of list, i think, may well dissapear often when it is embedded in a context that is unambiguosly of list or particular curried function type
21:04:43 <Heffalump> yep
21:04:46 <Heffalump> I was just testing that out
21:05:04 <Heffalump> (remove the type signature of test2, put that of test3 back and move test2 to a where clause inside test3)
21:05:35 <ski> it's just that at top-level there's no embedding context supplying type informations needed to resolve the ambiguity
21:05:58 <ski> BTW, don't try list 1 2 3 :: [Int] (or try it if you dare)
21:07:08 * Heffalump thinks about that
21:07:23 <Heffalump> IM the error it gives
21:07:50 <ski> the problem with numbers are that they're overloaded in haskell so one has to write the consideably more tedious list (1 :: Int) (2 :: Int) (3 :: Int) :: [Int]. but is only a problem with number literals, i think.
21:08:07 <yusri> ah
21:08:45 <Heffalump> I assume the reason is that it can't tell whether there might be a "VarArgList Integer [Int]" instance, for example?
21:08:55 <ski> ah, your version uses a function accumulator, just what i though could perhaps also do the job of correcting the sequence order from reversed to non-reversed
21:10:23 <ski> hmm, it's possible. perhaps it would be nice to be able to delimit which instances of classes should be provided, such that one can't later define more instances (perhaps a little like "final" java classes or methods)
21:11:53 <ski> perhaps something like : class Foo a delimited FooX,FooY,FooZ where ...
21:12:16 <ski> and then only FooX,FooY,FooZ could be made an instance of Foo
21:12:36 <Heffalump> but here you want a limit that allows any a -> a ... -> [a] , how would you express that?
21:12:59 <ski> but this is perhaps more like subverting type classes to do things they weren't originally concieved to do. whaddya think ?
21:13:49 <Heffalump> yes, I think it would be
21:14:13 <ski> hmm, we have to revise the syntax a little so we write perhaps something like :
21:14:24 <Heffalump> you'd just be moving the job of resolving ambiguity from a specific definition,, where it belongs, to the class declaration
21:14:45 <ski> class VarArgList f a delimited (VarArgList [a] a,VarArgList f a => VarArgList (a -> f) a) | f -> a where ...
21:18:11 <ski> hmm, this would ensure that the only possible cases or those types generated from the two instances (i.e. [a],a -> [a],a -> a -> [a], ...), perhaps it wouldn't it this case help resolving ambiguity (not sure). Though if one only intends to make a finite, predetermined set of instances to a class, it seems to me that declaring that explicitely could perhaps give better ambiguity resolving. though as i said this may be a case of twisting type class
21:18:57 <Heffalump> yeah
21:19:44 <ski> the "normal" use of type-classes is to provide structured overloading of separate function definitions with similar types, more or less intrinsically open to new instances declared much later.
21:20:02 * xbill likes it
21:20:26 <ski> but here we've used type classes to be able to implement a particular effect, through perhaps more or less a trick.
21:22:25 <Heffalump> hmm. defining a generic zip seems impossible as I can't see any way of generically adding a single element to a tuple of arbitrary length 
21:22:45 <ski> i.e. this type class VarArgList is more like an implementation detail and shouldn't perhaps be accesible from outside, but we have to make at least the class known (cuz list's type is using it !), but we don't perhaps wan't other people to make new instances and possible corrupt ;) our small library, do we ?
21:24:02 <ski> yes, the problem here with tuples is that they aren't recursively defined from smaller tuples or the base type ()..
21:24:35 <xbill> that is an unfortunate aspect of them
21:24:50 <ski> i don't remember how they did some generic zip. it's fully possible it wasn't in haskell (though type classes were present), i don't recall.
21:25:55 <ski> xbill : one could perhaps wan't (at least for these kinds of tricks we're trying to do) them to be defined recursively
21:27:13 <ski> such that (a,b,c) == #(a,#(b,#(c,()))) where #(...,...) is a "tuple cons" constructor (with corresponding type)
21:28:08 * xbill yes, instance decls covering all tuples would be so nice
21:29:04 <ski> BTW : i can't seem to find clog's log of this channel at http://tunes.org/~nef/logs/haskell/ now when clog left and entered the channel to begin a new log file ..
21:29:47 * xbill has no idea
21:29:49 <ski> xbill : yes, for many "generic" functions and algorithms
21:29:55 <ski> ok
21:30:32 * xbill would like genericity over tuples
21:30:55 * ski phews (a little more tired, need sleep soon perhaps)
21:36:00 <jemfinch_> do Haskell's type classes incur any runtime penalty?
21:36:38 <Heffalump> yes, a dictionary gets passed around to any function that has a class constraint in its type
21:37:04 <Heffalump> (the alternative would be compile-time specialisation of all such functions, which would lead to a code size explosion)
21:37:53 <ski> jemfinch_ : it's called "dictionary passing style" but this only applies to functions polymorphic in the type belonging to a class
21:39:50 <ski> jemfinch_ : say if you write a functions that explicitely handles, say Int, then there's no dictionary passed around in that function, only direct refering the the global Int instance of the class in question. (except of course if that function calls a polymorphic function (excluding specialization) that must be passed such an dictionary), ok ?
21:40:04 <ski> Heffalump : yes
21:40:49 <ski> Heffalump : though one needn't blindly specialize all such functions but some perhaps..
21:40:55 <Heffalump> true
21:41:03 <Heffalump> I'm not sure if any work has been done on that
21:41:11 <ski> me neither
21:43:23 * xbill sighs.
21:44:38 <yusri> ok, im stumped
21:45:01 <ski> hmm, i'm not sure of what you mean..
21:45:10 <yusri> unrelated
21:45:36 <ski> you're unrelated ? what does that mean ?
21:45:56 <yusri> im stumped on a subject unrelated to your current discussion
21:46:05 <yusri> though, I'm sure I'd be stumped on that too ;)
21:46:17 <yusri> Doing some haskell exercises, and I'm stumped
21:46:42 <ski> ah, ok.
21:46:59 <jemfinch_> Heffalump: wouldn't the compile time specialization only be the same as C++ templates?
21:47:34 <ski> jemfinch_ : i guess at most like C++, but i'm not totally sure
21:48:06 <jemfinch_> does haskell have exceptions?
21:48:46 <yusri> something similar in monads, didn't i hear?
21:49:04 <ski> hmm, i don't think Haskell 98 has (but then again maybe it has, not sure), but some extensions (e.g. ghc) provide exceptions at least
21:49:44 <ski> oh, yes of course one can also make exception monads (Maybe being a vary simple "built-in" one)
21:51:14 <jemfinch_> yusri: you asked a question earlier about "unecessary" by I forget the context.
21:52:36 <yusri> jemfinch_: you said list comprehensions were ugly and unecessary in python
21:52:44 <jemfinch_> yusri: oh, yes.
21:52:54 <jemfinch_> they exist only because of python's former scoping issues.
21:53:01 <jemfinch_> and their syntax is ugly and non-pythonic.
21:53:21 <yusri> ah
21:53:25 <yusri> I was unaware scoping changed
21:53:45 <jemfinch_> yeah, in 2.2 it doesn't use the locals/globals/module scope anymore.
21:53:59 <jemfinch_> it uses a nested scope that's *almost* lexical.
21:55:40 <ski> ok.
21:56:26 <jemfinch_> dash (a #python person) says it's not lexical because you can't modify bindings in an outer scope.
21:56:42 <jemfinch_> (ie, no equivalent of scheme's set!)
21:56:59 <yusri> ah
21:57:44 <ski> jemfinch_ : is it not lexical then ?
21:57:47 <yusri> what would be a good substitute for the list comp in python? (if you'll allow me to get off subject)
21:58:21 <jemfinch_> ski: he says so, since python does allow modification of bindings under normal circumstances.
21:58:34 <jemfinch_> (whereas ML is certainly lexical, but doesn't allow modification of bindings *anywhere*)
21:58:54 <jemfinch_> yusri: map(lambda elt: <code>, list)
21:59:35 <jemfinch_> the only reason list comprehensions exist is to be able to capture the entire environment in the <code> -- with Python's old scoping, variables you wanted to be visible in <code> had to be passed in using the default-argument trick.
22:00:04 <ski> jemfinch_ : but IMHO that doesn't change the fact that the variables are scoped lexically, now, does it ?
22:00:16 <jemfinch_> ski: you can argue with him about it.  I'm on your side :)
22:01:29 <ski> jemfinch_ : ML as haskell doesn't allow binding modification, no. but ML allows changing the contents of a reference cell that is scoped lexically ..
22:01:41 <jemfinch_> yusri: it's funny that you're a linguist and you like Ruby -- I come from a linguistics background too and I *dislike* ruby, particularly for that reason.
22:02:38 <ski> jemfinch_ : ok, perhaps i will sometime..
22:02:47 <jemfinch_> :)
22:02:56 <jemfinch_> dash is a lisp programmer.
22:03:59 <ski> jemfinch_,yusri : i don't know much about Ruby. please enlighten my on why Ruby inyour opinion is disliked respectively liked. if you wan't to, of course :)
22:04:35 <jemfinch_> ski: In my opinion, it's in every way inferior to Python :)
22:04:50 <ski> jemfinch_ : aha, mostly Common Lisp, or is it Emacs Lisp (with dynamic scoping) ?
22:05:11 <Heffalump> jemfinch_: yeah, but with more inlining opportunities (belatedly)
22:05:26 <jemfinch_> Heffalump: remind me what question you're answering :)
22:05:37 <jemfinch_> ski: he's a CL person, I think.
22:05:44 <ski> jemfinch_ : aha, ok. why ?  the syntax, the built-in control,basic datatypes,basic libraries or semantics ?
22:06:11 <ski> jemfinch_ : ok.
22:06:57 <jemfinch_> ski: the syntax for python is more consstent, there are more users, more implementations, more modules, the implementation (in C) of the interpreter is of *much* higher quality, the list goes on and on.
22:08:29 <ski> jemfinch_ : i remember a while ago on comp.lang.scheme when there was much debate about an setf-alike thing in scheme, whether it should be named set! or something other. (some people argued that the former conflates mutating a datastructure with mutating the environment (a meta-level entity), the other side liked it for the same reason.. *sigh*)
22:09:53 <ski> jemfinch_ : ok, all these seems to be good things (more or less)
22:13:09 <ski> BTW : about clog, my mistake, clog didn't switch date, but instead quited (20:47:30) and joined again (20:47:57) to continue logging the same date (i think one comment by Heffalump got unlogged in between, or so), i have seen it do that one time before, perhaps because of some internal error..
22:14:46 <yusri> ski: coming back to your question (was away)
22:15:26 <yusri> of course I disagree with jemfinch
22:16:03 <yusri> I think the concept that a language should be less liked b/c it is less widespread is baseless
22:16:25 <yusri> I'm not talking about commercial use
22:16:32 <yusri> of couse companies like big names
22:16:35 <jemfinch_> what kind of bot is clog?
22:16:59 <yusri> jemfinch_: talking to me?
22:17:11 <yusri> ah-
22:17:14 <yusri> disregard
22:17:21 <jemfinch_> yusri: in these days of powerful computers, programmer efficiency is by and large the metric by which programming languages are measured.
22:17:38 <ski> yes, in some sense at least. even a non-widespread language may have novel and interesting and potentially much generally useful (at least in some problem domain) approaches to programming.
22:17:57 <yusri> I think the best person to defend my position is PragDave, but i see he's out ;)
22:18:07 <jemfinch_> yusri: and the size of the community, the number of quality third-party modules, the documentation available, the development that occurs in the language, all these have a very significant effect on programmer productivity.
22:18:22 <yusri> True- then why do you know haskell?
22:18:27 <jemfinch_> yusri: I don't :)
22:18:37 <yusri> ha.
22:18:40 <jemfinch_> I'm an MLer myself -- currently O'Caml, switching to SML when I get some time :)
22:18:49 <ski> jemfinch_ : all i know is that clog logs some channels here on this irc server and that it perhaps primarily logs them for the TUNES project
22:18:56 <jemfinch_> I hang out here because you people are smart :)
22:19:10 <yusri> jemfinch_: not me, ski ;)
22:19:31 <yusri> I hang out here b/c I hope it rubs off 
22:20:00 <jemfinch_> yusri: the main problem with ruby is that its user community is smaller and its implementation doesn't have anything over Python's -- it's both starting already behind and growing slower.
22:20:09 <yusri> jemfinch_: I program in both, and I think I program faster and more effiently in ruby
22:20:36 <jemfinch_> yusri: I think you're in a minority, from what I've observed.
22:20:51 <yusri> ah well
22:20:59 <ski> jemfinch_ : size of the community, etc. IMO can be a historical (practical) accident, even though it's theoretical practicalness ;) could be good. but of course that won't always save the language from extinction or near-extinction.
22:21:13 <yusri> In general, I think advocacy is useless.
22:21:21 <yusri> People will like what they like for whatever reasons.
22:21:27 <jemfinch> yusri: you're right, and I waste too much of my time with it.
22:21:35 <yusri> I live certain things in Python ruby doesn't have, yes
22:21:38 * jemfinch freely admits that, but can't seem to stop it much.
22:21:47 <yusri> s/v/k/
22:21:53 <jemfinch> yusri: have you read up about 2.2?
22:21:55 <yusri> in particular, the namespace issues
22:22:18 <yusri> well, i don't think that will change my feelings, but no- I don't know that particulars
22:22:24 <jemfinch> ski: you're a haskell programmer, right?  What other languages do you know?
22:22:30 <yusri> sheesh, ignore my spelling
22:23:34 <jemfinch> yusri: well, the type/class distinction is gone -- you can inherit from builtin types now.  Generators make coroutines easy as cake to pull off.  There's now a generic iteration API which allows classes to specify their own iteration semantics however they want it.
22:23:36 <yusri> jemfinch: if you have anything in particular in 2.2 you think is noteworthy, drop me an url ;)
22:23:53 <ski> jemfinch_ : why me smart ? i'm not sure, though i'm sure i have much interest in these topics (even to sometimes think on it on large parts of my free-time)
22:23:58 <yusri> Yes, I do recall reading up a little on the iterators
22:24:15 <yusri> frankly, it's a matter of OOPness for me
22:24:26 <yusri> If I'm going to OOP, I don't feel like doing it halfway
22:24:27 * jemfinch has to go study, he'll be back in a couple hours :)
22:24:46 <ski> jemfinch_ : so you mean that ruby is a little like a bad plagarizing of python, and come to late also ?
22:24:59 * yusri has heard that before
22:25:16 <yusri> I _hate_ the python 're' module
22:25:32 <yusri> When you're in the business of language parsing, python bites it.
22:26:10 <ski> jemfinch : yes, the functional language i know best is haskell, i think.
22:27:13 <ski> jemfinch : more or less tranparent generators and coroutines sounds interesting, i've not had much experience with such things.
22:27:59 <ski> yusri : 're' module ?
22:28:29 <xbill> Haskell is good
22:29:06 <yusri> regex
22:29:33 <yusri> python regex is _tedious_
22:29:42 <ski> yusri : aha.
22:29:46 <yusri> although I'm sure it has its good points
22:30:04 <ski> xbill : Haskell is good in what aspects ?
22:30:42 <ski> yusri : so you don't wan't part OOP part not, then i presume ?
22:31:13 <ski> s/wan't/want/ (stupid recurring misspelling)
22:33:49 <yusri> haha
22:34:07 <yusri> well- when working in OOP, I prefer to work with a language that supports it correctly
22:34:14 <ski> ok.
22:34:36 <yusri> my main problem is the lack of closures
22:35:09 <yusri> why should functions be required to use () to enclose params when it's not necessary?
22:35:27 <ski> ah, that is a problem for someone used to higher-order-functions
22:35:40 <yusri> things like that annoy me.  - Why must a user or program know when a function in a function and not just a value?
22:35:52 <ski> how do you mean with () ?
22:36:01 <yusri> that's another reason why I like haskell
22:36:02 <yusri> yes
22:36:04 <yusri> exactly
22:36:12 <yusri> function()
22:36:18 <ski> you mean like foo :: () -> Int instead of foo :: Int ?
22:36:29 <yusri> well, like
22:36:36 <ski> that's because haskell is lazy, i assume.
22:36:56 <yusri> fun()
22:37:00 <yusri> instead of just
22:37:01 <yusri> fun
22:37:16 <ski> (whereas most languages are not, regardless of availability of closures and/or higher-order-functions)
22:37:23 <yusri> right
22:37:55 <ski> yes, that's definitely it ! ('nother game citation)
22:39:14 <yusri> I do like python exceptions
22:39:24 <yusri> but ruby has them as well
22:39:36 <yusri> so, I don't think I'm missing anything
22:39:49 <ski> i pondered a little about a language with no explicit function arguments, you just use both dynamic and static scoping (dynamically scoped variables simulate function arguments)
22:39:57 <ski> ok.
22:42:49 <ski> so a sample use of a map might be : let xs = [1,2,3] ; {x * x} in @ map
22:46:22 <ski> but i don't think it would be of much practical use. just a wild though i had (the definition of a thunk "{...}" has to tell if it wan't the dynamic scope or the first static level above, or the next, and so on ...)
22:47:07 * PragDave is away: zzzzz
22:47:36 <yusri> ah
22:54:41 <ski> was this PragDave logged on to this channel, i don't recall him saying anything. (though perhaps listening). he is one of those who founded Pragmatical Programming as a concept, is that correct ?
22:55:14 <yusri> He is one of two, yes
22:55:27 <yusri> He's also a leading member of the Ruby community
22:56:28 <yusri> ok- here's (yet another!) question for you, ski
22:56:39 <ski> ok, nice.
22:56:44 <yusri> I have a function: call it scaleChar
22:56:47 <ski> ok
22:57:03 <yusri> Char -> Int -> [Char]
22:57:10 <ski> aha, ok.
22:57:17 <yusri> I want to use it in a list comprehension
22:57:25 <ski> ok
22:57:40 <ski> what is it supposed to do. or is that irrelevant ?
22:57:51 <yusri> irrelevant
22:57:51 <ski> (scaleChar, i mean ?)
22:57:55 <ski> ok
22:58:03 <yusri> replicate x y
22:58:06 <yusri> that's all
22:58:22 <yusri> so- the list comp:
22:58:43 <ski> so, then, what would you like to accomplish with the list-comprehension using this function of aforemented type ?
22:58:58 <yusri> x > 0 = [ scaleChar char x | char <- line ]
22:59:05 <ski> (is scaleChar === replicate ?)
22:59:22 <yusri> yes, basically
22:59:42 <yusri> my problem is w/ 'x'
22:59:49 <ski> hmm, what do you want with x > 0 ?
23:00:12 <yusri> it's an int that gets tested
23:00:22 <yusri> I want it to be a the int param for the function
23:00:24 <ski> in a guard ? ok, i get that.
23:00:28 <ski> ok
23:00:45 <yusri> problem is that 'x' is not in scope, I'm guessing
23:00:50 <ski> (and line is propable another argument)
23:00:56 <yusri> yes
23:01:07 <yusri> line is a string
23:01:08 <ski> hmm, how not in scope
23:01:13 <ski> yes
23:01:27 <yusri> I want to be able to take, for instance, "this" and make it "ttthhhiiisss"
23:01:45 <ski> so you have something like :
23:02:06 <ski> foo line x | x > 0 = [scaleChar char x | char <- line]
23:02:09 <ski> or what ?
23:02:46 <dennisb> that should work fine, i don't see what the problem is
23:03:05 <ski> hmm, this generates a list of strings and not i string, i suppose. that can e.g. be fixed by concat.
23:03:23 <dennisb> ski: true
23:03:29 <yusri> right
23:03:38 <yusri> well- that was stupid
23:03:41 <ski> so perhaps foo line x = concat [scaleChar char x | char <- line]  (is the guard really nessecary ?)
23:03:42 <yusri> x was in scope-
23:04:14 <yusri> yes
23:04:16 <ski> or you want to write it somehow without concat ?
23:04:27 <yusri> no, concat is fine
23:05:02 <ski> ok, i have a little trouble understand what you though was a problem (and perhaps is).
23:05:44 <ski> hmm, one can dispense with concat by :
23:06:35 <ski> foo line x = [c | char <- line , c <- scaleChar char x]
23:06:56 <dennisb> (I prefer the concat version)
23:07:09 <ski> i think, at least, that that does it. but that wasn't of course what you wanted ?
23:07:28 <ski> dennisb : i agree, in at least this case.
23:08:37 <yusri> well, my question actually answered itself-
23:08:38 <yusri> but
23:08:48 <yusri> you gave me background that explains some other issues
23:08:55 <yusri> (that I would have asked you about anyhow)
23:08:57 <ski> ok, so why did you want the guard, was it because you want to recursively call foo with (x - 1), say ?
23:09:03 <yusri> So you saved yourself some time ;)
23:09:16 <ski> oh, thanks ;)
23:09:24 <yusri> actually, I need to determine if it's necessary
23:09:33 <ski> ok.
23:11:37 <ski> (i was trying to make a list version that uses reverse at last, but i can't seem to get it work right now. maybe later)
23:15:03 * ski reading a little more at www.pragmaticprogrammer.com
23:27:45 <yusri> you were right- that guard wasn't necessary
23:28:01 <ski> uhum, ok
23:33:29 * xbill sighs.
23:33:49 <ski> xbill : again ? why ?
23:40:14 <xbill> not enough time for Haskell hacking
23:40:35 <ski> ah. :(
