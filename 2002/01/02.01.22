01:16:56 <shapr> re dennisb 
01:17:00 <Heffalump> morning
01:17:36 <shapr> g'mornin Heffalump 
01:17:39 <shapr> what's up?
01:18:37 <Heffalump> not much
01:18:40 <Heffalump> I should go to work
01:18:54 <shapr> yah, probably so
01:19:04 <shapr> I've been at work since 9am
01:19:06 <shapr> I should start
04:16:11 <shapr> hm, Michael Feathers asking about SMTP and POP3 libs for Haskell
04:16:17 <shapr> I gotta get movin
04:26:02 <jewel> movin where?
04:26:19 <shapr> well, start cranking out libraries
04:27:01 <shapr> xbill passed me a minimalistic Imap.hs he wrote, it includes a bit of SMTP support as well
04:28:35 <shapr> plus it's pretty likely that if I release crappy newbie versions of Haskell libs
04:28:46 <shapr> then more experience people will complain and fix them =)
04:35:45 <shapr> or at least give me advice on how to fix them
05:05:44 <shapr> yay! I got ASN.1 Haskell code!
05:14:07 <shapr> wow cool
05:14:16 <shapr> it's an LDAP module written in Haskell
05:14:20 <shapr> it's pretty, too
05:14:59 <Heffalump> cool.
05:15:13 <shapr> very elegant
05:41:07 <shapr> hrm
05:41:15 <shapr> data ASN = forall a . (CF a, Encodable a, Show a) =>
05:41:15 <shapr>               Primitive' Tag a |
05:41:15 <shapr>               Constructed' Tag [ASN]
05:41:23 <shapr> any idea why that won't compile?
05:41:32 <shapr> ASN.hs:12: not a constructor: `forall'
05:41:35 <shapr> that's from ghc
05:42:07 <shapr> that looks like a type statement on a type alias..
05:46:31 <Heffalump> try it with ghc -98
05:46:47 <Heffalump> an explicit forall isn't valid Haskell 98, but it's a fairly standard extension
05:47:33 <shapr> hrm, ok
05:48:19 <shapr> I was using "ghc --make -package data Test.hs"
05:48:28 <shapr> it doesn't recognize -98
05:49:38 <shapr> hrm
05:52:23 <shapr> oh
05:52:29 <shapr> hugs -98 Test.hs *does* work
05:52:39 <Heffalump> oh, the flag to ghc might be different, sorry
05:53:01 <Heffalump> possibly -fglasgow-exts ?
05:53:07 * shapr tries that
05:53:35 <shapr> yay!!
05:54:04 <shapr> thanks!
07:17:09 <xbill> re graydon
07:17:10 <xbill> ltns
07:28:20 <jewel> "Sometimes people don't even realize they have bought illegal software, or don't realize that sharing software with friends is illegal," Piquette said.
07:28:38 <LoganH> BSA?
07:28:59 <jewel> http://www.wired.com/news/business/0,1367,49856,00.html
07:29:04 <jewel> melkrasoft
07:29:18 <LoganH> I like how they always lump all software sharing as illegal.
07:29:36 <LoganH> Because I guess it doesn't sound as nice if you say that just your software is illegal to share. :P
07:30:20 <LoganH> Heh, I'm not sure I'd pay $3 for Windows XP. :P
07:30:24 <jewel> but that is exactly what they should be saying
07:30:27 <jewel> hehe
07:31:17 <LoganH> Look, criminals are involved in anything that will make them a profit," Angonasta said. "And anything that will make a profit can also be used to fund terrorism activities, so it's probably happening somewhere.
07:31:21 <LoganH> Wow, that is the worst argument ever.
07:31:33 <LoganH> It's like straight out of Monty Python or something.
07:31:59 <LoganH> This is a really good story to make fun of on my site. *grin*
07:32:40 <LoganH> There are so many fallacious arguments here.
07:35:54 <graydon> erm. you're quoting out of context.
07:36:10 <graydon> "... It's an interesting concept, but to my knowledge there's only one possible case where they think one guy, who seemingly operates on his own out of South America, may have been kicking back part of his profits to a terrorist group. I just don't see this as a fascinating new trend"
07:36:26 <graydon> the rest of what the guys says clearly indicates he _doesn't_ think it has anything to do with terrorism.
07:36:53 * LoganH nods.
07:37:03 <LoganH> He's poking fun at the people that do claim that.
07:37:18 <LoganH> Gotta go to class, later.
11:06:05 <shapr> hi zorb 
11:06:12 <zorb> hello
11:06:26 <shapr> accomplished Haskeller? or just learning?
11:06:28 <zorb> wow, this place is popular compared to efnet haskell.
11:06:36 <shapr> how many on efnet?
11:06:40 <zorb> still learning.
11:06:46 <zorb> um... a few.
11:07:08 <shapr> well, invite 'em over ;)
11:07:20 <shapr> I've taken a sacred vow never to return to efnet
11:07:24 <shapr> so I can't
11:07:25 * shapr grins
11:07:26 <zorb> they probably already know about this place :)
11:08:05 <shapr> if you're still learning Haskell, you may want to check out the Language of the Year project
11:08:21 <shapr> http://pragmaticprogrammer.com/loty/
11:08:43 <jewel> efnet, what's that?
11:08:47 * jewel grins
11:08:52 <zorb> hehe
11:09:03 * shapr grins
11:09:09 <jewel> and leaves for jujitsu, later
11:09:23 <shapr> bye jewel!
11:09:34 <zorb> later jewel
11:11:11 <shapr> so zorb... have any questions?
11:11:24 <zorb> well...
11:11:26 <shapr> wanna donate code to the Haskell Libraries Project? :)
11:11:36 <zorb> oh sure.
11:11:47 <zorb> just tell me what to write :)
11:12:13 <shapr> I'm working on an Imap.hs
11:12:25 <zorb> hmm, Imap?
11:12:35 <shapr> on comp.lang.functional, Michael Feathers just requested an SMTP and POP3 module
11:12:52 <shapr> I think libs of that flavor would be useful to the general public
11:12:57 <zorb> oh right.
11:13:07 <zorb> hmmm.
11:13:12 <shapr> what do you think?
11:13:29 <zorb> um, of doing something like that?
11:14:00 <shapr> yah
11:14:02 <zorb> im ambivalent
11:14:08 <shapr> hi, I'm Shae ;)
11:14:16 <zorb> heh
11:14:18 <LoganH> How do I convert a list of elements to a list of single-element lists?
11:14:44 <Igloo> map (\x -> [x])
11:14:49 <zorb> on the one hand, i can see much usefullness for something like that as a haskell module
11:15:15 <shapr> if you have better suggestions for Haskell modules, I'd love to hear 'em
11:15:22 <LoganH> Igloo: Thanks.
11:15:27 <LoganH> I need to learn this anonymous lambda thing.
11:15:48 <shapr> hrm, I want a cvs server for the Haskell Tutorial
11:15:50 <Igloo> Do you want me to explain how it works?
11:15:58 <shapr> maybe I should use sourceforge
11:16:20 <zorb> on the other hand I'm lazy enough to want to use a ffi to some other imap library :)
11:16:39 <zorb> if there is one.
11:17:45 <zorb> (i guess the reality is for me that im not too interested in learning the ftp http,imap, etc protocols)
11:18:24 <zorb> hmmm.
11:18:29 <LoganH> Igloo: Sure.
11:18:52 <LoganH> I guess \x -> expr makes expr a function that acts on x?
11:19:22 <zorb> (\x -> x + 3) 5 => 5+3
11:20:18 <zorb> the x in that expression gets bound to 5.
11:20:42 * LoganH nods.
11:20:44 <LoganH> It makes sense.
11:20:53 <LoganH> When I first read about it, I wasn't thinking this way.
11:21:09 <Igloo> (\ p1 p2 p3 ... pn -> f)  is a function that takes n arguments matching the patterns p1 through pn, binding the values as normal functions do, and evaluates f with them having these values
11:21:29 <LoganH> Cool.
11:22:17 <Igloo> So you can also have tuples or lists on the left, so you can do (\(x, y) [a,b,c] -> x + y + a + b + c) (4, 5) [3,4,5]
11:24:12 <zorb> yeah, of coures you'd better not try that against something that has more than 3 elements in that list..
11:24:29 <Igloo> Yeah  :-)
11:25:53 <LoganH> I can't make this function correct no matter what I try.
11:25:58 <Igloo> What function?
11:26:21 <LoganH> I have a FiniteMap that associates Strings to Strings.
11:26:35 <LoganH> Or, really, Chars to Strings.
11:27:00 <LoganH> And I want to replace each character in a word with the string it's mapped to in the FiniteMap.
11:27:22 <LoganH> I think I know what I may have done wrong, now that I've formalized it like that. *grin*
11:27:32 <Igloo> :-)
11:27:48 <shapr> yah, the "cardboard wookie" syndrom
11:27:56 <LoganH> Cardboard wookie?
11:27:58 <zorb> hmm?
11:28:05 <shapr> er, it's a story I read...
11:28:15 <zorb> I've never heard of it posed like that.
11:28:32 <LoganH> I didn't define the types of my function properly.
11:28:39 <shapr> the lead developer on a project had all his time taken up by his team members coming to him to explain their problem
11:28:42 <LoganH> Because the translation as I describe is String -> [String], which I didn't realize. :P
11:29:00 <shapr> about 75% of the time they figured it out halfway through the discussion
11:29:03 * LoganH nods.
11:29:05 <LoganH> I do that all the time.
11:29:14 <LoganH> I'm more used to channels where people rarely answer me. :P
11:29:17 <shapr> so the lead put a cardboard wookie in the small room in front of his office
11:29:43 <shapr> and then clients on tour would say "why is your developer talking to a cardboard wookie?"
11:30:01 <zorb> ah!
11:30:24 <zorb> damn, that's not such a bad idea :)
11:30:48 <shapr> yah, I have a small purple stuffed pterodactyl hanging from an ethernet cable over my monitor =)
11:31:19 * graydon contemplates adapting eliza to the task
11:31:28 <shapr> yah, that would be a good idea
11:31:58 <Igloo> "I have a function of type [String] -> [String]"
11:32:05 <Igloo> "Why do you have a function of type [String] -> [String]?"
11:32:10 <Igloo> "Oh, yeah, thanks"
11:32:12 * shapr laughs
11:34:25 <LoganH> Hahaha.
11:39:45 * Igloo growls at people who don't know how to use tabs properly
11:40:05 * shapr hides his unsightly stack of spaces
11:40:05 <LoganH> What is proper tab usage?
11:40:19 <shapr> tabs on cereal boxes?
11:40:24 <shapr> that does irritate me.
11:41:10 <Igloo> Proper tab usage is fairly complicated, but using 4 "space" indentation but collapsing every 8 spaces into a tab is the worst and most common error
11:42:08 * LoganH nods.
11:42:18 <LoganH> I wish vim didn't do that by default when autoindenting.
11:42:25 <shapr> Igloo: is proper usage documented somewhere?
11:42:25 <LoganH> That's why I'm really strict about only indenting to tab stops.
11:43:03 <LoganH> I can imagine mixed tab usage could really screw up Haskell parsing.
11:43:17 <LoganH> I've never been a big fan of layout governing syntax.
11:43:22 <Igloo> shapr: I haven't seen anything that does so
11:43:22 <Igloo> emacs does by default too
11:43:25 <Igloo> I just use spaces
11:43:41 <LoganH> A lot of people have very strong and very opposing views regarding tab usage.
11:43:45 <Igloo> Haskell defines tabs to be 8 spaces for the purposes of the layout rule
11:44:18 <LoganH> When vim autoindents, it uses as many tabs as it can, then uses spaces to make up the remaining difference.
11:44:27 <LoganH> So it's pretty safe that way.
11:45:14 <shapr> I'm used to Python, correct usage there is: one indent is four spaces, two indents together take up 8 spaces. continue adding four spaces every indent
11:45:29 <shapr> and *never* use tab characters in your source code.
11:45:44 <shapr> Igloo: you should be receiving email from me about now ;)
11:45:45 <Igloo> Tabs in Haskell are harder than normal because of the way people tend to write it
11:45:45 <Igloo> (if you ignore the fact they are defined to be 8 spaces)
11:45:53 <LoganH> I use a tabwidth of 4.
11:45:55 <LoganH> And just use tabs.
11:46:02 <LoganH> That way you can have the tab character actually mean indention.
11:46:23 <LoganH> The problem occurs when other people modify your code with editors that aren't smart with tabs.
11:46:33 <Igloo> shapr: Who are you?
11:46:40 <shapr> Hi Igloo, I'm Shae Erisson.
11:46:47 <shapr> nice to meet you.
11:47:01 <Igloo> Hi, but whois already told me that  :-)
11:47:06 * shapr grins
11:47:16 <Igloo> Will the mail be from Shae Erisson too?
11:47:20 <shapr> yup.
11:47:32 <LoganH> shapr: Let's see some ID.
11:47:37 <shapr> uh oh
11:47:37 <Igloo> Ah, OK, not one of the ones I just got then
11:47:57 <Igloo> LoganH: That doesn't work in Haskell
11:47:59 <shapr> part of the Haskell Tutorial Series, brought to you by a realllly long CC: list
11:48:08 <Igloo> <tab>foo = do bar
11:48:13 <Igloo> <tab>         baz
11:48:22 <Igloo> Is not the same as
11:48:25 <Igloo> <tab>foo = do bar
11:48:34 <Igloo> <tab><tab><tab> baz
11:49:06 <LoganH> I do <tab>foo = do<newline><tab><tab>bar<newline>baz
11:49:39 <LoganH> I think "cuddling" expressions with keywords makes it too difficult to line things up.
11:49:43 <Igloo> OK, that style will work
11:50:02 <Igloo> Hmm? How is it any harder?
11:50:04 <shapr> with emacs, I can hit C-c = and stuff lines up happily.
11:50:20 <LoganH> Igloo: First, it pushes your amount of indenting way out to the right.
11:50:48 <LoganH> Second, you either have to follow the keyword you're cuddling with a tab (so you can still use just tabs to indent), or you'll have to use mixed tab/space usage to line things up.
11:50:51 <Igloo> shapr: Is this mail going to be about CVS, before I send one about it?  :-)
11:51:02 <LoganH> And either case is bad, because you might change your tab width.
11:51:09 <LoganH> In which case the number of tabs required to line things up will change.
11:51:17 <LoganH> Which means someone else won't necessarily see your stuff lined up.
11:51:43 <LoganH> If you constrain tabs solely to the beginning of lines, your code will look the same regardless of editor settings (though it may get wider or narrower :P).
11:52:09 <Igloo> I'm not convinced I like
11:52:16 <Igloo> somethingverylong = do
11:52:27 <Igloo>     stuff inside the do block starts way back here
11:52:29 <shapr> Igloo: yah, it is
11:52:34 <Igloo> OK
11:52:53 <shapr> Igloo: I volunteered for chapter 2 (since that's all I'm really qualified for) and I asked about CVS, and requested a mailing list.
11:52:59 <LoganH> Igloo: Well, I hate how somethingverylong = do has a body that is indented at a different level than short = do.
11:53:27 <LoganH> You could do somethingverylong =<newline><tab>do<newline><tab><tab>body
11:53:37 <LoganH> I'm kind of undecided between the two styles.
11:53:41 <Igloo> And I'm not sure what you meant about tabstop changing making the code not line up properly - it will if you are using tabs correctly
11:53:41 <LoganH> I tend to use the latter style in bash scripts.
11:53:46 <Igloo> e.g.
11:53:47 <Igloo> <Igloo> <tab>foo = do bar
11:53:47 <Igloo> <Igloo> <tab>         baz
11:54:01 <LoganH> Yeah, but most editors don't autoindent that way.
11:54:04 <Igloo> Or replace the rightmost space on each line with a tab if you prefer
11:54:11 <LoganH> And I've found typing that way is a pain.
11:54:11 <Igloo> No, but that's the fault of the editor
11:54:20 <LoganH> I used to line up the conditional expressions in if statements in C, for example.
11:54:23 <LoganH> And ran into the same problems.
11:54:27 <Igloo> And is basically the reason why I use spaces
11:55:05 <LoganH> I think my style makes the semantic meaning of every whitespace character perfectly clear to me. :P
11:55:06 <Igloo> Editors will lign subsequent lines up correctly, if you are just using spaces, when you hit enter
11:55:11 <LoganH> So if I'm ever processing my code itself, I know what to do.
11:55:34 <Igloo> Yeah, I don't think there is anything wrong with your style, it's just not my preferred style
11:55:34 <shapr> imho, if it works in ghc, I can always reindent it later.
11:55:48 <Igloo> It's code that breaks when your tabstop isn't the same as the author's tabstop that annoys me
11:55:48 <LoganH> This just goes to show that there can never be any consensus on the matter, hence there is no "proper usage documented" anywhere. :P
11:56:07 <LoganH> I think my way is consistent enough to be safe.  I'm not an expert on Haskell syntax yet, though. :P
11:56:30 <Igloo> You can define "Proper usage of tabs", but you will be defining a set of possibilities rather than the One True Way
11:56:41 <LoganH> I think if the only whitespace that can occur before any non-whitespace at the beginning of the string is tabs, then it's safe.
11:56:51 <LoganH> Maybe A True Way. :P
11:57:08 <Igloo> :-)
11:57:15 <shapr> soo...
11:57:34 <shapr> anyone wanna contribute code to the Haskell User-Submitted Libraries project?
11:57:35 <LoganH> So I need to fix this code. :P
11:57:37 <LoganH> shapr: Sure.
11:57:43 <shapr> anyone wanna join as a developer?
11:57:48 <Igloo> What is that, shapr?
11:57:57 <LoganH> I just started learning Haskell 36 hours ago, though.
11:57:59 <shapr> it's a sourceforge project I just created
11:58:00 <Igloo> :-)
11:58:08 <Igloo> Ah, has it actually been created already?
11:58:12 <shapr> because honestly, the standard libs are missing lots of stuff
11:58:15 <shapr> well, submitted
11:58:17 <shapr> not approved
11:58:18 * Igloo has not been impressed with my SF experiences
11:58:27 <LoganH> Is it just packages, or cookbook style code snippets?
11:58:27 <shapr> hey, it's better than what I have
11:58:31 <zorb> shapr where is it?
11:58:50 <shapr> zorb: it'll be sf.net/projects/haskell-libs/ if they approve it (which I assume they will)
11:58:56 * Igloo really should have replied half an hour ago instead of collapsing on here  :-)
11:59:05 <LoganH> I'm putting together a cookbook (in C) for the programming teams I coach. :P
11:59:06 <Igloo> What did you put for the license OOI?
11:59:22 <shapr> LoganH: oh cool, you coach programming teams!
11:59:29 <LoganH> Well, assistant coach.
11:59:41 <LoganH> But I thought it'd be cool to have this cookbook.
11:59:52 <LoganH> We've always had code lying around, but never organized and thus never much reused.
12:00:03 <LoganH> And you can only have paper sources in an ACM contest. :P
12:00:59 <Igloo> diff -ub rocks
12:01:22 <shapr> Igloo: I chose a BSD license
12:01:27 <LoganH> diff --side-by-side :P
12:01:33 <shapr> mostly because I read the GHC license today
12:02:08 <shapr> and it says "we can't use lGPL because binaries would require something, and this, and that, and so.. we use something that's almost BSD"
12:02:51 <shapr> honestly, I don't care about the license as long as no one tries to sue me.
12:03:28 <Igloo> Overkill - it was a 3 line change hidden as the guy doing it had changed all the tabs to spaces - hence the -b  :-)
12:03:55 <shapr> aha
12:04:27 <shapr> Tom Moertel wants to get the latest version of tHT also
12:04:28 <Igloo> Hmmm, that's not in the Debian copyright file
12:05:06 <Igloo> MS do their best not to touch anything GPLed to avoid possible problems if they write similar things unrelatedly, though
12:05:15 <shapr> "viral" licenses
12:06:45 <Heffalump> what does Sourceforge actually provide?
12:07:09 <shapr> cvs tree, website, bug tracking, etc
12:07:18 <shapr> and I just got the approval mail :)
12:07:20 <shapr> yay!
12:08:12 <shapr> anyone else wanna join?
12:08:22 <shapr> if so, tell me your unix username for sf.net
12:08:25 <LoganH> What is the definition of Ordering?
12:08:37 <LoganH> shapr: I'm loganhanks.
12:08:42 <shapr> awright
12:09:16 <LoganH> Oh, I think I found it, LT | GT | EQ ?
12:10:08 <zorb> i think I have a name as nrut uder sourceforge.  I may need to create a new account though.  (yes I want in)
12:10:32 <shapr> ok, check to see if you can login to sf.net
12:10:36 <shapr> if you can, I'll add you
12:15:02 <zorb> I'm in.
12:15:27 <shapr> and your username is?
12:15:48 <zorb> nrut
12:15:51 <shapr> awright
12:16:06 <Heffalump> loganh: yep
12:16:37 <shapr> ok, you're added
12:17:35 <LoganH> Can patterns be nested (like: [(a, b):rest])?
12:17:51 <Igloo> Yes
12:18:04 <LoganH> Thought (hoped) so. :P
12:18:09 <Heffalump> though that pattern is probably wrong
12:18:25 <Heffalump> unless you really want a singleton list whose element is a list of tuples
12:18:30 <Heffalump> s/a/to match a/
12:18:38 <Heffalump> doh, s/a /to match a /
12:19:02 <zorb> incidently [a,b,c] is rather a ahort version of (a:(b:(c:[])))
12:19:03 <shapr> alrighty
12:19:34 <zorb> so you were implicitly using a nested pattern.
12:19:37 <shapr> I'll try to have Imap.hs (donated by xbill) cleaned up and in CVS tonite
12:23:51 <shapr> anyone else have some libs or code they want to donate?
12:24:58 <LoganH> I meant ((a, b):rest) :P
12:26:23 <LoganH> I'm starting to get to the point where I have bugs more often than type errors. :P
12:26:33 <Igloo> :-)
12:26:41 <zorb> I posted something onto the haskell-cafe mailing list about a week ago, but frankly its 1. too ugly and unruly 2.my goal was to ambitious for my level of knowledge of Haskell.
12:27:36 <zorb> so franky,  I dont have anything :(
12:27:54 <Igloo> huh?
12:28:24 <zorb> um..
12:28:34 <Igloo> Oh, I see, code to contribute
12:28:40 <zorb> right.
12:28:54 <Igloo> What did you post OOI?
12:29:06 <zorb> OOI?
12:29:10 <Igloo> out of interest
12:29:18 <zorb> ooh.
12:29:24 <zorb> Differentiate.lhs
12:29:38 <zorb> (more of a web page to it).
12:29:39 <Igloo> Ah, right
12:29:47 <LoganH> How do I convert a list of lists to a flat list?
12:29:51 <LoganH> Seems like it should be obvious to me.
12:29:52 <Igloo> Yeah, I remember the link being mentioned now
12:29:57 <Igloo> concat
12:30:47 <LoganH> Thanks
12:30:54 * shapr goes off to watch Dark Angel
12:31:12 <zorb> mmm. Jessica Alba
12:31:46 <LoganH> Now to come up with something analagous to strstr in C. :P
12:32:14 <LoganH> I really need a good Haskell function reference. :P
12:32:28 <Igloo> The report is fairly good as a reference
12:32:49 <Igloo> www.haskell.org, definition and follow the link to the revised edition
12:33:03 <zorb> well..., if you want fast there's something like Knuth, Morris, Pratt, which I have no idea how'd that be translated to haskell :)
12:33:20 <LoganH> The report seems to just be type signatures and implementations. :P
12:33:28 <zorb> or the best way anyway.
12:33:37 <xbill> Knuth-Morris-Pratt is not quite as good as Boyer-Moore.
12:34:01 * Heffalump thinks the report is only good as a reference if you like that sort of thing, which most people don't
12:34:11 <Igloo> Or implementation and specification are fairly close in Haskell, and type signatures, specification and name (often gives a hint as to what it does) make a good reference IMO
12:34:25 <Igloo> s/Or //
12:34:39 <LoganH> KMP and BM would both be overkill for the substring searching I'm doing. :P
12:34:47 <zorb> hehe
12:34:58 <LoganH> Since my max word size here is 80.
12:35:33 <LoganH> Is there a trivial way just to get the length n prefix of a string?
12:35:40 <LoganH> (or the first n elements of any list?)
12:35:55 <zorb> take n
12:35:56 <Heffalump> take
12:35:59 <LoganH> Ohhh yeah.
12:36:01 <LoganH> Heh.
12:36:11 <Heffalump> and if you're looking for prefixes, isPrefixOf is a good function..
12:40:27 <zorb> hmmm. strstr searchstr str@(_:xs) = (searchstr 'isPrefixOf' str) || strstr searchstr str;strstr _ [] = False .... (or something :-)
12:40:34 <zorb> oops.
12:41:09 <zorb> s/strstr searchstr str/strstr searchstr xs/
12:41:14 <Heffalump> :-)
12:41:25 <Heffalump> strstr [] [] should be true
12:42:14 <zorb> I think I understand your thinking
12:42:21 <Igloo> Is tails not in the prelude?!
12:42:38 <Igloo> Hmm, it's in List
12:43:18 <zorb> but rather str [] _ should probably be true. (null is a substring of anything including null)
12:45:15 <Heffalump> igloo: would tails make the code particularly better?
12:45:44 <Igloo> My strstr is 82 chars long
12:46:18 <Heffalump> I didn't say shorter, I said better
12:46:36 <Igloo> I think it's nicer
12:47:03 <LoganH> Here's my strstr:
12:47:04 <LoganH> substring :: String -> String -> Bool
12:47:04 <LoganH> substring _ (_, []) = True
12:47:04 <LoganH> substring [] _ = False
12:47:04 <LoganH> substring a b
12:47:04 <Igloo> tails makes the recursion implicit
12:47:05 <Heffalump> igloo: yes, but you're an experienced Haskell programmer
12:47:06 <LoganH>     | (take (length b) a) == b = True
12:47:09 <LoganH>     | otherwise = substring rest b
12:47:11 <LoganH>     where
12:47:14 <LoganH>         (_:rest) = a
12:47:18 <LoganH> Oops, that's not quite it.
12:47:21 <LoganH> Change (_, []) to []
12:47:31 <Igloo> strstr needle haystack = elemIndex True $ map (isPrefixOf needle) $ tails haystack
12:47:33 <Heffalump> shapr: I'm eleganesh on sourceforge, btw (having taken a little while to find this out...)
12:47:36 <LoganH> (the substring I'm actually using takes a (String, String) as second argument, due to what my program is doing)
12:47:48 <LoganH> Heh, I'll have to try that.
12:47:50 <LoganH> What's the $ operator?
12:47:58 <Heffalump> loosely bound application
12:48:02 <Igloo> Function application, but low precedence
12:48:24 <LoganH> Is a $ b shorthand for a (b) then?
12:48:29 <Igloo> No
12:48:33 <LoganH> Oh.
12:48:34 <Igloo> a b c = (a b) c
12:48:40 <Igloo> a $ b c = a (b c)
12:48:53 <LoganH> That's what I meant. :P
12:49:09 <Igloo> Oh, yeah, ISWYM now  :-)
12:49:28 <Heffalump> it's shorthand for (a) $ (b), in a sense
12:49:32 <LoganH> I was using b to mean any string of characters, wasn't very clear of me.
12:49:38 <Igloo> Only that assume that $ (and various other things) aren't in a
12:49:46 <LoganH> Yeah, I can see how that saves it from being too much like lisp syntax. :P
12:49:58 <Heffalump> igloo: errm, it associates to the left, so $ wouldn't matter
12:50:12 * Heffalump tries to think of something that would
12:50:31 <Igloo> Ooops, yes
12:50:37 <Igloo> Well user defined operators could
12:50:53 <Heffalump> how does associativity work on things of equal precedence?
12:51:10 <Igloo> left and right work in the obvious way
12:51:12 <Heffalump> 1 is lowest, isn't it?
12:51:15 <Igloo> non gives an error
12:51:17 <Igloo> 0 is
12:51:24 <Heffalump> and ($) is 1?
12:51:32 <Igloo> If you say so
12:52:28 <Heffalump> nope, 0
12:52:33 <Heffalump> so is there anything?
12:53:17 <Igloo> Oh, maybe there isn't anything that's valid Haskell
12:53:19 <LoganH> I like the word "fixity."
12:53:54 <Igloo> That's quite a cute result
12:54:05 <zorb> um, somehow operators are determined to be right or left associative.
12:54:26 <Heffalump> that comes from infixl or infixr in the definition
12:54:37 <Igloo> or infix for non-associative
12:54:40 <Heffalump> s/definition/fixity declaration/
12:54:43 <zorb> ah.
12:55:02 <Heffalump> igloo: wdym by "non-associative"
12:55:03 <Heffalump> hmm
12:55:06 <Igloo> Ooops, I think I got distracted from what was distracting me from work
12:55:26 <Igloo> a & b & c is an error if & is non-associative
12:56:20 * Heffalump wonders if anyone has ghc 4.08 or 5.something on a platform that isn't i386-linux, sun4-solaris or i386-cygwin
12:58:22 * zorb scratches head as to whether his 5.something is cygwin. does cygwin mean "windows platform" or "running under cygwin under windows"
12:58:43 <zorb> you want to test some code?
12:59:29 <Heffalump> cygwin means windows platform really
12:59:38 <Heffalump> the Makefile won't work without cygwin, that's all
12:59:56 <Heffalump> and yeah
13:01:03 <LoganH> Heh, finally have a working implementation for this problem.
13:01:06 <LoganH> Now to try a harder one.
13:01:48 <Igloo> What problem?
13:02:11 <zorb> ah.. ok, sorry
13:02:15 <LoganH> I'm learning Haskell by implementing solutions to past problems from ACM programming contests.
13:02:26 <Igloo> Ah, right
13:02:38 <LoganH> I just did Problem C from the '97 ICPC. :P
13:04:08 <LoganH> For the next one I'll have to learn how to use actual data structures in Haskell. :P
13:06:42 <LoganH> How do I do records in Haskell?
13:06:52 <LoganH> I presume I use a tuple, but how do I easily access particular elements of the tuple?
13:07:17 <LoganH> Write a function for each member? :P
13:07:20 <zorb> you can use tuples, or you can declare your own datatype with accessors.
13:07:23 <Igloo> You use a data statement
13:07:24 <Heffalump> there's proper records
13:07:35 <LoganH> I just need a good example.
13:08:54 <LoganH> A search for "haskell accessors" didn't turn up much on Google. :P
13:09:23 <LoganH> Works better if I search for the singular, I guess.
13:09:50 <zorb> well, i dont know the proper name for them.
13:10:36 <Heffalump> try Haskell records
13:10:51 <zorb> yeah.
13:11:08 <LoganH> Heffalump: That's the first thing I tried, I didn't feel like sifting through a bunch of government stuff for towns or counties named Haskell. *grin*
13:11:22 <LoganH> I should be able to constrain the search.
13:11:46 <Igloo> Have you looked at the section in the report on records?
13:11:51 <zorb> ok, since I went to the trouble to look at some of my other code....
13:12:45 <LoganH> I'm looking.
13:12:48 <zorb> something like data X a = Z {list::[a],int::Integer,fefifofum::a->b} etc.
13:13:02 <zorb> oops
13:13:10 <zorb> X a b = Z {list::[a],int::Integer,fefifofum::a->b} etc.
13:14:25 <LoganH> I found something in the gentle introduction that does a binary tree.
13:15:26 <zorb> ok, I guess  I shouldn't have used type variables in my example.
13:16:42 <zorb> or uh..
13:16:46 <zorb> ok.
13:18:07 * zorb just wondered if his example needed any more explaining.
13:18:31 <LoganH> It was completely incomprehensible to me. :P
13:18:46 <zorb> sorry about that.
13:18:51 <zorb> how about this.
13:18:58 <LoganH> All I want is a simple directed acyclic graph. :P
13:19:22 <LoganH> Or, rather, I want a record type that contains a value of arbitrary type and two lists of that record type.
13:19:45 <zorb> alright
13:20:09 <LoganH> I was trying to understand how the example in the "gentle" introduction worked.
13:20:33 <zorb> I need to find my copy of "gentle". 
13:20:52 <LoganH> http://haskell.org/tutorial/goodies.html is where I'm looking now.
13:21:59 <LoganH> But it's not really what I want.
13:22:06 <LoganH> I just want a familiar notion of a record. :P
13:22:33 <LoganH> What did the X and Z stand for in your example?
13:22:49 <Igloo> That page doesn't look like it talks about record?
13:23:05 <LoganH> No, but it does build a binary tree. :P
13:23:08 <zorb> I'm not quite sure what to call Z (other than a constructor)
13:23:20 <Igloo> data Tree a = Tree { leaf :: a, left, right :: Tree a } is what you want I think
13:23:22 <zorb> actually, i guess it is a constructor
13:23:23 <LoganH> Oh.
13:23:59 <LoganH> Igloo: Hmm, and so if I have an instance of Tree in variable x, left x would return the left subtree of x?
13:24:03 <Igloo> data Tree a = Fork { leaf :: a, left, right :: Tree a } | Leaf actually
13:24:08 <Igloo> Yup
13:24:31 <LoganH> What is the significance of the constructor identifier?  Does the constructor have to be defined somewhere?
13:24:38 * Igloo should mention I don'e use records
13:25:01 <zorb> you define it by using "data"
13:25:06 <Igloo> Fork 5 lefttree righttree   is an expression of type Tree Integer
13:25:33 <LoganH> Oh, so you're just providing an identifier that'll represent a function you can use to construct instances of that type?
13:25:39 <Heffalump> yep.
13:25:42 <LoganH> That answers my other question, then.
13:25:56 <Igloo> (at least I think you can use that syntax with records)
13:26:02 <Heffalump> but it's also special in that you can use it to pattern-match too
13:26:14 <Heffalump> you can't normally use functions in pattern-matching
13:28:07 <shapr> Heffalump: want me to add you to the project then?
13:28:13 * shapr finishes watching Dark Angel
13:28:17 <shapr> mm, good episode
13:28:35 <Heffalump> shapr: may as well
13:28:45 <shapr> alright
13:33:25 * Heffalump and Igloo get distracted by major sysadmin problems
13:33:26 <shapr> ok, you're added
13:46:53 <zorb> later people
13:49:58 <LoganH> If I have a function of type a -> b -> c, and I give it its first parameter, what is its type signature?
13:50:01 <LoganH> b -> c?
13:50:18 <LoganH> I guess that makes sense.
13:51:06 <LoganH> I actually have a use for a "section" now.
13:51:24 <LoganH> That's a really nice feature.
13:58:50 <shapr> LoganH: yah that's right
13:59:31 <shapr> I wrote a fractal module, one method is "iterUntil"
13:59:45 <shapr> so I have a function called "bail"
13:59:55 <shapr> that bails out after so many iterations
14:00:29 <shapr> I do partial resolution on it: bail 200, or bail 400
14:00:43 <shapr> then I use the returned function in the rest of the module
14:01:03 <shapr> it's a lot simpler to try stuff in the interactive mode of ghc or hugs:
14:01:12 <shapr> map (+1) [1..6]
14:01:32 <shapr> do you have an interactive session open?
14:02:45 * LoganH nods.
14:03:14 <shapr> ok, so try these lines of code:
14:03:16 <shapr> [1..6]
14:03:24 <shapr> [1,3,12]
14:03:27 <shapr> er, oops
14:03:32 <shapr> [1,3..12]
14:03:34 <LoganH> :t (+1) :P
14:03:34 <shapr> that's right
14:04:00 <LoganH> I think I'm going about this code all wrong.
14:04:09 <shapr> map (+1) [1..6]
14:04:11 <LoganH> I just can't think in a functional manner regarding this problem. :P
14:04:23 <shapr> filter (>3) [1..6]
14:04:42 <shapr> filter (>3) . map (+1) $ [1..6]
14:04:59 <shapr> hm, I'm not sure if I got that last one right
14:07:33 <shapr> hoi lodewijk 
14:07:38 <lodewijk> re
14:07:47 <shapr> what's up?
14:07:49 <lodewijk> how do I create a Show instance for a polymorphic type?
14:07:59 <lodewijk> shapr: still learning haskell :)
14:08:05 <shapr> same here
14:08:11 <shapr> keep the code flowing
14:08:20 <shapr> I'm not sure what a polymorphic type looks like
14:08:33 <lodewijk> data BinTree a = Nil | Node a (BinTree a) (BinTree a)
14:08:46 <shapr> hm, good question
14:08:48 <lodewijk> so BinTree Int would be a binary tree for integers
14:09:14 <lodewijk> so I turn to page 222 of thompson and whip up:
14:09:15 <lodewijk> instance Show (BinTree a) where
14:09:15 <lodewijk>         show Nil = "Nil"
14:09:15 <lodewijk>         show (Node e _ _) = show e
14:09:40 <lodewijk> and hugs starts to complain about "Cannot justify constraints in instance member binding"
14:09:56 <shapr> wow
14:10:04 <shapr> I've never heard of that error message
14:10:15 <lodewijk> cool huh ;)
14:10:15 <shapr> yah, I'm impressed
14:11:01 <lodewijk> oh, wait, ghc gives a more helpful message.
14:11:07 <shapr> what does it say?
14:11:33 <shapr> hmmm
14:11:35 <lodewijk> Could not deduce (Show a) from the context (Show (BinTree a))
14:11:35 <lodewijk>     Probable fix:
14:11:35 <lodewijk>         Add (Show a) to the instance declaration context
14:12:00 <shapr> instance Show BinTree where
14:12:14 <shapr>     show (BinTree a) = 
14:12:14 <shapr> ?
14:12:22 <shapr> here's what Heffalump helped me write recently:
14:12:27 <shapr> newtype MandelData = MandelData (Integer, Complex Double, Complex Double)
14:12:32 <shapr> instance Show MandelData where
14:12:32 <shapr>     show (MandelData (iters, z, c)) = "MandelData with values: Iteration Count: " ++ show iters ++ ", value of Z:" ++ show z ++ ", value of C:" ++ show c
14:13:08 <lodewijk> "Illegal type in class constraint"
14:13:11 <lodewijk> hmm...
14:13:22 <shapr> I had some problems putting together 'instance' and a type constructor 
14:15:20 <shapr> that's my only suggestion, btw
14:15:45 <lodewijk> ah.. show (Node _ left right) = "foo" gives to type errors
14:16:04 <shapr> no errors?
14:16:29 <lodewijk> show (Node e left right) = "foo" doesn't either, so it's the "show e" part.
14:17:51 <shapr> hm
14:18:48 <lodewijk> apparently I have to show that a is a Show instance.
14:19:34 <shapr> uh
14:19:44 <shapr> oh
14:20:00 <shapr> do you have to make Node a show instance or something?
14:20:00 <LoganH> I'm having a hard time thinking how to do graph transformations in a functional manner.
14:20:02 * shapr is guessing
14:20:19 <LoganH> I'm stuck in the imperative mindset all of a sudden.
14:20:27 <shapr> LoganH: er, how do you do them procedurally
14:20:58 <LoganH> Usually with traversals of some sort.
14:21:27 <LoganH> Where upon visiting a node you might change its value or its edges.
14:21:48 <LoganH> Hmm, I guess if I think of it carefully like that, I can do this.
14:22:47 <LoganH> I might need a better way of representing a graph here too.
14:22:55 <shapr> I don't know anything about graphs
14:23:01 <shapr> at least, not the ones your talking about.
14:25:07 <shapr> oh
14:25:08 <shapr> hey
14:25:17 <shapr> are these like state automata?
14:28:12 <LoganH> A finite state machine can be represented as a graph, and its execution is a particular sort of graph traversal. :P
14:28:17 <LoganH> A binary tree is a graph.
14:28:20 <shapr> oh
14:28:24 <shapr> that sounds simple enough
14:28:44 <LoganH> A collection of vertices and a collection of ordered pairs of these vertices defines a (directed) graph.
14:29:23 <shapr> why a pair of vertices?
14:29:36 <lodewijk> (from, to)
14:29:47 * shapr thinks about that
14:30:47 <shapr> so...
14:30:51 <shapr> what's the point of a directed graph?
14:30:56 <shapr> maybe I should just hit google
14:32:06 <lodewijk> shapr: it is something a lot of problems can be modeled into and something where there's a lot of existing algorithms for.
14:32:15 <shapr> oh
14:32:15 <shapr> ok
14:33:34 <lodewijk> map problem to DAG, run algorithm, map solution to problem domain, voila.
14:34:39 <lodewijk> got it.. from the source of the Functional Graph Library, so maybe LoganH can be helped by it too. got it from www.haskell.org.
14:34:49 <lodewijk> instance Show a => Show (BinTree a) where
14:34:50 <lodewijk> etc
14:35:45 <shapr> oh
14:35:46 <shapr> nifty
14:36:35 <lodewijk> Main> Node 4 Nil Nil
14:36:36 <lodewijk> (4 Nil Nil)
14:36:43 <shapr> cool!
14:37:01 <lodewijk> Main> Node 4 (Node 2 Nil Nil) (Node 6 Nil Nil)
14:37:02 <lodewijk> (4 (2 Nil Nil) (6 Nil Nil))
14:37:07 <LoganH> A lot of things can be represented as graphs (directed or undirected)...
14:37:17 * shapr thinks about that
14:37:24 <LoganH> And quite a few th ings can be represented as directed acyclic graphs, or DAGs for short.
14:37:41 <shapr> I'll have to read up on those
14:37:44 <LoganH> For instance, a packaging system, where packages have sets of dependencies, is a DAG.
14:37:49 <LoganH> Or represented by a DAG, rather.
14:38:03 <LoganH> So is a set of courses and their prerequisites.
14:38:12 <shapr> that's interesting
14:38:28 <lodewijk> LoganH: http://www.cs.orst.edu/~erwig/fgl/haskell
14:38:33 <LoganH> For example, there is an algorithm known as a "topological sort" that applies to figuring out what order you have to take classes in, in order to meet all prerequisites.
14:38:44 <shapr> I'd enjoy making a directed graph of debian packages
14:39:01 <shapr> that's fascinating
14:39:13 <lodewijk> shapr: how do you think dpkg works? :)
14:39:29 <LoganH> shapr: Heh, go to that page lodewijk just pasted, it actually shows topological sort as an example.
14:39:58 <LoganH> Yeah, when you tell apt-get to install a set of packages, apt does a topological sort to determine what packages have to already be installed before it can install those packages.
14:40:10 <LoganH> And it uses topological sort to determine what order to install them in.
14:41:39 <shapr> fascinating
14:42:02 <lodewijk> I'm off. good luck hacking :)
14:42:20 <LoganH> You can also represent a road system as a graph.
14:42:26 <LoganH> If you have one-way roads, it's a directed graph.
14:42:45 <LoganH> And you can associate weights with each edge, representing the cost of traversing that edge, for instance.
14:42:58 <LoganH> So the weights in a graph representing a system of roads could represent how long it takes on average to drive that stretch of road.
14:43:15 <LoganH> And then you can run any one of tons of shortest path algorithms to compute the most efficient path between any two points.
14:43:22 <LoganH> That's how stuff like mapquest work.
14:43:29 <shapr> cool
14:43:31 <shapr> routing tech ;)
14:45:33 <LoganH> Yes, that too.
14:45:36 <LoganH> Computer networks are graphs.
14:47:36 <LoganH> There are certain routing protocols, like "OSPF", which stands for "Open Shortest Path First", that rely on graphing algorithms to pick optimal paths, I presume. :P
14:51:02 <shapr> interesting stuff
14:55:23 <LoganH> I'm finding in this graduate digital picture processing class I'm taking this semester, some of the stuff we're doing right now can really just be reduced to graph theory. :P
14:55:33 <shapr> nifty
15:00:45 <LoganH> Is there a library for doing a lot of unix system type stuff (like exec, for example)?
15:01:06 <shapr> yah
15:01:33 <LoganH> Or, better yet, pipes.
15:01:40 <LoganH> Like popen in C.
15:01:41 <shapr> that would be Posix
15:01:45 <shapr> lemme show you some code...
15:02:02 <shapr> http://kungens.kemi.fi/~shae/Hsh.hs
15:02:14 <LoganH> Cool, I think I found the documentation.
15:02:58 <LoganH> Heh, I should've noted ghci outputting: Loading package posix ... linking ... done.
15:03:04 <LoganH> Aren't I observant? :P
15:04:06 <shapr> heh :)
15:04:14 <LoganH> Hmm, is there something analagous to popen in Posix?
15:04:25 <shapr> somewhat
15:04:46 <shapr> er
15:04:51 <shapr> wait, no I don't know that :)
15:05:12 <LoganH> I guess I can just use a named pipe.
15:06:46 <LoganH> Which negates the need for Posix entirely for now.
15:07:36 <shapr> ok
15:07:38 <shapr> http://haskell.org/onlinelibrary/io.html
15:08:03 <shapr> I think the handles they mention in here are popen kinda things
15:09:11 <LoganH> If I use hGetContents to get the characters of a file, how do I split them into lines easily?
15:10:42 <shapr> List.lines maybe?
15:11:15 * shapr is guessing again
15:11:53 <LoganH> I really wish I had this standard libraries documentation in html rather than PDF.
15:12:01 <shapr> http://haskell.org/onlinelibrary/
15:12:55 <LoganH> Oh, I missed that one. :P
15:13:06 <shapr> we're here to help :)
15:20:44 <LoganH> What's the optimal way to remove the first n elements of a list?
15:21:08 <shapr> drop ?
15:21:09 <LoganH> Oh, drop?
15:21:10 <Heffalump> drop.
15:21:10 <shapr> drop 5
15:21:11 <LoganH> Heheh.
15:21:28 <LoganH> I veentually remembered where I asked a similar question to that, where take was the answer. :P
15:22:06 <shapr> takeWhile, dropWhile
15:22:09 <shapr> are also fun and useful
15:27:25 <shapr> does hugs have Socket??
15:28:08 <shapr> I can't find it
15:38:18 <LoganH> I don't know.  Does ghc?
15:39:31 <shapr> yup
15:39:45 <shapr> in ghc I have to do :set -package net
15:45:35 * shapr falls over asleep
15:59:11 <LoganH> What's the difference between Int and Integer?
16:02:10 <Heffalump> Integer is unbounded
16:02:14 <Heffalump> Int is 32 bit (I think)
16:03:32 <LoganH> Hmm, does which one you use affect efficiency?
16:04:38 <Heffalump> yes
16:06:39 <LoganH> I'll have to keep that in mind, then. :P
16:06:49 <LoganH> Writing my first useful program in haskell.
16:06:51 <LoganH> Or just wrote it, rather.
16:07:35 <LoganH> Examines output of the ping command and picks out where there are lost or out-of-order packets.
16:07:46 <LoganH> Heffalump: Do you know if there is something analagous to popen available for haskell?
16:15:35 <LoganH> I like how ghc builds an executable that requires libgmp.so.3.
16:21:26 <Heffalump> dunno, sorry
16:46:04 <LoganH> Heh, functional programming lets me do a lot of things I've often strived to do for years in other languages.
17:29:12 --- topic: 'Functional Programming, that's the opposite of Dysfunctional Programming (like VB) | we be loggin' http://tunes.org/~nef/logs/haskell/ | welcome to the Haskell Dojo | julien is up to white belt! jewel and shapr are up to yellow belt!'
17:29:12 --- topic: set by shapr on [Mon Jan 21 04:46:00 2002]
17:29:14 <LoganH> What do I use for integer division?
17:29:40 <LoganH> Oh, div.
19:09:10 <LoganH> I need some sort of swap function.
19:27:03 <LoganH> If I have two lists of the same length, how do I build a list of tuples, the nth tuple being the nth element of the first list and the nth element of the other list?
19:27:27 <LoganH> Is that what zip does?
19:28:32 <dblack> LoganH: yes
19:28:33 <dblack> i think
19:28:41 <dblack> Main> zip "abc" [1,2,3]
19:28:41 <dblack> [('a',1),('b',2),('c',3)]                                                          
19:29:01 <dblack> yeah
19:42:01 <LoganH> How do I efficiently append an element to a list?
20:55:24 <La_mala> Ruby rules!
20:58:14 <juhp> it does?
20:58:41 <La_mala> Maybe, maybe not!
20:59:02 <juhp> it's popular here in Japan
20:59:13 <juhp> do you like it?
20:59:45 <La_mala> I don't know much about it, bat it seems clean.
21:01:23 <juhp> the little i know about it, it seems to have taken a bit too much from perl for my taste
21:02:51 <La_mala> It has taken a bit from python too but even more object oriented. I can't say you much more about it. 
21:04:02 <La_mala> How is the health of linux in Japan? It's only for geeks? It's conquering the desktop?
21:31:09 <ismael> Someone has seen the Monad Lisa?
21:33:50 <juhp> ismael: fine.  though maybe the adoption by businesses is slower than in the US.
21:34:02 <juhp> ismael: how about in Spain?
21:36:20 <ismael> juhp: Slow too. Spanish government goes on supporting Microsoft.
21:36:43 <juhp> same here really :(
21:37:17 <ismael> Last month gave a lot of money to Microsoft to get more Licenses of Windows for Universities.
21:37:31 <juhp> ouch!
21:37:56 <juhp> hard to tell whether it is conservatism or some conspiracy really
21:38:37 <ismael> I like to think there's lack of knowledge.
21:39:13 <juhp> "Madrid writes fat cheque to M$" -- hmm nice headline!
21:39:17 <ismael> But the idea of conspiracy is always floating.
21:42:04 <juhp> or "How do you want to pay today?" ;)
21:42:09 <ismael> They gave money to install Explorer and Office. <ironic> Wow, they are carrying university to the future! </ironic>
21:42:46 <juhp> ;)
21:44:24 <ismael> or "How much can you pay today?...and tomorrow?"
21:46:38 <juhp> ;)
21:46:52 <juhp> ismael: using haskell?
21:49:11 <ismael> Not now, but last year I use it in the university. It was love at first sight.
21:49:24 <juhp> Login message
21:50:24 <juhp> Choose payment method (choose cancel to pay automatically by tax)
21:51:14 <juhp> [Credit card] [Cash] [.money] [Cancel]
21:51:17 <juhp> ;-)
21:52:13 <ismael> [Credit card] [Cash] [.money] [All]
21:52:35 <juhp> Of course we don't want your money, just your grandchildren's last dime....
21:53:03 <juhp> ok, sorry -- guess i'm getting carried about and very off topic
21:53:52 <juhp> we should thank MS Research for indirectly supporting the GHC developers at least
21:54:04 <juhp> that is something positive
21:54:12 <ismael> We don't want your money, we want your soul for the rest of the eternity.
21:54:42 <juhp> but MSR and M$ are different i like to think
21:54:52 <ismael> They call it 'Colaterar damage', or something like that.
21:55:17 <ismael> 'Colateral damage', sorry.
21:55:53 <juhp> they can call it what they like -- i'm not giving them a penny if i can help it
21:55:58 <juhp> ;)
21:56:55 <ismael> Do you think they use it GHC to make Windoz? It's imposible!
21:57:33 <juhp> windoz 2010?
21:58:18 <juhp> my understanding is that the GHC developers are not being paid by MSR to work on GHC
21:58:55 <ismael> Not even Haskell can help them to make a half-good product!
22:00:45 <ismael> Sorry juhp but I go to sleep now (7:00 AM). (Shit!, I must change my vampiric habits!)
22:01:09 <juhp> ismael: night!
22:01:43 <ismael> night! (or morning!)
22:14:01 <LoganH> dropWhile isn't doing what I think it should be doing.
