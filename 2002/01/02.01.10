00:03:20 <shapr> hi
00:03:24 <shapr> what's up?
00:03:38 <bsh> hey, nothing much
00:06:27 <shapr> written any cool code lately?
00:07:02 <bsh> i
00:07:13 <bsh> i've just been working on an interpreter
00:07:27 <shapr> nifty, what kind of interpreter?
00:07:58 <bsh> ah its a self made language.. just an educational thing 
00:08:11 <shapr> got any code online?
00:08:35 <bsh> nah .. not yet
00:10:16 <shapr> hei teek 
00:10:25 <teek> terve shapr
00:10:47 <shapr> haluatko code shaelta? ;)
00:10:51 * shapr practices his terrible finnish
00:11:49 <teek> hmm, what do you mean ? haluatko is in Finnish, code is in universal language, but shaelta is unknown to me ? 
00:12:00 <teek> ;)
00:12:15 <shapr> my name is shae
00:12:25 <shapr> so I think that means, "want code from shae?"
00:12:28 <teek> oh, then it's almost correct ....
00:12:49 <teek> "haluatko koodia shaelta" 
00:12:54 <shapr> finnish is extremely cool
00:12:57 <shapr> ah, thanks
00:13:09 <teek> extremely elegant language. Like Haskell
00:13:13 <shapr> yah, I agree
00:14:14 <teek> When I started IRCing, I noticed that my knowledge of english grammar is in terrible shape. Now I'm practicing it again. 
00:15:10 <shapr> I have a chance to practice my .fi grammar on #debian-fi, but I usually end up coding instead
00:16:43 <teek> heh. I'm fixing some code at the moment, so maybe we shall look your haskell code in (near) future. ok? 
00:16:53 <shapr> no worries :)
00:16:59 <shapr> are you fixing haskell code?
00:21:33 <teek> no. C code not written by me. Segmentation faults pop once in a while... And as it's client/server app (freeciv), debugging is a hard work. 
00:21:42 <shapr> oh
00:21:55 <shapr> why not write an analyser in Haskell? ;)
00:22:22 <teek> That would be more enjoyable...  
00:22:32 <shapr> yah, and more automatic
00:22:41 <teek> It
00:23:03 <shapr> if you could generalise a mistake you found into a new rule or function for your analyser, it'd actually be less work
00:23:26 <teek> i feel a little bit stupid, when I waste my free time in something like hunting down seg faults from someone else's code... 
00:23:59 <teek> byt as i'm recovering (is that right word ?, toipua) from a leg surgery, i have a lot of free time. 
00:24:01 <shapr> I understand that feeling.
00:24:17 <shapr> yah, I think recovering fits there
01:09:38 <shapr> hi julien!
01:09:50 <julien> hi shapr
01:09:56 <julien> how are you ?
01:10:04 <shapr> doing well
01:10:21 <shapr> working right along
01:10:22 <shapr> how are you?
01:13:28 <julien> fine, a lot of work
01:13:32 <julien> but funny :-)
01:13:56 <shapr> nifty work?
01:14:03 <shapr> found a way to use haskell at work?
01:15:41 <julien> not yet, I've no time to learn
01:16:24 <julien> :-(
01:17:40 <julien> but I will move to brussels in march, and then I will have time and ADSL connection
01:20:22 <shapr> nice
01:42:22 <julien> I won't get my yellow belt before some time ...
02:04:57 <jewel> what is a yellow belt?
02:06:44 <julien> second level in judo, karate and other fighting sports
02:15:38 <jewel> tsk
02:15:52 <jewel> in haskell!
02:17:11 <julien> that's shapr idea, see the topic of the channel :-)
02:22:29 <shapr> I'm working on my yellow belt :)
02:25:26 <julien> I'm working for my green belt, but in taekwondo :-)
02:26:12 <shapr> there's a good dojo across town, I'm tempted to start classes again
02:29:03 <julien> taekwondo ?
02:29:13 <shapr> karate I think
02:29:34 <julien> nice
02:30:04 <shapr> imho, any art is fine as long as the dojo is good
02:30:19 <shapr> I just want to get back in shape and improve my coordination and focus
02:30:37 <shapr> I had muscles less than a year ago :-/
02:30:57 <julien> :)
02:56:40 <jewel> shapr: so what is a yellow belt?
02:57:17 <shapr> hrm, I better start documenting this somewhere :)
03:07:09 <shapr> re dmiles
03:07:22 <shapr> jewel: I dunno, what would a yellow belt involve?
03:07:24 * shapr thinks
03:07:40 <dmiles> hi
03:07:57 <dmiles> how big is a haskell memory model.. can i handle a gig of data with some implimentations?
03:08:05 <shapr> I think so
03:08:09 <shapr> should work
03:08:23 <dmiles> i have a machine with 3 gigs of ram for trying it out on
03:08:44 <dmiles> i have about 60,000 logical axioms :0
03:09:13 <dmiles> i just need a simple contraint logic solver
03:09:23 <dmiles> is there an example of that in haskell?
03:09:53 <dmiles> i have the liogic converted to if/thens right now
03:11:42 <shapr> why  not allocate 3 gb of ram as a quick test in haskell?
03:11:42 <shapr> then you'd know
03:11:42 <dmiles> i have but need software
03:11:42 <dmiles> weerr i mean need a *(good* haskell implementation to try
03:11:42 <shapr> huh?
03:11:42 <shapr> you mean, not hugs?
03:11:42 <dmiles> n/m one sec/.. downloading :)
03:11:42 <shapr> I'd recommend ghc
03:11:49 <dmiles> ok ussing that
03:12:08 <dmiles> 2 November 01 GHC 5.02.1 released 
03:13:47 <shapr> I'm using the debian package, which is ghc-5.02.00
03:14:27 <dmiles> cool.. i have 6 hrs to learn the langauge and release a buio.,d of my app
03:14:56 <dmiles> oh and hook it to the java interface :)
03:15:23 <clausen> !
03:15:41 <dmiles> so if i have a bunch of if thens that are cirucular...
03:15:43 <shapr> dmiles: yikes :)
03:15:44 <dmiles> meaning i neeed what is called memoizatuion..
03:16:21 <shapr> yah I understand
03:16:30 <shapr> use the memo function ;)
03:16:43 <dmiles> it has one sppecific for this?
03:16:55 <dmiles> if a then b
03:16:59 <dmiles> if b then a
03:17:02 <dmiles> a is ture
03:17:04 <dmiles> is b true?
03:17:17 <dmiles> for a problem like that?
03:17:57 <shapr> not that I'm aware of
03:17:59 <dmiles> http://216.39.172.56/_/engine/testit <- jhere is a small part of my datatbase
03:18:14 <shapr> but the memo function compares function + parameter calls
03:18:19 <dmiles> towards the bottem are the if/then
03:18:23 <shapr> and under the hood it does pointer equality
03:18:41 <shapr> so if you've already passed parameter x to function myFun
03:18:50 <shapr> then it just returns the cached result rather than recalculating
03:20:01 <shapr> what's nefph?
03:20:11 <nefph> meaning i bneed to do unifification with occurs checking
03:20:11 * shapr thinks "never-ending-project-from-hell"
03:20:20 <shapr> but that would be nepfh
03:20:29 <dmiles> my efnet nick is nephrael
03:20:31 <dmiles> hehe
03:20:31 <shapr> oh!
03:20:41 <dmiles> very quick
03:21:01 <shapr> ?
03:21:15 <dmiles> oh your metal acronym resolver 
03:21:20 <dmiles> err mental
03:21:26 <dmiles> :)
03:22:04 <dmiles> did you see my page of prtolog if/thens?
03:22:17 <shapr> heh
03:22:25 <dmiles> i can export to any formayt in a mater of minutes
03:22:47 * shapr looks
03:22:50 <dmiles> so it looks like i am going to have it generate data for haskel;
03:23:43 <dmiles> A:-B  means if B then A
03:24:03 <shapr> interesting 
03:24:06 <shapr> why do you need to do this for haskell?
03:24:18 <dmiles> prolog is beeing too slow
03:24:37 <dmiles> and cycle loop cjheckiong is being a pain
03:25:01 <shapr> oh
03:25:01 <dmiles> expecially where single varibles are involved
03:25:19 <dmiles> like a(B) :- c(D,E)
03:25:21 <dmiles> err
03:25:23 <dmiles> like a(B) :- c(B,E)
03:25:31 <dmiles> E is single..
03:25:49 <dmiles> you know enough prolog my examples make sense?
03:26:33 <dmiles> you could get a(B) for as many times as you could get  c(B,E) 
03:26:52 <shapr> no, I know zero prolog
03:26:54 <dmiles> if there are c(foo,bar) c(foo,baz)
03:27:14 <dmiles> that means you can get a(foo) and a(foo) twice]
03:27:27 <dmiles> this is combitoric for other predicates that use a(B)
03:27:55 <dmiles> so there is this thing called memoization that helps solve this kind of prtobelm
03:28:13 <dmiles> but one problem here..
03:28:22 <dmiles> if haskell can solve then i am set..
03:28:26 <dmiles> if a then b
03:28:29 <dmiles> if b then a
03:28:32 <dmiles> a is true
03:28:37 <dmiles> is b true?
03:29:10 <dmiles> without it going into a->b->a->b->a etc
03:31:59 <clausen> hmmm
03:31:59 <clausen> have you looked at mercury?
03:31:59 <dmiles> yes.. too unstable
03:31:59 <clausen> ?!
03:31:59 <dmiles> its version of 'mtabling'
03:31:59 <clausen> anyway, haskell isn't a logical language... it isn't obvious to me how to implement easily
03:31:59 <dmiles> Table Space IOverflow
03:31:59 <clausen> but, I'm ignorant
03:31:59 * xbill grinds out statistical stuff in Haskell to assist his kernel hacking endeavors.
03:31:59 <clausen> xbill: !
03:31:59 <xbill> (i.e. chi^2 and Kuiper)
03:31:59 <shapr> xbill: got code online we can peek at?
03:31:59 <dmiles> i may be trying to use Haskell wrong :).. 
03:31:59 <shapr> dmiles: there are constraint logic solvers written in haskell
03:31:59 <dmiles> xbill is familiar with my problem
03:31:59 <xbill> http://holomorphy.com/~wli/special/
03:31:59 <xbill> also see special/stats/
03:31:59 <dmiles> yes if they are mostly bullet proof rand quick that is what i need
03:31:59 <dmiles> i have a gig of if/thens
03:32:10 <dmiles> mercury breaks on that much memory
03:32:20 <xbill> oh great
03:32:26 <clausen> that surprises me
03:32:31 <clausen> have you flamed them? hehe
03:32:31 <xbill> Has Fergus Henderson started to do anything about it?
03:32:40 <dmiles> i will start to
03:32:58 <dmiles> i just spent 4 hrs auditing each CLP kernel i could find
03:33:14 <dmiles> (never giving a fair test)
03:33:15 <shapr> xbill: your code is great fun to read
03:33:27 <xbill> how's that?
03:33:38 <dmiles> soi your saying i could probkly get more from mercury if i spent time
03:34:01 <xbill> no idea but they have bettered a lot of straight Prolog implementations
03:34:05 <dmiles> i shall do this on my ne4xt release.. try porting as much as i can
03:34:06 <clausen> dmiles: well, mercury has a reputation for being able to handle ridicoulus loads
03:34:12 <clausen> dmiles: I've never used it
03:34:12 <xbill> OTOH they may not have the semantics needed.
03:34:36 <xbill> I've used it several times and was disappointed only a few of those
03:34:59 <dmiles> well i can always use prolog for writting the database for mercurly
03:35:11 <xbill> Did you just post to the mercury list?
03:35:14 <dmiles> xbill: mercury?
03:35:26 <xbill> never mind it was someone else
03:35:34 <dmiles> " <xbill> I've used it several times and was disappointed only a few of those "
03:35:51 <xbill> dmiles: yes, Mercury
03:36:46 <dmiles> hrrm
03:37:06 <shapr> xbill: your code is cool
03:37:08 <dmiles> well i think now thast i have the problem simplified .. i have my arguemtn domains.. my data.,. my rules..
03:37:26 <dmiles> its genric enough to fit into anty CLP
03:37:48 <dmiles> except i have further rulers that gen4erate more contraits.. thats the only harsgh part
03:37:56 <dmiles> err harsh part
03:38:04 <dmiles> like if hairy then animal
03:38:14 <dmiles> ansd animal may be a contraint to something elsoe
03:38:35 <dmiles> but i can forward chain issues like that out
03:41:15 <xbill> shapr: what's cool about it?
03:41:43 <shapr> it goes off in different directions than I usually think
03:41:48 <shapr> it's a different approach
03:41:50 <shapr> and that's nifty
03:42:00 <xbill> what's the approach?
03:42:46 <shapr> I'm not sure how to quantify it
03:43:42 <xbill> well how would you describe the style in general?
03:44:08 <shapr> much more recursive than my style
03:44:47 <xbill> well, that's difficult for me to draw conclusions from...
03:45:03 <shapr> that's about as specific as I can get at the moment ;)
03:45:04 <xbill> I'm sort of interested in "getting a look in the mirror" so to speak.
03:45:31 <shapr> hm, I'll think about it
03:50:34 <shapr> one example: sort $ take 20 (map (take 7) . map cf . map (/(2::Rational)^64) . map fromIntegral $ getCands)
03:51:12 <shapr> seeing that many maps in one line makes my internal algorithmic complexity evaluator envision DNA strands with their recrursive twists
03:55:25 <xbill> I should have done sort $ take 20 (map (take 7 . cf . (/(2::Rational)^64) . fromIntegral) getCands)
03:56:04 <xbill> intermodule optimization doesn't go so well just read Main.hs
03:56:36 <xbill> I put everything in Main.hs because of that.
03:57:31 <xbill> Stats.hs is too slow
04:00:22 <shapr> since I don't know much math, I'm not sure what it's doing
04:00:28 <shapr> I took a statistics class once, long ago
04:00:34 <shapr> well,  ten years
04:04:38 <xbill> it's trying to figure out whether things are evenly distributed across buckets of a hash table given the counts of things i the buckets.
04:04:49 <shapr> oh
04:04:50 <shapr> nifty
04:05:30 <xbill> Fibhash.hs (and the Main.hs in the same dir) are trying to find prime numbers to multiply by for hash functions
04:05:44 <shapr> cool
04:05:54 <xbill> Stats.hs is trying to figure out whether they really work
04:05:55 * shapr gets the urge to read up on hashing functions
04:06:03 <shapr> what's the conclusion?
04:06:21 * shapr grabs a handy copy of Applied Cryptography
04:06:37 <xbill> cryptographic hashes are not useful for this
04:06:47 <shapr> oh
04:07:35 <shapr> I didn't know that the hash functions mentioned in crypto and the hash functions used for evenly distributing things were different
04:07:52 <xbill> computational expense is the dominating factor here
04:08:08 <shapr> ah
04:08:09 <xbill> perfectly even distribution is worthless if it takes 10 minutes to find the hash value of one key
04:08:15 <shapr> makes sense
04:08:26 <shapr> python claims to have a fast and perfect hashing function
04:08:36 <shapr> it's used for dictionaries in python
04:09:19 <xbill> perfect hashing is a different subject entirely
04:09:24 <shapr> oh
04:09:26 <shapr> I have much to learn :)
04:09:53 <xbill> a perfect hash is when you know the data in advance and are trying to create a hash function for that data with no collisions whatsoever.
04:11:36 <shapr> what kind of hashing are you trying to do?
04:11:53 * shapr tries to figure out what hashing + NUMA =
04:11:59 <xbill> hash functions for the Linux kernel's internal search algorithms
04:12:49 <shapr> oh
04:13:02 <shapr> I didn't know the kernel had an internal search
04:13:32 <xbill> lots of it
04:13:43 <xbill> most of it exhaustive search of linked lists
04:14:57 <shapr> that makes sense
04:15:13 <xbill> for instance
04:15:25 <xbill> when linux looks for all processes sharing a single address space
04:15:47 <xbill> it loops over every process in the system and checks to see if the address space matches
04:16:16 <shapr> sounds sensible
04:16:24 <xbill> hardly
04:16:45 <xbill> there should already be a list hanging off of the address space
04:17:15 <shapr> that would be faster
04:17:59 <shapr> because then your search time would only depend on amount of address space rather than number of processes
04:18:14 <xbill> shapr: you don't know the gypped feeling you get when you've got a gazillion-way SMP machine and the kernel will only let you use one of your CPU's at a time
04:18:17 <xbill> shapr: no
04:18:26 <xbill> shapr: you know the address space in advance
04:18:38 <shapr> oh
04:18:42 <xbill> so you would just traverse the list with in the address space structure
04:19:03 <shapr> I can guess what that gypped feeling feels like.. it's almost like using windows :)
04:19:20 <shapr> right
04:20:02 <shapr> 'amount of address space' should have been "number of separate chunks of address space you have to go through"
04:21:35 <shapr> this increases my curiosity about the linux kernel
04:21:49 <shapr> I'm occasionally tempted to finish learning C and do kernel hacking
04:21:57 <shapr> it could be fun
04:22:42 <clausen> xbill: address space == struct address_space == bsd's objects?
04:22:46 <xbill> no
04:22:56 <xbill> address space = struct mm_struct
04:23:11 <shapr> aha, *  A new hashed wait queue patch was posted by William Lee Irwin III.
04:23:17 * shapr reads the kernel page of lwn.net
04:23:36 <clausen> riel told me about that... saves lots of memory
04:23:38 <xbill> I always wait for other people to tell me.
04:23:39 <clausen> (on big boxen)
04:23:44 <clausen> hehe
04:23:51 <xbill> It saves 3MB on my 768MB Athlon.
04:23:55 * clausen staying with riel ATM, so gets to hear a lot about VM stuff
04:24:01 <clausen> (and he about file system / partition stuff, hehe)
04:24:03 <xbill> spiffy
04:24:12 <shapr> yah, cool
04:24:28 <clausen> living with hackers is cool :)
04:24:34 * xbill shrugs.
04:24:51 <shapr> I'd like to live even in the same city as hackers
04:24:55 <shapr> but irc is pretty close
04:25:44 <xbill> well, you're in Finland, land of Linus no? =)
04:25:47 <shapr> heh
04:25:57 <shapr> true, but I'm also 800km north of Helsinki
04:26:07 <shapr> .fi is very long and narrow
04:26:16 <clausen> ouch
04:26:19 <clausen> that must be REALLY cold
04:26:22 <shapr> yah, it is
04:26:26 * clausen enjoying .br summer :)
04:26:31 <shapr> -34C a coupla weeks ago
04:26:44 <clausen> the coldest I've had hear about 15°C
04:26:49 <shapr> lucky you
04:26:54 <clausen> :)
04:27:57 <shapr> on the good side, oulu is just south of me, and that's where irc started :)
04:28:21 <shapr> I haven't gotten to see the first irc server yet, but I've heard it's a flower pot in a professor's room
04:29:03 <clausen> .au has lots of hackers :)
04:29:10 <clausen> (where I live normally)
04:29:20 <shapr> when I lived in southeast USA, we didn't have many
04:29:38 <shapr> atlanta seems to have improved since I left
04:31:20 <xbill> I don't want to know about how Indiana has been since I left... I'd like to just forget about it.
04:31:38 <shapr> where are you now?
04:31:42 <shapr> MA?
04:31:44 <xbill> Oregon
04:31:46 <shapr> ah
04:31:51 <shapr> portland?
04:32:00 <xbill> I've never set foot in MA, this is a friend's machine.
04:32:04 <xbill> yep
04:32:32 <shapr> portland has much nifty stuff, including leatherman.com and the original wiki
04:34:50 <shapr> oh, and xbill of course ;)
04:46:30 * xbill =)
06:49:33 * Heffalump waves
06:49:37 <shapr> hi!
06:59:01 <jewel> ganesh the elephant
06:59:15 <Heffalump> absolutely
07:16:36 <shapr> Heffalump: sometimes there's lots of conversation here, and sometimes none
07:16:54 <shapr> this channel is logged, and you can find those logs at the url in the channel topic.
07:19:43 <Heffalump> right
07:25:18 <Heffalump> who is logging the channel, btw?
07:25:22 <Heffalump> (or what)
07:28:22 <shapr> one of the guys from tunes.org
07:28:28 <shapr> the bot is named clog
07:29:29 <Heffalump> right, just wondering which client's disappearance would lead to logs stopping
11:19:20 <shapr> ok, time to learn bunches of Haskell!
11:20:37 <shapr> hello everyone
11:26:31 <shapr> hi ski!
11:26:39 <ski> hi shapr !
11:26:49 <shapr> I'm just about to open the book for some serious haskell learning
11:26:58 <shapr> I am therefore very happy to see you ;)
11:26:58 <ski> aha, ok.
11:27:17 <ski> thank you.
11:27:20 <shapr> actually, I'm happy to see you anytime
11:27:27 <shapr> but you know, now is particularly good
11:27:46 <ski> good, then !
11:27:55 <shapr> what are you working on?
11:28:28 <ski> well, i'm not working on anything particulary, right now. just reading a little newsgroups on usenet 
11:30:12 <ski> i've read a little in comp.lang.functional, comp.lang.scheme, alt.dreams.lucid, alt.out-of-body
11:30:45 <ski> so i'm mostly all yours, if you wan't anything discussed, asked, etc ...
11:31:21 <shapr> w00h00!!
11:31:26 <ski> what ?
11:31:37 <shapr> that you have time to answer questions :)
11:31:40 <shapr> I'm thrilled!
11:32:27 <ski> well, local time here is half past eight in the evening, but i think i'll wait a little with going home ..
11:32:52 <shapr> half past nine here
11:32:56 <shapr> you're at work?
11:32:58 <ski> i woke quite late today, about 1 hour after noon
11:33:03 <shapr> oh, at school
11:33:06 <ski> no, i'm at school
11:34:20 <ski> so, i just reloaded http://tunes.org/~nef/logs/haskell/02.01.10 then and then to see if there was any discussion started or etc ..
11:34:37 <ski> interspersed with my usenet reading of course
11:34:52 <ski> (the reloading i mean)
11:34:56 <shapr> heh
11:35:05 <shapr> we had some amusing discussion about haskell belt colors
11:35:24 <shapr> I decided that white belt means "wrote any haskell program that worked"
11:35:30 <shapr> what's the next step up?
11:36:18 <shapr> oh, do you know if constructed datatypes can be added to type classes just like other types?
11:36:22 <xbill> able to use the I/O monad for more than getContents?
11:36:25 <ski> perhaps : wrote a little more advanced programs (perhaps pattern matching), but don't yet understand recursion
11:36:29 <xbill> yes
11:36:37 <shapr> xbill: fair enough
11:36:53 <shapr> since I don't know what means, I'll keep myself at white belt for the moment ;)
11:37:12 <ski> whaddya mean about constructed datatypes, explain yourself man ! :-)
11:37:34 <shapr> ok... 
11:37:39 * shapr looks at his code
11:37:51 <shapr> aha
11:38:10 <ski> you mean datatype constructors, taking parameters, like "list of" or "IO of" , etc ... ?
11:38:13 <shapr> I can do something like data Season = Spring | Summer | ...
11:38:18 <shapr> and then I have a new type
11:38:21 <ski> ok, yes
11:38:29 <xbill> instance C (T a)
11:38:34 <shapr> and if I put "deriving (Eq,Ord,Show)"
11:38:44 <shapr> then it somewhat automatically picks up those methods
11:38:46 <ski> T is a type constructor here
11:38:56 <shapr> right
11:39:27 <shapr> hmm
11:39:35 * shapr tries to understand his question better
11:39:38 <ski> you mean if you can derive some classes (like Eq,Show) for parametriced datatype (constructors) like "list of" ?
11:39:51 <ski> like :
11:40:15 <shapr> yah
11:40:29 <ski> data MyList a = Nil | Cons a (MyList) deriving (Eq,Show,Read,Ord)
11:40:51 <shapr> riiight!
11:40:53 <shapr> that's it
11:41:25 <shapr> is that normal?
11:41:27 <ski> i think it's okay for at least some of the derivable classes (a closed set, unfortunately)
11:41:27 <shapr> does it work?
11:41:59 <ski> well, Bounded and Enum don't work with that MyList i think.
11:42:07 <ski> but that's more or less natural
11:42:21 <shapr> hrm, I had a demo in the Craft book
11:42:35 <ski> Enum only works for an all-zero-argument-constructor-datatype
11:42:58 <ski> i.e. can only be automatically derived
11:43:01 <shapr> they show a Tree that's constructed with nodes that can be recursize
11:43:03 <ski> like that
11:43:05 <shapr> recursive
11:43:09 <ski> ok
11:43:27 <shapr> so I was wondering whether it would be possible to make a Node class
11:43:42 <shapr> that had methods like parent, leftchild, rightchild, content
11:44:02 <ski> hmm, parent is perhaps problematic
11:44:24 * shapr tries to find the Tree demo
11:44:34 <shapr> but the others are possible?
11:44:41 <ski> a parent link in a tree is more or less like a double-linked list
11:44:49 <ski> i guess so
11:45:12 <shapr> aha
11:45:31 <shapr> data Tree a = Nil | Node a (Tree a) (Tree a) deriving (Eq,Ord,Show,Read)
11:45:52 <ski> should the argument to the Node class be a type (kind = *) or a type constructor (perhaps kind = * -> *) ?
11:45:59 <ski> ok
11:46:02 * shapr blinks
11:46:11 <shapr> I haven't gotten into kinds yet
11:46:15 <shapr> just heard of them
11:46:21 <ski> so you want Tree as an instance of the Node class, not say Tree Int ?
11:46:34 <shapr> er, I don't know :)
11:46:47 <ski> kinds are for types(-constructors) what types are for values
11:46:57 <shapr> oh
11:47:00 <shapr> kinds = metatypes
11:47:03 <shapr> that's easy enough
11:47:42 <ski> an good example of the difference (with Tree / Tree Int), look at the predefined Functor class
11:47:52 * shapr looks
11:47:55 <ski> here comes (by heart) :
11:48:01 <ski> class Functor f
11:48:03 <ski>   where
11:48:16 <ski>   fmap :: (a -> b) -> f a -> f b
11:48:20 <ski> ok ?
11:48:36 <ski> some instances :
11:48:36 * shapr thinks through that definition
11:48:45 <ski> instance Functor []
11:48:47 <ski>   where
11:48:52 <ski>   fmap = map
11:48:57 <ski> or
11:49:04 <ski>   fmap f [] = []
11:49:29 <ski>   fmap f (x:xs) = f x : fmap f xs
11:49:36 <shapr> makes sense
11:49:42 <shapr> so that's how they implement map?
11:49:46 <ski> instance Functor Maybe
11:49:47 <ski>   where
11:49:56 <ski>   fmap f Nothing = Nothing
11:50:15 <ski>   fmap f (Just x) = Just (f x)
11:50:23 <ski> yeah.
11:51:08 <ski> you understand the difference of saying that Maybe Int belongs to a class, as opposed to Maybe ?
11:51:16 <shapr> err
11:51:27 <shapr> I think that Maybe Int is a Monad a
11:51:31 <shapr> like
11:51:43 <shapr> it's a Maybe monad somehow 'applied' to an Int
11:51:46 <shapr> or something like that
11:51:49 <ski> look as the class definition of Functor
11:52:02 <ski> f is a type constructor
11:52:15 <shapr> oh
11:52:23 <ski> it wants a type (here a or b) to give a type (here f a or f b)
11:52:25 <shapr> that almost clicks...
11:52:34 <ski> Maybe is a type constructor
11:52:38 <shapr> ohh
11:52:48 <shapr> err
11:52:48 <ski> you can't have a value of type Maybe
11:52:49 <shapr> hmm
11:52:50 <xbill> Either monads are good too
11:52:58 <ski> it must be Maybe something, you know
11:52:58 <xbill> Maybe a 
11:52:59 <shapr> why can't you have a value of type Maybe?
11:53:06 <shapr> why?
11:53:25 <shapr> because type constructor can only take a set number of parameters?
11:53:40 <shapr> and Maybe is defined as "Maybe a" ?
11:53:43 <ski> well all types (as opposed to the super-set type-constructors) can have values
11:53:52 <ski> Maybe /= Maybe a
11:54:00 <shapr> yah, that makes sense
11:54:24 <ski> Maybe is like a functon taking a type and giving a type, on the type level
11:54:38 <ski> could perhaps be written :
11:54:44 <ski> Maybe :: * -> *
11:54:49 <ski> Int :: *
11:54:52 <ski> Bool :: *
11:54:57 <ski> Maybe Bool :: *
11:54:59 <ski> see ?
11:55:13 <shapr> ummm
11:55:23 <shapr> ok
11:55:25 <shapr> I think I've got that
11:55:52 <ski> we have a set of values, and we categorise them for likeness (and usability with operators like plus)
11:56:13 <ski> each category corresponds to a type
11:56:36 <ski> so we say True :: Bool and 'a' :: Char
11:56:54 <ski> so types are sort of like a categorisation of values
11:57:17 <ski> now one can see things in two ways (at least) :
11:57:46 <ski> either a type is a sort of value (so its type is say Type (what's Type's type ? :-))
11:58:07 <ski> or it's at a different level "above" values
11:58:17 <ski> you with me so far ?
11:58:36 <shapr> yeeesss... somewhat
11:58:40 <shapr> I have to go over that several times
11:58:47 <shapr> but it makes sense kind of...
11:58:57 <shapr> types are categories of values
11:58:59 <shapr> right, that I understand
11:59:11 <shapr> but types must be a sort of value also
11:59:15 <ski> the second way is usually easier and clearer (but some languages do it the first way instead)
11:59:19 <shapr> which makes sense (like metaclasses make sense)
11:59:54 <ski> in haskell you can't pass types around as data at run-time, say in data-structures
12:00:07 <ski> so in haskell it's different levels, ok ?
12:00:10 <shapr> ok
12:00:23 <shapr> no constructing types at run-time
12:00:44 <ski> in some (stupid) prog.langs one can't define new types
12:01:26 <ski> in some other (like C or Java) you can define new types (like IntTree,ObjectTree,HashTable,Banana,Season, ...)
12:01:47 <shapr> yah
12:02:32 <ski> these languages often have some sort of type constructors built-in (in C there is "array of" and "pointer to", in Java there's "array of", in Pascal there's "set of")
12:02:42 <shapr> ok
12:03:01 <shapr> uh...
12:03:14 <shapr> hmm
12:03:16 <shapr> hmmmm!
12:03:22 <shapr> things are becoming cleare
12:03:23 <shapr> clearer
12:03:44 <ski> but the real array- or pointer- or set- constructor is not yet a type. it's a means of generating types with some certain similarities in how they are built
12:03:57 <shapr> right
12:04:29 <ski> but array-of-int,pointer-to-set-of-array-of-float, etc .. is real types which have values 
12:04:50 <ski> (a type can be a real type without having any values, though)
12:05:13 <shapr> empty types?
12:05:15 <shapr> weird
12:05:18 <shapr> oh wait!
12:05:28 <shapr> the Season type was one of those, right?
12:05:30 <shapr> or was it...
12:05:34 <ski> no
12:05:38 <shapr> if it can be Enum'ed it might have a value
12:05:51 <ski> you know a little C ?
12:05:55 <shapr> some..
12:05:58 <shapr> very little :)
12:06:06 <shapr> I'm best with Python and Java at the moment
12:06:15 <shapr> though I have done a bit of Scheme and elisp as well
12:06:29 <ski> if we write enum { true,false } boolvariable;
12:06:44 <shapr> yah
12:06:54 <ski> then boolvariable is a variable of an enum type consisting of the values true and false, right ?
12:07:10 <shapr> right
12:07:19 <ski> if we could write enum { } foo;
12:07:24 <shapr> oh
12:07:31 <shapr> I see
12:07:33 <shapr> empty types
12:07:36 <shapr> wow
12:07:46 <ski> then foo would be an (uninitialized) variable of a type for which no values exist !
12:07:53 <ski> in haskell :
12:07:55 <shapr> wow, cool
12:07:57 <ski> data Void
12:08:06 <shapr> that's nifty
12:08:51 <ski> these can sometimes be useful (not often), but we (at least i) don't like arbitrary restrictions (of e.g. trivial "unusable" cases)
12:09:27 <shapr> oh you mean, the implementors could have said "there's no use for this, so you can't use it" but that bugs you?
12:10:12 <ski> when it dawned upon me that we e.g. in sorting algorithms (most often) don't have to treat a single-element collection as a special trivial case, but instead the empty collection, a light lit up :-)
12:10:16 <ski> yes
12:10:36 <shapr> ohhh
12:10:37 <shapr> cool
12:10:55 <ski> it's better with symmetry so you don't have to remember so many catches and special exceptions/cases
12:11:05 <shapr> riiight
12:11:31 <ski> well where was i, with types now, ahh now i recall :
12:11:39 <shapr> and you can do fun stuff like instance Void Ord and tell it that everything is larger except itself
12:11:52 <shapr> cute
12:11:58 <ski> so a type (at least potentially) can have values, ok ?
12:12:08 <shapr> right!
12:12:47 <ski> but a type constructor (like "array of") can't because it's a means for constructing a "real" type, ok ?
12:12:51 <shapr> ok
12:13:16 <shapr> (though as a quick aside, in Smalltalk, the Metaclass object is an instance of an instance of itself)
12:13:25 <shapr> (or something close to that)
12:13:38 <ski> so we can say that types have the (meta-)type "star" (written *), meaning that it can have values, ok ?
12:13:50 <shapr> ok
12:14:18 <ski> yes, i know, one can create circles and cycles also,but thats the other different approach
12:14:39 <ski> so we can write
12:14:43 <ski> Int :: *
12:14:55 <shapr> so * means "I'm neither a type constructor, nor am I data Void"
12:15:00 <ski> (perhaps :: is misleading, perhaps we should use ::: or something)
12:15:02 <shapr> ohh, I get it!
12:15:08 <shapr> no, it makes sense
12:15:10 <ski> except for :
12:15:13 <ski> Void :: *
12:15:15 <shapr> you're treating Int as a function, and I get it
12:15:21 <shapr> I wasn't thinking like that before
12:15:42 <ski> you mean List or Maybe or something instead of Int ?
12:15:59 <ski> or waht do you mean by function ?
12:16:01 <shapr> huh?
12:16:26 <shapr> Int :: *
12:16:58 <shapr> looks like Foo :: Int
12:17:13 <ski> Int's meta-type (or kind /= ordinary type) is star ( * ),which means that it can have values (but Void "chooses" to not have anyway), ok ?
12:17:15 <shapr> er, sorry "foo :: Int ; foo = 42"
12:17:19 <ski> ok
12:17:41 <shapr> but then when you said "Int :: *" it suddenly clicked
12:18:02 <shapr> it implies that Int is a function which constructs Ints
12:18:08 <ski> you mean it looks like a typing (a type assosiated with a value having that type) , except this is a meta-typing (kinding (?))
12:18:43 <ski> Int is a general form for all Int's (like 5,-4,8) and for nothing else
12:18:44 <shapr> er, yah, I think so
12:19:03 <shapr> it's like there can be another one 'above' "foo :: Int" yah, meta-typing is the right word
12:19:24 <ski> when you say function, for me at least, it implies that it takes an argument (which Int doesn't, but Maybe do)
12:19:27 <shapr> so I can now envision "Int :: * ; foo :: Int ; foo = 42" as being normal and understandable
12:19:36 <ski> yes
12:19:37 <shapr> true
12:19:51 <shapr> but it's typing Int that makes sense to me
12:20:08 <ski> there are some implementation drawbacks of course, with doing this fully through
12:20:15 <ski> ok, good
12:20:40 <ski> now we can easily say :
12:20:45 <ski> Maybe :: * -> *
12:20:52 <shapr> aha!
12:21:15 <ski> (or perhaps Maybe :: * -*> * , because the -> is not the same as -> in ordinary types !)
12:21:33 <shapr> Maybe's meta-type is something that takes a type and returns a type?
12:21:41 <ski> it's more or less a type-level function, loosely expressed.
12:21:49 <shapr> ok
12:22:08 <ski> but we can imagine something like this :
12:22:21 <ski> Foo :: (* -> *) -> * -> * -> *
12:22:30 <ski> defined by :
12:22:47 <ski> data Foo f a b = Foo (f a) (f b)
12:23:26 <ski> this Foo takes an a type-constructor (like Maybe) and two types
12:23:41 <shapr> ok
12:23:58 <ski> ok ? (this is of course more complex but can occosionally be useful)
12:24:09 <shapr> yah, I got it
12:24:52 <ski> this is most often not ordinary day-to-day types of a programmer, but theoretically they're there (and sometimes practically too)
12:24:56 <shapr> I'm not sure why you'd want to do it
12:25:04 <shapr> at least, not yet
12:25:45 <ski> i can't think of any example right now (see it's not commonly used) but i know i have seen real useful examples
12:26:31 <shapr> ok
12:26:36 <ski> side note : [Int] can also be written [] Int, with analogy to Maybe Int
12:26:55 <ski> and Int -> Bool == (->) Int Bool
12:26:56 <shapr> so [] is a type constructor?
12:27:01 <shapr> oh
12:27:05 <ski> on the type level, yes
12:27:26 <ski> [] as a type(-constructor) is diffenent as [] as a value
12:27:38 <shapr> I understand that
12:27:39 <ski> same characters but different concepts
12:27:53 <ski> like () is both a type and a value
12:27:56 <shapr> []:'a':'b'
12:28:01 <shapr> is the value
12:28:12 <ski> (in ML () is the value and unit the type)
12:28:18 <shapr> Foo :: []
12:28:21 <shapr> is the type constructor
12:28:30 <ski> yes (execpt it's reversed)
12:28:42 <shapr> ?
12:28:58 <ski> well you have to do foo :: [a] or foo :: [] a
12:29:11 <shapr> can you have a function that returns an empty list?
12:29:24 <ski> because [] (in the type world) is a type constructor (like Maybe) (of kind * -> *)
12:29:29 <ski> yes
12:29:42 <ski> bar :: a -> [b]
12:29:47 <ski> bar _ = []
12:30:26 <ski> ok ?
12:30:38 <shapr> ok
12:30:45 <shapr> I got that
12:31:10 <ski> can you figure out the kind (meta-type) of the function arrow -> ?
12:31:31 <shapr> hm
12:31:37 * shapr thinks
12:31:42 <ski> (it's infix syntactic sugar like  a + b == (+) a b )
12:31:57 <ski> so it gotta be something like :
12:32:03 <ski> (->) :: ???
12:32:09 <shapr> ok
12:32:42 <shapr> (->) :: (* -> *) -> (* -> *)
12:32:45 <shapr> ?
12:32:45 <ski> (i.e. if we use the same syntax for infix type-operators as for infix value-operators (like (+) and (*) ) )
12:32:56 <ski> not quite
12:33:03 <shapr> ok, lemme think about it again
12:33:47 <ski> example type to look upon :   ([Int],Char) -> [Int -> Char]
12:33:55 <ski> perhaps it helps
12:34:21 <shapr> hrm
12:35:11 <shapr> I get the feeling I'm close
12:35:21 <ski> what kind does the two subexpressions to the left and right of the "->" have (trying to help your thoughts)
12:35:43 <shapr> kind means meta-type, right?
12:36:06 <ski> (you can also compare with (1 * 2 * 3) + (sum [4,5,6]), where you want the type of (+) )
12:36:11 <ski> yeah
12:36:33 <shapr> type of (+) in that case is just Int -> Int
12:36:39 <shapr> at least, I think it is
12:36:51 <shapr> <shapr> at least, I think it 
12:36:52 <shapr> er
12:36:53 <shapr> oh
12:36:57 <shapr> I see something I missed at least
12:37:13 <ski> (except we can define a meta-meta-type for meta-types if we want (but it's probably not so interesting (a little like platonic bodies in dimensions greater than four)))
12:37:36 <shapr> (->) :: (* -> *) -> (* -> *) -> f
12:37:38 <shapr> ?
12:37:41 <shapr> uhh
12:37:45 <shapr> lemme check that
12:38:09 <ski> look a little at my example in the paranthesis with +
12:38:34 <shapr> that looks like it would be Int -> Int -> Int
12:39:00 <shapr> which would imply that (->) :: (* -> *) -> (* -> *) -> (* -> *)
12:39:10 <ski> the type of +'s first argument is the type of the expression to the left of +, with the second it's the right expression, otherwise similar
12:39:11 <shapr> but I'm not convince that -> would return a type constructor
12:39:43 <shapr> uh
12:40:02 <ski> the kinds of a typeconstructors arguments are the kinds of the sub-typexpressions passed as arguments, ok ?
12:40:20 <shapr> ok
12:40:24 <ski> so look at ([Int],Char) -> [Int -> Char]
12:40:38 <ski> what kind does ([Int],Char) and [Int -> Char] have ?
12:40:53 <ski> that's the kind of the function arrows arguments
12:41:23 <shapr> uh
12:41:30 <ski> the kind of the whole expression ([Int],Char) -> [Int -> Char] is the kind of the result generated by the function arrow, ok ?
12:41:52 <shapr> uhh
12:42:06 <shapr> I can almost get this, but not quite
12:42:16 <ski> Int has kind * , therfore [Int] has kind * and Char has kind *
12:42:19 <shapr> what's the kind of *any* expression?
12:42:27 <shapr> ok
12:42:29 <ski> now what kind does ([Int],Char) have ?
12:42:30 <Heffalump> expressions don't have kinds, types do
12:42:34 <shapr> Int has kind * because it can have a value
12:42:45 <shapr> kind would be (*,*) ?
12:42:49 <shapr> is it really that simple?
12:43:06 <shapr> is there a tuple constructor I have to think about?
12:43:10 <ski> is a pair of int lists and char a value ?
12:43:13 <shapr> is a tuple a type?
12:43:34 <ski> a pair of int lists and char is a type, yes.
12:43:51 <shapr> ok, that's nice to know
12:44:10 <ski> (maybe, i'm just confusing the issue with my feeble attempt with these examples)
12:44:36 <ski> so anything of type ([Int],Char) -> [Int -> Char] is a function, right ?
12:44:38 <Heffalump> as a general point, not having read this entire discussion, I'd note that I've been using Haskell for years without ever having to properly understand the kind system to do useful work with the language
12:44:42 <shapr> I'm definitely learning stuff, so if you want to keep talking, I'll keep trying to understand :)
12:45:06 <smkl> (->) :: * -> * -> *
12:45:13 <shapr> yah, I know I could probably keep using it with knowing this kind of stuff, but this is *fun* !
12:45:18 <Heffalump> yeah :-)
12:45:36 <Heffalump> that's a good enough reason, just don't get too bogged down with it if it stops being fun :-)
12:45:39 <shapr> OH!
12:45:54 <ski> Heffalump : well, you might say that porperly understanding kinds and stuff is over-course, but i was interested, so i figured it out
12:45:54 <ski> smkl : your'e correct, hooray !!
12:46:01 <shapr> so both * and (*,*) would both fit into the * type?
12:46:28 <ski> no (*,*) is not into *
12:46:34 <shapr> oh
12:46:55 <ski> but (Int,Int) is into * because it's a type (which can have values)
12:46:55 <shapr> hm
12:47:01 <shapr> oh!
12:47:24 <ski> you can write (,) 1 2 instead of (1,2) as a value in haskell
12:47:32 <shapr> cool
12:47:44 <ski> therfore (,) is a function (type is a -> b -> (a,b) )
12:47:56 <shapr> wow, spiffy
12:48:00 <Heffalump> ski: do you have a reference for the "any type which can have values is kind *" thing, or did you just figure it out?
12:48:12 <smkl> there isn't much difference between "kinds" and "types". "types" are types for terms, "kinds" are types for types
12:48:16 <ski> but now they write the type with the same syntax, confusing things up (at least syntactically)
12:49:53 <ski> Heffalump : no i don't have a reference but i'm pretty sure about it, because otherwise it don't think the paper's iv'e browed through and tried to understand, which used kind, would have made any sense to me at all
12:49:58 * shapr takes his new knowledge and applies it to the original question
12:50:00 <shapr> <ski> should the argument to the Node class be a type (kind = *) or a type constructor (perhaps kind = * -> *) ?
12:50:34 <Heffalump> ski: right. It certainly makes sense to me, but as I said I've never really understood the kind system.
12:51:27 <ski> smkl : yes, that one good was to put it (except, i'd like to (syntactically also) separate between type as type for value and type as this categorizing concept applying to both values, types,kinds (meta-types), etc ...)
12:52:31 <Heffalump> I like to think of types as sets, sometimes
12:52:52 <ski> shapr : well, that your choice, but it certainly (to me seems easier) with the constructor way, i.e. one instance is defined (e.g. Maybe) , instead of many instances (Maybe Int, Maybe Bool, etc ...)
12:54:01 <ski> Heffalump : well, that's a quite good view. i see sets as a certain possible interpretation/implementation of types, but it's not the only one possible
12:54:54 * ski is trying to catch up with all the sudden explosion of responses ;-), and read them all thu
12:55:26 <Heffalump> ski: yeah
12:55:31 <shapr> hi Diego 
12:55:47 <Heffalump> I suspect proper type theoreticians would tell me exactly why the view of them as sets is wrong
12:56:35 <ski> Heffalump : about now only learn about theoretical things like kinds : yes, point taken, but right now, it's still fun ! (i'm also interested in more mundane things, perhaps not always so much :-)
12:56:58 <Heffalump> :-)
12:57:06 <Heffalump> what do you do?
12:57:23 * ski has a tendancy to let the thought race on and on and forget the original issue
12:57:34 <ski> (still reading thu)
12:57:46 <Heffalump> thu?
12:58:30 <shapr> probably should have been thru or tho
12:58:46 <ski> shapr : Diego ? i saw no Diego ?
12:59:15 <shapr> ski: he and kepler joined while we were talking
13:00:30 <shapr> I think of type classes as Interfaces in Java
13:00:36 <shapr> obviously they are much much more
13:00:53 <smkl> http://www.cis.upenn.edu/~bcpierce/types/archives/current/msg00807.html
13:00:55 <Heffalump> that's a reasonable approximation to what they are
13:01:04 <ski> Heffalump : often in math they say that  this or that is defined as a certain set in some way. for some reason it makes me angry. because often many more-or-less equivalent (in effect) definitions are possible. so i consider them only as possible implementations and the "real concept" is what all possible implementations have in common, i.e. the "spirit" of the concept
13:01:29 <shapr> that also applies to life in general btw
13:01:37 <shapr> occams razor does get overused
13:01:38 <ski> Heffalump : whaddy mean by "what do you do?", me not understand
13:01:40 <Heffalump> but if many equivalent definitions are possible, what's the problem with choosing one?
13:01:56 <Heffalump> ski: e.g. student etc
13:02:02 <ski> Heffalump : (s/thu/thru/ or s/thu/though/)
13:02:09 <Heffalump> right :-)
13:02:26 <ski> shapr : ok, missed that (about kepler ..)
13:03:06 <ski> interfaces in java has much in common with type classes in haskell
13:03:50 <Heffalump> the major conceptual difference is that interfaces and classes sit on the same "level" in Java
13:04:09 <Heffalump> whereas Haskell type classes and Haskell types are completely separate
13:06:09 * shapr tries to write a Node class
13:06:13 <ski> Heffalump : no problems with choosing one implementation, only you're aware that it could be defined in diffenent ways and still yield same consequences. what makes me upset is when they say (or imply) that this is the One True definition. understand me now ?
13:06:28 <shapr> with 'methods' parent, leftchild, rightchild, and content
13:06:34 <Heffalump> ski: right
13:07:01 <ski> interfaces just yield, just that an interface, while a class yields both an interface and an implementation
13:07:08 <Heffalump> shapr: why are you writing that as a class, btw?
13:07:33 <shapr> Heffalump: couldn't think of a better way to drill the idea of type classes into my head
13:07:44 <shapr> therefore, I may be going about this all wrong
13:07:53 <shapr> is that a sensible thing to do?
13:08:07 <ski> Heffalump : i think he want's to see if he can make some sort of general interface for it, not dependant on particular type. and also to experiment with type constructor classes
13:08:15 <Heffalump> okie dokie
13:08:22 <shapr> right
13:08:39 <ski> ok, then i understood you correctly.
13:08:39 <Heffalump> shapr: no, it's a reasonable thing to do, though I suspect you'll find that you could do the same thing just using a polymorphic type
13:08:44 <shapr> several days ago, jewel asked me if you make 'methods' on a variable
13:08:54 <ski> i think it could be interesting to do it as a class.
13:08:57 <shapr> and I thought type classes might be a good way to do that
13:09:26 <ski> methods on a variable ?
13:09:29 <shapr> Heffalump: ok, I'll try to figure out how to do it as a polymorphic type after I get the class working
13:09:39 <shapr> yah, like calling methods on an object
13:09:41 <ski> like a method on an object value in java ?
13:09:45 <shapr> right
13:09:47 <ski> ok
13:10:17 <ski> well, the object/value's type must of course be made an instance to the class
13:10:20 <shapr> type classes appear to be a reasonble facsimile
13:10:31 <shapr> right
13:10:38 <shapr> I've done that from the book
13:10:47 <shapr> but I've never thought of using a kind
13:11:08 <ski> if one is trying to convert a java class to haskell, one have to make both a type and a class (because java classes is both interface (= methods) and an implementation (= haskell type))
13:11:09 <Heffalump> you can't really "use" a kind because they have no existence within the language itself
13:11:50 <Heffalump> they're just important for typechecking a Haskell program. But there's no way (as far as I know...) of actually explicitly declaring something to be of a certain kind
13:11:51 <ski> yes, unfortunately, one can't write kinds explicitely in haskell
13:11:53 <shapr> er, type constructor,sorry
13:11:55 <shapr> not kind
13:12:05 <Heffalump> ski: why do you think that's unfortunate?
13:12:11 <ski> but you can reason about them, and both hugs and ghc also do !
13:12:16 * Heffalump has difficulty thinking how the ability to do it would be useful
13:12:24 <Heffalump> and nhc and hbc, I hope :-)
13:13:19 <ski> well John Hughes come up with an example (real practical,i swere !) in some parser or something i thing
13:13:34 <shapr> of wanting to use a kind directly?
13:13:43 <Heffalump> ski: ah, ok.
13:13:56 <ski> Heffalump : yes , of course, it's needed for kind-inferencing. like a type-inferencer but in mini
13:13:57 <Heffalump> oh, I might have seen that on the list.
13:14:16 <ski>  John Hughes ended up defining something like this :
13:14:37 <ski> data Foo c a = Foo a | Unused (c Int)
13:14:53 <Heffalump> to force c to be of kind * -> * ?
13:15:09 <ski> i guess he had also other types of kind (* -> *) -> * -> *
13:15:15 <ski> which he wanted to make instances of some class
13:15:24 <ski> to this Foo was the trivial case
13:16:01 <ski> if he hadn't put Unused (c Int) in there, c would defaulted to kind * and not (* -> *) as he wanted
13:16:35 <ski> but i guess these things don't come up practically so often (his code was of course advanced, that'
13:17:02 <ski> that's why it came in there at all i guess)
13:17:03 <Heffalump> but even if most programmers wouldn't need it, they might want to use combinator libraries that did need it
13:17:15 <ski> yes
13:17:50 <ski> i think collection classes in haskell is best done using type constructors
13:17:52 <Heffalump> especially if the example involved parsing
13:18:32 <ski> Heffalump : it this case i think it was an internal type in the implementation and not exposed to the outside
13:18:54 <Heffalump> yep, but you still can't use a combinator library that doesn't work :-)
13:19:32 <ski> no, exactly. in Hughes case there was a workaround (or redesign the solution)
13:20:32 <ski> ok, now we've wandered far from shapr's initial example/problem/whatever (as always ?)
13:20:52 <shapr> the wanderings are cool btw
13:21:10 <shapr> this is like two months worth of the haskell mailing list =)
13:21:14 <shapr> at high speed
13:21:15 <ski> (but, we've had fun on the way. at least i if i can speak for myself (which i think i can))
13:21:24 * Heffalump too
13:21:38 <Heffalump> the haskell list has John Hughes and other scarily clever people on it :-)
13:21:46 <ski> they do ?
13:21:48 <shapr> I'm still trying to wrap my head around passing a type constructor to a class
13:22:08 <shapr> ski: you're not on the haskell mailing list???
13:22:09 <Heffalump> I wish I had more time to understand the complicated examples of problems that get pasted there
13:22:15 <Heffalump> s/pasted/posted/
13:22:17 <ski> iv'e not read so much there. never subscribed there. only browsed sometimes from haskell.org
13:22:29 <shapr> I wish I had enough clue to understand some of the stuff they post
13:22:39 <Heffalump> shapr: you don't so much "pass" things to classes as "declare instances"
13:22:50 <shapr> class Node (a -> b) where
13:22:50 <shapr> ?
13:23:00 <Heffalump> that's not legal
13:23:08 <shapr> I suspected as much
13:23:09 <ski> shapr : no, iv'e never been on a mailinglist in my life. i'm scared of overfull mail-inbox
13:23:12 <Heffalump> you have to do "class Node a where ..."
13:23:22 <Heffalump> ski: you really need to filter email to do that
13:24:24 <ski> Heffalump : i sometimes write something like  Eq :: * -> instance  , Functor :: (* -> *) -> instance  , for mnemonics sake
13:24:58 <Heffalump> ski: in a comment?
13:25:13 <ski> shapr : you want functions as an instance of Node 8-0 ! (good luck)
13:25:24 <shapr> Node 8-0?
13:25:36 <Heffalump> shapr: when you say "class Node a where ..." where "..." is some things involving a, you will determine what kind a has by how you use it in the "..."
13:25:49 <shapr> oh
13:25:53 <shapr> oh I see
13:26:03 <shapr> ohhh
13:26:06 <Heffalump> so if you say "class Node a where parent :: a e -> a e" then you are saying a must be of kind (* -> *)
13:26:08 <ski> Heffalump : well i think it's legal syntax (i.e. if has Node class takes a type (and not a type constructor))
13:26:38 <Heffalump> ski: sorry, I don't understand the bit in brackets. But is '*' ever legal syntax in a type?
13:26:43 <ski> Heffalump : well, i've been to lazy to learn how to filter mail, sadly
13:27:17 <ski> Heffalump : yes, in a comment
13:27:42 <Heffalump> ski: oh, sorry, I thought what you said was a response to something else :-)
13:27:47 <ski> Heffalump : as i write the types for exported (and sometimes imported) values in a module
13:28:23 <Heffalump> I still don't see how "class Node (a->b)" can ever be legal syntax
13:28:29 <ski> Heffalump : * is not a legal syntax in a type
13:28:41 <Heffalump> ski: yeah, like I said I misunderstood what you were referring to with that comment
13:28:53 <ski> shapr : 8-0 was a smiley, ok ?
13:29:04 <shapr> oh
13:29:14 <shapr> duh :)
13:29:21 * Heffalump wonders when Haskell 2 might happen
13:29:23 <shapr> I should have noticed that
13:30:18 <ski> if haskell had (optional of course) "kindings" of types then one could write the kind of argument types to a class directly (even if the class has no method members)
13:30:30 <shapr> is => only used in a type declaration to limit to type classes?
13:30:42 <Heffalump> shapr: I think so
13:31:01 <Heffalump> I certainly can't think of anywhere else it is used, and I hope it's not legal to use it in your own operators
13:31:07 <ski> Heffalump : well, i'm also waiting for Haskell 2. there are some thing that should be fixed (more important than kindings that is)
13:31:15 <shapr> ski: like what?
13:31:35 <Heffalump> I want them to bring back guards in monad comprehensions, but that's not really very important :-)
13:31:51 <ski> shapr : => is used both in type,class and instance declarations to limit type classes.
13:32:03 <shapr> ok
13:32:09 <Heffalump> oh yes, I forgot that, sorry
13:32:30 <Heffalump> so you get (==) :: Eq a => a -> a -> Bool
13:32:41 <Heffalump> and class Monad a => MonadPlus a where ...
13:32:50 <ski> Heffalump : no it's not legal as a value operator, it's a non-alpahbetic reserved "keyword" , like \ and -> 
13:33:05 <Heffalump> good :-)
13:34:14 <ski> shapr : i'm not very happy with the current state of thing with the numeric classes (WHAT DOES SHOW HAS TO DO IN NUM ?), and a special issue regarding class contexts in datatype definitions
13:34:43 <shapr> how can the show in num be fixed?
13:34:49 <ski>  shapr : (that's right => is permitted in data declarations (and in newtype i presume) as well)
13:35:27 <ski> shapr : why should every type that i want to be an instance of Num be Showable ?
13:35:34 <Heffalump> Prelude> :i Num
13:35:39 <Heffalump> [...]
13:35:44 <Heffalump> class (Eq a, Show a) => Num a where
13:36:07 <Heffalump> shapr: he's complaining that Show is a prerequisite for Num
13:36:14 <ski> shapr : somotimes one can't (impossible) do that, in that case one has to declare a dummy Show instance which generates error when calling show
13:36:30 <Heffalump> what's your example?
13:36:48 <ski> Heffalump : yes, Eq is also disputable if it should be there.
13:37:28 * ski whine whine whine (perhaps 'nuff whining now ?)
13:38:15 <ski> Heffalump : e.g. function of type Int -> Int
13:38:26 <Heffalump> go on then, why is that a Num?
13:38:49 <ski> Heffalump : it's not in Num class, but : (coming)
13:38:56 <Heffalump> I can see how you can put it in Num
13:39:06 <Heffalump> but is it really useful to do so?
13:39:23 <ski> one might want foo + bar to be equal to \n -> foo n + bar n
13:39:44 <Heffalump> yeah, I guess
13:40:20 <ski> Heffalump : well, i'm not sure if this particular example is practically useful (really that is)
13:41:10 <ski> Heffalump : but it still seems like an unnecessary prerequisite for membership of the Num club, so to speak :-)
13:41:24 <Heffalump> yeah, fair enough
13:41:43 <ski> one might want to define Set a as implemented as a -> Bool
13:41:45 <Heffalump> though in general I think when you design interfaces you sometimes have to sacrifice overall elegance for general convenience
13:42:16 <Heffalump> you can't define (*) :: a -> a -> a on sets
13:42:18 <ski> that's a often taken view i math i think
13:42:41 <Heffalump> oh, I guess you could make it intersection
13:42:52 <Heffalump> but you still can't define abs :-)
13:43:44 <ski> Heffalump : no i can't but i perhaps (not sure if i really want) want to split the num class into AdditiveRing,MultplicativeGroup, etc. at least for it be possible to do so. not saying here that is is normally always preferred
13:44:15 <ski> Heffalump : Clean's type-classes are a little in that direction
13:44:26 <Heffalump> right, I've not looked at that
13:44:37 <ski> they have in Clean a PlusMinus class (supporting +,-,negate)
13:45:12 <ski> and then built the (more or less) corresponding class for Num on such things
13:46:42 <ski> so Boolean and and or can also be fitted into some of the classes that numbers fit in, ok ? (isn't it beautiful (well, i don't know really for sure because i'm not worked very much with Clean))
13:48:11 <ski> ok, perhaps 'nuff said about revamping haskell's numeric classes here ? or anyone wan't to say more (who am i really to dictate what people here should talk about ?? ;-)
13:49:11 <ski> hello you shapr : have you come any way with that Node class of yours ? or have you decided to try something else ?
13:50:03 * ski is trying to cool down a little
13:51:58 <shapr> ski: er, I got distracted into reading about type classes more
13:52:26 <shapr> how do I use a type constructor in a class?
13:52:51 <Heffalump> use it to do what?
13:53:00 <ski> well, it's quite interesting. it's a little like prolog. i.e. type classes without any methods are (partly) similar to prolog's predicates
13:53:29 <ski> shapr : look at the definition of the Functor class
13:53:54 <ski> i can provide it once again below if you like, do you ?
13:54:35 <ski> Heffalump : i think shapr mean't how to write it, did you shapr ?
13:54:42 <shapr> yup
13:54:55 <Heffalump> so you want to write a type class that has type constructors as instances?
13:55:28 <shapr> sure :)
13:55:37 <shapr> I hadn't even thought about it before
13:55:49 <ski> shapr : yup, i want to see Functor class again   or just   yup, i want to know how to write and use it ?
13:55:53 <shapr> but ski mentioned it as an option
13:56:01 <shapr> I want to know how to write and use it
13:56:07 <ski> ok
13:56:15 <shapr> I've pasted the definition you gave me earlier into a buffer
13:56:25 <ski> it more or less as a normal class and instance definition
13:56:26 <Heffalump> ok, so "class Node c where ..." is how you get started
13:56:35 <Heffalump> you can call c whatever you like
13:56:47 <Heffalump> oh, and leave out the ... :-)
13:57:02 <ski> yes, just that c must get some arguments (cuz otherwize it's not a type constructor)
13:57:25 <Heffalump> yep, so when you *use* c in the body of the type class, you give it argument(s)
13:57:36 <ski> Heffalump : you mean me :-) (sorry:)
13:58:03 <ski>  Heffalump : i missunderstood. ignore my previous comment.
13:58:05 <shapr> but you can still pass the type constructor in as just c
13:58:20 <ski> yes
13:58:42 <ski> something along these lines perhaps :
13:58:48 <ski> class Node n
13:58:50 <ski>   where
13:59:02 <ski>   leftChild :: n a -> n a
13:59:10 <ski>   rightChild :: n a -> n a
13:59:21 <ski>   nodeContent :: n a -> a
13:59:41 <ski> was it something along these lines you thought about ?
14:00:28 <shapr> yup
14:00:54 <ski> and you probably want some constructing methods like :
14:01:04 <ski>   nullNode :: n a
14:01:25 <ski>   makeNode :: a -> n a -> n a -> n a
14:01:32 <ski> or something..
14:01:47 <shapr> as part of the class?
14:02:32 <Heffalump> yeah, probably
14:02:51 <Heffalump> you need to think what kind of trees you want to model
14:03:06 <ski> well, hmm. it depends on how the class is to be used. i thought about using it for abstract datatypes, but now i realise that you can of course have it only as an extra class atop for easier browsing thu nodes ..
14:03:18 <Heffalump> i.e. will they have data at the tips, in the nodes (the non-tips) or both?
14:03:59 <shapr> er
14:04:04 <shapr> I'm not picky :)
14:04:46 <Heffalump> ok, so if you do what ski said then they'll have data at the non-tips only
14:04:49 <ski> Heffalump : good questions to ask oneself. but it doesn't have to be used for providing abstrat datatypes , so in that case constructing methods are not totally nessecary (cuz you already know the type and constructors of the data you're manipulation)
14:05:00 <Heffalump> ski: minor detail, what would you expect nodeContent nullNode to return?
14:05:24 <Heffalump> ski: true, if you leave out the nullNode and makeNode functions above
14:05:57 <ski> different kind of trees for different needs. when i head an unqualified tree, i thinks : tree with data in nodes but not at tips (probably binary too)
14:06:07 <ski> s/head/hear/
14:06:57 <ski> Heffalump : well error as head [] does ? (most probably anyway)
14:07:32 <Heffalump> ski: ok.
14:07:53 <ski> Heffalump : another way is to make a "case-function" with type (a -> n a -> n a -> b) -> b -> (n a -> b)
14:08:02 <Heffalump> I think if not all parts of the tree will have data, then nodeContent should be type n a -> Maybe a
14:08:15 <ski> yes thats possible
14:08:19 <Heffalump> anyway.
14:09:11 <shapr> right
14:09:13 <shapr> anyway :)
14:09:20 <ski> ok
14:09:34 <shapr> taking the simplest case of using a type constructor here...
14:09:47 <ski> mmm.
14:11:03 <shapr> hm
14:11:33 <ski> shapr : you working or thinking on your program right now ?
14:11:38 <shapr> thinking
14:11:53 <shapr> I don't really know what to do about instances with type constructors involved
14:12:26 <Heffalump> ok, so how would you define an instance without a type constructor involved?
14:12:47 <Heffalump> e.q. show me how to write an instance of Eq for Bool
14:12:48 <ski> Heffalump : me ?
14:12:56 <Heffalump> no, shapr
14:13:03 * Heffalump was kind of assuming you could do that :-)
14:13:07 <shapr> instance Node NodeInst where
14:13:28 <shapr> of course, I'd usually put a built in type there
14:13:35 <shapr> like Char or Int or whatever
14:13:47 * ski thought about "define an instance without a type constructor", ok ?
14:13:58 <shapr> oh
14:14:24 <ski> shapr : that's was a comment to Heffalump
14:14:36 <shapr> oh
14:14:49 <shapr> I thought suddenly that I need to do "data NodeInst"
14:14:54 <shapr> and I think that's right
14:15:07 <shapr> yes it is
14:15:12 <Heffalump> data NodeInst is how you declare the type NodeInst
14:15:24 <Heffalump> instance Node NodeInst is how you make it an instance of Node
14:15:39 <shapr> data NodeInst left right content = 
14:15:41 <ski> yes you need at least some type poulating your class, otherwise there wouldn't be much point in defining it in the first place, would it ?
14:15:41 <shapr> something
14:15:49 <shapr> ski: right
14:16:09 <shapr> hmm
14:16:30 <shapr> (left,right,content) ?
14:16:46 <ski> shapr : data NodeInst left right content = ... means that the type of the left and the right tree can be different (probably not what you want)
14:16:53 <shapr> oh
14:17:01 <shapr> I'm still thinking in values
14:17:45 <shapr> hrm
14:18:05 <shapr> data NodeInst branches content =
14:18:17 <shapr> er
14:18:40 <ski> it takes some practice to be able to think in types. some functions are so nice that they can sort of be generated from their type. that's espessially good when it would be hard (or very hard) to directly come up with the implementation.
14:19:18 <shapr> I'm definitely finding it challenging
14:19:57 <ski> shapr : perhaps you should start with trying to think out what constructors you want and what arguments (parts of a NodeInst .. value) they should have
14:20:20 <shapr> good point
14:20:31 <ski> shapr : and wait with determining exactly what arguments the type constructor NodeInst should have
14:21:27 <ski> when one is writing code in an editor before one's eyes, it's easy to change that many times, and not always even remember that one has changed it
14:21:46 <shapr> urf
14:21:56 <ski> becuz it's easy to edit, and should be
14:22:09 <shapr> I'm having coders block :)
14:22:21 <shapr> or something
14:22:23 <shapr> my mind is blank
14:22:29 <ski> oh
14:23:18 <shapr> if I say data foo = ...
14:23:24 <ski> well, try to choose if you want data in nodes or tips (or both). e.g. choose data in nodes for simplicitys sake (or whatever you like)
14:23:27 <shapr> there is a way to make multiple constructors for that custom type?
14:23:32 <shapr> in nodes, not tips
14:23:45 <shapr> for simplicitys sake as you said
14:23:54 <ski> ok.
14:24:28 <ski> multiple constructors is easy. remember : data Either a b = Left a | Right b
14:24:49 <ski> only put a | between the different constructor forms
14:24:49 <shapr> hm
14:25:05 <ski> (i know you know that :)
14:25:25 <ski> or more nicer in an editor :
14:25:32 <ski> data Either a b = Left a
14:25:43 <ski>                 | Right b
14:25:46 <shapr> yah, but I hadn't explicitly thought of that as multiple constructors
14:26:00 <ski> well, that's what it is.
14:26:13 <shapr> nifty
14:26:43 <ski> Left, and Right are constructors, they are plural (more than one), hence multiple. Q.E.D. ;-)
14:26:51 <shapr> heh
14:26:54 <shapr> good point
14:27:19 <ski> just a tautology.
14:27:20 <shapr> but I'm not sure how to generalize that notion...
14:27:27 <shapr> I think my brain may be full for the moment
14:27:28 <shapr> :(
14:28:12 <shapr> I think I need to wander off and do something mindless for awhile and let this all sink in
14:28:30 <ski> if i understand you correctly you want that one for of an NodeInst ... should contain data (say of type a) and 2 (or do you want more ?) subnodes. is this right ?
14:28:43 <shapr> right
14:28:59 <shapr> 2 subnodes (of type NodeInst I assume)
14:29:01 <shapr> and one content
14:29:31 <ski> shapr : could be, sometimes it helps to rest the brain, and come back to a problem from a new view-point, when one's not into the subject at the same way.
14:29:53 <ski> say the constructor look like :
14:30:04 <ski> NodeI a (NodeInst ...) (NodeInst ...)
14:30:19 <ski> is this good ?
14:31:15 * ski yawns a little
14:31:45 * ski a little tired, but can still stay more time if wanted
14:32:32 * Heffalump has got back to writing SML, which is his current job
14:32:42 <Heffalump> sadly I keep trying to write Haskell syntax :-/
14:32:51 <ski> btw : according to what time does clog time these channels, GMT ?
14:33:04 <shapr> I dunno
14:33:09 * shapr looks
14:33:11 <Heffalump> GMT I think
14:33:41 <Heffalump> oh. no.
14:33:43 <ski> Heffalump : can be a little hard sometimes to switch syntax-mind-set
14:33:45 <Heffalump> looks like PST
14:34:04 <ski> Heffalump : so you're writing SML, care to tell what ?
14:34:18 <Heffalump> umm, stuff to manipulate .NET IL
14:34:25 <shapr> IL?
14:34:30 <Heffalump> intermediate language
14:34:33 <Heffalump> like Java bytecode
14:34:38 <shapr> oh
14:34:46 <shapr> I wondered if .net was related to IP
14:34:51 <Heffalump> not really
14:35:06 <shapr> ski: much thanks for your patience and teaching today :)
14:35:08 <ski> Heffalump : current time according to clog is approx. 14:34:18 . but it's half past eleven in the evening here in Sweden
14:35:16 <Heffalump> ski: yeah, that's why I said PST
14:35:31 <shapr> half past midnight in .fi
14:35:34 <Heffalump> cos it's GMT-8, and it's 22:35 GMT atm
14:36:57 <shapr> 19.	A language that doesn't affect the way you think about programming, is not worth knowing.
14:37:06 <shapr> part of alan perlis' sayings
14:37:15 <ski> shapr : it's always a pleasure for me. i only worry sometimes that i somtimes may reveal answer too quickly or talk over the head of talked-to-person, cuz i try to make it understandable. but i'm totally inside it and used, and has perhaps sometimes forgotten how it seems like from the outside
14:37:41 <shapr> ski: I think you do quite well
14:37:42 <ski> Heffalump : i'm not sure what time PST exactly is.
14:37:51 <Heffalump> GMT -8 :-)
14:37:52 <shapr> Pacific Standard Time
14:37:55 <shapr> oh
14:37:56 <shapr> that part
14:37:57 <Heffalump> ah, yes, that too.
14:38:07 <ski> shapr : who's alan perlis' ?
14:38:07 <Heffalump> West Coast of the US, anyway
14:38:08 <shapr> aka, west coast usa
14:38:24 <shapr> I'm from Central Time originally
14:38:39 <shapr> or EST sometimes
14:38:44 * Heffalump has lived in GMT/BST all his life
14:38:51 <shapr> cool :)
14:38:59 <shapr> I went from EST to EET
14:39:00 <Heffalump> except for brief excursions to PST/PDT and various holidays
14:39:11 <ski> shapr : i've never "officially" lectured or teached anything, but i love to learn (at least most things, except perhaps Deusche grammatik, and some other things)
14:39:28 <ski> Heffalump : ok, west coast, then.
14:40:01 <shapr> ski: sadly, official teachers and lecturers aren't nearly as much fun to listen to as enthusiastic learners
14:40:33 <Heffalump> it's very easy to get bored of teaching the same thing over and over again
14:40:44 <ski> shapr : some of my lecturers even said wrong things (that i think was not simplifications)
14:40:49 <shapr> http://www.cs.yale.edu/homes/perlis-alan/quotes.html
14:41:01 <shapr> Heffalump: yah, I agree with that
14:41:03 <Heffalump> ski: not John Hughes I hope :-)
14:41:09 <shapr> believe it or not, I'm alpha geek where I work
14:41:26 <shapr> teaching people how to read a file in Java is ok the first four or five times
14:41:32 <shapr> after that it loses its thrill
14:41:51 <ski> Heffalump : i hadn't thought of that. probably because i havn't teached (officially). could well be so in some case. the lecturer is perhaps more engrossed in his own special research project :-)
14:43:08 * Heffalump has taught classes for a functional programming courses and for a procedural programming course. I found the functional programming course more interesting, but I still got bored with both.
14:43:09 <ski> shapr : i believe you. that doesn't sound much fun to me either.
14:43:24 <shapr> I've only taught coworkers
14:43:39 <shapr> I really wanted to start them with SICP
14:43:54 <shapr> but they and my bosses really wanted them to learn Java, since that's how we get money
14:43:58 <shapr> oh well
14:44:00 <ski> Heffalump : so moral is : try not to officially teach cuz it makes you less excited ?
14:44:19 <Heffalump> ski: but if noone ever officially taught then most people would never learn
14:44:22 <shapr> I think the moral is "don't do stuff if you're bored with it"
14:44:38 <Heffalump> I was taught Haskell by a completely incompetent lecturer but I still got to like it a lot
14:44:52 <shapr> I've never had any CS courses.
14:44:55 <ski> it's probably a difference if one is teaching all day long or only then and then to friends,coworkers and people you meet.
14:45:34 <Heffalump> I don't do very much teaching, so I don't have that much opportunity to get bored with it. If I was a lecturer I suspect it might get quite bad :-)
14:46:06 <ski> shapr : no one should look down on one for that. some people learn better by themselves.
14:46:29 <shapr> I think I learn best in a peer to peer environment like this
14:46:52 <shapr> but I can also teach myself
14:47:03 <ski> though, i suppose some people have more or less a gift for teaching, but i think that even then it can get boring at times.
14:47:47 <ski> okeydokey.
14:49:13 <ski> shapr : you sitting at home,school or work ?
14:49:15 <shapr> ski: do you think you'll be back online soon?
14:49:19 <shapr> at home
14:49:32 <shapr> working with Java makes enough money to pay for a dsl line :)
14:49:41 <shapr> even just across the border from Haparanda
14:50:28 <shapr> ski: do you live far from school?
14:50:32 <ski> shapr : well, i suppose i often have irregular habits (because i'm "tankspridd"(swedish) often) but i hope to be back here some time soon, yes .
14:50:56 <shapr> what's tankspridd?
14:51:18 <ski> shapr : well, it's biking-distance. maybe 3 - 6 kilometres or something, i'm not sure.
14:53:14 <ski> shapr : "tankspridd" (i don't know the english translation), when you often have lots of diverse thoughts about different things and easily forgot things, like to eat breakfast, or pay the bill the correct day (though i'm getting better at that) , and returning loaned books to the library
14:53:50 <ski> y'know what i mean ?
14:54:05 <shapr> forgetful?
14:54:12 <shapr> distractable?
14:55:02 <shapr> yah, I know what you mean
14:55:04 <shapr> same for me
14:55:49 * ski trying to look up the word in an web-dictionary that used to be somewhere on these web-pages ..
14:55:54 <shapr> well, I'm off to play tribes2 for a bit, and then time for sleep
14:56:31 <shapr> once again, much thanks for your help ;)
14:56:33 * shapr waves
14:56:43 <ski> well, cant find it now :-(
14:56:51 <ski> goodby , shapr.
14:57:00 * ski waves back
14:57:56 <ski> ok, you others there. perhaps you wan't to discuss things on your own without me interupting you, or are you still there ?
14:58:42 * ski stays at least a little while longer here and is still available
14:59:35 * ski will read a little more usenet now. shout if you want my attention, ok ?
14:59:48 <Heffalump> BOO! (just joking)
15:00:28 <ski> Heffalump : i heard you !
15:01:12 <ski> oops, my shell has broken a little, will log on fresh ..
15:38:14 <ski> hi, kepler.
17:46:06 <ski> bye
22:50:39 <dmiles> xbill: i am porting to mercury now
22:50:52 <dmiles> xbill: have you used it much?
22:52:58 <dmiles> any mercury experts here?
