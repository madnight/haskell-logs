03:58:20 <Continuum> hi all
03:58:32 <shapr> hi Continuum 
03:58:37 <shapr> what's up?
03:59:06 <Continuum> well i'm just about to start learning haskell so i thought i'd drop in
03:59:20 <shapr> you should also check out #loty then
03:59:36 <Continuum> ok whats that ??
03:59:49 <shapr> I'd recommend purchasing "Haskell : The Craft of Functional Programming" by Thompson
04:00:12 <Continuum> yeah i think thats the prescribed text for my uni course
04:00:40 <shapr> it's the best book I've found yet for learning Haskell.
04:00:49 <shapr> the Hudak book is pretty spiffy
04:01:02 <shapr> but not as good for learning in my experience
04:01:07 <Continuum> so you know a bit about it then :)
04:01:13 <shapr> yah, some.
04:01:30 <shapr> I'm still a beginner really, but I've spent some time learning and written some code.
04:01:42 <Continuum> :) ok well if i have a couple of small questions, can u answer them 4 me ?
04:01:49 <shapr> as much as I can, I will
04:01:52 <Continuum> :)
04:02:28 <Continuum> well u see i've done heaps of procedural programming but this is all kinda a mess to me....
04:02:57 <shapr> yah, functional programming is really different
04:02:58 <Continuum> i think i need to learn how to think haskell before i can program in ti
04:03:03 <Continuum> it
04:03:17 <shapr> I had to try to program in it before I could learn to think in it 
04:03:35 <ChoJin> :)
04:03:51 <Continuum> whats the general way to do if statements? or do things not work like that in haskell
04:04:02 <ChoJin> sometime it takes 6h to write 8lines  at the beginning :)
04:04:18 <shapr> yah, my first ten lines of Haskell took me several days
04:04:23 <Continuum> ie. if x > y do blah else do blah
04:04:25 <ChoJin> 'if' is not used a lot in haskell
04:04:26 <shapr> but after that it got easier fast
04:04:43 <Continuum> well i wrote a permutations code in like 3 min
04:04:48 <ChoJin> I prefer to use '|' when I can
04:04:49 <Continuum> but that was easy
04:04:56 <Continuum> hows that work ??
04:05:02 <Continuum> i'm kinda confused
04:05:10 <ChoJin> max a b | a >= b = a
04:05:14 <ChoJin> for instance :)
04:05:22 <ChoJin> read | as 'such as'
04:05:23 <Continuum> ah ok i can do it now :)
04:05:28 <ChoJin> like in math
04:05:28 <ChoJin> :)
04:05:33 <Continuum> lol
04:05:33 <shapr> Continuum: http://kungens.kemi.fi/~shae/Mandelbrot-0.2.hs
04:05:58 <shapr> I'd suggest reading the tutorials you can find online if you don't have the Thompson book yet
04:06:09 <shapr> if you already have the book, it's by far the best place to start.
04:06:22 <Continuum> ok
04:06:23 <Continuum> :)
04:06:31 <Continuum> i'll buy it tomorrow :)
04:07:35 <Continuum> well i tried to follow the online intro to haskell at www.haskell.org
04:07:35 <ChoJin> we bought this book for our library "Algorithms: A functional programming approach", dunno yet if it is good :)
04:07:49 <ChoJin> read the gentle introduction to haskell :)
04:07:51 <Continuum> but i got confused
04:07:55 <shapr> ChoJin: I've heard it's good, but I've not seen it myself
04:07:56 <Continuum> i did
04:08:13 <ChoJin> I read another paper about monad which was good
04:08:21 <ChoJin> let me look if I can find it
04:08:41 <Continuum> ok well the gentle intro is at the haskell home site
04:08:53 <shapr> I think I understand monads, but I really don't know how to creatively use them.
04:08:55 <Continuum> but i think it's a little to gentle
04:09:03 <shapr> I thought it was too hard :)
04:09:08 <Continuum> or not gentle enough
04:09:16 <Continuum> was being sarcastic
04:09:18 <Continuum> :)
04:09:27 <shapr> oh ok :)
04:09:28 <shapr> whew
04:09:30 <Continuum> so did i shapr
04:09:45 <Continuum> thats why i'm here now
04:09:54 <shapr> there is a new tutorial in the works
04:10:15 <shapr> but so far, the thompson book is still the best intro
04:11:01 <ChoJin> btw I read this "* Structuring Depth First Search Algorithms in Haskell"
04:11:06 <ChoJin> it was interesting
04:11:11 <shapr> you have an url?
04:12:07 <Heffalump> that's not exactly a tutorial paper
04:12:12 <Continuum> ChoJin - Could write it in C or ASM but no way in haskell!!!!!!!!!!!!!1
04:12:22 <shapr> hi Heffalump!
04:12:24 <ChoJin> ftp://ftp.dcs.glasgow.ac.uk/pub/glasgow-fp/papers/essence-of-fp.ps.Z
04:12:28 <shapr> ltns!
04:12:29 <Heffalump> http://www.dcs.gla.ac.uk/fp/authors/David_King/structuring-dfs.ps.gz
04:12:35 <Heffalump> oops, too slow :-)
04:12:41 <ChoJin> read this, its about monad
04:12:44 * shapr is spending too much time doing work that pays
04:12:50 <Heffalump> hi Heffalump
04:12:51 * Heffalump too
04:12:55 <Heffalump> oops.
04:13:00 <Heffalump> s/Heffalump/shapr/
04:13:05 <Igloo> lol
04:13:05 * Heffalump unconfuses himself
04:13:07 <shapr> heh :)
04:13:09 <shapr> hi Igloo!
04:13:09 <Continuum> shapr.... thanks for the help :) ( max a b | a >= b = a ) got my code to work now
04:13:11 <shapr> ltns too!
04:13:12 <ChoJin> and for graph: http://www.cse.ogi.edu/~jl/biblio-functional.html
04:13:24 <Heffalump> no, I've definitely seen myself recently
04:13:32 <Igloo> Hi   :-)
04:13:36 <Continuum> hi
04:13:37 <Continuum> :)
04:13:42 <Logan> You want to see something really sad?  This is how my university attempts to teach functional programming:
04:13:43 <Logan> http://courses.cs.vt.edu/~cs5314/Spring02/programs/prisoner-2P.scm
04:13:50 <shapr> hi Logan!
04:13:54 <shapr> wow, this is great, lots of activity :)
04:14:16 <Logan> Just looking at "Part I" is enough to make you shake your head in disbelief.
04:14:38 <Logan> I'm not sure if the professor wrote it or his TA.
04:14:42 <Continuum> back in a sec
04:17:41 <Continuum> hey again
04:17:52 <shapr> y0
04:19:03 <Logan> I'm seriously considering submitting a strong critique of the choice of scheme as representative of functional programming.
04:19:40 <shapr> before I knew haskell, I thought scheme was all about FP
04:23:36 <Logan> Scheme seems to really hinder FP.
04:23:43 <Continuum> lol
04:23:57 <Logan> It's like using Fortran to teach people imperative programming.
04:24:02 <Logan> Sure, you can do it, but why?
04:29:24 <ChoJin> lol
04:30:27 <Logan> It's like teaching OOP with javascript.
04:30:32 <Logan> Oh well, good night.
04:31:32 <shapr> g'night Logan!
04:31:40 * shapr wanders off to do Zope stuff to get more money
04:45:59 <shapr> wow, lotsa people around
04:46:12 <nodie> hi shapr
04:47:01 <shapr> hi nodie, what's up?
04:47:33 <nodie> :)
04:47:46 <nodie> implementing things with haskell
04:48:15 <nodie> my friends call me fool because i'm implementing CGI with haskell 
04:48:41 <nodie> i saw that libraries are badly documented :-(
04:49:56 <nodie> it's hard to implement interesting things
04:50:20 <shapr> I don't think it's foolish to implement anything.
04:51:00 <shapr> if it improves your personal learning, or it serves a useful purpose, then I think it's worthwhile.
04:52:36 <nodie> i see that people implements programs and does'nt look a good design for futures updates or revisions
04:52:44 <Heffalump> though others have already implemented CGI with Haskell
05:06:58 * shapr sighs
05:07:10 <shapr> sometimes I wish I could use Haskell from inside Python/Zope
05:27:13 <nodie> bye
11:40:00 <arete> hello, I'm having some trouble with hugs crashing when I try to run some code from the hudak book... specifically translating coordinates
11:40:18 <arete> anyone had similar probs?
12:02:19 <dennisb> no, hugs is usually stable
12:03:22 <dennisb> arete: i have not read that book, what kind of examples? window programs where you draw things in windows?
12:03:36 <arete> yeah
12:03:53 <arete> but I suspect my problem is some type issue
12:04:01 <arete> because the problem code is just some simple conversion routines
12:04:25 <dennisb> well, if hugs crashes because of some type problems it is a bug in hugs
12:04:56 <arete> all I get is "Illegal instruction", then the process dies
12:04:58 <dennisb> are the functions small?
12:05:17 <arete> however nhc98 gives me a different error and the compiled app dies
12:05:20 <arete> yeah very simple
12:05:42 <dennisb> then show it!
12:05:53 <arete> ok
12:05:55 <arete> inchToPixel :: Float -> Int
12:05:56 <arete> inchToPixel x = round (100 * x)
12:06:16 <arete> trans :: Vertex -> Point
12:06:16 <arete> trans (x, y) = (xWin2 + inchToPixel x, yWin2 - inchToPixel y)
12:06:27 <dennisb> is that crashing??
12:06:32 <arete> yeah
12:07:02 <arete> xWin2 and yWin2 are Ints derived from other Ints 1div1 2
12:07:06 <arete> er `div`
12:07:20 <dennisb> very, very strange
12:07:52 <arete> yeah =/ 
12:10:35 <arete> guess I should see if it runs on win32... this is macos X
12:10:41 <dennisb> sounds like you have a broken installation..
12:11:24 <arete> it has worked fine so far though
12:11:47 <dennisb> there is nothing here that can fail, I pasted it in hugs that I have (linux) and it seems to work fine
12:11:54 <arete> ahh hmm
12:12:25 <dennisb> (I had to add some lines for Point and so on)
12:12:32 <arete> *nod*
12:13:16 <dennisb> but on the other hand, i've seen hundreds of programs like this and never seen it fail. I think there is some other problem that you have
12:14:19 <dennisb> if it uses macos X to open windows and doing graphical stuff, then maybe there is some bug there that corrupts the memory and causes it to crash later, or something
12:14:42 <arete> yeah but I've isolated this code in its own module and it still crashes
12:14:52 <arete> no graphics stuff at all, and no imports
12:15:02 <dennisb> fun
12:15:12 <dennisb> I could try it if you want
12:15:24 <dennisb> but i'm sure it will work here :-)
12:15:27 <arete> hehe
12:15:32 <arete> probably, think there is a law about that
12:16:38 <arete> can I dcc it to you?
12:16:44 <dennisb> sure
12:18:35 <arete> it crashes winhugs too
12:18:42 <dennisb> I see the bug
12:19:00 <dennisb> xWin2       = xWin2 `div` 2
12:19:13 <arete> ack
12:19:26 <dennisb> this is a recursive definition, to calculate xWin2 you need the value of xWin2, and so on
12:19:43 <arete> ugh, right you are
12:19:52 <arete> now that is a dumb error
12:20:06 * arete raps his knuckles
12:20:21 <arete> well thanks!
12:20:23 <arete> it runs fine now
12:20:41 <dennisb> to much imperative programming
12:21:06 <arete> yeah, this is my first foray into fp
12:24:01 <dennisb> arete: well, it
12:24:47 <dennisb> it works now at least!
12:24:54 <arete> yeah I'mm happy =)
12:24:57 <arete> can continue
12:25:12 <arete> I spent several days trying to figure out why it wouldn't work
12:25:23 <arete> now I have lots of pretty shapes being drawn on the screen
12:25:39 <dennisb> yes, it takes time to debug when you work with a language you don't know that much
12:26:12 <dennisb> control stack overflow is usually caused by some recursive definition
12:26:38 <dennisb> badly defined recursive definition I should say
12:26:49 <arete> yeah, I might have been able to figure out the problem if I knew it was a stack overflow
12:27:02 <dennisb> Didn't hugs say so?
12:27:11 <arete> nope, just crashed with "Illegal instruction"
12:27:17 <arete> what does yours say?
12:27:30 <dennisb> Main> main
12:27:30 <dennisb> (
12:27:30 <dennisb> ERROR - Control stack overflow
12:28:14 <dennisb> it printed the ( and then when it was going to calculate the number it overflowed the control stack
12:28:21 <arete> hmm yeah
12:28:28 <dennisb> it's lazy so it printed the ( first
12:28:28 <arete> I get the ( too, shoulda been a clue
12:29:06 <dennisb> if I compile it I get:
12:29:10 <dennisb> $ ./a.out 
12:29:10 <dennisb> Fail: <<loop>>
12:29:39 <dennisb> No ( this time, I guess the compiler optimized it in some way
12:30:09 <dennisb> Illegal instruction sounds bad
12:30:22 <arete> i get Black hole detected in eval ZAP!
12:30:30 <arete> from nhc, ghc doesnt' compile on os x
12:30:54 <dennisb> yes, black hole is the same thing
12:31:12 <arete> means infinite loop?
12:31:20 <dennisb> I don't know where that comes from, but it's a usual name for it
12:31:24 <dennisb> yes
12:31:28 <arete> ahh, thats good to know
12:31:35 <arete> its a nice error message, but didn't tell me much =)
12:32:26 <dennisb> it's not exactly like infinite loop, but some cases it can detect and print an error message for
12:32:48 <arete> *nod*
12:33:05 <dennisb> you can also write functions that are looping for ever and not get a black hole error
12:33:10 <dennisb> (of course)
12:34:01 <dennisb> well, got to go. you are on your own again, bye
12:34:01 <arete> does it not overflow the stack in that case?
12:34:06 <dennisb> no
12:34:09 <arete> ahh ok, well thanks for the help!
12:34:15 <dennisb> it is detected before
12:34:32 <arete> ahh I see
12:35:54 <dennisb> or do you mean if you write a function that are looping?
12:36:08 <dennisb> you can write tail recursive functions that does not use any stack
12:36:25 <dennisb> well, now I really have to go :-)
12:36:31 <arete> hehe bye, thanks for the save
15:34:48 <pesco> I'm trying to implement a CRC in Haskell. Char has 16 bits. readFile returns a List of Chars. Do those include two bytes of the File at a time?
15:35:19 <Heffalump> no
15:35:29 <pesco> Good, thought so, just to make sure.
15:35:53 <pesco> Now all I need is an XOR function. There is none in the Prelude?
15:35:58 <Logan> If you're really paranoid about it, you could maybe use IOExts, but at least on my computer with ghc, IO has been observed to be a byte at a time, I think.
15:36:30 <pesco> Anything else wouldn't make sense, because the file might well be of odd length.
15:37:10 <Logan> Odd length of what?
15:37:16 <Heffalump> bytes
15:37:18 <Logan> That presupposes bytes as a unit. :P
15:37:30 <pesco> Yes. It does.
15:37:45 <Logan> An odd-length of 16-bit characters would pose no problem for wide character input.
15:38:23 <pesco> But you do agree that binary data does not usually adhere to such alignments?
15:38:37 <Logan> Yes.
15:38:53 <pesco> Now, what about that XOR?
15:39:15 <pesco> Or am I supposed to convert the bytes to [Bool]? ;^)
15:40:13 <Logan> http://google.com/search?hl=en&q=haskell+xor
15:40:28 <pesco> :) Thanks.
18:47:59 <malc> anyone alive?
18:58:10 <juhp> see http://www.iaa.wide.ad.jp/
18:58:14 <juhp> ;)
18:59:36 <malc> heh
19:00:51 <malc> anyhow i just wanted to ask how would flipsum be implemented in haskell (i.e. \sum_{i=0}^n(-1)^{i}...)
19:03:38 <juhp> i guess you can first set up an infinite alternating list
19:03:57 <juhp> then you can just "take" the required number
19:04:05 <malc> my first version was
19:04:09 <juhp> and "sum" that
19:04:18 <malc> a = 1:(-1):a
19:04:30 <malc> sum (zipWith (*) list a)
19:04:47 <malc> but somehow that restricts type of list to natural numbers and i dont like it
19:05:12 <juhp> does it give the right answer?
19:05:18 <malc> sure it does
19:05:29 <malc> but it wont work on say Church numerals
19:05:35 <juhp> do you really need "(*)"?
19:05:49 <juhp> s/need/mean/
19:06:05 <malc> yes i really mean (*)
19:06:47 <juhp> wait a minute
19:06:50 <malc> Prelude> let sinf = 1:(-1):sinf
19:06:50 <malc> Prelude> sum (zipWith (*) [1,2,3] sinf)
19:06:50 <malc> 2
19:08:07 <juhp> hmmm, guess i am not sure what you mean by flipsum :)
19:08:33 <juhp> what's "..."?
19:08:49 <malc> a-b+c-d+e...
19:09:04 <malc> ... in the context means addend
19:09:15 <juhp> ah, gotcha
19:10:24 <juhp> have you given a type signature for your function?
19:11:37 <malc> Num a=>[a]->a
19:12:22 <juhp> but that implies they have the same type
19:12:47 <juhp> no
19:13:30 <malc> Prelude> :t sum
19:13:31 <malc> forall a. (Num a) => [a] -> a
19:13:44 <malc> flipsum is the same in this respect
19:17:19 <juhp> Prelude> :type flipsum 
19:17:21 <juhp> [Integer] -> Integer
19:17:35 <juhp> in ghci
19:18:16 <juhp> let flipsum as = sum $ zipWith (*) alt as where alt = 1: -1: alt
19:19:52 <malc> Prelude> let flipsum as = sum $ zipWith (*) alt as where alt = 1: -1: alt
19:19:52 <malc> Prelude> :t flipsum
19:19:52 <malc> forall a. (Num a) => [a] -> a
19:20:03 <malc> ghci
19:20:44 <malc> but this is irrelevant, as i said this version works(and it was the first out of 3 i have implemented), but i dont like it
19:21:12 <juhp> what's wrong with it?
19:21:55 <malc> it needs negative numbers
19:22:37 <juhp> ?
19:23:28 <malc> suppose i have instance of Num for natural numbers. flipsum wont work here. (because of -1)
19:26:31 <juhp> but that doesn't seem possible since you can't define (-) on Nat
19:26:41 <malc> why is that??
19:27:12 <juhp> so what is 1-2 then? :)
19:27:27 <malc> that doesnt mean that 2-1 doesnt exist, now doesnt it? ;)
19:28:07 <juhp> well, you can give a complete instance for (-) in this case, can you?
19:28:19 <malc> correct
19:28:49 <malc> but Float doesnt have complete instance of sqrt, this doesnt seem to stop anyone
19:29:22 <juhp> mmmh, you have a point
19:31:14 <malc> thats why (as a newbie in Haskell) i want to know what would be a haskellish way to define flipsum under this constraint
19:31:32 <juhp> well can't you define somwthing like
19:32:21 <juhp> fromNat :: Num a => Nat -> a
19:32:52 <malc> say i cant
19:33:08 <juhp> but then that breaks polymorphism, right
19:33:50 <malc> im sorry?
19:34:34 <juhp> i just mean dropping something like fromNat in your function, would break polymorphism
19:34:56 <juhp> ie restrict flipsum :: [Nat] -> Nat
19:35:02 <juhp> if it were defined
19:35:34 <malc> right. thats what i actually want
19:36:18 <juhp> but (*) -1 is not well-defined on Nat either!
19:36:50 <malc> ofcourse
19:37:29 <juhp> there needs to be some severe restricts on the list of numbers for the problem to be meaningful i would say
19:39:21 <malc> this will get us nowhere, apparently you just hiding the true haskellish way from me. oh well
19:44:59 <juhp> probably ;)
19:45:49 <juhp> but i'm just trying to say that flipsum is not well-defined for most Nat lists
19:49:23 <juhp> of course if you want [Nat] -> Integer thne that's a different story
19:49:32 <juhp> s/thne/then/
