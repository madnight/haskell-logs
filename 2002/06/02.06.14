00:17:06 * shapr appears
00:17:18 <shapr> enter from stage left
00:17:52 <shapr> phoenix`: hey, have you installed a haskell interpreter or compiler? have you come up with questions?
00:18:18 <phoenix`> i just dl it now
00:18:24 <shapr> cool
00:18:26 <phoenix`> gonna install it
00:18:30 <shapr> excellent
01:07:36 * shreya wonders how phoenix is doing
01:13:53 <shapr> shreya: do you have any questions?
01:16:25 <shreya> yeah i do have one question. when i make an executable, how do i make the main function display output on the screen? I just made my first proper program but i have no idea what to do now
01:16:36 <shreya> i have main :: String
01:18:05 <shreya> then main = "hello world!"
01:19:50 <Heffalump> try main :: IO ()
01:19:57 <Heffalump> main = putStr "hello world!"
01:20:16 <Heffalump> (without the "try " bit :-)
01:21:45 <shreya> IO? is that a type?
01:21:52 <shreya> what's the ()'s for?
01:21:54 <shapr> yah it is
01:22:03 <shapr> it's an empty thing
01:22:29 <shapr> I was reading about that in this book last week.
01:22:30 * shapr looks
01:22:36 <shreya> ok so is putStr :: String :: IO ()
01:22:41 <shreya> oops
01:22:42 <shreya> i mean
01:22:47 <shreya> :: String -> IO ()
01:22:53 <shapr> you got it
01:23:19 <shapr> ah here it is:
01:23:19 <shreya> ok
01:23:36 <shapr> "Haskell contains the type () which contains one element only."
01:23:38 <Heffalump> IO () is an IO action which results in an empty type
01:23:59 <Heffalump> don't worry about it too much for now, just make sure your main function always has that type
01:24:10 <shapr> "this element is also written (). A value of this type can convey no useful information and so the type is not often used"
01:24:26 <Heffalump> except once in every program... :-)
01:24:35 <shapr> hah
01:24:44 <shreya> ok i am going to try compile a program
01:24:45 <shreya> lol
01:25:26 <shapr> here's the simplest program I know of:
01:25:30 <shapr> module Main where
01:25:33 <shapr> main = putStr "Hello"
01:26:26 <shreya> don't i need a type decleration?
01:26:30 <shreya> declaration even
01:26:46 <Heffalump> no, you don't need them usually
01:26:47 <shreya> or is the standard main just IO ()
01:26:48 <shapr> not always
01:27:02 <Heffalump> they sometimes help, but in most cases Haskell can infer the type from the code you write
01:27:09 <shapr> the haskell compiler is smart enough to guess the types most of the time.
01:27:14 <shapr> yah, what he said :-)
01:27:19 <shreya> oh lol
01:27:35 <shapr> shreya: are you using hugs or ghc?
01:27:44 <dennisb> if you are in an interpreter (hugs or ghci) you can ask it what type somethinh has.  In this case you write :t main
01:27:58 * shapr tries that
01:27:59 <shreya> i use hugs
01:28:10 <shapr> hm
01:28:14 <shapr> Main> :t main
01:28:15 <shapr> PrelIOBase.IO ()
01:28:15 <shapr> cool
01:28:57 <shreya> ok this is my first program
01:29:06 <shreya> module Main
01:29:06 <shreya> where
01:29:06 <shreya> main :: IO ()
01:29:06 <shreya> main = putStr "Hello world! :)"
01:29:07 <shapr> w00
01:29:18 <shapr> does it work?
01:29:20 <dennisb> shapr: I use that all the time, :t putStr
01:29:25 <shreya> i don't know yet
01:29:27 <shreya> how do i compile it
01:29:30 <shreya> :(
01:29:45 <shreya> so i don't have to run it through hugs
01:29:46 <dennisb> in hugs just load the file and run it by writing > main
01:29:56 <Heffalump> or use "runhugs filename" from a shell
01:29:57 <dennisb> shreya: get a compiler, like ghc
01:30:10 <shapr> shreya: you can use ghc to compile programs to executables
01:30:12 <shreya> oh ok, so hugs doesn't do compilation?
01:30:15 <Heffalump> nope
01:30:18 <Heffalump> it's just an interpreter
01:30:21 <shreya> i see
01:30:22 <shapr> shreya: but ghc is much less informative about errors
01:30:30 <shreya> yeah i know
01:30:31 <dennisb> If you are in a unix system you can use the #!/usr/bin/runhugs trick
01:30:36 <shreya> i use hugs to test stuff
01:30:46 <shapr> so I'd suggest you use hugs for most of your development, and ghc to make real binaries.
01:31:10 <shreya> yeah shapr i use hugs to test my programs as i go along
01:31:12 <dennisb> ghci is also nice, if you have a lot of memory in your machine
01:31:51 <shapr> happily, I do.
01:32:23 <shapr> I even have two CPUs in this machine =)
01:32:31 <shapr> I want to figure out how to get Haskell to use both of them...
01:32:55 <shreya> dennisb; what's that #!/usr/bin/runhugs trick?
01:32:58 <shapr> I've read about the Concurrent stuff, but I guess I should learn to do basic stuff like IO first.
01:33:17 <dennisb> shreya: put it as the first line and you can run the file
01:33:34 <dennisb> (after doing chmod +x foo.hs)
01:33:53 <shreya> ah yeah like perl programs
01:33:54 <dennisb> Just like shellscripts or perl-programs
01:37:05 <shreya> hehe dennis, that runhugs method is pretty slow
01:37:12 <shreya> i think i'll get the ghc thingo
01:38:38 <dennisb> shreya: is it that slow? I use it every once in a while and have no complains really
01:38:51 <shapr> shreya: how fast is your machine?
01:39:14 <dennisb> There is some startuptime, but after that it shouldn't be that bad. But for a one liner the startuptime dominates
01:39:42 <shreya> p120, 80 mb ram
01:39:58 <shreya> yeah, the startup time is what took long
01:40:43 <shapr> shreya: if you don't mind me asking, how old are you?
01:40:45 <dennisb> I think you will find the compiler quite slow as well, the compiled program should be ok
01:41:19 <shapr> yah, ghc can take a long time.
01:41:47 * shreya is 17
01:42:01 <shapr> ah cool, you're getting into programming early :-)
01:42:26 <Heffalump> s/programming/programming properly/ :-)
01:42:32 <shreya> lol, it feels like it's late for me
01:42:36 <shapr> yes, of course
01:42:42 <shapr> I waited till I was much older.
01:43:03 <shreya> i reckon if i started learning haskell earlier it'd be so much easier, after haskell i started understanding more :(
01:43:17 <shapr> aha, I've discovered that the guy who wrote Hsh.hs is now working at transmeta
01:43:22 <shapr> now I need to find his email address.
01:43:34 <shapr> shreya: well, you can't change the past, but you can affect the future.
01:43:59 <shreya> yep
01:44:24 <shreya> ooh i can just apt-get ghc5
01:44:32 <shreya> no need to scurrow through websites :/
01:44:32 <shapr> oh, you use debian?
01:44:43 <shapr> I'm using debian/sid
01:44:45 <shreya> yeah
01:45:10 <shreya> i only moved to linux at the start of this year from my uni pc
01:45:16 <Heffalump> what uni do you go to?
01:45:24 <shreya> i had redhat but they kept giving me crap for not being suscribed to RHN
01:45:25 <shreya> uwa
01:45:30 <dennisb> the more languages you know the easier it gets, no matter how high level stuff you program you still have to understand the hardware and knowing som C or similar (assembler) is always a good idea
01:45:37 <Heffalump> you're learning Haskell in your course?
01:45:44 <shreya> yeah
01:45:50 <Heffalump> do you know a guy called Adrian Chadd?
01:45:51 <shreya> well, only for one unit, then we stop :(
01:45:58 <shreya> nah, Dr while
01:46:05 <shreya> i am going to learn more by my self on the holidays though
01:46:11 <shreya> i don't want to stop learning haskell :(
01:46:13 <shapr> good idea!
01:46:18 <dennisb> I guess he is called Do While
01:46:23 <shapr> haskell is an elegant language.
01:46:29 * shapr laughs
01:46:33 <shapr> dennisb: that's what I'd call him!
01:46:47 * shapr laughs more
01:46:57 <shreya> heh
01:46:59 * dennisb has a bad sence of humor
01:47:09 <shapr> I think it's great :-)
01:47:10 <dennisb> (and can't spell)
01:47:32 <shapr> dennisb: hey, you're in Gotheburg, right?
01:47:45 <shapr> I'm moving to Boden
01:47:46 <shreya> aww i have an exam tomorrow :(
01:47:51 <shreya> i better do some practice exams
01:48:06 <dennisb> shapr: yes, gbg
01:48:18 <dennisb> Boden is quite near where you are now I guess
01:48:39 <shapr> 2.5 hours busride
01:48:51 <shapr> still much much closer than helsinki or stockholm though
01:48:59 <shreya> be back probably tomorrow sometime
01:49:00 <dennisb> shreya: welcome back!
01:49:12 <shapr> seeya tomorrow shreya!
01:49:39 <shapr> now that I understand the IO stuff better, Hsh.hs makes much more sense.
01:51:13 <dennisb> IO is not that hard, for me it was one of these aha-experiences and after that it all made sense
01:51:29 <shapr> yah, same here
01:51:36 <shapr> I had that aha experience on the bus last weekend.
01:51:59 <shapr> so I'm still applying it to code I didn't understand last time I read it
01:52:00 <dennisb> I think the types are most important, once you understand what types things have in haskell it's easy
01:52:32 <shapr> for me the big jump was seeing how referential transparency still works across do statements
01:52:39 <dennisb> yes
01:52:45 <shapr> actually, I think they're do expressions..
01:53:15 <dennisb> yes, expressions. do is just short syntax for using >>=
01:55:30 <dennisb> there is even a backwards version =<< in the prelude
01:56:12 <dennisb> you do know the :t function in hugs works on these to (of course)
01:56:16 <dennisb> Prelude> :t (>>=)
01:56:17 <dennisb> (>>=) :: Monad a => a b -> (b -> a c) -> a c
01:58:11 * dennisb goes back to work
01:59:57 <shapr> dennisb: what are you working on?
02:00:17 <dennisb> I've been teaching some haskell and have the grading left to do
02:00:21 <shapr> hi pho
02:00:26 <shapr> oh, cool!
02:00:40 <shapr> you get paid to teach haskell?
02:00:42 <pho> hi
02:00:49 <shapr> pho /w phoenix`
02:00:52 <shapr> oops
02:00:58 <shapr> hm
02:01:07 <pho> hmm
02:01:08 <dennisb> shapr: i'm a phd-student. It's part om my dutie to teach
02:01:10 <pho> how do i kill
02:01:11 <pho> nicks
02:01:15 <pho> on this server
02:01:20 <pho> -NickServ- Unknown command [kill]
02:01:20 <pho> :(
02:01:29 <dennisb> I just got lucky to teach haskell (i've been on many other courses)
02:01:33 <shapr> pho: if you've registered the nick phoenix` you can use /msg nickserv ghost
02:04:11 <shapr> dennisb: are you nearly finished with your phd?
02:04:16 <shapr> what's your phd thesis about?
02:06:32 <dennisb> shapr: i spend to much time on irc :-)
02:08:09 <dennisb> I still have some time left but i'm behind schedule
02:08:24 <Heffalump> the bits I can make out from your web page suggest that you're doing stuff with John Hughes' type specialisation ideas
02:08:40 <dennisb> yes
02:08:55 <dennisb> I should update the webpage I guess, it's been like that for years
02:09:06 <dennisb> but yes, I work with type spec
02:09:15 <Heffalump> how are you getting on with it?
02:09:32 <dennisb> the phd, or type spec as a subj.
02:09:37 <Heffalump> type spec
02:10:07 <dennisb> I think type spec is great
02:10:28 <Heffalump> yeah, it does seem pretty cool
02:10:37 <dennisb> When I first saw templates in C++ I thought they where the right thing to do. Type spec is so much more and better
02:10:38 <Heffalump> is John your supervisor?
02:10:41 <dennisb> yes
02:10:46 <shapr> wow, cool
02:12:06 * shapr finds the homepage of dennisb
02:12:53 <dennisb> John is a great person to talk to, especially about haskell and FP of course but he knows a lot about lots of things
02:13:59 <shapr> generalising monads to arrows impresses me.
02:16:07 <dennisb> me to
02:16:53 <dennisb> category theory is not new, but it is difficult (for me at least)
02:17:17 <shapr> me too
02:17:51 <shapr> hm, interesting: http://ist.unibw-muenchen.de/relmics/tools/RATH/
02:18:04 <shapr> RATH is a collection of Haskell modules that allow exploration of (finite) relation algebras and several weaker structures such as categories, allegories, and Dedekind categories
02:18:58 <dennisb> I should maybe give it another try (category theory), every time I read about it I get further but I never feel I get to the bottom of it
02:19:29 <dennisb> ..... must ...... work ...... :-)
02:19:51 <shapr> heh :-)
02:20:12 * shapr goes off to do paying work.
02:45:39 <shreya> eek
02:45:49 <shreya> i tried something like
02:45:58 <shreya> main :: String -> IO ()
02:46:06 <shreya> main xs = putStr xs
02:46:10 <shreya> got strange errors
02:47:26 <Igloo> Main.main has to be of type IO a
02:49:36 <Heffalump> if you want command line arguments. use System.args (IIRC)
02:50:09 <Heffalump> System.getArgs, sorry
02:50:47 <shreya> i see..
02:50:47 <shreya> whoah
02:50:53 <shreya> going from an interpreter
02:50:56 <shreya> to an actual program
02:51:02 <shreya> is completely different experience :)
02:53:50 <shapr> yah it is :-)
02:53:57 * shapr enjoys Haskell
02:54:32 * shapr reads comp.lang.functional
02:57:29 * shapr decides to download a released ghc and try to build that rather than the CVS ghc
03:31:37 <shreya> wb
03:32:03 * shapr bounces
03:32:04 <shapr> hi hi hi!
03:32:10 <shapr> ono, I'm out of coffe
03:32:12 <shapr> must make more
04:25:57 <hornby> Anyone know an easy way of installing the graphics library on a debian machine?
04:26:47 <shapr> which graphics library?
04:26:50 <shapr> SOE?
04:27:05 <hornby> Er, the HGL?
04:27:21 <hornby> http://haskell.cs.yale.edu/graphics/ << that one
04:27:45 <hornby> i wanna play Haskell In Space
04:28:12 <shapr> did you try the installation instructions?
04:28:42 <shapr> I mostly use ghc, so I don't know if there's a simpler way
04:28:52 <shapr> have you checked to see if it's already included?
04:28:56 <hornby> yeah, but .... yeah I did
04:29:05 <hornby> it won't compile. 
04:29:15 <shapr> what's the error?
04:29:20 <hornby> cbits/HsXlib.h:11: X11/X.h: No such file or directory
04:29:22 <hornby> stuff like that. 
04:29:28 <shapr> I'm running debian/sid what are you running?
04:29:38 <hornby> same
04:29:39 <shapr> sounds like you need the dev part of X
04:29:46 <hornby> or unstable
04:29:55 <hornby> prolly. 
04:30:09 <hornby> I'll try xlibs-dev
04:30:31 <hornby> Oh, and it needs ghc : )
04:31:14 <hornby> hmm I think it worked.
04:32:04 <hornby> nope. ugh, lots of work
04:35:41 <hornby> jesus its slow
04:50:24 <shapr> how fast is your machine?
04:53:15 <shapr> haskell compiled slowly but ran well on my 200MHz pII, and it was great on 800MHz athlon...
04:53:33 <shapr> this machine has dual Athlon MP 1800+ so... Haskell is GREAT.
04:53:43 <shapr> even interpreted it's very fast on this machine.
04:56:01 <hornby> PII 350
04:56:09 <hornby> compilex
04:56:11 <hornby> er compiled
04:56:16 <hornby> *shrug*
04:56:32 <shapr> hugs is an interpreter
04:56:39 <hornby> I didn't use hugs :)
04:56:49 <shapr> it gives much more informative error messages and helpful output
04:57:06 <shapr> ghc is not so helpful, but does make binaries
04:57:26 <shapr> hornby: wanna see the first (and only) haskell program I've done?
04:57:26 <hornby> I'm just looking at this quicksort
04:57:34 <hornby> shapr: Sure. What does it do? :)
04:57:49 <shapr> http://kungens.kemi.fi/~shae/Mandelbrot-0.2.hs
04:58:05 <shapr> I'd like to memo-ize it
04:58:29 <hornby> Why? :)
04:58:51 <shapr> it's really rough
04:58:53 <shapr> it could be much faster
04:59:17 <hornby> Thats really cool
05:00:02 <shapr> yah, it's cute :-)
05:00:29 <hornby> I have no idea what the code is going, but the output is pretty :)
05:00:44 <hornby> I think I'll start small with the quicksort :)
05:01:01 <shapr> ok
05:04:22 <hornby> shapr: You IRC from emacs?
05:04:25 <shapr> yah, why?
05:04:33 <shapr> I'm using ERC 2.93 $Revision: 1.285 $ with XEmacs 21.4 (patch 8) "Honest Recruiter" XEmacs Lucid!
05:06:10 <hornby> crazy
05:06:49 <shapr> why do you think that?
05:08:13 <shapr> seems pretty normal to me.
05:09:04 <hornby> well 
05:09:23 <hornby> I don't even use emacs for text editing, so irc seems a little overboard :)
05:10:08 <shapr> you should try it sometime, it's quite powerful
05:13:29 <hornby> I have. 
05:13:45 <hornby> Its awkward
05:14:08 <shapr> I think it just has a very different way of looking at life.
05:14:23 <shapr> same thing with Functional Programming vs Procedural Programming
05:15:10 <hornby> Yeah, an awkward way of looking at life :)
05:16:07 <hornby> Emacs has some cool stuff going for it, but I don't think its worth the hassle. 
05:16:44 <shapr> I thought so too at one point.
05:16:47 <shapr> I was a vi user...
05:17:00 <Igloo> vi or vim?
05:17:03 <shapr> vim
05:17:28 <shapr> I decided to learn Emacs, that way I could either say "it sucks" or "I use it"
05:17:29 <hornby> Why'd you switch?
05:17:53 <shapr> because emacs is a lot more flexible.
05:17:58 <hornby> Emacs hurts my hands :)
05:18:00 <shapr> it does more stuff
05:18:08 <shapr> it's a real IDE rather than just an editor
05:18:24 <Igloo> Did you get to know vim's :make etc?
05:18:27 <shapr> some people want just an editor as a single component, but I like using an IDE
05:18:29 <shapr> Igloo: no, I didn't
05:18:42 <shapr> Igloo: I will go back the other way soon :-)
05:18:59 <Igloo> OK...I've never looked at it either, but I keep meaning to get around to it
05:19:13 <shapr> that is, go back to vim and see if it's better than emacs
05:19:25 <hornby> Vim is less than emacs. 
05:19:31 <hornby> Thats part of the point :)
05:19:47 <Igloo> emacs ought to be more flexible at the expense of size and ubiquitosity
05:20:10 <shapr> question is, will I like vim more, now that I have a deeper general understanding of programming and editing?
05:20:11 <Igloo> (although the latter is more WRT vi than vim)
05:20:13 <shapr> I don't know.
05:20:43 <hornby> shapr: an interesting exercise
05:20:47 <Igloo> I should look at things like folding in vim too
05:21:21 <shapr> hornby: once a year I try foods that I don't like.
05:21:34 <shapr> about five years ago I discovered that I now like eating asparagus.
05:21:53 <shapr> there was a food that I recently stopped liking, though I can't remember which one.
05:22:16 <hornby> shapr: really? 
05:22:21 <shapr> sure
05:22:42 <shapr> hornby: see, this is why the Solomon bit about "vanity of vanities, all is vanity" just doesn't cut it with me..
05:22:47 <hornby> shapr: But ... you must not like most of the foods the second time either?
05:22:49 <shapr> there's so much cool stuff to do and learn and find
05:23:00 <hornby> shapr: I agree. But ...
05:23:18 <shapr> hornby: sure, 99% of the time my interests in food,programming,editors, etc,etc stay the same
05:23:20 <shapr> but sometimes they change.
05:23:35 <hornby> shapr: But trying the same things over and over is tedious?
05:23:39 <hornby> shapr: You could be trying new things
05:23:52 <shapr> hornby: that's why I do it once a year.
05:24:21 <shapr> sometimes I find that new stuff I've found makes old things that I didn't like suddenly worthwhile
05:25:27 <shapr> I discovered that functions in Python that took a value and returned a value, and didn't affect the environment really appealed to me
05:25:47 <shapr> so I started learning functional programming when I realized it does that, but lots more of that.
05:26:09 <hornby> What was your start in programming?
05:27:03 <shapr> I bought my first computer in 1988, and I learned some asm then, but I thought debug was the only way to write new programs =)
05:27:48 <shapr> I started with Java just before the first jdk was released
05:28:00 <shapr> then I found Python :-)
05:28:22 <hornby> asm to java? 
05:28:25 <shapr> at my first pro job in 1998, I got paid to write VB
05:28:25 <hornby> crazy
05:28:40 <hornby> What do you do now?
05:28:56 <shapr> then I got a job being programming at a company, and was promoted to sysadmin when ours left.
05:29:17 <hornby> I think I'd like to try sysadmining for a time
05:29:26 <shapr> that sucked :-( I didn't know anything about unix or sysadmin'ing, so I was pretty bad at it the first two months
05:29:44 <hornby> heh :)
05:29:47 <shapr> the company was already failing, and I didn't help it stay together
05:29:58 <hornby> Why did they put you in charge? Not someone else?
05:30:02 <shapr> the boss fired me, and the company died the next month
05:30:08 <shapr> there wasn't anyone else
05:30:15 <shapr> and no money to hire a new sysadmin.
05:30:36 <shapr> that was in Seattle
05:30:51 <shapr> the VB job was in Birmingham, AL
05:31:00 <shapr> nowadays I work for widian.fi
05:31:09 <hornby> In Finland?
05:31:18 <shapr> where I write Java for desktop and mobile apps
05:31:22 <shapr> yup, in finland.
05:31:23 <hornby> Ooh, fun?
05:31:25 <shapr> it's ok
05:31:27 <hornby> Crazy, you move a lot :)
05:31:30 <shapr> yah I do.
05:31:49 <shapr> I got the company to switch several computers to debian linux
05:31:55 <hornby> nice :)
05:32:02 <hornby> What do they run, mostly?
05:32:03 <shapr> yah, they were paying out the ass for licenses
05:32:47 <hornby> How the hell did you end up in Finland? Do you speak Finiish?
05:32:50 <shapr> about five development workstations and three servers are running debian linux now, and I'm the most expert sysadmin, and one of the top programmers there.
05:32:53 <shapr> nah, my finnish sucks
05:33:07 <shapr> I can understand some of what people are saying, but speaking it is *hard*
05:33:30 <hornby> So why Finland?
05:33:33 <shapr> I was depressed after being fired, (victorian work ethics suck sometimes)
05:33:40 <shapr> and I met this cool woman on icq
05:34:09 <shapr> so she flew over to the US to spend a month with me, to see if it was as cool in person as it was across the 'net
05:34:14 <shapr> and it was better, so I asked her to marry me.
05:34:19 <hornby> Wow
05:34:26 <hornby> Thats crazy :)
05:34:43 <hornby> And she's from Finland?
05:34:49 <shapr> she has her own company here, and I was out of a job, and out of money, so we decided we'd live here for awhile.
05:35:02 <shapr> nah, she's french german dual-citizen
05:35:28 <hornby> So you're married now?
05:35:46 <shapr> no, I haven't gotten organized enough to make that happen in word, though we are in spirit
05:36:06 <hornby> Ah, engaged at least. Cool
05:36:16 <shapr> stuff like, my family wants to come to the wedding, and so does hers, so where do we have the ceremony? or do we have two?
05:36:46 <hornby> Ah ... could get expensive :)
05:36:53 <shapr> we've decided to move to sweden
05:37:00 <hornby> Why Sweden?
05:37:07 <shapr> we've got an apartment lined up, and some contracts
05:37:30 <shapr> well, this particular part of .fi has irritating properties
05:37:52 <hornby> So would you find a new job then, or commute? Or what?
05:37:53 <shapr> the good old boys network is stonewalling bea, keeping her from getting local business
05:38:09 <shapr> one of my jobs is in germany already
05:38:39 <hornby> Okay, so where in the world HAVEN'T you worked?
05:38:51 <shapr> so if widian wants me to keep working for them, it'll probably be telework
05:39:06 <shapr> I've lived in fifteen US states, and in finland...
05:39:50 <shapr> I'd like to spend time living in the center of europe at some point, and australia at some point
05:39:53 <shapr> and more in the US also
05:39:58 <hornby> Awesome
05:40:39 <shapr> oh, I have to go pick up my ritalin from the pharmacy
05:40:41 <shapr> hmm
05:40:56 <shapr> hm, that was an unintentional punchline
05:41:01 <hornby> :)
05:41:40 <hornby> Gonna run then?
05:41:55 <shapr> yah, I'll be back in less than an hour
05:41:58 <hornby> Cool
05:42:10 <shapr> if you have some haskell questions by then ;-)
05:42:11 * shapr grins
05:42:28 <hornby> Sweet :) Thanks. 
05:42:37 <hornby> ok ttys
05:50:19 <hornby> OMG haskell is funky. There are no variables, only constants? :) 
05:50:21 <hornby> Fun
06:26:25 <hornby> so I'm looking at this example of a function to determine if a sequence is a sub-sequence of another sequence ... 
06:26:42 <shapr> where is it?
06:26:44 <hornby> isSubseq ]
06:26:51 <shapr> is source online?
06:26:56 <hornby> isSubseq [] _ = True -- this I get
06:26:58 <hornby> yes
06:27:19 <hornby> http://www6.software.ibm.com/developerworks/education/l-hask/l-hask-ltr.pdf
06:27:31 * shapr wgets
06:27:38 <hornby> isSubseq _ [] = False -- this I also get
06:27:51 <hornby> This is the section "Pattern Matching"
06:28:13 <hornby> But I don't get the one after it
06:28:34 <hornby> mostly I'm confusd by "start" and "take" ... I assume || to be or
06:28:51 <shapr> bah, I have to login or something
06:29:08 <shapr> hornby: do you have hugs running?
06:29:12 <hornby> Oh yeah, it wants you to register. Yes I do
06:29:22 <shapr> ok, type in [1..7]
06:29:45 <hornby> yeah, I get that. I get heads and tails of lists. 
06:29:49 <shapr> now try "take 5 [1..7]"
06:30:05 <hornby> takes first 5?
06:30:07 <shapr> yup
06:30:18 <hornby> ah, okay, let me see if that helps my understanding :)
06:30:25 <hornby> start is defined
06:30:28 <shapr> ?
06:30:35 <hornby> isSubseq lst (x:xs) = (lst==start) || isSubseq lst xs
06:30:36 <hornby> where start = take (length lst) (x:xs)
06:30:40 <hornby> Thats what I'm looking at
06:32:02 <hornby> okay, so this makes sense
06:32:25 <hornby> it just sets the start element one deeper each time
06:32:39 <hornby> basically interates over the list
06:32:42 <shapr> yah looks like it.
06:33:25 <hornby> and the previous condition (isSubseq _ [] = False) terminates it 
06:33:26 <hornby> Cool
06:33:41 <shapr> and that's how you do things in haskell
06:33:46 <hornby> thats really neat
06:33:46 <shapr> recursive divide and conquer
06:33:50 <hornby> hard to get used to
06:34:07 <hornby> Fun to poke at though :)
06:34:22 <Igloo> Hmmm, not convinced I'd call that divide and conquer, although it might technically be
06:34:39 <shapr> Igloo: what would you call it?
06:35:36 <Igloo> Don't think I can think of a better name either  :-/
06:36:06 <shapr> ok, I'll stick with divide and conquer until you find something better :-)
06:36:28 <Igloo> :-)
06:36:44 <hornby> Oh, one thing I was wondering about. I was told that order doesn't matter in Haskell, but then, contradictorily, that when dealing with pattern matching, that "The first listed definition
06:36:48 <hornby> that succeeds in matching a given function call is the one used for that call."
06:37:15 <shapr> for pattern matching, it's top down
06:37:52 <hornby> okay, and ditto for guards
06:37:56 <shapr> right
06:38:12 <hornby> Ok, makes sense
06:38:23 <Igloo> Order matters all over the place, e.g. null xs || head xs == 0 - it sounds like you're confused with how lazy evaluation works
06:38:27 <shapr> but for most things, you should not depend on order, because the compiler might swap everything around to make stuff more eficient
06:39:11 <hornby> Right. The idea was that x = y+1, y = 5 .... just that you could do that :0
06:39:36 <hornby> "out of order" so to speak
06:39:41 <shapr> yah
06:39:54 <shapr> Igloo: can you explain about the lazy vs order thing?
06:40:48 <hornby> Mm, no don't worry about it, I understand :)
06:41:07 <shapr> hrm, where did you find the haskell part of devworks?
06:41:30 <shapr> aha
06:41:46 <hornby> I think its just one article. But its listen on the haskell.org site 
06:41:52 <Igloo> Well, the only place I can think of where textual order doesn't matter is in where or let blocks. However, someone explaining lazy evaluation might explain how pure functions can be *evaluated* in any order
06:42:16 <hornby> er listed. 
06:43:07 <hornby> shapr: http://www-105.ibm.com/developerworks/education.nsf/linux-onlinecourse-bytitle/9A31A3C4A0CE683E86256AD400822942?open&t=grl,l=805,t=haskell << that'll let you register
06:43:19 <shapr> now I'm trying to remember my login >:(
06:43:52 <hornby> it'll mail it to ya :) Or just create a new one, there is no email verification or anything
06:44:12 <shapr> aha, I think I found one
06:44:45 <shapr> yup
06:45:50 <hornby> What's sublist? And is there a good reference so I can look these things up instead of bugging you all the time? :)
06:46:38 <hornby> I think this must be a typo
06:46:43 <Igloo> Probably a list of which you have a list of (euch that's bead English)
06:47:08 <hornby> isSublist (e:es) (x:xs)
06:47:08 <hornby> | e==x && isSublist es xs = True
06:47:10 <hornby> | otherwise = sublist (e:es) xs
06:47:20 <hornby> I think "sublist" should be "isSublist"? 
06:47:43 <hornby> If so, Haskell is COOL. Otherwise, I'm very confused. 
06:47:56 <Igloo> Yup
06:48:35 <hornby> Okay, I thought it was a built-in function or something, but Hugs doesn't recognize it, so it must be a typo
06:51:25 <shapr> hornby: for reference there's haskell-doc deb
06:51:33 <shapr> and hugs-doc and ghc5-doc
06:52:19 <hornby> oh cool
06:52:32 <shapr> apt-cache search haskell has several things
06:52:56 <hornby> shapr: yeah, I got the hugs-doc and ghc5-doc , I musta missed the haskell-doc
06:53:49 <shapr> hornby: I'd suggest trying to write something that doesn't require I/O
06:54:31 <hornby> Is IO tricky? I've heard that monadic IO is very picky?
06:54:40 <shapr> I find it tricky, yes.
06:54:52 <shapr> from what I've heard, you don't have to understand it to use it,
06:55:00 <hornby> So "Hello, World" is out of the question? :)
06:55:10 <shapr> actualyl, Hello World is easy
06:55:22 <hornby> So what's the issue then?
06:55:41 <shapr> you want to see Hello World? or you want to try to write it yourself?
06:56:31 <hornby> Oh, quick question: [2, 4..100] means? 2, 4 ... then steps of 2? So [3, 4 .. 100] would be [3,4,5,6,7 .. 100]? not [4, 7, 10 .. 100]?
06:56:47 <hornby> shapr: Well I'll probably come across it in the article I'm reading
06:56:59 <shapr> hornby: type it into hugs, you'll see how it works :-)
06:57:06 <hornby> shapr: oh, good point. 
06:57:09 <hornby> duh :)
06:57:33 <hornby> oh, neat ... [2, 4 .. ] keeps going forever :)
06:57:34 <shapr> of course, I had to kill hugs once or twice when I was first trying out things
06:57:58 <shapr> yah, infinite ranges are just fine in a lazily evaluated language
06:58:01 <Igloo> What did you do that ^C wouldn't stop?
06:58:36 <hornby> I love [3, 6 .. 100], thats just cool
06:58:42 <shapr> Igloo: some kind of recursive fib where the recursion calls grew rather shrunk
06:59:01 <hornby> In fact, the mathematical conventions that Haskell uses make things really simple
06:59:05 <shapr> badly written recursive functions can take up memory and cpu *quickly*
06:59:18 <hornby> heh
06:59:22 <Igloo> I guess if you eat lots of memory you might have responsivity problems
07:01:31 <shapr> when I first think of how to write a program, the idea is like a diamond in my head, with all these sharp edges, and beautiful flat surfaces
07:01:43 <shapr> by the time I'm done writing the program, it looks more like a ball of lint.
07:02:07 <hornby> heh
07:02:17 <hornby> I know what you mean :)
07:02:26 <shapr> Haskell is one of the rare programs where I could see the beautiful sharp edges and flat surfaces soon after starting to use it.
07:02:40 <hornby> myLst = [(i,j,i*j) | i <- [2,4..100],
07:02:40 <hornby> j <- [3,6..100],
07:02:41 <hornby> 0==((i+j) `rem` 7)]
07:03:06 <shapr> that looks scary
07:03:24 <hornby> The only part about this bit I don't get is : why does it add things to the list when  0==((i+j) `rem` 7) is true, but not when its false? I don't get whats going on here
07:03:27 <shapr> hornby: you know Python got list comprehensions from Haskell?
07:03:55 <hornby> shapr: Didn't know that. :) But then again, I don't think I know Python list comprehensions :)
07:04:55 <Igloo> Because that's what predicates in the qualifications on the right of a list comprehension mean
07:05:01 <hornby> oh, wait I get it
07:05:04 <hornby> thats so simple?
07:05:14 <shapr> yah
07:05:15 <shapr> it is :-)
07:05:21 <hornby> Damn
07:05:23 <hornby> Wow
07:05:49 <shapr> it's a great way to make a list of items, yah?
07:05:52 <hornby> I thought it was some syntax trick or something... I didn't know what to think. But now that makes aboslute perfect sense
07:05:58 <hornby> That's awesome :)
07:06:23 <hornby> better than a bunch of ifs and appends
07:06:54 <shapr> yah I agree
07:08:26 <shapr> after you've read that article, you may want to read Tom Moertel's "Haskell, Perl, and XSLT" article on kuro5hin.org
07:08:56 <hornby> okay. 
07:09:30 <shapr> after you've used Haskell for a bit, imperative stuff feels restrictive...
07:09:41 <hornby> mmm :) 
07:09:48 <shapr> but then you realize you *can* do all the same stuff in imperative languages, with just one more notch of paradigm shift
07:10:07 <shapr> and then your coworkers look at your code and say "wtf is that sposed to do??"
07:10:28 <hornby> :)
07:10:35 <hornby> Isn't that a bad thing? :)
07:10:41 <shapr> I'm not sure...
07:10:58 <shapr> I know I can often write six lines of code that does the same thing as the next guy's fifty lines of code.
07:11:05 <shapr> and it's clear to me, but not to them.
07:11:59 <hornby> hmm
07:12:41 <shapr> If I can explain the conceptual structure of what I wrote, they usually start writing the same thing themselves
07:12:51 <shapr> sometimes I can't explain it without resorting to the lanugage it came from though.
07:12:51 <hornby> heh, well thats good :)
07:13:23 <shapr> trying to explain FP to a Java programmer who hasn't done anything else is often futile :-/
07:13:24 <hornby> So ideally, you're making everyone better programmer's by providing an example 
07:13:42 <hornby> I can imagine :)
07:14:08 <shapr> Python to FP is a smaller step, it has first class functions, map, reduce, and filter
07:14:12 <shapr> and lambda
07:14:18 <shapr> Java doesn't have those.
07:14:25 <hornby> But does functional programming really improve how people program in Java?
07:14:30 <shapr> sure
07:14:38 <hornby> How well do the concepts transfer? Must be hard without the same tools?
07:14:43 <shapr> it can be
07:15:05 <hornby> I mean in some cases it must be easier to just do it imperatively
07:15:31 <shapr> I often see one-off errors in loops
07:15:42 <shapr> python has "for x in sequence: print x"
07:16:06 <hornby> I love for x in s: print x
07:16:12 <shapr> in Python, that's equivalent to map(printFunc,sequence)
07:17:02 <shapr> so adding forEach stuff to Java saves you the effort of writing another explicit loop, and the possibility of one-off errors
07:17:38 <hornby> Yeah, I know I'm always having to think twice about loops 
07:17:46 <hornby> Just to make sure I'm not off
07:17:57 <shapr> function objects in Java let you do one thing to an entire group of objects
07:18:02 <hornby> I thought that was just my brain being funky though
07:18:18 <shapr> I've been doing explicit loops for years, and I still hate it :-)
07:18:36 <shapr> imho, it's a waste of my brainpower
07:18:41 <hornby> i agree. 
07:18:46 <hornby> how would a fixed loop look in java?
07:18:56 <shapr> you mean forEach?
07:18:59 <hornby> ya
07:19:16 * shapr scurfles through his bookmarks
07:19:36 <hornby> Java never really sparked my interest
07:19:48 <shapr> mine either, but it does pay my bills.
07:20:17 <shapr> this has all the code and explanation you'll need to do basic FP in Java: http://c2.com/cgi-bin/wiki?BlocksInJava
07:20:48 <hornby> oh cool
07:21:03 <shapr> http://c2.com/cgi-bin/wiki?AdvantagesOfFp
07:22:46 <hornby> Programming is just so cool in general. I wish I was good at it
07:23:17 <hornby> I still feel like a hack
07:23:29 <shapr> the number one way to improve your ability to do something is to do that thing
07:24:28 <hornby> Yeah, I know. But its time consuming :) And hard, honestly
07:24:42 <shapr> yah, I agree, but would you want to be good at something that's easy?
07:24:46 <hornby> I'm not complaining ... 
07:25:22 <shapr> I find creative and artistic stuff much easier than programming or math. Discipline does *not* come naturally to me.
07:25:36 <shapr> That's much of why it's so cool when I *do* something in those areas.
07:25:47 <hornby> So why do programming? Challenge? :)
07:26:18 <shapr> yah, sure
07:26:48 <shapr> I measure success against myself, not others
07:26:53 <hornby> There is definately a sense of accomplishment. 
07:27:10 <hornby> I try to meassure success against myself, but its so tempting to measure against others. :)
07:27:18 <hornby> Of course, when I do, I get disheartened
07:27:23 <shapr> yah, same here.
07:28:15 <shapr> the number of programmers in the world who are better than I am is very large.
07:28:39 <hornby> Discouraging. 
07:29:29 <shapr> on the other hand, many of the best programmers don't really find it rewarding, because it is so easy for them.
07:29:49 <hornby> Hm. 
07:30:30 <hornby> Well I guess I'll just have to become proficient enough to take their jobs, so they can move on to better things :)
07:30:38 <shapr> hah :-)
07:30:41 <shapr> excellent idea!
07:31:45 <hornby> I'm just a nice guy I guess
07:32:16 <hornby> Okay, so I thought I understood this, but now I don't 
07:32:17 <hornby> qsort (x:xs) = qsort [y | y<-xs, y<=x] ++ [x] ++ qsort [y | y<-xs,
07:32:18 <hornby> y>x]
07:32:45 <shapr> do you understand quicksort?
07:32:54 <hornby> In like C or something
07:32:59 <hornby> This is wierd
07:33:02 <shapr> if so, please explain it to me ;)
07:33:26 <hornby> uhhhh
07:33:44 <hornby> I don't understand it THAT well :)
07:33:57 <shapr> it looks like it's trying to find a middle point, and push all smaller items in front, and all larger items behind
07:34:27 <hornby> well it sticks the head in the middle, right?
07:34:31 <shapr> yah
07:34:37 <hornby> And then ... oh wait 
07:35:04 <hornby> all y that are less than x get sorted south of x... 
07:35:09 <shapr> right
07:35:11 <hornby> But ... 
07:35:16 <hornby> Oh
07:35:27 <hornby> Damn, why does it have to be so simple?
07:35:52 <hornby> I feel like I'm missing something :)
07:35:57 <shapr> hah
07:36:09 <shapr> well, rewrite it yourself and see if it should be different
07:37:43 <hornby> Thats crazy. A C quicksort is so long
07:38:05 <shapr> from what I've read, that quicksort is cheesy because the head is rarely a good pivot point.
07:38:28 <hornby> true
07:38:44 <shapr> on the other hand, it does work.
07:38:44 <hornby> Sorting algorithms make my head hurt even more than Haskell (did)
07:39:12 <hornby> Though there are faster methods?
07:40:03 <Igloo> C implementations tend to be faster by a constant factor as they are in place
07:40:16 <Igloo> mergesort and heapsort are both O(n lg n) algorithms
07:40:35 <Igloo> Except you'd need to do some thinking to do heapsort in O(n log n) in Haskell I think
07:40:55 <hornby> I'm only in first year, big O notation makes me run away
07:41:06 <Igloo> :-)
07:41:45 <hornby> this quicksort algothirm isn't very efficient is it? Its not even really much of an algorithm
07:42:09 <hornby> Haskell kind of removes the whole idea of an algorithm?
07:42:16 <Igloo> It's O(n^2) in the worst case and O(n log n) on average
07:42:16 <shapr> nah, just swaps it around
07:42:43 <Igloo> Well, the implementatin above might be (n^3) due to the ++s
07:42:45 <shapr> imho, recursion is more natural for many algorithms
07:43:59 <shapr> that statement is too general maybe...
07:44:01 <Igloo> but you could rewrite it with an accumulation parameter to make it O(n^2) - the GHC libraries have (maybe had) a stable O(n^2) implementations
07:44:24 <hornby> Igloo: Is that good? 
07:45:41 * shapr reads the recent memo-izing posts from haskell-cafe
07:46:48 <hornby> shapr: What is memo-ize?
07:47:02 <hornby> something like optimize?
07:47:09 <shapr> yah, of a specific type
07:47:16 <hornby> reducing O? 
07:47:58 <shapr> one cool thing about referentially transparent functions is that their result can always be substituted for a call to them
07:48:08 <shapr> makes sense?
07:48:56 <shapr> Igloo: Memo module in ghc compares pointer equality, do Integer values have in memory pointers?
07:49:08 <hornby> er
07:49:51 <hornby> a referentially transparent function is? 
07:49:59 <shapr> one that doesn't have any side effects
07:50:18 <shapr> http://c2.com/cgi-bin/wiki?ReferentialTransparency
07:50:58 * shapr reads the docs of the Memo module
07:51:05 <shapr> ohh, it says "integers get copied a lot"
07:51:57 <hornby> hm, okay that sort of makes sense. 
07:52:27 <shapr> it's like the variables in an equation..
07:52:40 <shapr> you know that x isn't going to change its value while you're solving the equation.
07:52:41 <hornby> yeah, I'm trying to think of an example
07:52:48 <shapr> this is not true in C :-)
07:53:12 <shapr> example of what?
07:53:14 <hornby> "f x = y" can be replaced by "y"?
07:53:18 <hornby> wait
07:53:45 <Heffalump> no, if you have the definition "f 5 = y" then anywhere you see "f 5" being used you can replace it by "y"
07:53:58 <shapr> hii Heffalump!
07:53:59 <hornby> oh :)
07:54:11 <hornby> See, that makes sense
07:54:13 <Heffalump> (as long as scopes work out properly)
07:54:37 <Heffalump> you do have to be a bit careful - if you had "let y=3 in f 5" you couldn't just replace the f 5 by y.
07:54:52 <Heffalump> because the y that's in scope there is a different y to the one that's in scope at the definition of f 5
07:55:36 <shapr> hornby: this might help: http://c2.com/cgi-bin/wiki?AdvantagesOfFp
07:56:06 <shapr> oh, that page brings up an interesting point...
07:56:10 <hornby> right
07:56:18 <shapr> pure functions are always threadsafe
07:56:50 <hornby>  Since subprograms do not alter some database behind your back, you can call them as many times as you want, even in different threads, etc., without having to worry about the state of the program.
07:57:00 <shapr> right!
07:57:01 <hornby> How do you know this though? 
07:57:13 <hornby> Why can't a subprogram access a database?
07:57:16 <shapr> know what?
07:57:23 <hornby> What?
07:57:25 <shapr> oh
07:57:29 <shapr> it can
07:57:42 <hornby> Right. 
07:57:49 <hornby> So how does this claim make sense? 
07:57:50 <shapr> input and output get weird in FP though...
07:58:03 <hornby> that whole monad thing that I haven't gotten to yet
07:58:06 <shapr> think about the equation model of FP
07:58:14 <shapr> getLine doesn't work in that model, right?
07:58:26 <shapr> because it's value is *not* the same each time you call it.
07:58:30 <hornby> shapr: I can't see how it would fit. 
07:58:51 <shapr> and yet, Monadic I/O really is referentially transparent
07:58:58 <hornby> Magic?
07:59:07 <shapr> mmm, sort of...
07:59:31 <shapr> Monads are mathematical constructs from category theory
07:59:50 <hornby> oh boy
07:59:55 <shapr> my favorite way of looking at monads is as "wormholes"
08:00:17 <shapr> the value gets 'wormholed' into your referentially transparent program
08:00:44 <shapr> I'd suggest you play with the other parts of Haskell first, if you can
08:00:50 <hornby> heh
08:00:58 <shapr> and then come back to I/O later
08:00:59 <hornby> Okay, I'll save monads for last. I'm not there yet in this article :)
08:01:20 <hornby> Going over lazy evaluation. More simple
08:01:25 <shapr> yah
08:40:15 <shapr> ya know, that last Jon Fairbairn post has lost me
08:41:42 <shapr> I have to open the window when building ghc... otheriwes my CPUs overheat.
08:42:56 <shapr> hornby: hey, are you around?
08:53:50 <shreya> goodnight everone ;)
08:54:57 <phoenix`> lol
08:54:58 <phoenix`> teacher
08:55:00 <phoenix`> from bcc
08:55:01 <phoenix`> :/
08:56:37 <shapr> bcc?
08:57:43 <phoenix`> far far from finland
08:58:28 <shapr> strange, make -j2 on 2 cpus fails with the ghc release
08:58:40 <shapr> it works if I leave off the -j2
08:59:05 <Heffalump> it's not hugely strange, the makefile might not have all the dependencies done right
08:59:08 <shapr> oh
10:18:24 <shapr> hmm
10:18:39 <shapr> well, I got ghc5 to build with opengl
10:18:40 <shapr> sort of
10:22:00 <hornby> ooh?
10:23:51 <shapr> I think I've got my ghc-pkg settings wrong somehow
10:24:53 <shapr> I need to read the HOpenGL docs I think
10:26:21 <shapr> hrm
10:26:22 <hornby> I think you're crazy
10:26:43 <hornby> :)
10:26:51 <shapr> er, why?
10:27:22 <shapr> Haskell + OpenGL = games
10:27:35 <hornby> Yeah, that'd be awesome, but does it even work?
10:27:40 <shapr> for other people, yes
10:27:46 <shapr> http://haskell.org/HOpenGL/
10:27:50 <shapr> I haven't gotten it to work yet though.
10:27:50 <hornby> heh
10:28:11 <hornby> oh that is so cool
10:30:25 <hornby> Good luck though, looks very rough
10:31:26 <shapr> it's simpler than I thought
10:31:43 <shapr> download the ghc-5.02.3 source release, ./configure && make && make install
10:31:50 <shapr> you need to have glutg3-dev though
10:32:32 <hornby> It works?
10:32:37 <shapr> it compiled
10:32:41 <shapr> it installed
10:32:42 <hornby> hahahaha
10:32:50 <hornby> Yeah, but does it WORK? :)
10:33:13 <hornby> Let me know -- I've got to have a shower :)
10:33:59 <shapr> I can't do :set -package HOpenGL
10:34:07 <shapr> I think I need to add the package definition or something
10:36:56 <hornby> OOOOOH!
10:37:05 <shapr> ?
10:37:34 <hornby> Lazy evalutation allows me to do [n | n <- [1..], (n `rem` 37)==0]
10:37:48 <hornby> And pull from it only the head element .... 
10:38:29 <hornby> Which isn't all that useful, but its cool, because it stops computing after it pulls the first element off
10:38:49 <shapr> right
10:38:51 <hornby> Sorry, completely off topic, but I have no idea what you're talking about :)
10:38:59 <shapr> haskell is on-topic here
10:39:20 <hornby> well, true, but you were talking about HOpenGL. 
10:39:31 <hornby> Anyway, and I was going to have a shower. Good luck :)
11:00:37 <dennisb> shapr: why do you need to recompile ghc?
11:12:22 <dennisb> I downloaded HOpenGL and here I just needed to do the normal configure and make
11:14:19 <jewel> coi coi
11:15:31 <dennisb> "coi coi" back at you
11:15:35 <jewel> hey dennisb
11:15:41 * dennisb have no idea what it means
11:15:48 <jewel> it was directed at shapr :-)
11:17:51 <dennisb> I'm playing around and running small opengl programs now, it's fun
11:24:58 <hornby> opengl rules
11:38:55 <hornby> sieve (x:xs) = x : sieve [y | y <-xs, (y `rem` x)/=0]
11:39:16 <hornby> A few things I don't get. Like what the second : is for. or what /= means?
11:41:05 <hornby> memberOrd :: Ord a => [a] -> a -> Bool <<< and for this one, am I right to guess that "Ord a =>" just means all a are just Ord? So it would be equivalent to writing memberOrd :: [Ord] -> Ord -> Bool ?
12:00:48 <dennisb> hornby: /= is "not Equal"
12:01:30 <hornby> dennisb: oh. wierd. 
12:01:32 <dennisb> : is the operator called cons, which you use to build lists. It puts an element and a list together to a new list
12:01:44 <hornby> ah, cool
12:01:46 <dennisb> type: 3 : [1,2,3]
12:02:08 <dennisb> (in hugs of course :-)
12:02:09 <hornby> like . in lisp gotcha :)
12:02:11 <hornby> ya. 
12:02:14 <hornby> cool, thanks :)
12:02:18 <dennisb> then we have the types
12:02:25 <dennisb> [a] -> a -> Bool
12:02:56 <dennisb> this is actually [a] -> (a -> Bool) if we put in the parentheses
12:03:37 <dennisb> this is a type of a function that takes a list with elements of type a, and returns a function
12:03:47 <dennisb> a can be any type here
12:04:10 <hornby> er
12:04:19 <dennisb> like Int, then the function takes a int-list, which we write [Int]
12:04:40 <hornby> Sorry, whats the Ord bit?
12:04:48 <dennisb> I'm coming to that
12:04:53 <hornby> oh, okay :)
12:05:35 <dennisb> a stands for any type, it's a type variable. The Ord a is a constraint on this type saying that a can be any type where you can compare elements for order
12:06:11 <dennisb> It's actually connected to classes in haskell, there is a standard class called Ord
12:06:37 <hornby> Ah, I think I see
12:06:41 <dennisb> but the effect is that the function memberOrd can only be used on lists with elements you can compare
12:06:51 <hornby> why the =>
12:06:52 <hornby> ?
12:07:04 <dennisb> Just a way to show it is a constraint
12:07:28 <dennisb> Here is another (stupid) example: Ord a, Eq b => a -> b -> Int
12:07:33 <hornby> okay. but I'm confused on one thing
12:07:34 <hornby> memberOrd :: Ord a => [a] -> a -> Bool
12:07:35 <hornby> memberOrd (x:xs) n
12:07:59 <hornby> oh wait, no I think I get it. 
12:08:18 <hornby> Ord a => [a] matches up with the (x:xs) right?
12:08:28 <dennisb> [a] matches up
12:08:28 <hornby> the a with the n, the bool is the return type
12:08:48 <hornby> Ord a refers to all subsequent a?
12:08:49 <dennisb> The "Ord a"  s for the whole type "[a] -> a -> Bool"
12:08:52 <dennisb> yes
12:08:57 <hornby> okay. gotcha. 
12:09:09 <hornby> now can a be b? or anything else? or just a? :)
12:09:17 <dennisb> so the second argument must be of the same type as the elements in the list
12:09:24 <dennisb> any name
12:09:27 <hornby> okay, cool
12:09:32 <dennisb> must by lowercase
12:09:51 <hornby> thats cool
12:09:59 <dennisb> types always start with an uppercase, and variables with lowercase
12:10:23 <dennisb> if you write bool by misstake it would mean any type
12:10:39 <hornby> case sensitive, gotcha
12:10:57 <hornby> primes = sieve [2 .. ]
12:10:57 <hornby> sieve (x:xs) = x : sieve [y | y <-xs, (y `rem` x)/=0]
12:11:01 <hornby> One more thing :) 
12:11:06 <dennisb> ok
12:11:13 <hornby> Shouldn't this do like [2,3,3 .. ]?
12:11:30 <dennisb> I don't understand
12:11:49 <hornby> Well whats the output here? it takes the head 
12:11:51 <hornby> (2)
12:11:55 <dennisb> it's a function that takes a list as input and gives a list as output
12:12:09 <hornby> and adds a three ... and then another 3?
12:12:13 <dennisb> no
12:12:30 <dennisb> the output list has the same first element as the input list (the x)
12:12:30 <hornby> Its supposed to list all the prime numbers: Sieve of Eratosthenes
12:12:41 <hornby> right... 
12:12:53 <dennisb> the rest of the outputlist is the same as the rest of the input list, except you filter out all the multiples of x
12:13:03 <hornby> oh, shit, I get it. 
12:13:10 <dennisb> (and run sieve again on the result)
12:13:16 <dennisb> I forgot that
12:13:45 <hornby> I was reading it wrong. I'm having a hard time getting used to something ... maybe its all the recursion, i dunno :)
12:13:47 <dennisb> It's a really nice definition
12:14:03 <dennisb> well, it's a lot of new stuf, both syntax and semantics
12:14:18 <Heffalump> it is very elegant
12:14:33 <dennisb> Heffalump: I totaly agree
12:15:19 <dennisb> well, i'm leaving for a while, someone else can take over the lesson!
12:15:23 <hornby> takes awhile on the larger numbers though
12:15:27 <hornby> thanks dennisb :)
12:16:15 <Heffalump> yeah, it's not exactly the most efficient definition :-)
12:16:55 <hornby> pretty though
12:17:00 <Heffalump> indeed.
13:15:18 <hornby> mkAdder n = addN where addN m = n+m
13:15:18 <hornby> add7 = mkAdder 7 -- e.g. 'add7 3' is 10
13:15:55 <hornby> oh wait, now it makes sense. bah :)
13:24:03 <hornby> Here's a real question though: 
13:24:05 <hornby> mkFunc ((i,j):ps) = (\n -> if n==i then j else (mkFunc ps) n)
13:24:12 <hornby> Where does n come from?
13:43:58 <jewel> it's whatever gets passed to that function
13:44:59 <jewel> eg  (\n -> n + 2) 3
13:45:01 <jewel> gives 5
13:45:57 <jewel> except here mkFunc is a function that makes a function specific to its arguments
13:50:48 <Heffalump> f = (\n -> n+1)
13:50:54 <Heffalump> is roughly equivalent to
13:50:56 <Heffalump> f n = n+1
13:51:51 <jewel> isn't it luverly?
13:55:04 * shapr returns
13:55:08 * shapr yawns
13:55:28 <shapr> dennisb: you did configure && make with ghc5 on debian/sid and it just worked?
13:56:17 <shapr> ah, dennisb has left
14:04:26 <shapr> it occurs to me that we could prepare for next years ICFP contest
14:04:50 <shapr> whenever that is
14:05:31 <shreya> grr
14:05:32 * Heffalump gets to go to ICFP this year, yay :-)
14:05:37 <shreya> an exam tomorrow
14:05:42 <shreya> got no sleep at all
14:05:43 <shreya> wait
14:05:47 <shreya> it's today
14:05:48 <shreya> lol
14:05:48 <shapr> Heffalump: I'm jealous :-)
14:06:30 <shapr> when does the icfp2002 contest happen?
14:06:54 <shapr> or has it already?
14:15:48 <shapr> hrm
14:15:54 <shapr> HOpenGL is still not happy3.
14:15:58 <shapr> but it's much closer.
14:20:44 * jewel plays with happy
14:25:59 <Heffalump> end of August IIRC
14:35:34 <jewel> how do I get the n'th item in a list?
14:36:30 <Heffalump> !!n
14:38:58 <jewel> and create a show method for a type?
14:42:05 <Heffalump> either "deriving Show" in the datatype declaration
14:42:14 <Heffalump> or "instance Show Foo where ..."
14:42:30 <Heffalump> I can't remember exactly what functions you need, check the prelude for that
14:46:25 * jewel examines some code written by heffalump
14:48:58 <shreya> ok, coffee isn't doing the trick
14:49:13 * shreya wish he had something more powerful
14:49:18 <phoenix`> speed
14:49:23 <phoenix`> :/
14:49:52 <jewel> What does it mean when I have:
14:50:00 <jewel> data Token = TokenVar String
14:50:18 <jewel> how do I show the string that was passed in the constructor?
15:13:02 <Heffalump> umm
15:13:10 <Heffalump> instance Show Token where
15:13:15 <Heffalump>    show (TokenVar str) = show str
15:13:27 <Heffalump> would probably do, though IIRC you're also supposed to define showsPrec for class Show.
15:13:34 <Heffalump> what code were you examining?
21:39:06 * shapr awakens
21:39:11 <shapr> gooooood morning!!!
21:40:01 <dennisb> hi
21:40:12 <shapr> hi dennisb!
21:40:22 <shapr> are you still awake from yesterday, or have you awakened very early?
21:40:36 <dennisb> i'm on redhat 7.3, but I still don't understand why you need to recompile ghc in debian to use opengl
21:40:42 <dennisb> I always wake up early
21:40:54 <shapr> early awakenings are rare for me
21:41:12 <dennisb> I don't even use an alarmclock, I always gets up at 6
21:41:22 <shapr> wow that's amazing
21:41:38 <shapr> I usually awaken about 9am on days when I need to go to work.
21:41:48 <shapr> or much later on non-workdays.
21:41:55 <dennisb> Just an habbit, it doesn't matter if I go to sleep at 2, I wake at 6 and is tired the whole day .-)
21:42:21 <shapr> I bet I'd like that.
21:42:32 <shapr> then I'd know I have to go to sleep at a certain time.
21:42:39 <dennisb> Now, what's up with the recompiling?
21:42:48 <shapr> the latest debian package is ghc-5.02.2
21:43:02 <dennisb> and?
21:43:05 <shapr> iirc, the correct green-card for the latest HOpenGL requires 5-02.3
21:43:12 <shapr> er, 5.02.3
21:43:13 <dennisb> I have 5.02.1
21:43:15 <shapr> oh
21:43:20 <shapr> well then
21:43:36 <shapr> I guess not.
21:44:18 <dennisb> and I have some precompiled greencard, the only thing I compiled was HOpenGL and it just worked (might be some bug somewhere, but the examples I tested was just fine)
21:44:25 <shapr> hm, wow
21:44:28 <dennisb> $ rpm -q greencard
21:44:28 <dennisb> greencard-2.03-1
21:44:42 <shapr> that's the latest greencard
21:45:12 <shapr> hei smkl
21:45:18 <dennisb> I would say there is some other problem you have, what is it that does not work?
21:46:04 <shapr> at the moment I think the HOpenGL package is setup incorrectly in ghc-pkg
21:47:24 <dennisb> ok, that can't be so hard to fix. For running the examples you don't even need to do that
21:47:29 <shapr> Loading package HOpenGL ... can't load .so/.DLL for: HOpenGL (libHOpenGL.so: cannot open shared object file: No such file or directory)
21:47:29 <shapr> Prelude>
21:47:33 <shapr> oh really?
21:47:47 <dennisb> They got compiled at maketime in the examples directory even before the "make install"
21:48:11 <shapr> cool, QuakeMovement works
21:48:34 * dennisb actually just tested examples
21:48:36 <shapr> nifty, TestGLUT works also
21:49:34 <shapr> ooohh, aaahh :-)
21:49:37 <shapr> this looks niiice
21:51:09 <shapr> cool, so how do I use it in ghci?
21:51:12 <dennisb> well, then it is just the small problem left at least, and you know that the program works. Maybe it would still work without compiling ghc, because it did for me
21:51:30 <dennisb> I have no idea, I just compiled it because you were doing it
21:51:49 <dennisb> fix the package problem and it will probably work
21:51:57 <shapr> hah :-)
21:51:59 <shapr> ok
21:52:45 <dennisb> I'm going to build an rpm before installning, I always install rpm's. A little extra work, but it's worth it afterwards
21:54:07 <dennisb> time for breakfast, i'm getting hungry
21:54:17 <shapr> ok :-)
21:56:51 <shapr> ohhh
22:14:12 <dennisb> ooh?
22:14:52 <shapr> I'm trying to figure out how to fix the HOpenGL ghc-pkg entry
22:17:56 <dennisb> is it just ghci that does not work?
22:18:51 <shapr> well, the examples wore
22:18:52 <shapr> work
22:19:11 <shapr> but I can't figure where it wants to find libHOpenGL.so
22:19:17 <dennisb> can you compile doing just import OpenGL
22:19:20 <dennisb> or HOpenGL
22:19:40 <shapr> good question
22:19:55 <dennisb> I would guess that for compiling it can use the .a file and link statically, but for ghci it wants to load the .so file which is not built
22:20:21 <dennisb> I think you can start ghci so that it loads the .a file, and then it might work even there
22:20:57 <shapr> ohh
22:20:59 <dennisb> I thing the newer versions of ghci allows .a files to be loaded, i've loaded .o files before
22:21:26 <shapr> how much newer? I have 5.02.3
22:21:56 <dennisb> I don't know, I just remember for 5.00 it did not work when I tried to load a .a-file
22:22:01 <shapr> hmm
22:22:05 <dennisb> and later I saw that it was fixed
22:22:11 <dennisb> i've not tried it
22:22:47 <dennisb> the best would of course be if one could create the .so file in the first place
22:22:55 <shapr> how do I do that?
22:23:37 <dennisb> i don't knwo
22:25:34 <shapr> neither do I
22:25:39 <shapr> I'll keep reading the docs
22:51:34 <shapr> hrm
23:06:08 <shapr> ghc --make TestGLUT.hs in a separate directory fails
23:06:13 <shapr> can't find module GLUT
23:06:14 <shapr> hmm
23:18:30 <shapr> crrrrap
23:18:35 <shapr> http://haskell.org/pipermail/hopengl/2002-April/000172.html
23:18:43 <shapr> that shows how to make a .o file for ghci
23:18:52 <shapr> but I can't seem to get it to work
23:19:42 <shapr> it keeps saying argument list too long
