00:08:38 <hornby> hcentre = mkElem "CENTER" << ! Grrr. 
00:13:20 <hornby> refered to as hcenter of course, in the paper. rage.
00:42:32 <shapr> hornby: send 'em patches
00:44:24 <hornby> shapr: send 'em pipebombs
00:44:32 <shapr> that bad?
00:44:40 <hornby> shapr: I'm just frustrated
00:44:57 <hornby> I just got something to compile though, so all my anger has vanished
00:45:21 <shapr> yay!
00:46:21 <hornby> I've been trying to get xml anything to work for hours
00:46:39 <shapr> got some working demo code?
00:46:46 <hornby> no :)
00:47:14 <hornby> Just other peoples "examples" that never work because they are incomplete or just plain broken
00:47:32 <hornby> I spent forever trying to compile HaXmL before I realized it CAME with ghc
00:48:13 <shapr> yah, that was a surprise for me too
00:48:24 <shapr> you know how to use the locate and grep commands?
00:48:31 <hornby> shapr: yeah
00:48:36 <hornby> why? 
00:48:57 <Heffalump> hornby: it's quite easy to make mistakes in code in papers, because you generally have to retype it in TeX in order to get it to typeset nicely
00:49:09 <shapr> because I did "locate haxml" to see if I already had it.
00:49:11 <hornby> Heffalump: no pasting? 
00:49:28 <Heffalump> even if you cut and paste, you then have to insert formatting stuff around it
00:49:29 <shapr> Heffalump: haskell has a TeX source mode though
00:49:30 <hornby> Heffalump: I guess I shouldn't judge, huh? :) 
00:49:37 <hornby> its just frustrating
00:49:59 <hornby> shapr: ditto. but I came up with nothing
00:50:08 <Heffalump> shapr: that works if you're willing for a bit of hassle and don't mind all your source code ending up in verbatim
00:51:05 <Heffalump> (or similar)
00:52:32 <hornby> hrm. this program transforms xml to html, but its ugly. 
00:52:38 <hornby> <HTML
00:52:42 <hornby> ><HEAD
00:52:43 <hornby> etc
00:53:23 <Heffalump> the advantage of putting newlines inside tag closes rather than outside is that in the rare situations where newlines matter outside the tags, they won't affect the rendering
00:53:58 <hornby> so this is a feature, not a bug? 
00:55:30 <Heffalump> I suspect it's deliberate, yeah
01:43:22 <shapr> w00
01:43:26 * shapr bounces
01:55:14 <hornby> you bounce a lot :)
01:56:27 <shapr> I'm very bouncy.
01:56:30 <shapr> in person even more so.
01:56:49 <shapr> partially because I'm really happy.
01:57:01 <shapr> when I was 16 years old, I desperately wanted to learn how to program
01:57:03 <hornby> any particular reason? :)
01:57:08 <shapr> I had dos 3.31
01:57:18 <shapr> and there weren't any free compilers available
01:57:22 <shapr> and I had no money
01:57:26 <hornby> bummer
01:57:34 <hornby> So what'd ya do?
01:57:43 <shapr> I worked with debug.com for awhile and tried to write assembly programs with it.
01:57:54 <hornby> debug.com was fun
01:57:59 <shapr> I had some minor success, but debug is *not* a decent assembler.
01:58:45 <hornby> Then?
01:59:07 <shapr> I gave up on programming for many years.
01:59:29 <hornby> Pity
01:59:33 <shapr> I worked on a graphic design degree for awhile
01:59:43 <shapr> I did a lot of computer art
01:59:54 <shapr> then I tried getting a health physics degree
02:00:06 <shapr> then I just took classes I enjoyed going to :-)
02:00:21 <hornby> whats health physics?
02:00:27 <hornby> kinetics? 
02:00:30 <shapr> in short, radiation safety
02:00:43 <hornby> oh
02:00:50 <shapr> you run around a nuclear power plant with a detector and make sure people don't get sick.
02:00:59 <shapr> it wasn't very exciting...
02:01:02 <shapr> actually that's not true.
02:01:05 <hornby> hmm, nor safe?
02:01:11 <shapr> oh, it was wayyy too safe
02:01:16 <shapr> that's part of why it was boring.
02:01:18 <hornby> :)
02:01:31 <shapr> health physics is like being in a war....
02:01:37 <shapr> most of the time it's REALLY boring...
02:01:47 <shapr> the very small amount of time where it's not boring it's WAY TOO EXCITING.
02:01:54 <hornby> heh
02:02:48 <shapr> so honestly, I'll do my best to stay out of both of those areas.
02:03:14 <hornby> Well, you finally got into programming, and you seem to be doing pretty well :)
02:03:21 <shapr> yah, I'm really quite happy doing programming.
02:03:32 <shapr> I never did get a degree, even though I have enough credits for 1.5 degrees
02:04:00 <shapr> none of my college credits are enough in one area to complete any degree requirements though.
02:04:22 <shapr> I had fun, I learned a lot.
02:04:38 <shapr> nowadays I want to go back and get into math.
02:04:50 <hornby> hmm, what kind math?
02:05:01 <shapr> I'd like to go from the ground up.
02:05:07 <shapr> my current math knowledge is very small.
02:05:26 <shapr> so far, I'm most interested in fractals
02:05:54 <shapr> but stuff like penrose tiles, cantor dust, etc etc
02:05:58 <shapr> it's all fascinating.
02:06:13 <hornby> yeah, I know what you mean
02:06:19 <shapr> I've read about quasiperiodic crystals in relation to superconductivity
02:06:23 <shapr> that's nifty stuff
02:06:34 <shapr> I'd like to know more about the physics of photorefractive crystals
02:06:36 <hornby> very physics
02:06:48 <shapr> I'd enjoy learning about routing theory
02:07:10 <shapr> I've read about it in the past, but I didn't understand the math, only the conceptual structure.
02:07:45 <shapr> I thought of a new much more extensible design for computers for example
02:07:55 <hornby> Oh?
02:08:10 <shapr> if each component of your computer is a tetrahedron, with connectors on all four sides for most componets
02:08:22 <shapr> then you can continue expanding it till you start taking off the old pieces
02:08:32 <shapr> rather than running out of PCI slots and having to buy a new system
02:08:47 <shapr> you just stick on more memory, or another newer processor
02:08:50 <shapr> or another hard drive
02:09:07 <shapr> sounds sensible?
02:09:45 <shapr> obviously, for components like graphics cards, you'd probably have one side of the tetrahedron that would be specialized for connecting to your actual display device.
02:09:50 <hornby> You'd still run out of room eventually, in theory, but in practice you wouldn't have too many components. 
02:09:56 <shapr> right
02:10:14 <hornby> hm, it'd look cool too :)
02:10:18 <shapr> because your 1gb drive from six years ago is something you can probably get rid of when you buy a 138gb tetra
02:10:26 <shapr> yah, it would look very star trek :-)
02:10:39 <hornby> :)
02:10:47 <shapr> so I've been thinking of how to design the infrastructure inside these tetras
02:11:45 <shapr> linux can run on asymmetric multiprocessors, did you know that?
02:12:18 <shapr> something like fibre channel or HIPPI would probably be best for inter tetra communication
02:12:21 <hornby> mmm. hmm. 
02:12:32 <hornby> HIPPI? Huh? :)
02:12:49 <hornby> I know less about hardware than I know about math :)
02:12:51 <shapr> it's how massive NUMA systems talk to each other
02:13:15 <shapr> in the really big systems, each chunk is a processor + memory combo
02:13:22 <shapr> and they sit on a HIPPI bus
02:13:29 <hornby> High Performance Peripheral Interface
02:13:34 <shapr> which is basically a really fast fiber connection to their neighbors
02:13:37 <shapr> you got it
02:13:42 <hornby> neat
02:13:48 <shapr> so they have their own memory
02:13:54 <shapr> but they can loan it to their neighbors
02:14:31 <hornby> isn't that overkill maybe though for a PC?
02:14:58 <shapr> so I'm thinking Linux-AMP, and each processor tetra should export a description file that tells you what kind of CPU it is, so you can cross-compile your kernel so it can run on that CPU also
02:15:11 <shapr> hippi is very expensive right now
02:15:16 <shapr> but PCI was really expensive when it came out..
02:15:30 <hornby> prices will fall
02:15:42 <shapr> plus it's not specifically hippi I'm thinking of, just something optical, so you don't have the problems that pure electrical communication has
02:15:53 <hornby> especially if you start mass producing the stuff
02:15:56 <shapr> right
02:16:10 <hornby> what problems does electrical communication have? 
02:16:24 <hornby> I mean, in a system like that? 
02:16:39 <shapr> optical processors can route signals without needing to regenerate them
02:16:50 <hornby> ah .. 
02:16:54 <shapr> if you look at the latest routers, they're purely optical for that reason
02:17:04 <hornby> electrical signals need to be boosted?
02:17:08 <shapr> the read/process/resend cycle is too solw
02:17:11 <shapr> er "slow"
02:17:22 <hornby> optical just needs a mirror? :)
02:17:35 <shapr> well, it's slightly more complicated than that, but effectively, yes
02:18:01 <hornby> is it fragile?
02:18:07 <shapr> at the moment, yes :-)
02:18:35 <shapr> it's a pain in the ass to install fiber optics because you need to put optical 'glue' on the place where the fibers join
02:19:19 <hornby> I'm sure they are looking into ways around that?
02:19:23 <shapr> yup
02:19:33 <shapr> but I haven't searched for the latest developments there
02:19:53 <shapr> I have been thinking of a way of compiling linux into a photorefractive crystal
02:20:11 <shapr> sounds bizarre probably...
02:20:35 <hornby> uh huh :)
02:20:38 <shapr> but a photorefractive crystal changes its refractive index depending on how much light is being shined onto it.
02:20:42 <hornby> I'm not sure what you mean in fact
02:20:51 <shapr> you know how transistors work?
02:20:57 <hornby> Oh. Neat. Sort of :)
02:21:07 <shapr> can you describe it to me?
02:21:14 <hornby> they amplify ?
02:21:22 <shapr> not really
02:21:37 <shapr> the beginnings of the transistor happened with what's his name...
02:21:40 <shapr> edison
02:21:42 <shapr> thomas edison
02:21:44 <hornby> oh wait, they get strung together to create logic gates
02:21:48 <shapr> riight
02:21:52 <hornby> and ... well everything. how they work, i dunno :)
02:22:02 <shapr> want me to tell you?
02:22:03 <hornby> memory too
02:22:05 <hornby> sure
02:22:06 <shapr> ok
02:22:15 <shapr> first, there was noise on the line
02:22:27 <shapr> hm
02:22:29 <shapr> even more basic
02:22:47 <shapr> an electrically charged sphere distributes the charge equally around itself
02:22:57 <hornby> okay
02:23:10 <shapr> a cone has a stronger charge on the pointy part than anywhere else
02:23:35 <shapr> so, someone figured out you can have a pointy bit that's pointing at a round bit
02:23:43 <shapr> and that'll get rid of noise in the wire
02:24:01 <shapr> it works because it makes a higher 'threshhold' for the signal to jump across.
02:24:04 <shapr> makes sense, yah?
02:24:13 <hornby> sure
02:24:34 <shapr> ok, so someone else, I think it was DeForest Kelly..
02:24:45 <hornby> DeForest Kelly? Scotty? 
02:24:49 <shapr> hmm
02:24:52 <shapr> the name is close
02:25:02 <shapr> I always get the actor and the inventor mixed up..
02:25:03 <shapr> no idea why
02:25:41 <shapr> but whatever
02:25:41 <hornby> ok, doesn't matter :)
02:25:41 <shapr> this guy thought of putting a screen between the pointy bit and the round bit
02:26:01 <shapr> so that way if you put a lot of charge on the screen, it would amplify the signal
02:26:01 <shapr> iirc, it worked just fine
02:26:15 <shapr> but it had the extra ability that an uncharged screen kept the signal from passing through at all
02:26:22 <hornby> ooh
02:26:42 <shapr> so now you have the ability to pass the signal, or stop the signal.
02:26:51 <hornby> very handy
02:26:53 <shapr> yup
02:27:04 <hornby> the begining of conditionals? :)
02:27:12 <shapr> yah, that's a transistor
02:27:18 <hornby> its like an or-gate or something? 
02:27:26 <shapr> well, think about it...
02:27:28 <hornby> er ... 
02:27:32 <shapr> how would you make an or-gate out of those?
02:27:53 <shapr> hm, debian unstable just got some electronics simulation packages recently
02:27:55 <hornby> ok, or is if either are true, you get a true
02:27:58 <shapr> lemme see if they do this stuff
02:28:10 <hornby> so its more of an and
02:28:14 <shapr> correct!
02:28:37 <hornby> but you can make an or out of it ... by .. hrm, let me get some paper
02:29:03 <shapr> this is where it gets fun :-)
02:29:34 <Igloo> If you can do "not" and "and" then you can do "or" </not following conversation>
02:30:05 <hornby> do we have a not?
02:30:19 <Igloo> I dunno, but if you do...  :-)
02:30:47 <hornby> I dont think we do
02:31:21 <hornby> yeah we need something more -- we can't make an or out of multiple ands alone?
02:31:46 <Igloo> No
02:32:25 <shapr> hm, I wonder where I put my electronics design book
02:32:44 <shapr> it takes you up from nothing to building very tiny computers
02:33:24 <hornby> neat, what book?
02:34:43 <shapr> aha
02:34:43 <shapr> I have a copy of "Transistor Physics and Circuits" from 1958
02:34:43 <shapr> not what I was looking for, but it'll do.
02:34:43 <shapr> that's the name of it :-)
02:35:27 <hornby> hrm
02:35:58 <shapr> hm
02:36:08 <shapr> this doesn't show how to implement boolean logic with transistors
02:36:58 * shapr apt-gets oregano
02:37:20 <Igloo> In general pull the output high via a resistor and have suitable transistors pulling it low
02:37:32 <Igloo> Series for and, parallel for or
02:37:41 <Igloo> Oh, I have high and low the wrong way round
02:37:55 <hornby> didn't notice :)
02:38:04 <Igloo> But nand and nor are more useful anyway  :-)
02:39:24 <hornby> i don't think we have those yet either
02:39:33 <hornby> all wee have is a cone, a ball, and a screen
02:41:05 <hornby> oregano looks cool
02:41:22 <shapr> my local debian mirror is ignoring me >:(
02:43:04 <hornby> all kinds of wierd stuff in here. flip flops, mosfets, shift registers, 32K static ram, awesome
02:43:24 <shapr> http://library.thinkquest.org/2723/lesson11/index.html
02:43:40 <shapr> from http://library.thinkquest.org/2723/lessons.html
02:44:07 <shapr> hm
02:44:22 <shapr> that still doesn't tell you how to build it up from multiple transistors
02:46:42 <shapr> ah, this looks better
02:46:48 <hornby> http://userpages.wittenberg.edu/bshelburne/Comp150/LogicGatesCircuits.html
02:46:55 <shapr> http://library.thinkquest.org/15433/unit7/7-0.htm
02:47:41 <hornby> hmm
02:48:43 <shapr> both of our urls show the same thing
02:48:46 <shapr> that is, how to make a NOT gate
02:49:15 <hornby> they do? where?
02:49:56 <shapr> from the url that I pasted, click on "Logic Gates"
02:49:57 <hornby> oh
02:50:00 <hornby> i see 
02:50:16 <shapr> from your url, scroll down to "implementing boolean logic - the transistor"
02:52:53 <shapr> I don't quite understand it though
02:53:25 <hornby> i think i'm too tired to right now
02:53:26 <shapr> do you?
02:53:37 <shapr> ok, tomorrow then if you want :-)
02:53:44 <hornby> ya, that'd be better
02:53:52 <hornby> Is this stuff useful?
02:53:54 <shapr> it's fun to talk about this kind of stuff
02:53:57 <shapr> oh yes, very useful
02:54:10 <hornby> I mean it is a fundamental building block ..
02:54:12 <shapr> once you understand the NOT gate, you can understand logic circuits
02:54:17 <hornby> But no one operates on this level? 
02:54:20 <shapr> sure they do
02:54:32 <hornby> Well I guess they have to 
02:54:34 <hornby> Hm
02:54:35 <shapr> think of embedded controllers
02:54:43 <shapr> the guy who designed your fridge had to lots of this stuff
02:54:48 <hornby> Yeah :)
02:54:58 <hornby> I want to play with this oregano thing
02:55:04 <hornby> its like lego ... with electricity
02:55:19 <shapr> yah!
02:55:52 <hornby> See, my goal is to write a Haskell todo program 
02:56:00 <shapr> that's a good goal.
02:56:14 <hornby> Which I could then add this to
02:56:32 <hornby> Its looking more complicated than I had planned though
02:56:35 <shapr> do you have any specifications for your todo program?
02:56:41 <shapr> that's pretty normal for software :-)
02:56:49 <shapr> it's always more complicated than it looks
02:56:55 <hornby> actuyll, I got a little ambitious and decided to do a structured text editor :) 
02:56:59 <shapr> yikes
02:57:12 <hornby> hierarchal 
02:57:13 <shapr> I'd strongly suggest defining one small piece of functionality, and making that happen
02:57:20 <shapr> then extending it
02:57:23 <hornby> yeah, start small :) 
02:57:29 <shapr> basically, build your NOT gate first :-)
02:57:47 <hornby> yup. I've got curses working -- thats my ui
02:58:02 <shapr> cool!
02:58:12 <hornby> I've finally got some XML sort of working -- thats my structured text file format
02:58:24 <hornby> Needs a lot of design work though
02:58:36 <shapr> I'd strongly suggest starting with something more basic, but if that's how you want to do it..
02:58:39 <hornby> I have no idea what I'm doing :) Gotta look into tree structures and such
02:58:51 <hornby> Basic is boring :)
02:58:55 <shapr> I agree with that.
02:58:57 <shapr> very much so.
02:59:15 <hornby> This gives me a challenge. 
02:59:27 <shapr> hey, if that works for you :-)
02:59:33 <hornby> And helps me build some much needed skills :) I think I'm going to go through SICP. 
02:59:37 <shapr> yay!!
02:59:53 <shapr> that's book number zero on the way of the wizardly hacker
02:59:59 <hornby> it looks like it has some handy stuff. I'll probably end up building some small things in Haskell, toys and such. 
03:00:00 <shapr> tPP is book number one
03:00:02 <hornby> :)
03:00:08 <shapr> then XP book 1
03:00:16 <hornby> Then? :)
03:00:20 <shapr> well
03:00:42 <shapr> I'd suggest learning Python in the book zero stage
03:00:42 <hornby> SICP alone will take me long enough :)
03:00:50 <hornby> I know Python. 
03:00:58 <shapr> and learning Haskell after tPP
03:01:09 <shapr> and then learning C
03:01:14 <hornby> Fairly well actually. I've written a few thousand lines of it. 
03:01:23 <shapr> yah, I've written quite a bit of Python myself.
03:01:41 <hornby> Much to do. 
03:01:53 <shapr> yah, but it's fun stuff that's worth doing
03:01:58 <hornby> Maybe I'll compromise and start with a more basic todo list first :)
03:02:01 <hornby> Definately. 
03:02:37 <shapr> I'm planning on really learning C after Haskell
03:02:42 <shapr> then I'm going for Mercury.
03:03:15 <hornby> I've not really thought that far ahead. 
03:03:26 <shapr> well, my plans change when I learn new stuff
03:03:38 <shapr> so what I've said is not even set in peanut butter
03:03:39 <hornby> I know I pretty much _need_ Python, Haskell, and C.
03:03:45 <shapr> yah, I agree with that.
03:03:49 <shapr> I already know Java
03:03:57 <shapr> though it's highly irritating
03:03:59 <hornby> I've avoided Java, well mostly
03:04:02 <shapr> it does pay money
03:04:07 <hornby> Ooh, and Smalltalk. I want to do Smalltalk
03:04:09 <shapr> I have a very low opinion of Java
03:04:13 <shapr> yah, I want to do smalltalk also
03:04:26 <shapr> I keep thinking I should start #learn channel
03:04:29 <shapr> or maybe #neophile
03:04:30 <hornby> I'm not really familiar with Mercury. OCaml looked neat ... but it was confusing :)
03:04:40 <hornby> Hrm, thats a neat idea
03:04:53 <shapr> I think you'd fit in there
03:04:55 <shapr> I know I would
03:04:58 <shapr> so would dnm
03:05:01 <shapr> not sure who else
03:05:13 <shapr> probably rc
03:05:18 <shapr> hm
03:05:23 <hornby> I think it would grow. the learning bug would spread :)
03:05:26 <shapr> yah, I agree.
03:05:31 <shapr> what should we name it?
03:05:39 <hornby> tough call :) something non-cheesy. 
03:05:42 <shapr> yah agreed
03:06:05 <hornby> Hmmm
03:06:25 <shapr> #neophile is accurate
03:06:36 <hornby> maybe. but what happens when people outgrow it? 
03:06:37 <shapr> #learn is a bit too general maybe
03:06:43 <shapr> ?
03:06:58 <shapr> what do you mean outgrow it?
03:07:02 <hornby> the neo bit :) 
03:07:14 <shapr> huh?
03:07:48 <hornby> Well, wait, I get neo-phile implies the love of new things?
03:07:51 <shapr> right
03:07:55 <hornby> I was thinking neophyte, sorry :)
03:07:58 <shapr> hah :-)
03:08:10 <shapr> I gotta go downstairs and do groceries
03:08:17 <shapr> I'll be back soon
03:08:20 * shapr bails
03:08:20 <hornby> okay
03:13:49 <hornby> I like #neophile/neophiles/neophilia
04:26:46 * hornby wonder if Heffalump knows MALCOLM
04:26:47 <hornby> WALLACE
04:26:49 <hornby> oops
04:27:00 <Heffalump> nope
04:27:13 <shapr> hmm
04:29:04 <hornby> or of. he wrote HaXmL and has the research interest "Using source transformation to improve program efficiency"
04:29:20 <shapr> sounds refactoring related
04:29:23 <shapr> do you have an url?
04:29:25 <Heffalump> I know of him, certainly
04:29:44 <Heffalump> lots of people have that research interest :-)
04:29:58 <hornby> mm 
04:30:09 <hornby> www-users.cs.york.ac.uk/~malcolm/
04:30:12 <shapr> Heffalump: would you happen to have a general idea of the pound euro exchange rate?
04:30:14 <hornby> I didn't see any details
04:30:27 <Heffalump> hornby: he's the main developer of NHC
04:30:37 <Heffalump> shapr: umm, 1.5:1 I think?
04:30:46 <shapr> I'd like to buy a maltron keyboard, but I'm afraid to ask how many euro £375 is
04:31:07 <Heffalump> £375 for a keyboard??
04:31:10 <Heffalump> what on earth does it do?
04:31:16 <hornby> Heffalump: Oh, neat :)
04:31:20 <Heffalump> (that's about 580 euros)
04:31:33 <hornby> omg, does it come with a death ray?
04:31:39 <shapr> hah
04:31:43 <shapr> I have a kinesis right now.
04:31:52 <shapr> that cost me $250 for the economy model
04:32:02 <shapr> http://www.kinesis-ergo.com/
04:32:06 <shapr> the maltron is better though
04:32:09 <shapr> http://www.maltron.com/
04:33:13 <shapr> 580 euro is still a bit high.
04:33:22 <hornby> ha
04:33:36 <hornby> wierd looking thing
04:33:48 <shapr> better than flat keyboards
04:33:54 <shapr> far better
04:34:02 <Igloo> Not if you're on the phone typing one-handed
04:34:08 <shapr> imho, ms natural is also a flat keyboard
04:34:31 <shapr> Igloo: this is finland, we all have earpiece microphone combos that plug into our phones.
04:34:35 <hornby> my worst problem is my chair -- i need a comfy one
04:34:40 <shapr> Igloo: not really :-)
04:34:48 <shapr> most people do, but I never get calls.
04:36:53 <Igloo> Ah, cool
04:38:17 <hornby> hrm, this is sort of fun. There are almost no docs on HaXmL, only 2 code snippets, and nothing that does any more than hint that it can do what I want. Time to read the code I guess
04:38:34 <shapr> I've seen some demo code on comp.lang.functional
04:39:12 <hornby> shapr: really? I didn't turn anything up
04:41:16 <shapr> hm
04:42:46 <hornby> meh, I'm pretty much resigned to digging through the code
04:47:25 <hornby> mm, tomorrow though
04:47:43 <hornby> sleep first
04:48:31 <shapr> g'night hornby
04:48:55 <hornby> night
07:30:29 * shapr sproings
07:59:06 <shapr> hi py_ksh^^
07:59:46 <shapr> py_ksh^^: are you a haskell programmer?
08:01:25 <py_ksh^^> no,...was not sure what this channel was about
08:02:01 <shapr> have you heard of the programming language called Haskell?
08:03:15 <py_ksh^^> no again...(sorry) have been working with python recently though
08:03:19 <shapr> you can find out more about it on haskell.org
08:03:35 <shapr> I'm much more familiar with Python than Haskell, but I'm learning Haskell.
08:03:42 <py_ksh^^> thanks..I'll go check out the documentation
08:04:15 <py_ksh^^> I use python mostly for my own commandline scripting - sysadmin stuff
08:04:41 <shapr> I use Jython and random usefulness for one of my jobs
08:04:50 <shapr> and Zope in the other job.
08:05:21 <py_ksh^^> guess I'm behind the times...still using structured programming style
08:05:28 <shapr> hm?
08:05:31 <shapr> structured programming?
08:05:37 <shapr> what do you mean?
08:05:42 <py_ksh^^> stop laughing  :)
08:05:50 <shapr> :)
08:06:50 <shapr> actually, I'm really not sure what structured programming means exactly.
08:07:23 <py_ksh^^> It's a methodology of programming I was taught back in C, and COBOL
08:07:27 <shapr> oh
08:07:29 <shapr> nifty!
08:07:35 <py_ksh^^> defs, modules, straight thru syntax
08:07:41 <py_ksh^^> not object oriented
08:07:42 <shapr> my college was teaching COBOL when I left.
08:08:10 <py_ksh^^> well at least I have never sunk to the depths of using GOTO statements hehe
08:08:35 <py_ksh^^> I like python's straight approach to calling functions
08:08:39 <shapr> yah, me to
08:08:42 <shapr> er, "too"
08:09:10 <py_ksh^^> I'm hoping to start exploring some of the socket libraries...
08:09:28 <py_ksh^^> too bad the people at work want me to actually do my job instead
08:09:31 <shapr> hah
08:09:36 <shapr> what's your job?
08:10:05 <py_ksh^^> sysadmin/ engineer
08:10:16 <shapr> I was a sysadmin for six months once
08:10:23 <shapr> it was a lot of work for not much recognition.
08:10:31 <py_ksh^^> yup
08:10:44 <shapr> I did learn a lot about Unices though.
08:11:01 <py_ksh^^> constant tug of war with full time programmers too over resources
08:11:04 <shapr> we had AIX, Irix 5.3, SunOS, Solaris, RedHat 5.1
08:11:22 <shapr> I was the head programmer also :-)
08:11:31 <py_ksh^^> I'm mostly a Sun and Linux guy
08:11:31 <shapr> that job sucked.
08:11:36 <py_ksh^^> geez too many hats
08:11:40 <shapr> I really like Sun hardware
08:11:51 <shapr> I much prefer Linux for the OS
08:12:06 <shapr> though I do wish Linux could take advantage of the MMU that Sun hardware has...
08:12:08 <shapr> I forget the name of it.
08:12:14 <Heffalump> why can't it?
08:12:14 <py_ksh^^> had the opportunity to set up an E6500 with 4terabytes of storage
08:12:32 <py_ksh^^> MMU ?
08:12:35 <shapr> Heffalump: no one has written support for it yet.
08:12:44 <Heffalump> what's good about it?
08:12:52 <Heffalump> py_ksh^^: Memory Management Unit
08:12:58 <shapr> yah, SPARC hardware has the equivalent of a DMA controller for moving stuff around in memory.
08:13:00 <o3> 01:12 <Heffalump> what's good about it?
08:13:00 <o3> 01:12 <Heffalump> py_ksh^^: Memory Management Unit
08:13:02 <o3> grr
08:13:05 <o3> stupid mouse
08:13:22 <shapr> py_ksh^^: that E6500 sounds like a fun box to set up.
08:13:45 <py_ksh^^> $250,000 machine and it doesn't come with a sound card
08:14:04 <shapr> but it does come with a world reable microphone.
08:14:20 <shapr> actually they fixed that problem :-)
08:15:20 <py_ksh^^> now you've got me curious about the MMU...I think that sits on the CPU board
08:15:27 <shapr> yah, it does.
08:15:34 <shapr> I can't remember the name of it.
08:17:23 <shapr> I'm tempted to buy SPARC hardware next time I get a desktop system.
08:17:39 <shapr> even though they're less 'bang for the buck'
08:17:47 <shapr> you can depend on them to keep banging.
08:18:01 <py_ksh^^> I'm using an Ultra10 now...it's OK
08:18:23 <shapr> I have a dual athlon mp 1800+
08:18:36 <shapr> it's fast, but the hardware is a bit flaky.
08:20:57 <shapr> maybe it's the IOMMU I'm thinking of
08:23:12 <py_ksh^^> I don't know,...I'm looking up the 6500 manual now
08:23:45 <py_ksh^^> their is a data controller that connects the ceterplane with memory
08:24:15 * shapr dunno about that
08:28:04 <shapr> centerplane sounds like backplane, makes me think of a NUMA system
08:28:13 <shapr> I don't know anything about the 6500
08:30:09 <py_ksh^^> the backplane allows a data transfer rate of 9.6GB per second between all of the connected system boards
08:30:19 <py_ksh^^> that's gigabytes
08:30:24 <shapr> nice =)
08:30:49 <shapr> both of my processors together have a total bandwidth of 4.3GB or so
08:31:10 <py_ksh^^> well thanks for the tip about the haskell language..I'll check it out
08:31:12 <py_ksh^^> gotta split
08:31:17 <shapr> sure, come back some time
09:30:39 <shapr> yay
09:30:45 <shapr> Zope stuff is over for today.
09:30:49 <shapr> Time to do Haskell.
09:34:05 <shapr> w00
11:06:23 * shapr bounces
11:09:48 * jewel ponders writing a go program in haskell
11:09:56 <shapr> excellent idea!
11:10:18 <jewel> my idea is to write a program that can win on a 9x9 board with a four stone handicap
11:10:19 <jewel> (which is huge)
11:10:25 <shapr> wow
11:11:16 <jewel> http://www.britgo.org/tech/gmp.html
11:13:33 <shapr> looks easy enough at first glance
11:30:15 <jewel> heh
11:30:18 <jewel> http://www.haskell.org/pipermail/glasgow-haskell-users/2001-November/002680.html
11:30:40 <shapr> hmmm
11:34:22 <shapr> ok...
11:44:13 * hornby rolls out of bed, tries a sort of half-bounce, and falls flat on his face 
11:44:21 <hornby> mmrruhn
11:59:57 <shapr> gooood morning hornby!
12:00:11 <hornby> mmm
12:00:12 <hornby> hi
12:00:25 <hornby> i hate mornings
13:21:04 <hornby> Anyone know what IOMisc is?
13:22:08 <hornby> nevermind, it doesn't matter
13:22:19 <shapr> hiiiii!
13:22:29 <hornby> hiiiiiii ya!
13:22:32 <shapr> I'm just getting into another coding binge
13:22:48 <hornby> Nice. I'm trying to, but having great difficulty
13:23:06 <shapr> got questions?
13:23:31 <hornby> Yeah, how the hell does HaXmL work? :)
13:23:36 <shapr> I don't know.
13:23:37 <hornby> no one seems to know :)
13:23:51 <shapr> lemme see if I can find some short demos
13:23:56 <hornby> I've looked
13:23:59 <hornby> I've found like 2
13:24:11 <hornby> Neither doing anything near what I want. 
13:24:21 <shapr> http://www-106.ibm.com/developerworks/xml/library/x-matters14.html
13:24:28 <shapr> tried that one?
13:24:29 <hornby> Yes. 
13:24:33 <shapr> sucks?
13:24:51 <hornby> Everything is centered on simple XML to HTML transforms. Not what I'm looking for. I need a reference and a tutorial, not a cheap transform script :(
13:25:00 <shapr> what are you looking for?
13:25:42 <shapr> specifically, what task do you wish to accomplish?
13:25:49 <hornby> General XML handling ... parse an XML document so I can display parts of it. then, allow changing of that xml document
13:26:19 <hornby> Basically: XML -> internal data structures -> XML
13:27:12 <hornby> If that makes sense? 
13:27:23 <shapr> yah I think so
13:27:29 <shapr> can you give me a use case?
13:27:47 <hornby> Hm. 
13:28:36 <hornby> Okay, so I want to create a simple to do list :) I'll start from scratch. I create a node with text. Below that, more nodes with text. Below those, more nodes. I want to then save this information 
13:28:50 <shapr> ok
13:29:04 <shapr> you want your datatypes to be able to output themselves as xml, right?
13:29:10 <hornby> Yeah, basically
13:29:22 <shapr> you know type classes in haskell?
13:29:56 <hornby> I think I've seen um, don't know how to use um. I've been focussing on xml, haven't really looked at how the internals might work yet :)
13:30:38 <shapr> hm
13:30:46 <shapr> have you read this: http://www.cs.york.ac.uk/fp/HaXml/icfp99.html ?
13:30:51 <hornby> ursj
13:30:52 <hornby> er yeah
13:31:02 <shapr> did it help?
13:31:16 <shapr> hah, you use qwerty
13:31:17 <hornby> No :) Its all about XML to HTML transforms too. 
13:31:31 <hornby> What's wrong with qwerty? :)
13:32:00 <shapr> I don't use it.
13:32:05 <shapr> so I get to tease those who do.
13:32:07 <hornby> dvorak?
13:32:08 <shapr> yup
13:32:15 <hornby> Since when? 
13:33:06 <hornby> hrm, maybe it'd be easier to write my own XML handling functions
13:33:16 <shapr> since 1992
13:33:29 <shapr> actually, HaXml can do what you want.
13:34:00 <hornby> shapr: Yeah, I'm pretty sure it CAN, I just don't know how. And at this point, my only option is to spend a dozen hours staring at the source
13:34:12 <shapr> you know DTDs?
13:34:31 <hornby> shapr: Actually, I don't know much about xml. I'm familiar with the basic concept though
13:35:02 <shapr> you need to write a Document Type Description for your save format, and then compile that into Haskell data types.
13:35:37 <hornby> okay. 
13:36:12 <hornby> I've actually got one here that I might borrow for now
13:36:24 <shapr> cool
13:38:33 <hornby> DtdToHaskell.hs
13:38:57 <hornby> -- This program is provided to convert an XML file containing a DTD
13:38:58 <hornby> -- into a Haskell module containing data/newtype definitions 
13:38:59 <hornby> awesome
13:40:37 <hornby> okay, I'll poke at this for a bit. thanks
13:40:43 <shapr> sure, np
13:47:04 <hornby> ghc-5.02.2: can't find module `IOMisc'
13:47:16 <shapr> did you try importing it?
13:47:17 <hornby> oh wait, I dont have to compile it
13:47:38 <hornby> its already part of the package. I'm going to need a vacation after this
13:48:30 <shapr> hah
13:49:42 <hornby> hrm, it didn't work though .... 
13:49:54 <jewel> The haskell go guy is going to send me his code
13:49:57 <hornby> giving up is tempting
13:54:01 <shapr> jewel: awesome!
13:56:58 <hornby> hehe, it worked. 
13:57:29 <shapr> determination wins again!
13:57:40 <hornby> I feel validated. 
13:57:43 <hornby> heh
13:57:45 <shapr> hah
13:57:49 <shapr> funny :-)
14:01:38 <jewel> hehe
14:05:07 <jewel> night all
14:05:11 <hornby> night
14:05:15 <shapr> g'night jewel
14:09:58 <shapr> hmm
14:09:59 <shapr> crap
14:11:11 <hornby> DtdToHaskell is damn cool
14:20:26 <hornby> data Priority = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
14:20:32 <hornby>     deriving (Eq,Show) 
14:20:49 <hornby> test.hs:18: Illegal data/newtype declaration
14:21:45 <hornby> What's wrong with that?
14:22:05 * shapr dunno
14:23:00 <hornby> mm
14:23:19 <shapr> can you split that out into its own file and try to make it work?
14:24:02 <shapr> hornby: oh I get it
14:24:09 <hornby> shapr: ?
14:24:10 <shapr> hornby: change those to One | Two | Three
14:24:18 <hornby> oh
14:24:20 <shapr> see if that works
14:25:09 <hornby> yup. neat. thans
14:25:12 <hornby> thanks
14:29:16 <shapr> cool
14:30:07 <hornby> Uh oh. There are no errors. I don't know what to do  now .... 
14:30:17 <shapr> run it!
14:30:26 <hornby> :)
14:34:25 * shapr is confused about algebraic types
14:34:52 <shapr> ohh
14:34:56 <hornby> wow, I did something that didn't make an error: Tree []
14:38:13 <hornby> Now I have to understand this type:
14:38:48 <hornby> data Node_Attrs = Node_Attrs { nodeDone :: (Maybe Done), nodePriority :: (Maybe Priority)} deriving (Eq,Show)
14:41:50 <shapr> ahhaaa
14:42:50 <shapr> looks like your type says that done="" and priority="" are optional attributes in your DTD
14:45:11 <hornby> yes
14:45:28 <hornby> I can build a tree like so : Tree []
14:45:35 <hornby> I I should be able to do something like: 
14:45:52 <hornby> Tree ( [ Node (???) "DATA" [] ] )
14:46:23 <hornby> A tree with one node and some data. The Node_Attrs go where the (???) is ... I just don't know how the sytax
14:46:35 <hornby> the Gentle Introduction is no help. 
14:46:39 <hornby> I guess I'll read the report
14:47:16 <shapr> Node_Attrs (nodeDone Nothing) (nodePriority Nothing)
14:47:20 <shapr> does that work?
14:48:08 <hornby> hm no
14:48:10 <hornby> interesting though
14:48:28 <shapr> afaiu, Maybe can return Just <result> or Nothing
14:48:35 <shapr> oh
14:48:38 <shapr> er
14:49:02 <shapr> so it should have Nothing or Done in that nodeDone
14:49:17 <shapr> but I think you have to throw it through the Maybe monad, and I don't know how to do that at the moment.
14:49:48 <hornby> Expected type: Maybe Done
14:49:58 <hornby> Inferred type: Done
14:50:00 <hornby> Tree ([Node ( Node_Attrs Yes One ) "DATA" [] ])
14:50:14 <hornby> well I'll look up Maybe then
14:51:16 <shapr> hm
14:51:30 <shapr> what type alias should I use for negative numbers
14:51:46 <shapr> I need to figure out how to make useful type constructors
14:52:09 <hornby> Haskell is much trickier than the tutorials make it out to be
14:52:38 <shapr> It might be much easier than something like Python if you come from a math background.
14:52:40 <shapr> I don't though :-)
14:52:51 <hornby> At first it was like: "This is simple, easy and obvious" ... now its like: "this is impossibly complex, strange, and unintiuitive"
14:53:01 <hornby> Ditto
14:53:15 <shapr> Python is also non-intuitive to people who have never programmed before
14:53:23 <shapr> but it's much more intuitive than something like C
14:53:27 <shapr> or Java
14:53:29 <hornby> At one point the throught crossed my mind to write this thing in Python ... that would be sooo much easier for me right now, but it feels too much like giving up
14:53:39 <shapr> I understand.
14:53:47 <hornby> Python is really quick to learn though too. I learned OO on Python
14:53:55 <shapr> so did I
14:54:20 <shapr> Haskell is harder to learn, but I think it is also much more powerful once you really understand it.
14:54:40 <shapr> some everyday haskell stuff is impossible in Python
14:54:56 <hornby> Thats what it looks like
14:59:12 <hornby> Whats Just?
14:59:23 <shapr> Just that
14:59:33 <shapr> Maybe Done returns Just Done or Nothing
14:59:41 <shapr> at least, I think that's true
14:59:49 <shapr> it's a way of transparently handling errors
14:59:57 <hornby> <interactive>:1: Data constructor not in scope: `Maybe'
15:00:13 <shapr> you probably need to import it.
15:00:24 <Igloo> It's not a data constructor
15:00:42 <Igloo> data Maybe a = Just a | Nothing
15:00:52 <hornby> The functions maybe and either are found in
15:00:52 <hornby> the Prelude.
15:00:52 <Igloo> I'm trying to think if it's a type name or something else
15:01:04 <hornby> but thats a lowercase m
15:02:47 <hornby> Under what circumstances does Maybe return Nothing?
15:03:12 <Igloo> Maybe isn't a function - it doesn't return anything
15:03:49 <hornby> oh
15:03:52 <hornby> Duh
15:05:19 * shapr fights the type system
15:08:24 <hornby> data Node_Attrs = Node_Attrs { nodeDone :: (Maybe Done), nodePriority :: (Maybe Priority)} deriving (Eq,Show)
15:08:51 <hornby> This is the same as Node_Attrs (Maybe Done) (Maybe Priority) right?
15:09:49 <Igloo> The former will define functions like nodeDone :: Node_Attrs -> Maybe Done and allow you to alter values easier
15:10:02 <Igloo> But they both define the same type
15:11:10 <hornby> blah = Node_Attrs Nothing Nothing ? 
15:11:28 <hornby> wtf that worked
15:11:54 <shapr> cool
15:12:39 <hornby> but ....  Node (Node_Attrs Nothing Nothing) doesn't
15:12:55 <shapr> what's the type of Node?
15:13:02 <hornby> oh wait, yes it does
15:13:51 * shapr wrestles with unifying types
15:14:05 * Heffalump waves
15:14:11 <shapr> hiii Heffalump!
15:14:14 <shapr> what's up?
15:14:14 <hornby> !!! IT WORKED
15:14:18 <shapr> hornby: awesome :-)
15:14:22 <hornby> possibly!
15:14:26 <hornby> DTD_tree> Tree [ Node (Node_Attrs Nothing Nothing) (Just (Data "DATA")) [] ]
15:14:26 <hornby> Tree [Node (Node_Attrs{nodeDone=Nothing,nodePriority=Nothing}) (Just (Data "DATA")) []]
15:14:40 <Heffalump> unification?
15:15:04 <shapr> er, yeah...
15:15:17 <shapr> remember what I was talking about last night?
15:15:21 <Heffalump> yep
15:15:25 <shapr> a string has a type byte
15:15:29 <Igloo> Do you mean unioning?
15:15:36 <shapr> oh, yeah.
15:16:07 <shapr> anyone mind if I paste ten lines?
15:16:08 <Heffalump> oh, right.
15:16:14 <Heffalump> that's not quite the same thing :-)
15:16:28 <Igloo> Not I
15:16:36 <shapr> -- I guess I need a unification type?
15:16:36 <shapr> --type BList = []
15:16:36 <shapr> type BString = String
15:16:36 <shapr> type BInt = Int
15:16:36 <shapr> type BFloat = Float
15:16:37 <shapr> type BLongInt = Integer
15:16:39 <shapr> type BNeg = Int
15:16:41 <shapr> type BLongNeg = Integer
15:16:43 <shapr> data BananaType = BananaString BString | BananaInt BInt | BananaFloat BFloat | BananaLongInt BLongInt
15:16:58 <shapr> I don't know why I have to do "type BString = String"
15:17:04 <Heffalump> so BananaType is a union type
15:17:05 <shapr> but otherwise, those types won't compile
15:17:08 <shapr> right.
15:17:12 <shapr> question I have..
15:17:18 <Heffalump> what, even if you put BananaString String ?
15:17:27 <Heffalump> (instead of BananaString BString)
15:17:29 <shapr> afaict, yes
15:17:33 <Heffalump> what's the error?
15:18:24 * shapr blinks
15:18:25 <shapr> um
15:18:29 <shapr> it works fine now :-)
15:18:31 * shapr is way confused
15:19:08 <shapr> that answers my question
15:19:23 <shapr> I think
15:19:36 <Igloo> I think the only place type synonyms make a difference is when defining instances
15:19:38 <shapr> yes, it does.
15:20:00 <shapr> I was trying to figure out if this is correct or not: BananaList [BananaType]
15:20:09 <shapr> as part of the union type
15:20:12 <Heffalump> yep, it should be
15:20:12 <shapr> obviously, it is.
15:20:44 <shapr> I'm not really sure how to go about dispatching to the constructors though
15:22:00 <Heffalump> wdym "dispatching"?
15:22:48 <shapr> I mean figuring out which constructor to call depending on the type byte in the string
15:22:51 <shapr> but suddenly
15:23:00 <shapr> it looks like a set of guards will be simple enough
15:23:55 <Heffalump> you don't really "call" constructors, you just use them
15:24:15 <shapr> I'm not quite out of the OO mindset yet.
15:24:17 <Igloo> Do you call functions?
15:24:31 <shapr> not often.
15:24:36 <shapr> :-)
15:24:52 <Heffalump> igloo: yes
15:25:05 <Heffalump> since some evaluation happens
15:25:12 <Heffalump> constructors just make data values
15:26:20 <Igloo> So you would call (\_ -> 5)?
15:26:46 <Igloo> (afk)
15:27:56 <Heffalump> a function
15:28:26 <shapr> crap
15:28:33 <shapr> HUnit wants types that have Show
15:28:39 <Igloo> back - you're answering a different question to the one I asked
15:28:41 <shapr> and Eq
15:28:47 <shapr> crappity crap.
15:29:00 <shapr> how do I pull the String out of a BananaString ?
15:29:06 <shapr> pattern matching?
15:29:08 <shapr> hm
15:29:12 <Igloo> Yes
15:29:15 <hornby> instrance XmlContent Tree where << Tree is derived from XmlContent? 
15:29:22 <Igloo> You probably want to derive Show at least for testing purposes
15:29:29 <Heffalump> igloo: OIC. Yes, of course.
15:29:34 <Heffalump> oh, errm. well.
15:29:39 <Heffalump> maybe not.
15:29:57 <Igloo> :-)
15:30:13 <Heffalump> I'd say it's a "call" if you have a function defined elsewhere that you refer to by name
15:30:36 <shapr> I wonder if I'm going in the wrong direction with this.
15:30:38 <Heffalump> so let f = \_ -> 5 in f 3
15:30:40 <Heffalump> is a call
15:30:41 * Igloo is of the opinion that defining a data type also defines some functions in a similar way to how records do
15:30:46 <Heffalump> but (\_ -> 5) 3 isn't
15:31:04 <Heffalump> but in the case of records the selector functions actually do some evaluation
15:31:12 <Heffalump> whereas a constructor does just that, constructs
15:31:19 <shapr> I'd like to be able to transparently exchange your average Int with a Python implementation of this same protocol
15:31:31 <Igloo> OK, I was actually using that as shorthand for f where you have defined "f _ = 5"
15:31:35 <Heffalump> shapr: you need to be careful about sizes of things
15:31:38 <shapr> huh?
15:31:39 <shapr> how so?
15:31:42 <Heffalump> igloo: ok, well then I'd say it was a "call"
15:32:13 <shapr> I'm just wondering whether BananaType will get in the way of swapping Ints with another computer.
15:32:23 <Heffalump> shapr: make sure that the Python type you use can express the entire range of Haskell's Int and vice-versa
15:32:28 <Heffalump> no, it shouldn't, why would it?
15:32:34 <shapr> maybe I should just make a BananaEncodable class instead, and put Int, etc as instance.
15:32:38 <shapr> er, instances
15:32:47 <shapr> I don't know :-)
15:33:16 <Igloo> The issue is whether each can represent the range needed by the banana spec, surely?
15:33:19 <shapr> yah, I think the banana types are safely swappable
15:33:34 <Igloo> Which Haskell's probably can't as they are probably 32bit vs 29bit(ish)
15:33:36 <shapr> no worries there.
15:33:44 <shapr> 29bit?
15:33:53 <shapr> are you thinking of elisp? :-)
15:33:59 <Igloo> I think that is what Int is guaranteed to, yes
15:34:04 <Igloo> No
15:34:13 <shapr> Haskell Int is 29bits?
15:34:28 <shapr> hm
15:34:30 <shapr> that's useful to know.
15:34:54 <Igloo> http://research.microsoft.com/Users/simonpj/haskell98-revised/haskell98-report-html/basic.html
15:34:55 <Heffalump> 29bit minimum defined by the standard, I think
15:35:04 <Heffalump> but they don't necessarily overflow beyond that
15:35:08 <Heffalump> (why is it 29 bit?)
15:36:03 <Igloo> No idea
15:36:59 <Igloo> Anyway, bedtime
15:37:04 <shapr> g'night Igloo
15:37:09 <Igloo> Night
15:38:17 <Heffalump> night
15:39:02 * shapr gets lost in the type system
15:40:22 <shapr> arggg
15:40:29 <hornby> ARGGG!
15:40:37 <shapr> ARGLE
15:41:21 <shapr> this is confusing to me.
15:44:10 <hornby> are there any haskell source viewers? you know, that draw pretty trees or something?
15:44:21 <shapr> emacs?
15:44:35 <hornby> uh 
15:44:41 <hornby> Emacs draws trees?
15:44:52 <shapr> what kind of trees are looking for?
15:45:33 <hornby> shapr: I'm just trying to find an easy way to get a handle on these 4500 lines of code
15:46:32 <shapr> the haskel-decl-scan minor mode is very useful for that
15:46:51 <hornby> mmm 
15:47:39 <hornby> I don't have emacs on here. 
15:48:00 <shapr> I use emacs for my irc client.
15:48:00 <hornby> I'll just vim it
15:48:03 <shapr> I'm an addict :-)
15:48:03 <hornby> I know :)
15:49:44 <hornby> Reading and understanding the entire HaXmL package will solve my problem, right? 
15:50:16 <shapr> I think you should go through the HaXml tutorials again now that you understand more about it.
15:50:29 <shapr> w00, I can encode Ints!
15:50:36 <hornby> maybe thats a good step. Sweet. 
15:50:58 <hornby> how far along are you now?
15:51:38 <shapr> two of seven types encode correctly
15:51:48 <hornby> Awesome. 
15:52:08 <hornby> The rest should fall into place quickly? Mmm! I'm going to make some soup
15:53:25 <shapr> I hope the rest falls into place quickly
15:53:28 <shapr> I need to refactor alredy
15:53:52 <hornby> Going to refactor before you move on to the other types?
15:54:49 <shapr> yah, if I can figure out good things to do
15:55:01 <shapr> refactoring is a very important part of developing
15:55:11 <hornby> I agree
15:55:18 <shapr> each time you clean up your code, you have a better chance of writing something that works correctly.
15:55:51 <hornby> I find I never truly understand a problem until I code a solution to it. Then I always see ways of improving my implementation
15:58:19 <hornby> soup time
15:58:28 <shapr> yah, same here.
15:58:39 <shapr> most managers don't understand refactoring though
16:02:16 * shapr cackles happily
16:05:05 <hornby> Well, if it works, why rewrite it? Waste of time
16:05:18 <hornby> :)
16:05:24 <shapr> I've heard that way too many times.
16:05:28 <hornby> I want to cackle happily 
16:05:39 <shapr> go for it.
16:05:54 <shapr> I only cackle happily when my code is working.
16:05:56 <hornby> Or rather, I want a reason to cackle happily :)
16:06:00 <shapr> ahh I see
16:06:04 <hornby> Ditto. 
16:06:11 <hornby> Otherwise I curse and swear
16:06:23 <shapr> yah, same here
16:06:57 <hornby> I think I'm going to go read for a bit, clear my mind. good luck with banana :)
16:07:01 <shapr> ok, have fun
16:46:56 <shapr> is there a struct module for Haskell?
16:47:11 <Heffalump> to do what?
16:47:30 <Heffalump> we have a PhD student working on refactoring Java code, btw
16:47:35 <shapr> awesome :-)
16:48:03 <shapr> banana.py does struct.pack as big-endian double
16:48:10 <shapr> C struct
16:48:14 <shapr> basically
16:48:17 <Heffalump> errm.
16:48:31 <Heffalump> C structures are basically multiple values put together into a single type
16:48:46 <Heffalump> so the equivalent in Haskell is just multiple parameters to a datatype constructor, or a tuple, or a record
16:49:07 <shapr> that's how banana.py packs a Float
16:49:27 * shapr thinks about that
16:49:48 <Heffalump> well, all you need to know is what the order of things will be in the encoded string, so as to extract the values correctly
17:14:03 <shapr> oh, I get it.
17:14:05 <shapr> I think.
17:19:03 <shapr> I need to encode as wel.
17:22:16 <hornby> the best part of writing a program called haste is that you get to do ghc --make haste.hs
17:22:23 <shapr> hah!
17:22:38 <shapr> you *must* put that into the README if you ever release it.
17:24:45 <hornby> :)
17:25:18 <shapr> hm, is a FiniteMap a dictionary in Python?
18:21:00 <shapr> I need to read a Double as its bit level representation, in network order.
18:21:04 <shapr> I wonder if that's possible.
18:21:16 <shapr> well, I wonder if it's easy to do in Haskell.
