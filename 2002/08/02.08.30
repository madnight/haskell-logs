03:19:01 <jewel> shapr: morning
03:36:03 <jml> 'ello
03:43:11 <shapr> g'morning jewel
03:43:13 <shapr> hi jml
03:43:24 <jml> hello
03:43:42 <shapr> yay, the icfp list is up!
03:43:47 <shapr> thanks Pseudonym!
04:00:53 <jewel> so, how many hours till it starts?
04:00:59 <jewel> and what's our plan?
04:01:38 <pesco> So who's in now anyways?
04:03:08 <jewel> dunno, me and shapr for sure
04:05:23 <pesco> OK, me and loom2 for sure, but he missed to contact Pseudonym about CVS access.
04:05:36 <pesco> I'm firing off a mail to Ps. in his name now.
04:07:09 <jewel> cool stuff
04:07:36 <jewel> now we just need to coerce heffalump
04:09:41 <shapr> Igloo is also a possible
04:10:05 <shapr> we know we have four definites
04:10:16 <shapr> are all four on the mailing list?
04:10:37 <dark> Wasn't four the maximum, anyway?
04:10:51 <shapr> nah, no max
04:10:58 <shapr> not according to contest rules
04:20:12 <dark> Are you going to be on #haskell while you participate?
04:20:43 <shapr> we can move to #haskell-icfp if that's a problem :-)
04:20:48 <pesco> I think loom2 said something about not being able to get on the mailing list. Might itstill be broken?
04:20:56 <dark> shapr: I meant I'd like to watch :)
04:21:02 <shapr> dark: ok, ok
04:21:07 <shapr> pesco: it appears to work as of this morning
04:21:09 <dark> I'm going to be working this weekend but I could have an irc window open.
04:21:14 <pesco> Ok.
04:25:07 <dark> It's difficult to choose between a mutable array, immutable array, or FiniteMap :)
04:26:26 <dark> I wonder how hard ghc tries to modify immutable arrays in place.
04:26:41 * jml couldn'
04:26:47 * jml couldn't get ghc to compile on gentoo
04:26:53 <Heffalump> if they're immutable, you shouldn't be modifying them...
04:26:59 <pesco> jml: what's the problem?
04:27:20 <jml> can't remember actually, I'll try again now
04:27:35 <jml> (kind of involved in nailing down a bug in python standard library)
04:27:46 <pesco> jml: Python? Er.
04:27:55 <dark> Heffalump: Yeah but replacing them with a similar array is almost the same.
04:28:06 <jml> pesco: it's lambda syntax is horrid, but other than that, it's fairly nice
04:28:18 <Heffalump> ah, right, yeah
04:28:26 <jml> pesco: I *did* try to convince my mate to do this project in haskell, but he only laughed.
04:28:33 <dark> Heffalump: If I throw away the old array and use the new one from then on, ghc could optimize that to a modify-in-place. 
04:29:19 <Heffalump> yeah
04:29:33 <Heffalump> I'm not sure how much it optimises that kind of thing
04:30:16 <dark> I could separate my data into changes-rarely, changes-often, and moves-around-a-lot categories, and use all three kinds.
04:31:39 <dark> Hmm, there might not be much point, if I have to query both arrays to get a useful answer, then I'll have to do all the querying inside the mutable array's monad anyway :)
04:32:09 <dark> Bah, Haskell makes me think about data structures.  Maybe I should wander over to perl and use hashes for everything :-)
04:32:24 <jml> pesco: shall I paste the compilation errors
04:33:30 <jml> #error GHC untested on this architecture
04:33:50 <pesco> jml: What architecture are you building on?
04:33:50 <jml> in StgTypes.h:45 
04:33:58 <jml> intel linux
04:35:03 <pesco> jml: Huh, what does uname -a say?
04:35:18 <jml> Linux sting 2.4.19-gentoo-r5 #3 Thu Aug 8 12:52:48 EST 2002 i686 GenuineIntel
04:35:29 <pesco> Ew, wtf?
04:35:34 <dark> jml: Does it say anything else on that line?
04:35:45 <jml> dark: yep, I'll paste it all
04:36:16 <jml> StgTypes.h:45: #error GHC untested on this architecture: sizeof(unsigned int) != 4
04:36:47 <jml> then there's others that say sizeof(void*) < 8 and sizeof(void*) != 4 or 8
04:36:59 <jml> which I think is BS
04:38:09 <dark> hmm, what does config.h say?
04:38:41 <pesco> Remembering the latest discussion of C char on haskell-i18n, that sounds like you have a big char. What compiler are you using?
04:38:41 <jml> hang on, it'll take me a bit to find it ('tis a gentoo ebuild)
04:38:46 <dark> It's complaining that macros like SIZEOF_UNSIGNED_INT aren't set or are set wrong.  They're supposed to have been set by "configure" and put into config.h
04:38:53 <dark> find -name is your friend :)
04:39:13 <jml> gcc version 2.95.3 20010315 (release)
04:41:52 <JC_freak> hey pplz wats up?
04:42:31 <JC_freak> anyone in here?
04:42:45 <dark> jml: Do you have a config.log file?
04:43:42 <jml> yep... on the phone .. bs
04:44:04 <dark> jml: Look for a "checking size of unsigned int" log entry :)
04:44:27 <dark> JC_freak: we're diagnosing a problem compiling ghc.
04:44:47 <JC_freak> .... ohhh ok
04:46:15 <JC_freak> so i guess all of you guys are pretty busy then...
04:50:03 <shapr> JC_freak: what's your question?
04:54:18 <JC_freak> well its kinda long
04:55:26 <JC_freak> well the thing is i'm trying to find the best method of finding the diagonals of a grid (i.e. a list of strings)
04:56:04 <JC_freak> i've done it by adding spaces to the grid so the diagonals turn out to be verticals
04:56:18 <JC_freak> but i was wondering if there might be an easier way
05:00:23 <dark> You're talking about a list of strings that are all the same length?  And you're treating them as a two-dimensional array?
05:00:43 <pesco> Consider Array (Int,Int) Char.
05:01:23 <JC_freak> yes
05:01:44 <JC_freak> so something like
05:01:53 <JC_freak> h o g h j
05:01:58 <JC_freak> r e t h j
05:02:06 <JC_freak> k l l o r
05:02:16 <JC_freak> k h d l p
05:02:21 <JC_freak> o o p r o
05:02:33 <JC_freak> but these would be 5 strings
05:03:11 <JC_freak> and i want to turn these 5 strings into a list of strings which represent the diagonals
05:03:26 <dark> Oh, all the diagonals?  Not just the one through the center?
05:03:48 <JC_freak> i.e "h","or","get","htlk"...etc
05:04:11 <dark> Diagonals in a strange direction, too :)
05:04:31 <JC_freak> well i need to do both ways actually
05:05:18 <JC_freak> the "get" is meant to be "gek"
05:06:09 <JC_freak> i've done it by adding spaces so that the diagonals line up vertically
05:06:44 <JC_freak> but would anyone know of an even better way (i.e easier)
05:07:01 <dark> Well it would probably easier if you have them in an array.
05:07:28 <JC_freak> array...ok
05:07:38 <JC_freak> i haven;t done arrays in haskell before
05:07:41 <dark> But actually... you could address this grid as if it were an array :)  Like (grid !! y || x)
05:07:54 <dark> Er, !! for both of these.  That's the list index operator.
05:08:07 <JC_freak> yes i know that bit
05:08:19 <JC_freak> what does the y and x represent?
05:08:27 <JC_freak> dimension?
05:08:43 <dark> y would be number of characters down, and x the number of characters across, starting with the top left being (0, 0)
05:09:08 <dark> So (grid !! y) selects the yth list, and ((grid !! y) !! x) selects the xth character from it.
05:09:25 <JC_freak> hmmm
05:09:46 <JC_freak> so ((grid !! 0) !! 1) = r
05:09:52 <JC_freak> from the example above
05:10:11 <dark> Then you could get for example the "hello" diagonal with a comprehension, like this: [ grid !! y !! x | x <- [0 .. size], y <- [0 .. size], x == y ]
05:10:16 <dark> JC_freak: yep
05:10:24 <dark> I haven't used comprehensions much, this example may be wrong :)
05:11:03 <dark> Hmm
05:11:06 <JC_freak> ohhh
05:11:14 <Igloo> [ grid !!xy !! xt | xy <- [0..size ] is simpler  :-)
05:11:24 <Igloo> Give or take typoes
05:11:30 <dark> Igloo: Yeah, it's overkill :)
05:11:40 <dark> But, if you want a variety of diagonals...
05:11:58 <Igloo> Then you want xy+c  :-)
05:12:43 <dark> Hmm, I forgot, can you do simple bindings in a comprehension?
05:12:58 <Igloo> You can have lets in them
05:13:02 <dark> Like, [ grid !! y !! x | x <- [ 0 .. size ], y = x ]
05:13:17 <Igloo> [ grid !! y !! x | x <- [ 0 .. size ], let y = x ]
05:13:23 <JC_freak> would you like to look at what i've done?
05:13:33 <JC_freak> i can send u my code
05:14:06 <dark> Igloo: That looks nice :)  Then you could have various expresions for y, and then add an y >= 0, y < size to be able to get shorter diagonals.
05:14:30 <dark> JC_freak: Can you put it up for http?
05:14:45 <JC_freak> ummm ok
05:14:53 <JC_freak> gimme a few minutes
05:15:09 <JC_freak> the aim of this is to create a find-a-word
05:15:16 <dark> JC_freak: I suspected as much :)
05:15:44 <JC_freak> =)
05:15:46 <dark> With arrays it would actually look pretty similar, except that you would have arr ! (x, y) on the left side instead of the grid with two !!
05:18:50 <dark> You could turn the grid into an array with listArray ((1, 1), (size, size)) (concat grid)
05:19:31 <dark> (1, 1) and (size, size) would be the boundaries, so you'd get an array that starts at (1, 1) instead of (0, 0).  Depends on what you want really :)
05:21:15 <Igloo> But you could do listArray ((0,0),(size-1,size-1)) (concat grid) if you wished
05:21:18 <JC_freak> i want to do it in some way so that i can easily find the coordinates afterwards
05:21:46 <JC_freak> is listArray a built in function?
05:22:12 <dark> listArray is in the Array module.
05:22:21 <JC_freak> the 3 files are http://www.cse.unsw.edu.au/~vtra238/WordSearch1.5.hs
05:22:31 <JC_freak> http://www.cse.unsw.edu.au/~vtra238/WordSearchTypes.hs
05:22:38 <JC_freak> http://www.cse.unsw.edu.au/~vtra238/GridCheck.hs
05:22:53 <JC_freak> oh ok
05:24:17 <jml> back
05:25:15 <jml> pesco: what should checking size of unsigned int say?
05:26:56 <dark> jml: Preferably it should say "4"
05:27:17 <jml> configure:3582: checking size of unsigned int
05:27:17 <jml> configure:3601: gcc -o conftest -march=i686 -O3 -pipe   conftest.c  1>&5
05:27:52 <dark> Hmm, that looks like a log entry for a failed check.
05:28:00 <dark> Otherwise it would say "result: " something
05:28:13 <dark> Does it print the code it tried to compile after that line?
05:28:50 <dark> JC_freak: I don't have read permission for WordSearchTypes.hs :)
05:28:59 <jml> dark: no
05:29:24 <JC_freak> oops
05:29:26 <JC_freak> sorry 
05:29:32 <JC_freak> should be ok now dark
05:30:08 <jml> hmm, config.h has SIZEOF_UNSIGNED_INT 4
05:31:18 <dark> jml: Hmm, then it looks like some file is including StdTypes.h without including config.h first.
05:31:22 <dark> Er, StgTypes :)
05:32:52 <dark> Hmm, would the failing file be called GranSim.c by any chance?
05:33:07 <jml> hang on
05:38:33 <jml> no, mkNativeHdr.c
05:41:12 <dark> jml: Hmm.  Then the only thing I can think of is that it's picking up the wrong config.h
05:41:38 <jml> hmmm.. i look at it tomorrow I think. I have an early start tomorrow.
05:41:46 <dark> jml: Do you have any config.h file in a default include directory?
05:41:49 <jml> dark, pesco: thanks for your help
05:41:54 <jml> dark: not sure.
05:42:03 <dark> jml: "locate config.h | grep /usr" :-)
05:42:30 <jml> locate: /var/spool/locate/locatedb: No such file or directory
05:42:33 <jml> heh
05:42:34 <dark> Oh, heh.
05:43:18 <dark> Anyway, you might want to check the directories listed in the compiler's -I flags, and see if one of them has a config.h
05:43:28 <jml> yep, will do.
05:43:49 <dark> JC_freak: I looked at the files but I'm not sure why :)
05:47:07 <JC_freak> so...wat do u think? can u help me improve it? plz
05:47:18 * shapr bounces
05:48:09 <dark> JC_freak: I think you can get rid of a lot of duplication, by making a generic function that searches for a word in a list of strings.
05:48:32 <dark> JC_freak: Then you can feed it in various ways, like findWord word grid, findWord (reverse word) grid, findWord word (transpose grid)
05:48:42 <dark> And of course findWord word (diagList grid)
05:49:32 <dark> This works fine if you just want a Bool result.  If you want to know the coordinates then it gets more difficult.
05:50:22 <dark> You would have to take the coordinates returned by findWord and translate them back :)  So findWord word (transpose grid) would give you (y, x) instead of (x, y)
05:52:01 <JC_freak> uh huh
05:52:18 <JC_freak> yea i have that findWord function
05:52:36 <JC_freak> and the coordinates are fine with the vert and horizontal
05:52:50 <JC_freak> i'm just having trouble with the diagonal coord
05:53:16 <JC_freak> that y i was wondering if there was a way such that it would be easier to check the coordinates
05:54:11 <dark> JC_freak: Hmm but you have findWord at the top, so that you need different functions for searching in different directions.
05:54:19 <dark> JC_freak: I mean a findWord that only searches horizontally.
05:54:37 <dark> JC_freak: Then you can search vertically with findWord word (transpose grid)
05:54:59 <dark> And then adjust the results.
05:56:17 <JC_freak> well how would i implement the same findWord to find diagonal (if i could)
05:57:36 <dark> Well you have a function that returns a list of diagonals, right?
05:58:08 <JC_freak> ohh u mean that
05:58:43 <JC_freak> but the thing is the coordinates gets messed up when i use the diagList
05:58:52 <dark> Right, you need to translate them back somehow.  Hmm.
05:59:19 <dark> If the diagList is lower-left to upper-right diagonals, then (x, y) in the diagList would be, um...
05:59:21 <JC_freak> yea, i've been trying all day
06:00:09 <JC_freak> if u run diagList on ["cat","dog","mat"]
06:00:49 <JC_freak> it should return ["-cat-","--dog-","---mat-"]
06:01:13 <JC_freak> umm wait a sec
06:01:15 <JC_freak> thats not right
06:03:04 <JC_freak> its supposed to be ["cat-","-dog-","--mat-"]
06:03:27 <JC_freak> c a t -
06:03:32 <JC_freak> - d o g -
06:03:37 <JC_freak> - - m a t -
06:07:52 <dark> Oh, I'm thinking of a diagList that would return ["c", "da", "mot", "ag", "t"]
06:08:59 <JC_freak> well thats what i'm trying to do
06:09:02 <JC_freak> but i haven't figured that out yet
06:09:05 <JC_freak> i could do it using !!
06:09:24 <Heffalump> does anyone know how well .o and .hi files that are compiled with one version of GHC work with another version?
06:09:29 <JC_freak> but i think it might be too long
06:09:47 <JC_freak> coz i have to check sub grids 
06:10:09 <dark> I'm thinking the conversion function might look like this:
06:10:09 <dark> fromDiag (x,y) | x + y < size  = (x, y - x)
06:10:10 <dark> fromDiag (x,y) | x + y >= size = (x + y - size, size - 1 - x)
06:10:17 <dark> But I'm not sure if I'm off by one somewhere :)
06:10:36 <dark> Heffalump: The answer in the ghc docs is that they don't :)
06:11:26 <Heffalump> damn
06:11:28 <JC_freak> dark: are u  using the list ["c", "da", "mot", "ag", "t"]
06:11:39 <JC_freak> or my list with the spaces
06:11:41 <Heffalump> oh well, that means that I might as well leave my HaXml package tied to the version of ghc it was built with
06:11:56 <dark> JC_freak: The first.
06:12:31 <dark> JC_freak: I'm assuming coordinates where "c" is (0,0), btw.
06:13:00 <JC_freak> and so "da" is (1,0)
06:13:23 <Heffalump> btw, there are solutions for diagonalising that don't involve !!, IIRC
06:14:12 <JC_freak> solutions as in someones' work
06:14:17 <dark> Jc_freak: Well, the "d" is (0, 1) and the "a" is (1,1).  I'm counting x across and y down :)
06:14:34 <JC_freak> umm ok
06:14:50 <Heffalump> well, ways of writing the program
06:14:57 <JC_freak> but i think the "a" is supposed to be (0,1)
06:15:12 <JC_freak> and "d" is (1,1)
06:15:28 <JC_freak> coz its -d---
06:15:35 <JC_freak> -d---
06:15:38 <JC_freak> a----
06:15:58 <JC_freak> i mean "d" is (1,0)
06:16:12 <dark> This is confusing :)
06:16:28 <JC_freak> heh
06:16:32 <JC_freak> tell me about it
06:17:14 <dark> Heffalump: This is not just about the center diagonal, but about a list of all diagonals. 
06:17:32 <JC_freak> c a t
06:17:35 <JC_freak> d o g
06:17:38 <JC_freak> m a t
06:18:06 <JC_freak> ok so c (0,0) a (1,0) t (2,0)
06:18:09 <JC_freak> etc
06:19:06 <dark> JC_freak: I'm thinking of a diagList that transforms that to ["c", "da", "mot", "ag", "t"], then a findWord "ag" (diagList grid) that finds "ag" starting at (0, 4), and a fromDiag that transforms (0, 4) back to (1, 3).
06:19:30 <dark> Of course it's all different for diagonals in the other direction :)
06:19:52 <JC_freak> yea tru
06:20:20 <dark> Sorry, (1, 2)
06:20:24 <dark> The final answer, I mean :)
06:20:36 <dark> Err...
06:20:43 <JC_freak> yea  thats right
06:20:46 <dark> I keep making these mistakes between 1-based and 0-based coordinates.
06:20:52 <dark> So "ag" would be found at (0, 3)
06:21:35 <JC_freak> isn;t it (1,2)
06:21:46 <JC_freak>   0 1 2
06:21:51 <JC_freak> 0 c a t
06:21:57 <JC_freak> 1 d o g
06:22:00 <JC_freak> 2 ma t 
06:22:23 <dark> So fromDiag would look like:
06:22:24 <dark> fromDiag (x,y) | x + y < size  = (x, y - x)
06:22:24 <dark> fromDiag (x,y) | x + y >= size = (x + y - (size - 1), (size - 1) - x)
06:22:34 <Heffalump> dark: yeah, you still don't need !! (having just done it)
06:23:06 <dark> JC_freak: It would be found at (0, 3) in the diagonalized list, and translated back to the original (1, 2) by fromDiag :)
06:23:32 <dark> Heffalump: Could you show?  It's exactly what JC_freak is looking for :)
06:23:41 <Heffalump> is it his homework? :-)
06:24:15 <dark> Heffalump: I don't think so, homework is generally more specific than "write a find-the-word game" :)
06:24:19 <JC_freak> dark: i see now
06:24:46 <JC_freak> but that equation will eventually fail
06:24:58 <Heffalump> anyway, if I tell him my solution he won't learn anything
06:25:00 <JC_freak> i think
06:25:16 <JC_freak> y won;t i learn anything
06:26:01 <dark> JC_freak: Fail where?
06:26:01 <Heffalump> I could help you work out what my solution is, if you like
06:26:13 <JC_freak> i learn most of my programming from the net =P
06:26:27 <JC_freak> yea ok i don;t mind 
06:26:38 <dark> JC_freak: remember that the result of diagList is not a full grid.  x can't be larger than y, for example :)
06:26:38 <Heffalump> yeah, but if I tell you the answer it won't help you know how to work out a solution for a different problem the next time
06:27:27 <JC_freak> ok well can we get started?
06:27:32 <Heffalump> ok, so the first thing to work out is what diagList [] should be.
06:27:53 <Heffalump> when you're working with lists, considering the "base" case first is often helpful
06:28:02 <JC_freak> well it should be a list of the diagonals right?
06:28:10 <Heffalump> yep
06:28:25 <JC_freak> the base case would be something like findDiag [] = []
06:28:45 <Heffalump> yep
06:28:54 <Heffalump> just to confirm, btw, this is what my code outputs:
06:28:55 <Heffalump> Diag> diag ["cat","dog","sky"]
06:28:55 <Heffalump> ["c","ad","tos","gk","y"]
06:28:55 <Heffalump> Diag> diag ["foo","bazoom","t"]
06:28:55 <Heffalump> ["f","ob","oat","z","o","o","m"]
06:29:15 <dark> JC_freak: Btw, diagonals the other way around aren't "completely different" after all, it's easy to define fromDiag2 in terms of fromDiag1 :)
06:29:39 <JC_freak> yea i guess
06:29:57 <JC_freak> btw the strings are meant to be of equal length
06:30:06 <Heffalump> the input strings?
06:30:14 <JC_freak> strings in the list
06:30:21 <Heffalump> the input list, or the output list?
06:30:25 <JC_freak> but input string can be of any length >= 2
06:30:31 <JC_freak> input list
06:30:42 <dark> Heffalump: Okay, so you're generating upper-right to lower-left diagonals :)
06:30:44 <Heffalump> ok, so my code is just more general than the spec, which is fine
06:30:55 <dark> That would change fromDiag1 a bit.
06:31:05 <JC_freak> ok cool
06:31:10 <Heffalump> dark: yeah. I can't do upper-left to lower-right so easily, I don't think
06:31:28 <Heffalump> JC_freak: ok, so now you need to worry about the "step" case - when the input list is non-empty
06:31:38 <JC_freak> so the type sig would be something like findDiag :: Grid -> Grid
06:32:02 <dark> JC_freak: More like Grid -> [[String]], if you want Grid to be square.
06:32:12 <dark> JC_freak: The type is the same, but calling it "Grid" is misleading :)
06:32:25 <dark> Er, just [String] of course.  I was thinking of [[Char]]
06:32:28 <JC_freak> Grid is defined as [[Char]]
06:32:39 <JC_freak> yea so its ok
06:32:56 <dark> JC_freak: Yeah but I would call it misdocumentation to call a non-square [[Char]] a Grid :)
06:33:22 <JC_freak> oh ok
06:33:44 <JC_freak> so about the stepping case
06:34:02 <Heffalump> ok, so think about what diag (xs:xss) should do
06:34:18 <Heffalump> suppose you know what diag xss is already, how can you work out diag (xs:xss) ?
06:35:22 <JC_freak> diag xs : diag xss
06:35:40 <JC_freak> ummm thats not right
06:35:40 <Heffalump> what's the type of xs?
06:35:46 <Heffalump> indeed :-)
06:35:59 <JC_freak> xs is a [char]
06:36:07 <JC_freak> xs is the first string isn't it?
06:36:08 <Heffalump> it's a bit more complicated than that - you'll need to treat the case where xs is empty and where it's non-empty separately
06:36:28 <ChilliX> Hi!
06:36:33 <Heffalump> hi
06:37:38 <pesco> Chilli: Hi! Never forget to turn on -O2 when using parr.
06:37:42 <JC_freak> so i need to use guards or if statements
06:37:42 <pesco> ;-)
06:41:10 <ChilliX> pesco: true :-)
06:41:24 <Heffalump> JC_freak: yep
06:41:33 <Heffalump> or split it up into two more pattern matching cases
06:41:35 <JC_freak> heffalump: is the solution your talking about long?
06:41:35 <pesco> Chilli: They get even slower than standard Array.
06:41:51 <Heffalump> JC_freak: 6 lines, for diagonalising it the way I demonstrated
06:41:57 <Heffalump> (+ another 2 if you want type signatures)
06:42:22 <JC_freak> hmm ok
06:42:36 <JC_freak> so we've done wat 1 line of it
06:42:47 <ChilliX> pesco: maybe I should emphasis the -O2 bit more
06:42:47 <Heffalump> yeah. the rest are a bit harder :-)
06:43:08 <dark> JC_freak: Notice, 2 lines for type signatures means he's using 2 functions :)
06:43:28 <pesco> Chilli: That might not be a bad idea.
06:43:37 <ChilliX> pesco: GHC has an optimisation called constructor specialisation, which is very effective at unboxing arguments to recursive functions
06:44:15 <pesco> Chilli: I can't follow.
06:44:15 <ChilliX> pesco: I could have written the core loops such that they don't need that optim, but it would have been a pain and why shouyld I, if GHC can do it
06:44:20 <Heffalump> one of them is an auxiliary function that's useful in other places too
06:44:27 <pesco> Chilli: Sure.
06:45:11 <ChilliX> pesco: the optim is cool, it is described in the "Playing by the rules" paper by SPJ et al
06:45:39 <dark> Chilli: Hmm does it have to be -O2 or is -O enough?
06:46:03 <ChilliX> unboxing makes sure that primitive values such as ints are stored as in C indead of being wrapped up into objects
06:46:25 <pesco> ChilliX: Yes, that I know.
06:46:38 <ChilliX> dark: constructor specialisation is turned on *only* if you specify -O2 
06:46:40 <dark> JC_freak: An example might help.  If xs is "cat", and xss is ["dog", "mat"], what does diag xss look like?  And what does it take to transform it into what diag (xs:xss) should look like?
06:47:04 <ChilliX> dark:  because it *may* increase code size
06:47:41 <Heffalump> chilli: what does it do?
06:47:59 <dark> ChilliX: Okay :)  Hmm, ghc docs say "At the moment, -O2 is unlikely to produce better code than -O"
06:48:30 <ChilliX> dark: consider that statement a bug
06:48:30 <JC_freak> well diag ["dog", "mat"] = ["d","om","ga","t"]
06:51:27 <Heffalump> ok, and what's diag ["cat","dog","mat"] ?
06:52:12 <JC_freak> diag ["cat","dog", "mat"] = ["c" "ad","tom","ga","t"]
06:52:28 <JC_freak> so i'm adding letters until xs is empty
06:52:54 <Heffalump> hmm, if you wanted the other diagonals, what would you expect from diag' ["cat","dog","mat"] ? ["t","ag","cot","da","m"] ?
06:53:06 <Heffalump> JC_freak: yeah, pretty much
06:53:31 <Heffalump> JC_freak: so can you think of a way to write that?
06:53:32 <JC_freak> so am i using the head function here
06:53:46 <Heffalump> what for?
06:53:59 <Heffalump> my program doesn't have it, but I could write is using head if I wanted to
06:53:59 <JC_freak> to take the individual letters out of xs
06:54:14 <JC_freak> or make xs = x:xs
06:54:29 <Heffalump> yeah, the latter is what I did
06:54:37 <JC_freak> ahhh
06:54:40 <Heffalump> it doesn't really matter though
06:54:53 <Heffalump> I just find using pattern matching where possible to be nicer style
06:55:57 <pesco> ChilliX: Do you know if, to enable profiling with the parr package, it will suffice to compile the sources with -prof, rename .hi and .a to _p.hi and _p.a, and copy those into the lib/import dir?
06:56:01 <JC_freak> but how would it know which string to add it too?
06:56:24 <Heffalump> to add what to?
06:56:40 <JC_freak> we want to add "c" to the beginning of list
06:56:48 <ChilliX> pesco: hmmm
06:56:49 <JC_freak> and then the "a" to "d"
06:57:05 <JC_freak> and "t" to "om"
06:57:34 <Heffalump> jc_freak: yep
06:58:04 <JC_freak> heffalump: so my Q is how would it know which string to add the char to
06:58:04 <Heffalump> ok, so start with the easy bit
06:58:11 <Heffalump> how do you add "c" to the beginning of the list?
06:58:20 <JC_freak> x : diag xss
06:58:24 <Heffalump> not quite
06:58:30 <Heffalump> check the types
06:58:31 <JC_freak> x ++ diag xss
06:58:41 <Heffalump> you're guessing :-)
06:58:57 <JC_freak> x needs to be a string
06:59:00 <ChilliX> pesco: might work, but I am not enitely sure whether something extra has to go into the package conf file
06:59:27 <JC_freak> heffalump: am i right?
06:59:30 <Heffalump> btw, why does package.conf pretend to use Haskell syntax when it doesn't really
06:59:33 <Heffalump> jc_freak: yep
06:59:42 <pesco> Chilli: *g* I'm wordering about that too, but I don't think so, because neither _p nor prof apear in it.
06:59:43 <Heffalump> so how would you make it one?
06:59:49 <JC_freak> show x
07:00:01 <Heffalump> that's one way, but it's rather overkill
07:00:13 <Heffalump> what is a string?
07:00:15 <Heffalump> and what is x?
07:00:24 <JC_freak> list of chars
07:00:34 <JC_freak> x is 1 char
07:00:51 <Heffalump> ok, so think of a simpler way to get a string from x
07:02:01 <JC_freak> heffalump: put it into a list ... ???
07:02:10 <Heffalump> how?
07:02:50 <JC_freak> is there like a built in function to do this
07:03:07 <Heffalump> you don't need a built in function, just the built in syntax for lists
07:03:24 <JC_freak> ['c','a','t']
07:03:37 <Heffalump> that's what the string "cat" is equivalent to
07:03:46 <JC_freak> yea
07:04:03 <Heffalump> so if you have the character 'c' and you want the string "c", what would you do?
07:04:34 <JC_freak> hmmm
07:05:30 <JC_freak> add empty list to it
07:05:32 <JC_freak> ...
07:05:37 <Heffalump> how?
07:05:55 <JC_freak> x : []
07:05:58 <Heffalump> yep.
07:06:11 <JC_freak> so x:[] : diag xss
07:06:15 <Heffalump> and actually Haskell provides syntactic sugar for that - you can just write [x] instead
07:06:36 <Heffalump> you'll need some brackets
07:06:40 <Heffalump> if you write it like that
07:06:50 <JC_freak> ohh i thought u couldn't do that
07:07:01 <Heffalump> (:) associates to the right, so that gets treated as x:([]:diag xss)
07:07:04 <JC_freak> but i confused it with [x:xs]
07:07:11 <Heffalump> ah :-)
07:07:27 <JC_freak> is that all?
07:07:39 <Heffalump> well, you still need to sort out adding the other things to diag xss
07:08:12 <JC_freak> so to add the "a" i need to recurse
07:08:27 <Heffalump> depends what you mean by recurse
07:08:37 <JC_freak> as in get the xs of x:xs
07:08:52 <Heffalump> well, if you're using pattern matching you've already got that xs
07:09:00 <Heffalump> show me what you've written so far
07:09:19 <JC_freak> findDiag :: Grid -> Grid
07:09:19 <JC_freak> findDiag [] = []
07:09:19 <JC_freak> findDiag ((x:xs):xss) = [x] : findDiag xss
07:09:47 <Heffalump> right so the remaining issue is getting the elements of xs inserted into the value from findDiag xss
07:09:58 <JC_freak> hmm yea
07:10:10 <dark> diagList would be a better name :)
07:10:27 <JC_freak> i had that already ... 
07:10:36 <Heffalump> at this point I suggest you take a step back from the details of findDiag and write a separate function to do the work
07:10:45 <JC_freak> it doesn;t really matter
07:11:02 <JC_freak> so its 2 functions
07:11:08 <JC_freak> i thought it was only 1
07:11:42 <Heffalump> no, hence the two type signatures I mentioned above :-)
07:12:56 <JC_freak> "the work" = getting the other chars in the list??
07:13:08 <Heffalump> well, merging them in
07:13:21 <Heffalump> you already have the other chars in the list, that's xs
07:13:42 <JC_freak> yea thats what i meant merging them to 1 list
07:13:48 <Heffalump> yep.
07:14:58 <JC_freak> so the function to do the work is something like merge :: String -> [[Char]]
07:15:16 <Heffalump> not quite
07:15:40 <Heffalump> you've forgotten something else it'll need
07:15:41 <JC_freak> what about merge :: [Char] -> [[Char]]
07:15:51 <Heffalump> that's the same thing
07:16:12 <JC_freak> what about merge :: [Char] -> [[Char]] -> [[Char]]
07:16:22 <JC_freak> ahh thats it
07:16:23 <JC_freak> i think
07:16:24 <Heffalump> yep.
07:17:00 <JC_freak> so base case merge [] (x:xs) = (x:xs)
07:17:40 <Heffalump> sort of
07:18:04 <Heffalump> working out what the cases are is a bit trickier here because you need to recurse over two lists simultaneously
07:18:27 <Heffalump> keep going, you can go back and fix it up slightly later
07:19:07 <Heffalump> wow, you get marks for keeping all your lines shorter than 80 characters?
07:19:18 <Heffalump> I wish someone would apply that to my boss :-)
07:19:38 <JC_freak> lol
07:20:15 <JC_freak> merge (x:xs) (y:ys) = ([x]:y:ys)
07:20:55 <dark> You're forgetting to recurse :)
07:21:39 <JC_freak> how's this
07:21:40 <JC_freak> merge (x:xs) (y:ys) = [x]:y : merge xs ys
07:21:58 <Heffalump> check the types
07:22:46 <JC_freak> oh need to have [[Char]]
07:22:51 <JC_freak> so
07:22:57 <JC_freak> merge (x:xs) (y:ys) = ([x]:y) : merge xs ys
07:23:02 <JC_freak> that ok?
07:23:43 <Heffalump> no.
07:24:18 <JC_freak> do i need to add the :ys) to ([x]:y)
07:24:25 <Heffalump> no.
07:24:36 <Heffalump> think carefully about the types of things and what you're trying to do
07:24:56 <Heffalump> I often find it helps to give things names that reflect their type, so x is a Char (in this instance), xs a [Char] and xss a [[Char]]
07:25:36 <dark> And xsss is a punctured snake :)
07:25:44 <JC_freak> oh the recursion is wrong
07:26:18 <JC_freak> but isn;t (x:xs) a string in this case
07:26:31 <JC_freak> oh yea thats right
07:27:22 <pesco> ChilliX: Once I figure out how to make profiling work with -package parr, do you think it would be a good idea to make the Makefile build profiling support by default?
07:27:36 <JC_freak> merge (x:xs) (y:ys) = (x:y) : merge xs ys
07:27:45 <JC_freak> didn;t need to make x a string
07:29:12 <ChilliX> pesco: to be honest, I am not sure how much profiling will help you with parr
07:29:22 <JC_freak> merge (x:xs) (y:ys) = [(x:y)] ++ merge xs ys
07:29:26 <JC_freak> now is that ok?
07:29:28 <ChilliX> pesco: usually heap profiling is good to estimate performance
07:29:57 <ChilliX> pesco: as heap allocation goes hand in hand with all computations, but in parr we try hard to not do any heap allocations in the inner loops
07:30:10 <ChilliX> pesco: so, I am not uite sure how much it will help
07:30:18 <ChilliX> pesco: but please try it and let me know
07:30:28 <pesco> Chilli: I don't wont to profile parr itself. I need to have the library compiled for profiling in order to be able to profile my own program.
07:30:55 <ChilliX> I thought so, but do you want to profile the parts using parr?
07:31:02 <ChilliX> or other parts?
07:31:19 <pesco> The parts using parr.
07:31:42 <pesco> I use it to build a vector type in a raytracer.
07:31:44 <ChilliX> parr tries to do the same there
07:32:11 <ChilliX> using inlining, constructor specialisation, and fusion
07:32:17 <ChilliX> anyway, try it
07:32:21 <Heffalump> JC_freak: how does that differ from the previous definition you gave?
07:32:26 <ChilliX> I am curious how useful you find it
07:32:43 <ChilliX> if it is useful, it should definitely be supported by the makefile
07:32:50 <pesco> ChilliX: Well, if I don't do it I'm not even able to compile the program with -prof in the first place.
07:33:00 <ChilliX> true
07:33:03 <JC_freak> well at least now the x can be added
07:33:12 <ChilliX> so, from that point of view, it should be supported anyway
07:33:18 <ChilliX> I agree :-)
07:34:53 <Heffalump> JC_freak: sorry?
07:35:17 <pesco> ChilliX: OK, then I'll shamelessly make the Makefile build both prof and non-prof versions and install them together by default.
07:35:21 <JC_freak> no it doesn;t work but i just sed that [x]:y is not the same as x:y
07:35:30 <ChilliX> pesco: ok
07:35:34 <Heffalump> jc_freak: yeah, I was asking about the two different versions you gave
07:35:41 <Heffalump> [15:27] <JC_freak> merge (x:xs) (y:ys) = (x:y) : merge xs ys
07:35:45 <Heffalump> [15:29] <JC_freak> merge (x:xs) (y:ys) = [(x:y)] ++ merge xs ys
07:35:48 <Heffalump> how do they differ?
07:35:55 <JC_freak> not much
07:36:32 <Heffalump> ok, so the first one is nicer, use that :-)
07:36:43 <JC_freak> if (x:y) is already a string then it should be ok then shouldn't it?
07:36:44 <Heffalump> they both do the same thing, because [x] ++ xs = x:xs
07:38:00 <JC_freak> the base case should return empty list then
07:38:33 <Heffalump> which base case?
07:38:40 <JC_freak> merge [] (y:ys) = []
07:39:30 <JC_freak> oh wait
07:39:32 <JC_freak> maybe not
07:39:49 <JC_freak> coz there might be more strings left in the list
07:40:18 <Heffalump> hello
07:40:22 <pesco> Ugh, the profiling extension is _p.a for libs but .p_hi (watch the dot) for interfaces. Garh, no wonder it didn't work.
07:40:45 <JC_freak> what does a non-exhaustive function imply?
07:40:52 <Heffalump> jc_freak: it means you missed some cases out
07:41:22 <JC_freak> so i need one for merge [] []
07:41:26 <Heffalump> jc_freak: yep
07:41:39 <JC_freak> so merge [] [] = []
07:41:49 <Heffalump> sounds sensible
07:42:04 <JC_freak> hows this?
07:42:05 <JC_freak> merge :: String -> [[Char]] -> [[Char]]
07:42:05 <JC_freak> merge [] [] = []
07:42:05 <JC_freak> merge [] (y:ys) = []
07:42:05 <JC_freak> merge (x:xs) (y:ys) = (x:y) : merge xs ys
07:42:06 * Heffalump suggests you put merge into diag in the appropriate place and try it.
07:42:25 <Heffalump> errm, remember what you said above about "there might be more strings left"
07:42:35 <JC_freak> oh yea
07:42:48 <JC_freak> should be merge :: String -> [[Char]] -> [[Char]]
07:42:48 <JC_freak> merge [] [] = []
07:42:48 <JC_freak> merge [] (y:ys) = (y:ys)
07:42:48 <JC_freak> merge (x:xs) (y:ys) = (x:y) : merge xs ys
07:43:02 <Heffalump> makes sense to me. Can you simplify it at all?
07:43:22 <JC_freak> simplify which?
07:43:31 <Heffalump> that definition
07:44:18 <JC_freak> can we take out merge [] [] = []
07:44:29 <JC_freak> coz we already have merge [] (y:ys) = (y:ys)
07:44:35 * Heffalump waves to GHC-Simon and wonders if he's going to say anything :-)
07:44:43 <Heffalump> not exactly
07:44:48 <JC_freak> so if (y:ys) = [] then it will return [] anyway
07:44:58 <Heffalump> how can (y:ys) = [] ?
07:44:59 <JC_freak> hmmm ok
07:45:39 <ChilliX> JaffaCakes visit was pretty short, I have to say...
07:45:57 <Heffalump> I'm impressed he managed to join and leave so quickly.
07:46:14 <ChilliX> maybe the client crashed ;-)
07:46:44 <Heffalump> welcome back
07:47:02 <JC_freak> heffalump: so the code is ok but i can simplify it
07:47:08 <Heffalump> jc_freak: yeah.
07:47:15 <Heffalump> don't worry about it too much.
07:47:33 <Heffalump> but working out how would help you understand pattern matching better
07:47:50 <Heffalump> but first I suggest you make use of merge in your diag function and try it out
07:47:52 <ChilliX> Hi JaffaCake!
07:47:58 <JaffaCake> Dudes :-)
07:48:05 <JC_freak> so was the diag function ok b4?
07:48:16 <JC_freak> findDiag :: [[Char]] -> [[Char]]
07:48:16 <JC_freak> findDiag [] = []
07:48:16 <JC_freak> findDiag ((x:xs):xss) = [x] : findDiag xss
07:48:24 <JC_freak> now i need to add the merge to it
07:48:25 <Heffalump> well, it needs to use merge somehow
07:48:26 <Heffalump> yep.
07:49:07 <ChilliX> JaffaCake: How are things in Cambridge?
07:49:29 <JaffaCake> not bad, unfortunately I can't join in the ICFP prog comp
07:49:37 <JaffaCake> got to go to a wedding tomorrow :(
07:49:49 <Heffalump> aww, having you on the #haskell team would be nice :-)
07:49:59 <JC_freak> so i just need to merge xs with the findDiag xss
07:50:01 <ChilliX> JaffaCake: yeah, SPJ said that your are busy
07:50:03 <JC_freak> that right?
07:50:07 * JaffaCake looks sad
07:50:08 <GHC-Simon> Waves back; I'm just lurking.  ChilliX has just introduced me to the wonders of this channel
07:50:08 <Heffalump> JC_freak: sounds good
07:50:21 <Heffalump> GHC-Simon: cool
07:50:40 * pesco grins
07:51:01 * Heffalump . o O ( right everyone, it's slag off GHC time :-) )
07:51:21 <juhp> hi everyone
07:51:22 <ChilliX> Hi juhp!
07:51:58 <JC_freak> like this
07:51:59 <JC_freak> findDiag ((x:xs):xss) = [x] : merge xs (findDiag xss)
07:52:12 <ChilliX> ok, time for me to go to bed
07:52:23 <ChilliX> 'night all
07:52:30 <JC_freak> night chilli
07:52:34 <Heffalump> night
07:52:34 * juhp yawns
07:52:45 <juhp> night from me too
07:52:46 <Heffalump> jc_freak: ok, time to try it, methinks
07:53:16 <JC_freak> it has non-exhaustive patterns
07:53:30 <Heffalump> ok, so work out what the case you missed out is and fill it in
07:54:42 <JC_freak> merge should only have 2 base cases right?
07:55:12 <JC_freak> merge [] [] = []
07:55:12 <JC_freak> merge [] (y:ys) = (y:ys)
07:55:57 <Heffalump> which function does it say is non-exhaustive?
07:56:09 <JC_freak> merge
07:56:48 <Heffalump> umm
07:56:52 <Heffalump> show me the definition again?
07:56:54 <Heffalump> oh, I see
07:56:55 <JC_freak> non-exhaustive patterns in functions on merge
07:57:01 <JC_freak> findDiag :: [[Char]] -> [[Char]]
07:57:02 <JC_freak> findDiag [] = []
07:57:02 <JC_freak> findDiag ((x:xs):xss) = [x] : merge xs (findDiag xss)
07:57:02 <JC_freak> merge :: String -> [[Char]] -> [[Char]]
07:57:02 <JC_freak> merge [] [] = []
07:57:02 <JC_freak> merge [] (y:ys) = (y:ys)
07:57:04 <JC_freak> merge (x:xs) (y:ys) = (x:y) : merge xs ys
07:57:08 <Heffalump> ok, there's one case you're missing
07:57:16 <JC_freak> in merge?
07:57:19 <Heffalump> yep
07:57:43 <JC_freak> is it merge (x:xs) [] = (x:xs)
07:57:54 <Heffalump> check the types
07:58:52 <JC_freak> oh oops
07:59:01 <JC_freak> is it merge x [] = [x]
07:59:12 <Heffalump> 'fraid not.
07:59:22 <Heffalump> think about what it should do and what that definition would do
07:59:45 <JC_freak> merge string with list of string
07:59:55 <Heffalump> think of an example
08:00:09 <JC_freak> so if the list is empty and there is still more ...
08:00:21 <JC_freak> oh it needs to add them 1 char at a time
08:00:24 <JC_freak> is that it?
08:00:28 <Heffalump> yeah.
08:01:19 <JC_freak> so its this
08:01:20 <JC_freak> merge (x:xs) [] = [x] : merge xs []
08:02:09 <Heffalump> sounds sensible
08:02:39 <JC_freak> findDiag ["cat","dog","sky"] = ["c","ad","tos","gk","y"]
08:02:43 <JC_freak> yay
08:02:46 <JC_freak> i think it works
08:03:08 <Heffalump> right, I'll leave you to work out how to do the opposite diagonals on your own :-)
08:04:11 <JC_freak> yea just do transpose
08:04:26 <JC_freak> thanks for all your help man
08:04:31 <Heffalump> np
08:04:56 <JC_freak> now i just need to figure out the relationship to get the actual coordinates
08:05:19 <Heffalump> heh
08:05:20 <Heffalump> have fun
08:05:26 <JC_freak> btw could u tell me how to simplify it
08:05:39 <JC_freak> since i already know how it works
08:05:40 <Heffalump> merge [] [] = []
08:05:44 <Heffalump> merge [] (y:ys) = y:ys
08:05:53 <Heffalump> is (essentially) equivalent to
08:05:56 <Heffalump> merge [] ys = ys
08:06:15 <dark> Calling it merge [] yss = yss would be clearer, though.
08:06:23 <JC_freak> ahhh i was close though
08:06:25 <Heffalump> true, but he hasn't used yss elsewhere in the definition
08:06:32 <dark> Oh, right.
08:06:34 <Heffalump> yep, it's just that (y:ys) will never match the value []
08:06:43 <Heffalump> because [] isn't a (:)
08:06:46 <JC_freak> ohh coz [] 
08:06:48 <JC_freak> yea
08:07:01 <JC_freak> [] is always at the end
08:07:05 <JC_freak> is that right?
08:07:09 <dark> Heffalump: Why the (essentially)?  Isn't it completely equivalent?
08:07:10 <Heffalump> yeah.
08:07:14 <Heffalump> dark: strictness
08:07:26 <JC_freak> hehe
08:07:27 <dark> Heffalump: Oh, right.
08:07:28 <JC_freak> oh ok
08:07:29 <JC_freak> cool
08:07:55 <JC_freak> this is pretty advanced considering we've only done haskell for a few weeks
08:08:11 <Heffalump> must be the wonderful lecturing :-)
08:08:31 <dark> How many hours per week?
08:08:35 <JC_freak> the last class' assignment wasn't even half as hard
08:08:40 <JC_freak> 3 h/w
08:09:34 <dark> Hmm I sometimes wish I could reuse Nothing as a data constructor :)  I keep adding NoFoo constructors to various types.
08:09:52 <Heffalump> heh
08:09:52 <JC_freak> but i heard a student made the assignment (this word search) ...
08:10:06 <JC_freak> why did he have to make it so hard
08:10:22 <JC_freak> or she (sorry)
08:10:31 <dark> JC_freak: You had a working solution before, didn't you?  It was just uglier.
08:10:41 <JC_freak> yea 
08:10:54 <JC_freak> but now it might be easier to implement coordinates
08:11:05 <JC_freak> since i don;t have to worry about spaces
08:11:38 <JC_freak> anyway it was worth the learning
08:11:45 <JC_freak> thanks for all your help
08:11:55 <dark> If you're ever interested in a harder problem, check out Nonograms :-)
08:11:59 <Heffalump> I remember when I was a student and wrote that solution for an exercise, it confused the tutor so much she had to type it into the interpreter to convince herself it worked :-)
08:12:16 <JC_freak> its 1:15 am now!!!
08:12:28 <JC_freak> is Nonograms a site? or wat?
08:12:42 <dark> JC_freak: It's a type of puzzle.
08:12:47 <dark> JC_freak: googling for it should get you a few hits.
08:13:10 <JC_freak> heffalump which uni did u go to?
08:13:15 <dark> There's a theory of solving them at http://www.comp.lancs.ac.uk/computing/users/ss/nonogram/theory.html
08:13:20 <Heffalump> Oxford
08:13:40 <JC_freak> wow
08:13:45 <dark> I'm going to try a nonogram solver in Haskell sometime :)
08:13:58 <JC_freak> is it numbers?
08:14:12 <JC_freak> i've never seen it before
08:15:20 <JC_freak> neway
08:15:25 * JC_freak yawns
08:15:28 <JC_freak> i'm tired
08:15:29 <Igloo> Am I missing an obvious explanation of what they are?
08:15:31 <JC_freak> nite all
08:15:42 <dark> Igloo: There doesn't seem to be one on that page, I'm looking for other links.
08:16:01 <Heffalump> http://www.comp.lancs.ac.uk/computing/users/ss/nonogram/build.html
08:16:32 * Heffalump didn't know that (>>) could have type URL -> String -> something :-)
08:17:46 <dark> http://www.puzzlemuseum.com/nonogram.htm
08:18:16 <dark> Heh, that page has a silly trademark claim.
08:19:26 <Igloo> Oh, cute
08:20:21 <dark> Hmm, none of these pages seem to describe multicolor nonograms.
08:20:39 <dark> They're similar, with the extra rule that there can be zero spaces between sequences of different colors.
08:21:23 <dark> Anyway, I want to write a solver to make it easy to find out if an arbitrary picture is solvable.
08:21:36 <dark> That way it becomes much easier to make new puzzles, or import PNGs or something.
08:24:52 <dark> Heffalump: Obviously >> invokes a web browser and it's of type URL -> IO String
08:29:11 <Heffalump> hmmm :-)
08:29:24 <pesco> No no no, :// constructs the IO action to open the browser.
08:31:13 <pesco> Actually, / must be an operator. :// a ctor, . is probably still function composition.
08:31:58 <pesco> >> appearently takes a function of one argument (because of the / section).
08:32:36 <pesco> I wonder what !!! is, though.
08:43:16 <dark> Another section, apparently.
08:43:34 <dark> So >> is some kind of function composition.
08:45:15 <dark> Hmm a definition of !!! that's consistent with ! and !! might be lookup in a mapping.
08:45:40 <Heffalump> what's ! ?
08:45:43 <Heffalump> array lookup?
08:45:52 <dark> Yeah, ! is array indexing, !! is list indexing
08:46:02 <dark> So !!! is probably an even more general kind of indexing.
09:07:42 <dark> Heh, I have an array where both index and element types are tuples... I'm drowning in parentheses.
09:28:05 --- topic: set to 'We put the Funk in Funktion || See logs @ http://tunes.org/~nef/logs/haskell/ || parr 0.2.3 released http://www.cse.unsw.edu.au/~chak/nepal/ || ICFP 2002 contest is about to start.' by shapr
09:42:58 <shapr> whoa, simon marlowe was here?
09:43:16 <Heffalump> Simon PJ is still here, if you look :-)
09:43:18 <shapr> and simonpj is still here, cool :-)
09:43:32 <Heffalump> he said he was lurking
09:43:54 <shapr> it's hard to lurk here with a username like that showing :-)
09:44:08 <pesco> lol
10:30:17 <shapr> cool, WASH-CGI will compile with ghc5.04.1, I wonder when it will be released.
10:31:47 <shapr> Heffalump: hey, did you ever get that info on ghci style dynamic loading?
10:34:17 <Heffalump> oh, no
10:34:26 <Heffalump> I saw o3 once briefly but didn't ask him about it
10:35:03 <shapr> seems like a heavily related discussion happening on ghc-users
10:35:34 <shapr> Duncan Coutts wants to have haskell as the scripting language of hIDE
10:42:18 <Heffalump> interesting
10:52:35 <PMode> re
10:52:45 <PMode> the contest will start soon ;)
10:53:25 <PMode> whats up with the wiki? http://haskell.org/wiki/wiki?CommonHaskellIdioms
10:54:07 <shapr> looks like some of the locks are still around.
10:54:27 <Heffalump> it's been broken for ages
10:54:30 <shapr> HaskellWiki is using an RCS backed system, and sometimes locks get left around
10:54:36 <shapr> Heffalump: most of the locks have been cleared up now.
10:54:44 <shapr> IcfpContest is still locked, along with a few other pages.
10:55:08 <PMode> shapr: what do you mean with locks? locks for editing pages?
10:55:38 <shapr> the HaskellWiki maintainer said "RCS locks"
10:55:48 <PMode> ok
10:55:53 <shapr> that's all I know :-)
10:56:32 <shapr> Heffalump: hey, o3 actually chimes in on that thread, and offers to make a short demo of his FFI-abusing dynamic linker.
10:56:57 <PMode> so, i will go to the contest now. meeting with other students to conquer the problem ;)
10:57:19 <shapr> we have a globally distributed team on irc also :-)
10:57:29 <PMode> hehe, cool.
10:57:53 <Heffalump> what uni are you at?
10:57:58 <PMode> we have build a team of students in leipzig (germany) and an old student which is now studing in karlsruhe
10:58:01 <Heffalump> no spying on our attempt :-)
10:58:07 <PMode> Heffalump: hihi
10:58:19 <Heffalump> shapr: cool
10:58:28 <PMode> Heffalump: where are you from?
10:58:32 <Heffalump> England
10:58:45 <PMode> Heffalump: at an university?
10:58:52 <Heffalump> yeah (not a student though)
10:59:00 <PMode> Heffalump: which city?
10:59:04 <Heffalump> Oxford
10:59:32 <shapr> PMode: you're using Haskell for your entry?
10:59:53 <PMode> some friends will make an exchange year in scotland (edinburgh)
11:00:06 <PMode> shapr: yes, our team will use haskell.
11:00:11 <shapr> nifty :-)
11:00:23 <shapr> that's at least three haskell entries total
11:00:33 <shapr> assuming Tom Moertel uses Haskell this year.
11:00:38 <PMode> shapr: i'm not familiar with haskell, but i hope to analyze the problem and profit from haskell gurus 
11:06:00 <PMode> so, i have to go to my university now.
11:06:01 <PMode> ciao
11:06:13 <shapr> ok, have fun in the contest!
11:06:39 <loom2> yo!
11:06:43 <Heffalump> yo!
11:06:44 <shapr> y0 y0
11:06:53 * shapr points to #haskell-icfp
11:07:18 --- topic: set to 'hash-haskell ICFP team on #haskell-icfp: observers welcome (no spies!) || We put the Funk in Funktion || See logs @ http://tunes.org/~nef/logs/haskell/ || parr 0.2.3 released http://www.cse.unsw.edu.au/~chak/nepal/' by Heffalump
11:07:36 <shapr> yah
11:09:06 <redcrosse> do you guys mind lurkers on #haskell-icfp?
11:09:14 <shapr> nah, drop by :-)
11:09:22 <shapr> observers welcome, as the topic says.
11:10:00 <redcrosse> bah...who reads topics?  :P
11:10:06 * shapr grins
11:11:34 * Heffalump pokes Igloo hopefully
11:26:42 <shapr> well, looks like no Igloo for the beginning of the contest, maybe he'll be in later.
11:27:56 <Heffalump> someone else asked for him about 30 mins ago and he didn't reply
11:28:10 <Heffalump> sadly I don't still live in the same house as him, or I could poke him in person :-)
11:28:16 <shapr> heh, oh well :-)
12:06:23 <PMode> re
12:06:30 <PMode> is there a server available for the contest?
12:09:56 <Heffalump> hmm.
12:09:59 <Heffalump> that's a good point.
12:12:36 * Heffalump can't see any mention of one.
12:24:08 <PMode> nice task.
12:24:13 <PMode> multi-player sokoban *G*
12:24:22 <Heffalump> lol
12:34:15 <dandelion-> did anyone successfully use "assert" within ghc? it doesn't work for me
12:37:41 <PMode> ciao
12:37:50 <Heffalump> I emailed the judges about the server, btw
12:41:56 <PMode> Heffalump: ok.
12:43:27 <PMode> ciao.
13:52:10 --- topic: set to 'hash-haskell ICFP team on #haskell-icfp: observers welcome (no spies!) (we're rockin!) || We put the Funk in Funktion || See logs @ http://tunes.org/~nef/logs/haskell/ || parr 0.2.3 released http://www.cse.unsw.edu.au/~chak/nepal/' by shapr
13:53:33 * shapr bounces
13:55:34 <Heffalump> morning
14:44:45 * shapr pants
15:14:11 <PMode> re
15:14:17 <Heffalump> 'lo
15:14:27 <Heffalump> how goes it?
15:14:48 <PMode> no problem.
15:20:06 <PMode> ciao
15:20:45 * shapr boings
22:42:48 <toadx> "no spies" -- hahah
