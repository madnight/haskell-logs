01:56:57 <pesco> *yawn*
01:57:01 * pesco stretches.
03:13:30 <PMode> re
03:13:53 <PMode> what is going on with the wiki? http://haskell.org/wiki/wiki?CommonHaskellIdioms
03:14:34 <Jerub> wiki is broken
03:14:38 <PMode> ok
03:14:46 <PMode> when will it work again? ;)
03:15:03 <Jerub> nfi, I just saw conversation about wiki being broken.
03:16:21 <PMode> thx for info
04:13:30 * shapr boings
05:41:50 * shapr bounces
05:41:55 <shapr> hey Marvin--
05:42:12 <Marvin--> hey
05:42:17 <shapr> eivuokko: no vuokko for you!
05:42:37 <shapr> Hm, do I write Java for money, or do I write Haskell for fun?
05:43:10 <shapr> Marvin--: sooon, my evil plan will reach fruition! TwistedHaskell will allow the fusion of two great technologies!
05:43:20 <Marvin--> heh
06:08:55 <pesco> shapr: What exactly is your plan? *raiseeyebrow*
06:09:18 <shapr> pesco: I'm porting the twisted.spread part of http://twistedmatrix.com/ to Haskell
06:09:21 <shapr> for great justice!
06:13:17 <ChilliX> Hi shapr
06:13:23 <shapr> hi ChilliX, what's up?
06:13:26 <ChilliX> shapr: is twisted used a lot?
06:13:33 <shapr> hmm
06:13:37 <shapr> it's used some.
06:13:45 <shapr> it's not yet up to "a lot"
06:14:01 <shapr> but I would bet my years income that it will overtake Zope as python's killer app.
06:14:10 <Marvin--> Hmm, what's the semantics of  seq a b  when a is an IO monad?
06:14:16 <shapr> I've been predicting that since I found out about it, and I still believe that.
06:14:16 <jewel> how is inter-process communication done in Twisted?
06:14:32 <ChilliX> Why is it better than other similar infrastructure?  (you mention the uniform comm arch before, I think)
06:14:35 <shapr> jewel: with pb, which is the layer I'm writing.
06:14:50 <jewel> which is similar to what?
06:15:09 <shapr> pb is mostly an RPC layer
06:15:11 <ChilliX> Marvin--: that the monadic value is evaluated before b, BUT that does not mean the monad actions are executed
06:15:45 <jewel> can you describe it in more detail?
06:15:46 <Marvin--> ChilliX: Ah, that's what I thought
06:15:51 <shapr> jewel: which part? :-)
06:15:55 <shapr> Twisted is a server framework
06:16:02 <Marvin--> ChilliX: so I can't rely on it for I/O?
06:16:03 <shapr> hey Marvin--, you use Twisted, what can you say about it?
06:16:21 <jewel> The RPC layer
06:16:25 <shapr> oh
06:16:28 <Marvin--> We-ell, we only use twisted.internet so far
06:16:42 <shapr> the rpc layer is called twisted.spread, and it's composed of three layers
06:16:47 <shapr> PB, Jelly, and Banana
06:17:03 <Marvin--> But I've found it well-designed and it gave me more time for the important things instead of fiddling around with BSD sockets :P
06:17:16 <shapr> PB is the Perspective Broker, Jelly and Banana are serializing layers.
06:17:27 <jewel> Perspective broker?
06:17:58 <shapr> yah, a perspective can give you access to a service
06:18:17 <shapr> for example, the MoinMoin wiki can publish itself via PB
06:18:34 <shapr> and since there's TwistedEmacs, I can use MoinMoin from with emacs
06:19:07 <jewel> Hmm, what kind of information does moinmoin supply?
06:19:46 <shapr> well, it's a wiki :-)
06:20:14 <shapr> MoinMoin can supply HTML, XHTML, and XML I think
06:20:22 <jewel> yeah,  but how does it  'register'
06:20:26 <jewel> or publish itself
06:20:26 <shapr> it does localization, file attachments
06:20:26 <shapr> oh
06:20:35 <shapr> it needs a small python file
06:20:55 * shapr looks for the file
06:21:12 <jewel> I have twisted-0.19 here, is there something similar in there?
06:21:55 <shapr> yah, look at moin/MoinMoin/twisted/pb_service.py
06:22:11 <PMode> ciao
06:22:39 <jewel> it's not in the twisted package
06:22:44 <shapr> oh
06:22:55 <shapr> sorry, that's in the MoinMoin package
06:23:11 <shapr> dpkg -L moin|fgrep twisted
06:24:24 <shapr> there's also TwistedJava
06:24:36 <jewel> Oh I didn't see this howto before
06:24:52 <shapr> so, Twisted is a server framework, it has support for FTP, SMTP, NNTP, HTTP, and TCP
06:25:07 <shapr> it doesn't have support for ICMP, SCTP, or IPv6
06:25:10 <shapr> though I'd like to see those.
06:25:30 <shapr> it doesn't use threading, it uses select()
06:25:43 <shapr> and I don't really understand that part
06:26:06 <shapr> I do know that everything happens with non-blocking requests, you make a request and pass a call-back that will be called when something happens
06:26:31 <hornby> If I had the money, I'd hire shapr ... he's honest. 
06:26:37 <shapr> I am?
06:26:38 <jewel> hehe
06:26:40 <shapr> I guess I am.
06:26:48 <shapr> cool :-)
06:26:52 <jewel> why do you think haskell has an advantage in this twisted scenario
06:27:11 <ChilliX> Marvin--: no, you can't
06:27:14 <shapr> I think Haskell is more orthogonal in general than any other language I've used.
06:27:17 <hornby> I dunno what I'd have you do... if I had that much money, I'd probably just make you work on twisted or something
06:27:22 <shapr> hah
06:27:48 <ChilliX> Marvin--: what would work is:  (unsafePerformIO <action>) `seq` e
06:27:53 <shapr> I strongly suspect that I will be able to develop software faster, and more safely, with less bugs, in Haskell than I will be able to in any other language.
06:28:00 <Marvin--> ChilliX: yeah I know, ick
06:28:08 <ChilliX> Marvin--: but it's not really something one would do
06:28:19 <shapr> on the other hand, Python is currently my native language, and I get paid to develop stuff for Zope, so I'd really like to join those interests.
06:29:02 <shapr> jewel: there are some languages that treat sockets as native types, I think that's becoming very important..
06:29:07 <shapr> twisted is like "import internet" for Python
06:29:07 <hornby> shapr: thats a strong statement in favour of Haskell
06:29:13 <shapr> hornby: yah, it is
06:29:28 <shapr> even so, I wouldn't want to limit myself to using only Haskell.
06:29:53 <shapr> As powerful as it is, I think solutions that use multiple languages/platforms/systems are the most flexible.
06:30:28 <shapr> http://c2.com/cgi-bin/wiki?AlternateHardAndSoftLayers
06:30:31 <hornby> shapr: well in a complex system, you'll want to break it into pieces, and each piece might require a different tool
06:30:37 <shapr> exactly!
06:30:58 <ChilliX> shapr: this twisted stuff sounds like a really good idea
06:31:01 <hornby> shapr: hm, so in such a system, where is Haskell used?
06:31:04 <shapr> that's one of the strengths of Haskll, Domain Specific Languages.
06:31:07 <hornby> ChilliX: Its really pretty cool. 
06:32:05 <ChilliX> when I have a bit more spare time, I think, I'll have a look at it
06:32:09 <shapr> cool :-)
06:32:44 <shapr> hornby: check out Peter Thiemann's WASH system, it does both CGI and HTML generation.
06:33:06 <ChilliX> I had writing a Haskell binding for XML-RPC on my todo list, but maybe twisted would be more interesting
06:33:06 <shapr> HaXml compiles XML DTDs to native Haskell datatypes...
06:33:44 <hornby> HaXmL seems pretty damn cool ... 
06:33:49 <shapr> ChilliX: maybe I'll have TwistedHaskell done by the time you get to it :-)
06:33:58 <ChilliX> shapr: I agree with you.  with a good binding of Haskell to twisted, you can probably do amazing stuff
06:34:05 <shapr> yah, I really do think so.
06:34:25 <shapr> each of the parts have certain strengths that mix well.
06:35:09 <ChilliX> must have a look at the interface; maybe it would be possible to cast it in the ports framework
06:35:17 <shapr> hm!
06:35:50 * jewel reads  howto
06:36:33 <ChilliX> your Haskell/twisted binding would surely be a good starting point
06:36:41 <ChilliX> what will the license of it be?
06:36:50 <shapr> I'm not picky
06:36:55 <shapr> I was thinking lGPL
06:37:01 <ChilliX> ok, that's good
06:37:09 <ChilliX> what's twisted's license?
06:37:18 <shapr> something equally sane.
06:37:22 <shapr> though I forget the details.
06:37:24 <ChilliX> ok
06:39:59 <shapr> actually, lGPL is good for TwistedHaskell, since I want to deploy this at client sites.
06:40:57 <ChilliX> ure
06:41:00 <ChilliX> ure = sure
06:43:08 <Marvin--> twisted is LGPL iirc
06:55:15 <jewel> what's this? % nc localhost 8007
06:55:29 <shapr> looks like a call to netcat
06:55:35 <jewel> ah
06:55:46 <jewel> it's mentioned further down the page :-)
06:55:57 <shapr> which howto are you reading?
06:56:16 <jewel> the one in the doc dir
06:56:21 <jewel> how to make a plugin
06:56:23 <shapr> oh
06:59:26 <jewel> in someone else's words: "nifty"
06:59:33 <shapr> hah
07:04:22 <shapr> jewel: still thinking about answers to your question of "what advantages for Haskell"
07:05:43 <shapr> point: system defined operators are functions just like user functions, and so the user can operate with/on them.
07:06:09 <shapr> unlike Java, where so much is static and vender dictated.
07:06:41 <shapr> Java loses type safety whenever I start casting.
07:07:02 <shapr> Python doesn't have much type safety because everything happens at runtime, but has much flexibility for the same reason.
07:08:02 <shapr> I find it easier to reuse referentially transparent code, because of RT.
07:08:45 <shapr> jewel: what do you think? what dis/advantages do you see?
07:10:03 <jewel> Well I don't know python that well
07:10:12 <jewel> so I'm thinking what haskell gives over python
07:10:28 <jewel> obviously practical issues like native code compilation come to mind
07:10:49 <jewel> the language embedding sounds tantalising, but again I've never writtne something like that
07:11:01 <ChilliX> How about when a Haskell program gets through the type checker it is closer to the intended behaviour than in most other languages?
07:11:36 <jewel> doesn't sound like a "killer-benefit" to me
07:11:46 <jewel> after all, people are still writing loads of programs in C
07:11:54 <Heffalump> and spending loads of time debugging them
07:12:13 <jewel> but back to haskell vs python
07:12:24 <ChilliX> if I am more productive due to this property, it's enough of a reason for me
07:12:46 <ChilliX> it's a Haskell vs Python point as Python is a dynamically typed language
07:14:10 <hornby> Python: Easy. Haskell: Hard. 
07:14:17 <hornby> Point Python
07:15:01 <ChilliX> easy/hard is IMHO a matter of previous experience
07:15:09 <ChilliX> I find Haskell rather easy
07:15:13 <Marvin--> definitely so
07:15:13 <jewel> shapr: have you looked at the prefixed-message-length protocol?
07:15:21 <ChilliX> to the point of completely natural
07:15:24 * Heffalump finds Python harder than Haskell, but I've not written any Python :-)
07:15:33 <Marvin--> I've taught Haskell to maths students and they pick it up easily
07:15:35 <hornby> ChilliX: Well, you come from extensive experience. :)
07:15:42 <Marvin--> Then we try to teach them Java, and boy do they have problems with imperative languages
07:16:01 <hornby> Marvin--: What if you taught them Java first, then Haskell?
07:16:42 <Marvin--> hornby: never tried, but the thing is that the students who have programmed before taking this course have a much harder time picking up Haskell
07:16:51 <Marvin--> hornby: so it's all a matter of perspective
07:17:21 <hornby> I guess.
07:18:02 <hornby> Marvin--: Do you use a text? If so, which?
07:18:22 <Marvin--> (disclaimer: I shouldn't say "teach", as I'm just a lowly student working as teaching assistant)
07:18:43 <hornby> close enough :)
07:18:53 <Marvin--> hornby: We use the book The Craft of Functional Programming by Thompson
07:19:09 <hornby> Marvin--: Ah, I hear thats good. I think .
07:19:22 <Marvin--> shapr: yeah I like it
07:19:52 <jewel> If twisted is single-threaded, does it scale on SMP?
07:20:11 <hornby> not yet, I don't think 
07:20:30 <Marvin--> It's hard to scale Python on SMP in general
07:25:15 <shapr> hey delYsid!
07:25:20 * shapr returns from being distracted for a bit
07:25:27 <delYsid> hey
07:25:43 * shapr reads the scrollback
07:26:36 <delYsid> damn damn disk, it still has this bug
07:26:46 * delYsid is afraid and plan to buy a disk rsn
07:27:03 <delYsid> shapr: read mail?
07:27:08 <shapr> yup
07:27:15 <delYsid> 3 min ago?
07:27:23 <shapr> nope
07:28:46 <shapr> my conclusion from the Python vs Haskell discussion is that both have their strengths, so integrating them should be even spiffier.
07:28:59 <shapr> but that was my conclusion before the discussion so... ;-)
07:30:04 <shapr> delYsid: ah, I got it.
07:30:31 <shapr> yes, there are further tricks
07:30:56 <shapr> delYsid: I can't say I understand monads very well, but I have a few clues.
07:32:06 <shapr> you don't always need to use do, you can also use stuff like mapM
07:32:44 <shapr> for example: mapM putStrLn ["Beer","Chips","Dip"]
07:32:52 <Heffalump> in practice writing any serious amount of monadic code without using do is impractical
07:32:53 <delYsid> ahh, monadic functions, converting IO data to real data types?
07:33:16 <delYsid> er, nm, the other way round.
07:33:23 <shapr> well, yah, kind of
07:33:28 <Heffalump> there are functions to lift functions over non monadic-types to monadic types
07:33:40 <shapr> yah, what he said :-)
07:33:45 <Heffalump> but removing the IO from a type directly can't be done
07:34:01 * Marvin-- digs around for his copy of "Generalizing Monads to Arrows" in order to give shapr a real headache
07:34:02 <Heffalump> (pedants who invoke any function beginning with the name unsafe will be shot)
07:34:07 <shapr> Marvin--: soon!
07:34:17 <Heffalump> Marvin--: what do you think of Paterson's arrows notation?
07:34:25 <shapr> Marvin--: I've read that paper, but I didn't even understand enough to get a headache.
07:34:30 <Marvin--> shapr: heh ;)
07:34:38 <shapr> actually, I kind of understood it...
07:34:45 <shapr> I have a little picture.
07:34:59 <shapr> imho, monads are like wormholes in star trek
07:35:03 * Heffalump gets confused by arrows quite frequently.
07:35:06 <delYsid> And good link on parsing using haskell?
07:35:10 <Marvin--> Heffalump: can't say I've used arrows myself :)
07:35:15 <delYsid> I've seen something about parser combinators or something
07:35:24 <Heffalump> well, three times in the last year or two, which is the number of times I've looked at them
07:35:25 <shapr> delYsid: hey, I've just been learning about the Parsec parser that's in the ghc5 deb
07:35:29 <shapr> delYsid: it's COOL.
07:35:46 <shapr> delYsid: yah, parser combinators totally rock!
07:35:59 <delYsid> okok
07:36:06 <delYsid> but where are they documented :)
07:36:07 <shapr> Heffalump pointed me to Meijer's paper on monadic parsing.
07:36:11 <shapr> that's where I read about it.
07:36:28 <shapr> I was playing with Parsec last night, lemme show you some examples.
07:36:41 <shapr> I'm used to seeing code that works like this:
07:36:46 <shapr> word1    :: Parser String
07:36:46 <shapr> word1    = do{ c  <- letter
07:36:46 <shapr>              ; do{ cs <- word
07:36:46 <shapr>                  ; return (c:cs)
07:36:46 <shapr>                  }
07:36:47 <shapr>                <|> return [c]
07:36:49 <shapr>              }
07:36:58 <shapr> that does char by char recursive building of a word
07:37:00 <Marvin--> Eew, lose the {} :)
07:37:15 <shapr> Marvin--: I will, but I'm trying to think like the doc writers atm
07:37:24 <shapr> and that's how they wrote it.
07:37:25 <Heffalump> Marvin--: be nice to people who dislike the layout rule, for fear of starting a holy war on the scale of vi/emacs :-)
07:37:30 <ChilliX> shapr: hahaha - monads as wormholes; that's a really good comparison (must remember that)
07:37:32 <Marvin--> Heffalump: true ;)
07:37:53 * Heffalump . o O ( if only Haskell had enough users to have a holy war on that scale... )
07:37:55 <shapr> ChilliX: it's the most natural comparison imho :-)
07:38:09 * Heffalump still doesn't get the comparison
07:38:18 <shapr> Heffalump: if Ashley Yakeley shows up, he's a holy war by himself about Haskell layout :-)
07:38:28 <Marvin--> shapr: I wrote a Python parser in Haskell last fall
07:38:58 <Marvin--> shapr: well, for a subset of Python anyway, but I don't think it'd be hard to extend it
07:39:04 <shapr> cool, I'd like to see that.
07:39:19 <shapr> delYsid: bea says hi
07:39:24 <Heffalump> using what parsing library (if any)?
07:39:49 <delYsid> shapr: say hi to bea
07:40:06 <Marvin--> One by Jeroen Fokkers I think, but it'd be cool to switch to Parsec
07:40:06 <shapr> delYsid:  with parser combinators, that code is rewritten as:
07:40:15 <shapr> word    :: Parser String
07:40:15 <shapr> word    = many1 letter
07:40:38 <shapr> delYsid: bea says she's horrified that you're learning Haskell because that will make it even more difficult to pry me off of my network connection.
07:40:40 <delYsid> yay!, I get the idea :) spiffy
07:40:54 * shapr grins
07:40:56 <shapr> he said "spiffy"
07:41:15 * shapr goes off to have sandwiches with Bea
07:41:15 <delYsid> shapr: well, I still have to less study material... so no danger there.
07:41:42 <Heffalump> DYM too little?
07:41:53 <delYsid> er, yup
07:42:08 <Heffalump> :(
07:42:30 <delYsid> Well, I really dont have the time to ocr a 400 page book.
07:42:35 <Marvin--> oh wait, does Parsec have 'match'?
07:42:36 <delYsid> but I'd like to read it :)
07:42:53 <Heffalump> Marvin--: not used it, sorry
07:42:58 <Heffalump> what does match do?
07:43:06 <Marvin--> match :: (a -> Bool) -> Parser a a
07:43:11 <Marvin--> in Fokker's lib
07:43:38 <Heffalump> ah, I think that's a fairly standard combinator
07:43:48 <Marvin--> I think there was some reason I didn't use Parsec
07:44:35 <Marvin--> yes it's farily standard, but I seem to remember a discussion with the lecturer about how you could implement more efficient parsers if you skipped match
07:44:58 <Heffalump> it has something called satisfy  :: (Char -> Bool) -> CharParser st Char
07:45:02 <Heffalump> (from a brief scan of the docs)
07:45:33 <Marvin--> hmm
07:45:46 <Marvin--> no wait, we didn't use Parsec, we used Parsek
07:47:14 <Marvin--> "This module implements fast and space-efficient monadic parser combinators. It is inspired by Daan Leijen's "Parsec" library. The aim was to get a library that was equally fast, without having to use the cumbersome "try" combinator."
07:48:59 <Marvin--> Parsek seems to be more general too
07:50:22 * jewel invites more examples of parsers in haskell using combinators or otherwise
07:51:17 <ChilliX> check out http://www.cse.unsw.edu.au/~chak/haskell/c2hs/ for a combinator parser of C header files
07:53:27 <jewel> is there an example of a GUI twisted plugin?
08:17:29 <shapr> jewel: #twisted ;-)
08:18:06 <ChilliX> g'nite
08:18:09 * ChilliX is away: Not at the machine...
08:18:11 <shapr> g'nite
08:22:24 <shapr> delYsid: hey, did see the parsec docs yet?
08:22:32 * shapr looks for the url
08:22:35 <shapr> hey Dalroth, wassup?
08:24:47 * Heffalump gets volunteered to help with the AFP summer school
08:25:10 <shapr> yay
08:25:12 <shapr> what's AFP?
08:26:33 <shapr> aha, the parsec homepage: http://www.cs.uu.nl/people/daan/parsec.html
08:26:37 <shapr> that's where the docs are.
08:26:46 <Heffalump> http://www.functional-programming.org/afp/afp4
08:27:00 <Heffalump> ChilliX is doing one of the tutorials
08:27:26 <shapr> nifty
08:27:57 <shapr> I wonder if he'll be discussing Nepal in his tutorial.
08:28:14 <Heffalump> "Fast Arrays in Haskell" is the title.
08:28:33 * shapr chuckles at Jocaml
08:29:35 <shapr> hm, Wadler will be talking about XQuery.
09:22:49 * shapr bounces
09:24:38 * shapr reads more about Parsec
09:24:50 <shapr> hei eivuokko, kuis kulkee?
09:34:39 <shapr> hi dandelion-
09:36:17 <hornby> someone should write a haskell parser in parsec
09:36:30 <shapr> hornby: I think they have
09:36:33 <hornby> oh
09:36:36 <shapr> HaskellLight iirc
09:36:42 <hornby> neat
09:37:03 <shapr> also, a parser for Mondrian comes with Parsec, might even be the real Mondrian parser.
09:37:04 <shapr> I dunno
09:37:10 <hornby> thats the thing I like about my ideas: if I have them, I know that whatever they are about EXISTS, somewhere ...
09:38:13 <hornby> By which I mean, when I say "Someone should do X", I find X completed and awating my expection
09:38:26 <shapr> that doesn't seem to work so well for me.
09:38:26 <dandelion-> hi sh
09:38:29 <dandelion-> hi shapr
09:38:33 <shapr> I said "someone should write a spoken programming language"
09:39:07 <shapr> hello dandelion-, are you looking for Haskell info? or do you bring Haskell experience to the channel?
09:39:14 <hornby> fortran?
09:39:19 <shapr> aiee
09:39:22 <ibid> anbody familiar with bnf-conf?
09:39:22 <dandelion-> no/no
09:39:30 <shapr> ibid: what's that?
09:39:33 <hornby> dandelion-: lost? :)
09:39:42 * shapr grins
09:39:44 <ibid> shapr: a compiler front end generator
09:39:53 <shapr> ibid: where can I find more info about it?
09:40:06 <ibid> http://www.cs.chalmers.se/~aarne/BNF/
09:40:13 <ibid> (it's listed in w.h.o)
09:40:20 <shapr> ibid: hey, did you get my patch for haskell-mode?
09:40:24 <ibid> yes
09:40:26 <shapr> cool
09:41:03 <ibid> i got as far as uupdating to a new upstream version, but then lost energy (no changelog, and the diff looked scary)
09:41:07 <ibid> are you a dd?
09:41:38 <shapr> nah,
09:41:43 <shapr> I keep considering it...
09:41:47 <shapr> but haven't gotten around to it.
09:41:52 <ibid> haskell-mode is available is somebody wants it
09:42:03 <shapr> you wanna orphan it?
09:42:04 <ibid> it's one of the packages i rescued from removal
09:42:10 <ibid> no, rfa
09:42:23 <ibid> i don't think i've wnppd it yet
09:42:48 <shapr> well, haskell-mode is a package I have interest in...
09:42:56 <shapr> I guess I should go ahead and apply.
09:43:26 <ibid> shapr: if you want, feed me patches, i'm out of energy wrt it for now
09:43:31 <shapr> ok, cool
09:43:55 <ibid> i consider the new upstream version and gnu emacs 21 compatibility most important now
09:44:04 <shapr> yah, I agree.
09:44:23 <ibid> of course, if you want to make it your application package, feel free to - but get a sponsor :-)
09:44:26 <ibid> (i don't sponsor)
09:44:32 <shapr> sure, no problem.
09:44:54 <ibid> just keep me informed
09:45:03 <Heffalump> how long does the sponsorship process take these days?
09:45:12 <ibid> what sponsorship process?
09:45:22 <ibid> you mean the new maintainer process?
09:45:25 <Heffalump> oh, yes, sorry
09:45:35 <shapr> I think it's like four weeks...
09:45:47 <Heffalump> I thought there was a huge backlog
09:45:50 <ibid> shapr: give me a warm fuzzy feeling that you know what you are doing and i'll advocate you in the nm process
09:45:51 <shapr> there was
09:45:59 <shapr> Heffalump: they cleaned it up
09:46:13 <shapr> ibid: as soon as I know what I'm doing ;-)
09:46:39 <ibid> shapr: and of course, there are someh haskell-related rfp's in wnpp from me, look at them :-)
09:47:01 * shapr looks
09:48:32 <shapr> I wish the hmake guy would fix his package to fit with ghc too
09:48:43 * ibid too
09:49:01 <shapr> I've had to custom compile my own
09:49:11 <shapr> I am happy michaelw put in hopengl
09:49:22 <ibid> there was an upload recently closing some bugs in hmake...
09:51:55 <ibid> shapr: you might want to subscribe to haskell-mode in the pts if you're really interested in that package
09:52:30 <ibid> (you'd get bug reports and upload reports just like me)
09:52:55 <shapr> hm
09:52:57 <shapr> good idea
09:54:40 <ibid> strangely little updates in unstable lately
09:54:56 <shapr> everyone's tired =)
09:55:37 <ibid> well, /me updated grep-dctrl :-)
09:55:46 <shapr> yay!
09:55:47 <ibid> there are some wishlists for it still open
09:55:55 <shapr> that's a handy package.
09:56:29 <ibid> yeah, i'm kind of surprised that it has caught on (although i did create it for debian domination, of course ;-)
09:56:40 <shapr> it's really useful actually
09:56:56 <shapr> you can emulate lots of apt and dpkg features in user space
09:57:06 <ibid> apt and dpkg are user space
09:57:38 <ibid> actually, grep-available and -status are breaking the rules - status and available are internal to dpkg
09:57:46 <ibid> (that's why i made them configurable :-)
09:58:40 <ibid> ObHaskell: i'd rewrite it in haskell except that it needs to be as fast as possible and there are no haskell compilers in debian that cover all arches
09:58:48 <shapr> hah
09:58:50 <shapr> I wish there were
09:59:04 <shapr> michaelw got ghc/sparc somewhat working
09:59:06 <ibid> even hugs has a problem with three
09:59:07 <shapr> what's missing? arm?
09:59:24 <ibid> ghc i386-only in debian afaik
09:59:30 <shapr> suckage
09:59:56 <shapr> doesn't ghc work on m68k and ppc at least?
10:00:00 * shapr looks at ghc pages.
10:00:00 <ibid> hm
10:00:14 <ibid> needs to be m68k/linux and ppc/linux
10:00:50 <ibid>       ghc5 |     5.04-1 |      unstable | source, i386
10:00:59 <shapr> hm
10:01:00 <ibid>       ghc4 |   4.08.1-6 |      unstable | source, i386
10:01:10 <ibid>      nhc98 |     1.14-3 |      unstable | source, i386
10:01:21 <shapr> much suckage
10:01:36 <ibid> build-essential needs hugs at build-time, and hugs fails on three arches
10:01:56 <shapr> :-(
10:02:21 <ibid> build-essential really needs to be buildable on all arces
10:02:40 <ibid> see #154274
10:02:48 <Heffalump> how does hugs fail?
10:03:16 <ibid> "Build killed with signal 15 after 150 minutes of inactivity"
10:03:32 * ibid has not seen it first hand
10:03:34 <Heffalump> interesting...
10:03:36 <Heffalump> what arches?
10:03:39 <ibid> http://buildd.debian.org/fetch.php?&pkg=build-essential&ver=7&arch=arm&stamp=1027378229&file=log&as=raw
10:03:45 <Heffalump> ta
10:03:49 <ibid> arm, powerpc and s390
10:04:20 <ibid> (the haskell program may not be pretty, i was still learning the language at the time:-)
10:04:29 <ibid> but it works everywhere else
10:04:42 <Heffalump> ah, I don't have any of those to play with myself
10:04:46 <ibid> the port experts think it's a signed char / unsigned char problem
10:05:10 <ibid> building hugs with -Wall on those arches should show the offending lines
10:05:22 <Heffalump> why would a build freeze up due to such a problem?
10:05:47 <ibid> mishandling an eof? (just guessing)
10:06:31 <ibid> -fsigned-char might fix it
10:06:54 <ibid> is Heffalump a hugs developer?
10:07:14 <Heffalump> nono
10:07:17 <Heffalump> I just felt like playing
10:07:38 <Heffalump> I (sometimes) like trying to make things compile
10:08:03 <ibid> i'll see if i can find a debian machine for one of the arches
10:08:14 <shapr> Heffalump: I might be able to find you a login on a debian ppc
10:08:14 <shapr> maybe
10:13:29 * Heffalump finds a friend with a PPC
10:15:49 <shapr> debian + ppc?
10:15:55 <Heffalump> yep.
10:16:05 <shapr> cool
10:19:21 * ibid is trying a compile on arm
10:19:25 <ibid> of hugs
10:19:42 * shapr tries to compile his foot, but accidentally shoots it instead
10:24:02 <ibid> i think i now the problem
10:24:25 <ibid> there is a comparison c == EOF (for char c), which is always false with an unsigned char
10:28:52 * Heffalump watches it build on PPC
10:29:38 <Heffalump> I still don't understand why the build would freeze up - is that a gcc bug?
10:32:38 <ibid> no
10:33:24 <ibid> it never sees the EOF
10:33:33 <ibid> so it tries to read even after EOF has been read
10:34:00 <ibid> (unsigned char)(-1) == (int)(-1) is false under C rules
10:34:34 <Heffalump> right, but why is it executing code from the package during the build?
10:35:20 * Heffalump (a) gets it to build without problems on powerpc and (b) discovers http://buildd.debian.org/build.php?arch=powerpc&pkg=hugs98
10:35:25 <ibid> ???
10:35:47 <ibid> Heffalump: it's build-essential build that is failing, not hugs98 build
10:35:56 <Heffalump> oh, sorry.
10:35:58 <ibid> Heffalump: build-essential has a runhugs script
10:36:04 * Heffalump completely misunderstood what was going on.
10:36:11 <Heffalump> just ignore me :-)
10:36:21 <ibid> ok, sent more info to the bug report
10:37:56 * Heffalump attempts to turn himself into a small insignificant thing in a corner so as not to look too stupid.
10:38:57 <ibid> heh
10:39:08 <ibid> don't worry, be happy
10:39:21 * ibid made a humiliating mistake myself earlier in this episode
10:47:54 * hornby sighs, contentedly, realizing even really smart people make mistakes
10:48:03 <shapr> of course :-)
10:48:46 <ibid> everybody makes mistakes
10:48:59 <shapr> yah, smart people just tend to make larger mistakes.
10:49:08 <shapr> really spectacular ones
10:49:11 <hornby> :)
10:49:30 <ibid> http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=154274&repeatmerged=yes - has my followup
10:49:53 <hornby> I'm so hungry .... I think I may venture out into the heat after all ....
10:50:19 <hornby> i wish I lived somewhere cold ... like Canada. Oh wait, I do ..... so WTF is it so HOT
10:50:48 * shapr grins
10:50:52 * hornby joins #weather and complains there instead
10:51:28 <ibid> hornby's realname reminds me of a guy(?) in comp.text,tex in 1998
10:52:42 <hornby> realname?
10:52:51 <hornby> scrg?
10:52:53 <ibid> 20:50 [OPN] -!-  ircname  : Steve and Rachel
10:52:56 <hornby> oh
10:53:00 <hornby> thats an ircname not a realname :)
10:53:09 <ibid> well, i call it a realname :-)
10:53:19 <ibid> i think finger calls it that
10:53:24 <Heffalump> ahah, another irssi user :-)
10:53:28 <ibid> yep
10:53:42 <hornby> I was too lazy to log out of my housemates guest account
10:53:53 <hornby> irssi rules
10:54:32 <ibid> five irssis here
10:55:09 * hornby cheers irssi and goes for food
10:55:14 <ibid> anyway, on c.t.t there was a "rebecca & rowland" there - i had some nice discussion with him/her back in 1998
10:55:25 <ibid> may still be there, i haven't read it in years
11:00:56 <ibid> so, nobody here knows bnf-conv?
11:02:40 <Heffalump> I'd not heard of it until you mentioned your rfps.
11:03:11 <ibid> it looks good otherwise but it's a pita to debug
11:03:21 <ibid> "error at end of file"
11:03:25 <ibid> very informative
11:03:45 <Heffalump> bnf-conv?
11:03:58 <ibid> yes
11:06:01 <buggs> hoi shapr
11:06:20 <ibid> does buggs know bnf-conv?
11:06:28 <Heffalump> is buggs just assuming shapr will be the first to say hi, or does buggs not want to talk to anyone else? :-)
11:07:31 <buggs> oh i think all others beside shapr are bots
11:07:58 * ibid kicks buggs
11:08:23 <buggs> ibid bnf-conv ? syntax description ?
11:08:33 <ibid> a compiler front end generator
11:08:49 <ibid> http://www.cs.chalmers.se/~aarne/BNF/
11:09:05 * Heffalump confirms that -fsigned-char fixes the problem on powerpc, btw
11:09:37 <ibid> tried build-essential too?
11:09:51 <ibid> followup on the report please :-)
11:10:09 <Heffalump> I can't install packages easily, so actually building build-essential with the fixed hugs would be a pain
11:10:25 <Heffalump> but without -fsigned-char for input.c hugs freezes on being run, and with it it doesn't
11:11:03 <Heffalump> I can just email 154274@bugs.debian.org, right?
11:11:13 <ibid> yes
11:12:48 <ibid> might want to mail hugs-bugs as well
11:12:59 <buggs> why can't you install packages easiliy Heffalump?
11:13:22 <Heffalump> ibid: damn, just too late
11:13:29 <Heffalump> buggs: lack of root on the machine in question
11:14:09 <Heffalump> or maybe my fingers just have a block against typing "apt-get install" or "dpkg -i" :-)
11:14:59 <buggs> hehe
11:16:00 <ibid> appears they know about this http://haskell.org/pipermail/hugs-bugs/2002-July/000858.html
11:16:24 <Heffalump> ah, and they supply a proper fix there :-)
11:17:08 <ibid> there seem to be several reports of this there
11:20:28 <Heffalump> hmm, yes
11:24:08 <ibid> found the error in my bnf-conf input file
11:26:07 <ibid> bah
11:26:20 <ibid> and now i found a bug in bnf-conv. argh
11:39:02 <ibid> not very understandable this code...
11:42:44 * shapr laughs
11:43:15 * ibid gets it
11:43:34 <shapr> hi buggs!
11:43:45 <ibid> they use init and last even though the tail can be more than one char long
11:49:01 * shapr bounces
11:49:09 <shapr> dandelion-: would you like to learn Haskell?
11:50:00 <dandelion-> shapr: i think i have learnt what i can learn from reading. to learn further, i would need to practice it
11:50:10 <hornby> practice is good and fun
11:50:13 <shapr> dandelion-: excellent idea!
11:51:01 <shapr> dandelion-: I can point you to a good interpreter if you wish.
11:51:05 * shapr bounces
11:51:12 <shapr> hornby: hey, wanna help me with Jelly.hs?
11:51:20 <hornby> shapr: what does jelly do again? :)
11:51:25 <shapr> I'm not really sure.
11:51:28 <shapr> that's why I wanted your help.
11:51:34 <buggs> lol
11:51:41 <hornby> oh boy
11:51:47 <shapr> hornby: the longer I look at it, the less I can figure out what I need to do.
11:51:47 <hornby> I'm going to need caffeine for this one
11:52:05 <hornby> shapr: i was up all last night though ....
11:52:13 <shapr> oh
11:52:17 <shapr> you should sleep then :-)
11:52:27 <shapr> maybe I'll just work on PB.hs
11:52:28 <hornby> Not until tonight, or I'll screw up my sleeping patterns
11:52:32 <shapr> oh, good point.
11:52:50 <hornby> whats pb.hs do ? :)
11:52:57 <hornby> don't you need jelly?
11:53:08 <buggs> a friend pointed me to http://www.haskell.org/wiki/wiki?TyingTheKnot
11:53:13 <buggs> but it is gone
11:53:29 <buggs> so google cache still has it
11:53:33 <dandelion-> shapr: what have you already programmed in haskell? i mean i would be interested to see some screenshots of cool apps or games by you
11:53:37 <shapr> yah, HaskellWiki is broken :-(
11:53:41 <shapr> dandelion-: hah, I wish.
11:53:47 <buggs> oh :(
11:53:56 <shapr> buggs: it's easily fixed, by someone who has a login.
11:54:07 <shapr> dandelion-: I've written a text based fractal grapher
11:54:28 <shapr> dandelion-: if you want to see cool screenshots, check out HOpenGL
11:54:41 <dandelion-> shapr: how does it output the fractal?
11:54:50 <buggs> shapr, then we need such a one ...
11:54:55 <shapr> just text output at the moment.
11:54:59 <shapr> buggs: truly, we do
11:55:52 <shapr> dandelion-: http://haskell.org/HOpenGL/
11:55:59 <dandelion-> shapr: it's hard to make good screenshots of text-only programs..
11:56:12 <shapr> dandelion-: I agree.
11:56:21 <dandelion-> shapr: thank you, i have seen it... but not got HOpenGL running so far... i need more
11:56:35 <shapr> dandelion-: http://kungens.kemi.fi/~shae/haskell/Mandelbrot-0.2.hs
11:56:40 <hornby> that * mandelbrot thing is cool
11:56:42 <hornby> even in text
11:56:52 <shapr> dandelion-: if you're using Debian, there's a binary HOpenGL package.
11:57:20 <dandelion-> shapr: i will look out for that..
11:57:26 <shapr> ok
11:57:40 <dandelion-> shapr: why don't you make your program create image output, to be viewed with any image viewer?
11:57:47 <shapr> that's an excellent idea.
11:57:54 <hornby> ooh
11:58:05 <hornby> pretty pictures! yay!
11:58:16 <shapr> I'll wait till after I'm done with TwistedHaskell though...
11:58:39 <shapr> I wonder if Haskell has image output support...
11:58:46 <shapr> image libs would be handy.
11:58:55 <shapr> would be fun to write also.
11:59:09 <ibid> wow, it works!
11:59:15 <dandelion-> shapr: where can i get the deb for hopengl? not at www.debian.org
11:59:26 <hornby> shapr: have you started on jelly or pb at all yet?
11:59:42 <shapr> hornby: yah, I've started on jelly, but I don't really know what to do...
11:59:49 <shapr> dandelion-: look for the package named ghc5-hopengl
12:00:05 <shapr> http://packages.debian.org/unstable/devel/ghc5-hopengl.html
12:00:05 <hornby> shapr: hmm, let me finish this game of ATC and I'll take a look
12:00:09 <shapr> hornby: ok
12:00:11 <shapr> thanks :-)
12:00:21 <hornby> shapr: give you some crazy ideas
12:00:28 <shapr> sounds good to me
12:00:30 <hornby> cool
12:00:30 <shapr> I need some discussion.
12:00:34 <dandelion-> shapr: okay, thank you
12:00:41 <shapr> dandelion-: are you using debian?
12:00:44 <hornby> discussion is good for the brain :)
12:00:46 <dandelion-> shapr: yes
12:00:58 <shapr> dandelion-: then you should be able to do "apt-get -uf install ghc5-hopengl"
12:01:08 <shapr> and that should install all the dependencies for you.
12:01:21 <shapr> that will require you to be using debian unstable though.
12:01:29 <dandelion-> what is the "-u" for?
12:01:40 <shapr> um
12:01:44 <shapr> I don't remember :-)
12:02:14 <shapr> oh
12:02:17 <shapr> show upgraded packages.
12:17:34 * hornby curses
12:17:38 <shapr> ?
12:17:44 <hornby> boom
12:17:48 <shapr> oh
12:17:56 <hornby> now I have to think
12:18:07 <shapr> Air Traffic Control?
12:18:12 <hornby> ya ")_
12:18:14 <hornby> er ya :)
12:18:17 <shapr> ah
12:18:23 <hornby> awesome game
12:18:35 <shapr> in the bsdgames package?
12:18:45 <hornby> yup
12:18:50 <shapr> never tried it..
12:18:58 * shapr puts it on his list
12:19:01 <hornby> try it :)
12:19:35 <hornby> hm, I really should be me to do this. brb
12:22:25 <hornby> shapr: you gonna try jelly first then?
12:22:38 <shapr> I dunno
12:22:52 <shapr> I'm reading through pb.py trying to put all the pieces together in my head.
12:23:31 <shapr> I think that much of jelly.py doesn't apply to Jelly.hs
12:23:47 <shapr> have you read through jelly.py?
12:24:08 <hornby> not yet :)
12:24:35 <hornby> About to.
12:24:41 <shapr> cool
12:24:43 <hornby> Hrm, are you going to need twisted.cred?
12:25:21 <shapr> I don't think so.
12:25:29 <shapr> at least not to start with.
12:25:44 <hornby> yay, only 734 lines of tests ...
12:26:04 <hornby> and 1194 lines of code ...
12:26:15 <hornby> I wonder which took longer to write ....
12:26:37 <hornby> (er oops, thats pb)
12:26:47 <shapr> I don't know.
12:27:22 <hornby> hrm this doesn't look so tough ... no harder than banana?
12:27:27 <shapr> hm
12:27:37 <shapr> it looks really simple at first.
12:27:58 <shapr> I think it might be =)
12:28:12 <hornby> hrm, simpler in Python than Haskell, for me anyway
12:30:00 <shapr> thoughts?
12:30:14 <hornby> not that far in yet :)
12:30:24 <shapr> ok
12:31:09 <hornby> if you can get integers to work first, then lists ... 
12:31:21 <shapr> yah
12:31:40 <hornby> the problem is, I don't know much about Haskell data types. Whats a dictionary in Haskell/
12:31:49 <shapr> it's a FiniteMap
12:31:57 <hornby> how might it look? 
12:32:07 <shapr> iirc, it's a list of tuples
12:32:22 <shapr> each tuple is size two, the first value is the key, the second value is the value
12:32:34 <shapr> FiniteMap is much smarter than that, but that's the basic idea.
12:32:44 <shapr> I haven't used FiniteMap before though.
12:33:47 <shapr> hi Hal, what's up?
12:33:54 <hdaume> not much...how goes it?
12:34:07 <hdaume> (just finished porting hMPI to ghc 5.04.  whee)
12:34:12 <shapr> cool!
12:34:28 <shapr> have you seen Manuel Chakravarty's Nepal project?
12:34:34 <hdaume> no
12:34:34 <hornby> and does haskell even have classes?
12:34:40 <shapr> I think he's doing something with GHC on top of MPI
12:34:49 <hdaume> hrm...i'll take a look
12:34:50 <shapr> hornby: kind of... but it's not the same thing.
12:35:03 <Marvin--> hornby: there are type classes, but not the object-oriented kind
12:35:06 <shapr> hdaume: have you released an updated version of hMPI yet?
12:35:15 <Heffalump> does said porting involve using the new FFI, or what?
12:35:17 <Marvin--> hornby: there are extensions that add OO though
12:35:31 <hdaume> i have not...i just emailed the original author that i had done it; i'd like to leave the distribution up to him :)
12:35:33 <hornby> hrm
12:35:38 <hdaume> Marvin--: more or less
12:35:45 <Marvin--> hdaume: yeah, more or less :)
12:35:47 <shapr> hornby: suffice it to say that Python-style classes, instances, and methods don't really exist in Haskell.
12:36:07 <shapr> Michael Weber did hMPI, yah?
12:36:19 <shapr> hm, he's offline at the moment.
12:36:36 <hornby> shapr: So your jelly.hs will be missing things, or partially incompatible with jelly.py?
12:37:02 <hdaume> shapr: yeah, i think he's at a conference
12:37:09 <shapr> hornby: I think I still need to be able to represent those so that I can address them remotely.
12:37:42 <shapr> hornby: that's the kind of thing I need discussion about, I don't really have the big picture yet.
12:38:23 <hornby> shapr: well, if you receive a Python class, you've got to do something with it ...
12:38:47 <hornby> shapr: build it into an appropriate Haskell object ... hm
12:38:56 <shapr> jelly receives the class as a line of text containing only the name of the class.
12:39:28 <hornby> right
12:39:46 <hornby> what good is that anyway? 
12:39:49 <shapr> I think I need datatypes representing remote objects.
12:40:12 <shapr> hornby: well, it lets you save stuff and restore it later.
12:40:19 <hornby> the actual objects?
12:40:21 <shapr> jelly is a pickle analog
12:40:32 <shapr> not the exact object, but something that's close enough.
12:40:48 <hornby> I see how it can store strings, or lists, or dictionaries
12:40:51 <shapr> right
12:40:58 <shapr> because then you're storing the real thing.
12:41:06 <hornby> but how can it store a function, say? 
12:41:31 <shapr> Function: string.join --> ['function', 'join', ['module', 'string']]
12:41:50 <hornby> right, but that doesn't store what string.join DOES
12:41:57 <shapr> you don't save the function itself, just something that represents it.
12:42:22 <hornby> Doesn't pickle store the whole thing?
12:42:23 <shapr> hdaume: hey, what's up with YAHT?
12:42:28 <shapr> hornby: I don't think so.
12:42:43 <Marvin--> pickle should most definitely store everything
12:42:58 <hornby> something has to store it ..
12:42:59 <shapr> Marvin--: so, if you store a module, it saves the source to that module?
12:43:04 <Marvin--> no wait
12:43:17 <Marvin--> maybe for builtin functions it doesn't
12:43:27 <shapr> yah, how do you save a C module?
12:43:30 <Marvin--> Hmm. I thought it'd pack down the whole code object
12:43:37 <Marvin--> true
12:43:56 <shapr> hornby: well, let's try it..
12:43:58 <Marvin--> no, you can't pickle modules
12:44:01 * shapr opens an interpreter
12:44:05 <shapr> but what about functions?
12:44:33 <Marvin--> apparently it only saves name information about it :/
12:45:05 <shapr> ok, so jelly does the same thing then.
12:45:07 <hornby> Say I pickled [1,2,3,4,"blah"] ... 
12:45:19 <shapr> hornby: that's actual date, that gets saved.
12:45:21 <shapr> er "data"
12:45:28 <hornby> I can later pull it back in and get my [1,2,3,4,"blah"] back
12:45:47 <hornby> Now say I pickle def f(x): return x**2
12:45:49 <shapr> right
12:46:05 <shapr> hornby: good question. I bet it saves __main__.f
12:46:30 <Marvin--> yeah
12:46:33 <hornby> Well say I want to run f(2) and get 4. How do I get the logic back?
12:46:38 <Marvin--> 'c__main__\nf\np0\n.'
12:46:50 <shapr> hornby: I think you don't.
12:47:08 <hornby> so why would I pickle it if I can't get it back?
12:47:19 <Marvin--> that'd be my next question too
12:47:20 <shapr> because you can pickle stuff that's pointing to modules.
12:47:34 <shapr> if you've written hornby.py, and it has a class Hornby
12:47:43 <shapr> then if you pickle an instance...
12:47:44 <hornby> ah, so I can pickle string.join. 
12:47:51 <hornby> Ahhh. 
12:47:54 <shapr> you can unpickle that instance and you have something that works the same way.
12:48:07 <Marvin--> ah, yeah, you pickle the reference
12:48:08 <shapr> iirc, that's where the new module came into play
12:48:23 <shapr> the new module can restore things and bypass constructor logic, etc
12:48:30 <shapr> it directly sets values on the object.
12:49:04 <shapr> of course, for a similar question, how do you compare two functions for equality?
12:49:12 <hornby> So here we can pickle (or rather jelly) an object and send it over the wire ... then if someone calls the function, it sends a request back to the server, where the function is actually stored and called?
12:49:55 <shapr> if I define x = lambda x:x+1 and y = lambda x:x+1, what happens when I do x == y ?
12:50:08 <shapr> hornby: right
12:50:14 <hornby> s/and called/and is called/
12:50:29 <Marvin--> shapr: f == g iff f:A->B, g:A->B and f(x) == g(x) for every x in A? :)
12:51:01 <hornby> >>> x == y
12:51:01 <hornby> 0
12:51:02 <shapr> Marvin--: yah, but how do find that out?
12:51:06 <Marvin--> won't work if you've got side effects 'course
12:51:14 <shapr> hornby: you know why that returns 0 ?
12:51:18 <Marvin--> shapr: you can't :)
12:51:36 <hornby> shapr: No
12:51:40 <Marvin--> reference identity
12:52:06 <shapr> hornby: because the address in memory gets compared.
12:52:09 <hornby> shapr: ah
12:52:15 <hornby> shapr: yeah, I was about to say that :)
12:52:17 <shapr> == is basically the same as "is"
12:52:41 <hornby> >>> y(1) == x(1) 
12:52:41 <hornby> 1
12:52:46 <hornby> compare their outputs instead
12:52:54 <Marvin--> shapr: or at least == falls back to "is" if there's no deep comparison defined
12:53:11 <shapr> Marvin--: I thought of a purely functional system that knows a function's s & k combinator structure.
12:53:16 <shapr> that could compare for equality.
12:53:28 <hornby> aren't there some languages where you can test for equality of structure?
12:53:36 <Marvin--> shapr: yeah sure
12:53:53 <shapr> Marvin--: why not, it could be interesting :-)
12:54:03 <hornby> like, uh, [1..10] == [2..11] ?
12:54:10 <Marvin--> shapr: that wasn't irony, I was agreeing
12:54:12 <hornby> well except not == .. 
12:54:36 * Marvin-- has to buy a good book on \-calculus
12:54:46 <Marvin--> I've only borrowed books on it
12:55:15 <shapr> Marvin--: oh, ok ... "yeah sure" is always sarcastic in american
12:55:35 <buggs> yeah sure
12:55:41 <shapr> :-P
12:55:45 <buggs> heh
12:55:48 <hornby> not ALWAYS
12:56:03 <shapr> hm, maybe just in my southeastern USA dialect.
12:56:18 <hornby> ugh, jelly hurts. I've got to run some errands. maybe I'll try again later :)
12:56:25 <shapr> ok, have fun.
12:56:30 <shapr> thanks for the discussion!
12:56:41 <Marvin--> shapr: :) when I'm being sarcastic, I add ';)' or something like that
12:56:49 <hornby> maybe after I read some more I'll have something actually enlightening to say
12:56:55 <shapr> ok, thanks for the social signal explanation :-)
12:57:06 <hornby> but don't hold your breath :) later
12:57:09 <delYsid> wow, I need to parse something! :)
12:57:16 <shapr> hiiii delYsid!
12:57:34 <shapr> have you read the Parsec docs?
12:57:58 <delYsid> yeah, now looking at Tiger
12:58:13 <shapr> Marvin--: I'd like to see a system that is written from S & K combinators on up, and allows for binary reimplementations of supercombinators.
12:58:33 <dandelion-> shapr: do you think functional programming really has any advantages over imperative prog. or is it only for its beauty that we are interested in it?
12:58:43 <shapr> that way you really could compare intrinsic equality, and still have something that's not too slow.
12:59:01 <shapr> dandelion-: I do think that FP has advantages over imperative programming.
12:59:28 <shapr> dandelion-: have you read about referential transparency?
12:59:48 <hdaume> Dalroth: i think most fp people think so; most of them also believe imperative has advantages over FP...it's the age-old "whatever's best for the task"
12:59:54 <dandelion-> shapr: yes, i know about all this
12:59:56 <hdaume> that was supposed to be for dand, not dal
12:59:58 <shapr> delYsid: what's tiger?
13:00:10 <dandelion-> shapr: but only an experienced programmer in both concepts could really tell us
13:00:32 <shapr> dandelion-: I agree, and I am not yet an experienced Functional Programmer.
13:00:37 <dandelion-> shapr: if FP is better then why hardly anyone uses it? because it's not needed?
13:00:56 <shapr> no, I think it's because imperative programming is well known
13:01:18 <shapr> and because it's hard to adjust from procedural to functional.
13:01:19 <hdaume> i agree; very few people know FPs and businesses are unlikely to go with something so untested
13:01:24 <hornby> dandelion-: imperative programming has a long history. 
13:01:34 <shapr> and because most people only learn what they need to keep their jobs ;-)
13:01:39 <dandelion-> are FP programs less likely to contain bugs?
13:01:44 <shapr> yes.
13:01:47 <shapr> all programs do.
13:01:58 <hornby> *thwap*
13:02:02 <shapr> it's true!
13:02:07 <hornby> shapr: can you back a statement like that up?
13:02:10 <shapr> er, sorry
13:02:11 <shapr> ahem.
13:02:40 <shapr> lemme try that again :-)
13:02:40 <dandelion-> i would like to program FP and only FP, for its beauty, but there is a lack of tools and stuff
13:02:42 <dandelion-> and libs
13:02:53 <shapr> dandelion-: sounds like the first task would be to write libraries then.
13:03:03 <shapr> I agree with you. FP needs libraries.
13:03:12 <hornby> anyway, I was going. I still am. 
13:03:15 <shapr> bye!
13:03:18 <hornby> bye :)
13:03:19 <dandelion-> shapr: yes, but since i am an inexperienced programmer, i don't feel like doing it
13:03:38 <Marvin--> what is definitely needed is good ways to connect imperative code and functional code
13:03:49 <shapr> I think writing libraries would be an excellent way to learn Haskell, and to give something back to the FP community.
13:03:58 <shapr> I'm doing what Marvin-- just said...
13:04:04 <shapr> I'm writing a connector between Python and Haskell
13:04:52 <hdaume> i think the lack of tools is more hurtful than the lack of libraries.  debuggin haskell is a pain; no debugger really works; HAT is okay but if you stray from haskell 98 (who doesn't) you're screwed
13:05:02 <shapr> yah, hat needs help.
13:05:10 <shapr> and trace doesn't really cut it.
13:05:36 <shapr> even so, for me the lack of libraries is most painful.
13:06:19 <shapr> dandelion-: well, find something you want to write, and go for it. if you need to write libraries in the process, you might enjoy it.
13:06:21 <hdaume> i really wish ghc would show thrown execptions with line numbers and backtraces like every other language, even if you have to compile with a special flag to get it
13:06:35 <shapr> Template Haskell will do that.
13:06:40 <shapr> have  you seen the paper on that?
13:06:41 <hdaume> so spj says :)
13:06:44 <hdaume> yeah
13:06:47 <shapr> it's awesome..
13:07:02 <shapr> I'll be able to use it to automatically build HUnit test suites.
13:07:09 <shapr> I'm looking forward to that.
13:07:57 <shapr> dandelion-: I really do think that Haskell lets me write programs faster, and with less bugs, than any other language I've used.
13:08:18 <shapr> that may not be true for you, different people work better with different tools...
13:09:10 <dandelion-> does ghc support dynamic linking now?
13:09:14 <shapr> hdaume: are you writing something with hMPI?
13:09:59 <shapr> dandelion-: such as?
13:10:27 <hdaume> shapr: yes...once i figure out how to use it and i get an account on our beowulf cluster
13:10:33 <shapr> cool :-)
13:10:52 <dandelion-> shapr: i mean, dynamic linking of libraries. last time i tried, my graphical hello world was several megs large! because ghc could like only statically
13:11:27 * Marvin-- wrote a web server in Haskell once
13:12:16 <hdaume> shapr: i would just use GPH, but our cluster uses MPI (at least i'm familiar with gph)
13:12:22 <dandelion-> Marvin--: cool. do you use it, too?
13:12:38 <Marvin--> dandelion-: no, it only shows static contents :)
13:13:42 <dandelion-> it seems to me that the researchers who write ghc, don't invest too much time and devotion into it
13:14:09 <shapr> there was  a discussion about static linking on the haskell list recently
13:14:09 <dandelion-> i mean, compare that with the pace of development of popular open source projects like KDE or gnome (imperative ones)
13:14:13 <shapr> they gave some details about it.
13:14:50 <shapr> If GHC had as many programmers as GNOME, I think it would have several more features.
13:15:23 <hdaume> i get the impression recently SPJ and SM have been working on the new RTS for version 6, which probably has eaten a lot of their time
13:15:23 <shapr> dandelion-: popularity doesn't mean technical superiority. Look at Windows.
13:15:51 <dandelion-> shapr: true! but it is frustrating and backsetting nonetheless
13:16:15 <shapr> dandelion-: I find out what works best for me, and then use that.
13:16:29 <dandelion-> i know about the principal superiority of haskell (or believe in it) but i can't use it or only very inconveniently
13:16:41 <shapr> why not?
13:16:52 <shapr> why is it inconvenient?
13:17:13 <dandelion-> lack of libs, lack of tools... we mentioned it
13:18:52 <ibid> lack of portability
13:19:41 <shapr> I'm willing to write more libs.
13:20:37 <shapr> I even started a sourceforge project with that purpose, though I haven't done anything with it yet.
13:21:10 <dandelion-> what's the URL?
13:21:24 <shapr> http://sourceforge.net/projects/haskell-libs/
13:21:28 <dandelion-> tx
13:21:32 <shapr> that project has nothing but a plan :-)
13:21:56 <dandelion-> btw... i never figured out what the "tunes" project really is
13:22:13 <dandelion-> it seems to me that it is even less than a plan... or do they actually write any code?
13:22:20 <shapr> I don't know.
13:22:28 <shapr> They do talk a lot.
13:23:24 <shapr> the plan for haskell-libs is to steal the plan for OCamlnet: http://ocamlnet.sourceforge.net/doc/goals/goals.html
13:24:27 <shapr> someone wrote HTTP.hs recently
13:26:03 <shapr> I'd like to see libraries for network stuff first, specifically: smtp, and pop3.
13:27:18 <hdaume> has anyone read russell's thesis on FAD?
13:27:36 <shapr> I haven't even heard of it, do you have an url?
13:28:07 <shapr> ah http://www.cs.ukc.ac.uk/pubs/2001/1152/
13:28:07 <dandelion-> shapr: have you already used any graphics lib with haskell? which one? how did you like it?
13:28:21 <shapr> dandelion-: yes, I've used HOpenGL on my computer, and it worked great.
13:28:36 <shapr> I tried the demo programs that come with it, it was cool.
13:28:49 <shapr> I've also tried the haskell interfaces to gtk and gtk2
13:30:41 <dandelion-> i could not get anything running and i tried a lot
13:30:52 <dandelion-> but i will try it again and eventually get it running
13:40:21 <shapr> feel free to ask question here on #haskell
13:42:49 * shapr reads rusell's thesis
13:42:55 <shapr> hdaume: have you read his thesis?
13:45:06 * hdaume is amazed with your reading speed :)
13:45:15 <hdaume> i've skimmed parts
13:45:23 <hdaume> i'm trying to decide if its worth reading the whole thing
13:45:50 <shapr> it looks like it so far.
13:46:00 <ibid> shapr asked some time ago about my heros. didn't you?
13:46:04 <shapr> I'm interested in how he compares OO and FAD
13:46:06 <shapr> ibid: yes, I did.
13:46:16 <shapr> ibid: and you said you'd get back to me after thinking about it some.
13:46:32 <hdaume> yeah
13:46:37 <shapr> hdaume: I use HUnit and Test Driven Development, XP style
13:46:40 <ibid> shapr: well, i'm watching a memorial concert for john lennon, and i just realized that he's one of them
13:46:47 <shapr> ibid: cool!
13:46:51 <ibid> both musically and as a human being
13:47:20 <shapr> yah, lennon had drive and ambition.
13:47:34 <shapr> and discipline
13:47:48 <ibid> (there's a lennon.cc.jyu.fi here :-) (not mine though)
13:48:00 <ibid> (they say it's named in the series of dead musicians)
13:49:07 <shapr> nifty
13:49:21 <shapr> hdaume: have you used QuickCheck?
13:49:48 <shapr> I think Ani DiFranco is the musician I'd most like to know in real life.
13:50:08 <Marvin--> huh... QuickCheck.. I recognize that, is it something done here at GU/Chalmers?
13:50:52 <shapr> yup
13:50:53 <shapr> John Hughes
13:51:07 <Marvin--> well, most likely the functional programming research group
13:51:13 <shapr> QuickCheck is a new way to test programs.
13:51:18 <shapr> It's not like anything I've seen before.
13:51:37 <Heffalump> it's Hughes and Claessen
13:51:54 <shapr> I'd like to have xUnit, Design By Contract, and QuickCheck available for every language I write code for.
13:52:00 <hdaume> shapr: no, i haven't
13:52:03 <ibid> quickcheck?
13:52:19 <Heffalump> typeclass based randomised testing framework for Haskell code
13:52:23 <Marvin--> Hmm, I wonder if Claessen is teaching AFP this fall
13:52:32 <shapr> ibid: comes with GHC, best doc is the ICFP paper they wrote about it.
13:52:46 <ibid> bib data?
13:52:48 <hdaume> i'm so jealous of you people who actually have FP courses at your universities
13:52:54 <shapr> me too :-)
13:52:55 * ibid too
13:53:03 <Heffalump> I don't have any bib data to hand, but http://www.cs.chalmers.se/~rjmh/QuickCheck/
13:53:08 <Heffalump> Marvin--: you're going to AFP?
13:53:09 * ibid proposed such a course, didn't pass
13:53:18 * hdaume did too
13:53:23 <shapr> ibid: http://www.cs.chalmers.se/~rjmh/QuickCheck/
13:53:39 <Marvin--> Heffalump: no, it's a course here with the same name
13:53:51 <ibid> ahh, yes, i've heard of that. the name just didn't ring a bell
13:54:00 <shapr> it's nifty.
13:54:18 * ibid is interested more in things along the way of ccured and esc/{java,modula3}
13:54:20 <Heffalump> Marvin--: oh, right
13:54:22 <shapr> I keep meaning to start using it for all my Haskell code, but I'm still in the xUnit rut
13:54:30 <shapr> ibid: what's that?
13:54:41 <Heffalump> the problem with QuickCheck for me is that the tests aren't repeatable
13:54:55 <Heffalump> i.e. each time you run QuickCheck it uses a different set of test data
13:55:00 <Heffalump> which in some cases makes sense, but...
13:55:02 <ibid> shapr: esc/* are extended static checkers, something between a type checker and a full formal verifier
13:55:12 <shapr> Heffalump: how hard would it be to extend QuickCheck to save tests that fail?
13:55:22 <shapr> and then always try those?
13:55:24 <Heffalump> it prints them out for you
13:55:40 <ibid> shapr: ccured is a new type system for c that statically finds most buffer overruns (requires little language changes)
13:55:50 <Heffalump> well, you'd have to actually store the tests somewhere in the source
13:56:01 <shapr> what about a config file?
13:56:21 <shapr> a boring flat file that saved test and test data?
13:56:23 <Heffalump> possibly, it'd all get rather messy
13:56:32 <shapr> can you think of a better solution?
13:56:50 <Heffalump> well, not really :-)
13:57:00 <shapr> I can't either...
13:57:01 * shapr thinks
13:58:43 <ibid> shapr: http://manju.cs.berkeley.edu/ccured/
13:59:01 <ibid> http://research.compaq.com/SRC/esc/
13:59:10 <ibid> neither are free software, sadly
14:05:05 <hdaume> shapr: out of curiousity, how do you pronounce your first name?  is it like "play" or "fly"?
14:05:19 <hdaume> (or neither)
14:09:14 * gene9 btw - http://tunes.org/~nef/haskell/ -- 404, and http://tunes.org/~nef/logs/haskell/ is ok
14:14:34 <shapr> hdaume: shay
14:14:48 <shapr> hdaume: how do you say yours? ;-)
14:15:12 * hdaume thinks...
14:15:21 --- topic: set to 'We put the Funk in Funktion || See logs @ http://tunes.org/~nef/logs/haskell/ || HOpenGL 1.03 released - http://haskell.org/HOpenGL || looking for team members for a #haskell ICFP contest entry, more info when the HaskellWiki returns.' by shapr
14:15:54 <shapr> dom? dowmeh?
14:16:08 * Heffalump always assumed "dorm"
14:16:19 <shapr> I assumed "dom"
14:16:26 <Heffalump> but I keep assuming things about names I see written down that turn out to be completely wrong
14:16:35 <shapr> me too.
14:16:50 <shapr> hi rjljr
14:17:24 <rjljr> greetings! I see some familiar names from the mailing lists
14:17:26 <hdaume> ooh, my last name.  kinda like dow may.  it used to me just "dom" but at some point in my family's history they movied to the alsace-lorraine (sp?) area and took on a psuedo-french pronunciation
14:17:51 <shapr> hi rjljr, have you posted to the mailing list?
14:17:54 <Heffalump> "alsace-lorraine" is spelt correctly but "psuedo" isn't :-)
14:17:55 <hdaume> (the "e" technically has an accent on it)
14:17:59 <hdaume> haha
14:18:01 <hdaume> oops
14:18:29 <rjljr> shapr: Yep .. (name is legere)
14:18:33 <shapr> ohhh
14:18:36 <shapr> you're ronald legere
14:18:39 <shapr> aha!
14:18:39 * Heffalump always thought Alsace-Lorraine was funny in history lessons
14:18:44 * hdaume is impressed that heff used the word spelt
14:18:44 <rjljr> yep, thats me!
14:19:08 <shapr> cool, nice to meet you in real-time.
14:19:18 * rjljr hasn't used IRC for some time :)
14:19:31 <shapr> I'm Shae Erisson, I don't remember if I've posted to the mailing list.
14:19:32 <Heffalump> "spelt" and "spelled" are both valid, aren't they?
14:20:00 <hdaume> yeah
14:20:06 <rjljr> I don't recall..
14:20:52 <shapr> rjljr: what do you do with Haskell?
14:21:25 <rjljr> Not much recently. I WANT to get back into doing some composing with Haskore, which is how I got started with haskell in the first place.
14:22:22 <rjljr> I have been using it with the ffi for doing some simulations. But really just toy problems. 
14:22:51 <hdaume> it really amazes me the variety of things people use haskell for...i'd always assumed it was alone as a person who didn't do compiler stuff with it :)
14:23:18 * rjljr laughs.
14:24:04 <shapr> I'm hoping to do web development with Haskell.
14:24:21 <rjljr> hal, did you resolve the issue with 'idiom'? Did you decide to use existentials?
14:24:46 <rjljr> shapr: I have no experience with that.. isnt there an Html library or something? 
14:24:46 <hdaume> rjljr: yes & yes
14:24:59 <shapr> rjljr: yes, several
14:25:23 <shapr> one comes with GHC, Peter Thiemann wrote WASH, which does both CGI and HTML generation
14:25:32 <shapr> and there's the ever famous HaXml
14:26:21 <rjljr> hal: Interesting. I have never been convinced that existentials are REALLY necessary, but they are convenient.
14:27:11 <rjljr> shapr: Right... i never had to use them though ...
14:27:11 <hdaume> rjljr: i agree; i've never *really* used them until now (where really = for anything other than a 50 line toy module)
14:27:25 <rjljr> heh
14:27:41 <shapr> I haven't tried Haskore. It does look interesting.
14:28:53 <rjljr> its pretty fun...  nice example of how to do DSL's too.
14:29:07 <hdaume> i feel somewhat silly: a month ago i defended that you couldn't have named fields in exist. datatypes, and now i want them :)
14:29:21 <shapr> does Haschorus add much functionality?
14:29:52 <rjljr> shapr: I never tryed Haschorus. Its on my things to do list. :)
14:30:19 <shapr> cool
14:30:40 <rjljr> Hal: heh, I dont recall that thread. was that ghc-users?
14:30:50 <hdaume> perhaps
14:31:00 * hdaume doesn't tend to pay attention to that
14:31:30 * rjljr doesnt much either. I get a digest, and must confess I sometimes delete without reading :)
14:32:23 <rjljr> but mostly I try to browse the subject lines :)
14:35:31 * shapr reads Haskore docs
14:35:38 <rjljr> Well, I must eat. Nice to meet you both online!  Cheers.. till next time
14:35:42 * rjljr waves.
14:35:45 <shapr> cya
14:39:38 <shapr> urk, it has case problems.
14:39:55 <Heffalump> what has?
14:40:03 <shapr> Haskore
14:40:13 <shapr> import Ssf  but SSF.LHS
14:40:31 <delYsid> ahem, how do I use parsec with ghc5 in debian?
14:40:43 <shapr> delYsid: -package text
14:40:44 <delYsid> Isn't this supposed to work with -pParsec or something?
14:40:56 <shapr> I dunno about that.
14:41:29 <shapr> delYsid: it works for me, what's up?
14:41:43 <delYsid> tnx, works now
14:42:12 <delYsid> hmm, can I persuade C-c C-l to also use this argument for ghci?
14:42:12 <shapr> delYsid: have you gone through the Parsec tutorial already?
14:42:23 <delYsid> tutorial?
14:42:30 <shapr> delYsid: yah, ":set -package text"  in ghci
14:42:39 <shapr> delYsid: you can also edit your ~/.ghci
14:42:43 <shapr> and put the same line into it.
14:42:57 <delYsid> cool
14:43:41 <shapr> delYsid: tutorial: http://www.cs.uu.nl/~daan/papers/parsec.html
14:43:56 <shapr> delYsid: in other formats also, from: http://www.cs.uu.nl/~daan/parsec.html
14:44:16 <hdaume> does anyone know if Haskell has any sort of reflection (ala Java)?
14:44:40 <shapr> I don't think it does.
14:44:47 <shapr> Heffalump does ask for it every few weeks though :-)
14:44:57 <ibid> the template stuff adds static reflection, no?
14:45:00 <shapr> Template Haskell will let you have that at compile time.
14:45:02 <shapr> right
14:45:10 <hdaume> i remember a discussion a while back about loading modules the way ghci does...it seemed to be a pain in the ass though
14:45:34 <Heffalump> chillix has a student who's done that, apparently
14:45:35 <shapr> One of Chilli's students has done something like that, but is currently on vacation.
14:45:53 <shapr> Heffalump: did you find out when he was returning?
14:46:01 <delYsid> shapr: yah, I've read that.
14:46:13 <delYsid> Well, I miss a dynamic kind of introspection too!
14:46:19 <shapr> delYsid: cool, how does it compare to Tiger?
14:46:23 <shapr> I haven't even looked at Tiger.
14:47:01 <ibid> tiger, appel's example?
14:47:06 <delYsid> shapr: Tiger i Parsec/examples/Tiger
14:47:08 <delYsid> :)
14:47:08 <shapr> ohhh
14:47:09 <shapr> duh
14:47:14 * hdaume loves Tiger
14:47:23 <shapr> geez, I thought Tiger was another parser.
14:47:36 <ibid> does it have anything to do with appel's tiger?
14:47:41 <delYsid> Tiger is infact a parser :)
14:47:53 * shapr is now thoroughly confused
14:48:11 <delYsid> Look at Tiger.hs, it's a Tiger parser :)
14:48:33 <Heffalump> shapr: nope
14:48:34 <shapr> oh, cool.
14:49:03 <delYsid> But it doesn't execute the code :/
14:49:37 <hdaume> for my final project in my undergrad compilers class my friend and i implemented software pipelining into our tiger compiler.  it was fun :)
14:49:59 <ibid> all the tiger stuff appears to be removed in cvs
14:50:22 <ibid> ah, it is appel's tiger
14:50:32 <ibid> (why didn't anybody say so?:-)
14:50:52 <shapr> I think this conversation has become recursive ;-)
14:51:32 <ibid> oh?
14:51:45 <ibid> maybe we can find its least fixpoint?
14:51:54 * shapr grins
14:52:11 * hdaume wants to slap ibid, but finds himself grinning too
14:53:10 <ibid> why?
14:53:33 <hdaume> that joke was unnecessary, yet somehow amusing :)
14:54:13 * shapr tries to get Haskore working in ghc5.04
14:54:25 * hdaume _hates_ ghc5.04
14:54:32 <shapr> really? why?
14:54:43 <ibid> which joke?
14:54:56 * ibid has been thoroughly confused during this whole conversation
14:55:01 <hdaume> i just had a hell of a time getting everything working in it
14:55:07 <hdaume> ibid: the fixed point joke :)
14:55:41 <ibid> it was a natural continuation
14:55:51 <Marvin--> argh, continuations
14:55:55 * shapr laughs
14:56:10 <hdaume> haha
14:56:18 <ibid> besides, i can give as my defense the fact that i've been working on the part of my thesis that describes fixpoints as a way to define recursive structures...
14:56:29 <shapr> are you using CPS in your thesis?
14:56:33 <ibid> no
14:56:52 <Marvin--> CPS?
14:56:58 <hdaume> cont passing style
14:57:01 <Marvin--> ah
14:57:01 <ibid> continuation passing style
14:57:29 <ibid> the thesis is about a particular formal method, i'm reconstructing its peculiar version of mathematics
14:57:43 <shapr> has the % op changed since 2000?
14:57:44 * ibid has learned to hate typed set theory in the process
14:58:01 <Marvin--> fixpoints are cute though
14:58:27 <shapr> I've fixed one fromInt to fromInteger in Haskore
14:58:32 <ibid> (besides, when is a jokrr necessary?)
14:58:37 <ibid> s/rr/e/
14:59:03 <shapr> it says "%" isn't in scope.. any idea what that operator was years ago?
14:59:24 * hdaume needs to learn more formal programming stuff...fixed points in math are fine...in programming they confuse me
14:59:46 <shapr> see, when I hear fixed point, I think of thumbtacks.
15:00:00 <ibid> thumbtacks?
15:00:17 <shapr> yah, pointy things you stick in the wall to hold up posters.
15:00:24 <ibid> ah
15:00:33 <ibid> nuppineula
15:00:44 <shapr> interesting word
15:01:19 <dark> I have my posters anchored better than that.  But it's so much work that half of my posters haven't been hung yet.
15:01:37 <shapr> are you using a nailgun? ;-)
15:02:03 <shapr> any idea what (3%2) used to be in haskell?
15:02:15 <dark> Nah, just screws, string, and frames.
15:02:23 <shapr> maybe mod?
15:02:26 * ibid uses sinitarra
15:02:26 <dark> Looks like an over-elaborate smiley to me :)
15:02:31 <ibid> whatever that's in english
15:02:50 <dark> ibid: The blue stuff?
15:03:02 <ibid> % is rational number constructor iirc
15:03:05 <ibid> dark: yeah
15:03:06 <dark> It's probably called Blu-Tack or something revolting like that.
15:03:10 <ibid> yes
15:03:18 <shapr> I think that is what it's called in the USA.
15:03:21 <ibid> that rings a bell
15:03:31 <shapr> ibid: any idea where it comes from?
15:03:41 <ibid> shapr: %? module Ratio?
15:03:48 <shapr> oh. too easy.
15:03:59 * shapr notes that #haskell has six .fi hostnames
15:04:23 <shapr> muuta, miksei
15:04:26 <dark> Symbols are used in so many modules that I don't dare define ones of my own :)  I wish I could mix letters and symbols, and have functions like expr_+
15:04:49 <Heffalump> dark: you don't have to export them
15:05:06 <ibid> or import
15:05:23 <Heffalump> indeed
15:05:27 <shapr> yay, HaskoreExamples.lhs loads!
15:05:29 <dark> Heffalump: Exporting them was the point :)  This is the interface for the expression-tree module that'll be the basis of my program.
15:05:36 <Heffalump> ah
15:06:09 <shapr> dark: you could just surround your ops with smiley faces. (-:!:-)
15:06:19 <dark> Are operators like [+] already used for anything?
15:06:34 <dark> shapr: Obviously that would conflict with the Smiley module :-)
15:06:34 <shapr> doesn't that mean a list?
15:06:37 * shapr laughs
15:06:37 <ibid> is [+] really allowed?
15:06:49 <dark> Hmm I hadn't thought to check :)
15:06:54 <ibid> no, the list would be [(+)] i think
15:07:00 <shapr> good point.
15:07:27 <dark> I get a parse error though.  So that's out.
15:07:37 <dark> I might just settle for expr_add, expr_bitand, etc :)
15:07:41 <ibid> dark: you can always say MyModule.+ and Prelude.+ :-)
15:07:56 * ibid would use data constructors
15:08:00 <dark> ibid: Expr.+ might actually be readable :-)
15:08:01 <ibid> :+, :- jne
15:08:16 <ibid> but that's me
15:08:24 * ibid wants everything to be an ast :-)
15:08:29 <Igloo> <+> etc aren't defined by H98
15:08:44 <Igloo> .+. is another one I've seen people use
15:09:38 <ibid> bed time
15:09:41 <shapr> g'nite
15:09:47 <shapr> hi Igloo, what's up?
15:10:05 * shapr tries to figure out how to actually play stuff with Haskore
15:11:25 <Igloo> Well, moved in to new house now, so poor connectivity for a bit  :-/
15:11:43 <Heffalump> what connectivity do you have?
15:11:47 <shapr> think you'll be connected for ICFP?
15:11:55 <dark> Igloo: a bit per what? :)
15:12:00 <shapr> rehi dandelion-
15:12:18 <dandelion-> rehello shapr
15:13:08 <Igloo> At the moment I have "Walk to the 512k connection on the othrer side of Oxford" connectivity
15:13:19 * shapr grins
15:13:39 <Heffalump> where are you sleeping then?
15:14:01 <Igloo> I will attempt to upgrade to "Walk to the 10M connection in the center of Oxford" connectivity next week
15:14:06 <Igloo> Chaos
15:14:28 <Heffalump> and you're at Art's now?
15:14:30 <dark> We used to DREAM of 512k connections... upstream both ways... matchboxes connected by wet string... kids these days...
15:14:37 <Heffalump> he does have to walk to it...
15:14:44 <Igloo> Yup
15:14:56 <shapr> dark: :-P
15:14:57 <Heffalump> just for the connectivity? :-)
15:15:03 <shapr> dark: hey, I started with a 1200 baud modem.
15:15:21 <shapr> my ftp sessions could take days.
15:15:24 <Igloo> Well, we had to go as far as the center to get food anyway. We paid a bus to do the working for us, too
15:16:28 <Igloo> Tomorrow we should have a cooker on which to cook, and the day after a fridge/freezer in which to put things to cook, though. Then on Wednesday we should get the bed,
15:20:37 <dark> Being ill means having a lot of time for coding... but it's not good for the quality of the code :)
15:21:50 <dark> Apparently I thought last night that "simplify t (Cast t' x) = simplify_cast t t' (simplify t' x)" didn't need commenting.  Now I wonder which t was what.
15:22:16 <hdaume> :)
15:23:12 <ChoJin> :)
15:23:16 <ChoJin> term ?
15:23:40 <ChoJin> or type
15:23:41 <ChoJin> :)
15:24:40 <dark> I think the first t is the "context type", in which the expression will be evaluated... so the t' is what the cast casts to, which is why it's the context type for the casted expression.
15:26:03 <dark> I think simplify_cast exists because I couldn't figure out another way to avoid infinite recursion :)  I made helper functions that got already-simplified arguments.  But now I wonder if that really works.
15:26:23 <dark> When I decided to make a reverse-engineering program, I didn't mean it quite like this :-)
15:26:39 * shapr laughs
15:29:55 * shapr still can't figure out how to make music with Haskore
15:39:17 * gene9 is away: I'm busy
15:39:33 * shapr is confused
15:40:30 <shapr> oh
18:51:04 * ChilliX is back (gone 00:00:55)
