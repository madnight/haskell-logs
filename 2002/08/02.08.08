00:10:40 <delYsid> eeeek, graphical programs, why?
00:11:49 <Pseudonym> In component-based development that doesn't sound too bad.
00:12:00 <Jii> hmh, is that www.cs.utexas.edu slashdotted now
00:12:05 <Pseudonym> You write the components in your convention language then the rest is plumbing.
01:47:54 <delYsid> Anyone know what SequenceUtilities is, and where I can find docu?
02:02:59 <Heffalump> the only reference to it I can find is in some ou.edu course material
02:39:25 * shapr blinks
02:40:15 <Jii> the humble programmer is a great piece of text
02:42:16 <Jii> "I pray daily that more of my fellow programmers may find the means of freeing themselves from the curse of compatibility." [he talks about fortran, but this applies today, too :-)]
02:49:00 <delYsid> grrrr
02:49:13 * delYsid tries to figure out how to define perfectGameFromPosition
02:49:45 <delYsid> perfectGameFromPosition :: Real num =>
02:49:45 <delYsid>  (position­>[position]) ­> (position­>num) ­> (position­>Player) ­> position ­>
02:49:45 <delYsid>  position
02:53:04 <Heffalump> what's it supposed to do?
02:55:54 <delYsid> It should generate the final position.
02:56:02 <delYsid> But I have another prob right now:
02:56:04 <delYsid> gameTree:: (position -> [position]) -> position -> Game position
02:56:17 <delYsid> -- What is wrong there? ghc complains about parse error at ->
02:57:02 <Heffalump> errm, types start with capital letters
02:57:12 <Heffalump> if you use small letters that's a type variable
02:57:17 <Heffalump> which may be what you meant, of course
02:57:22 <delYsid> yeah
02:57:25 <Heffalump> hmm, dunno why that'd be a parse error, actually.
02:57:33 <delYsid> position should be any kind of type...
02:57:40 <Heffalump> stick the whole file on the web?
02:57:47 <delYsid> k
02:58:29 <delYsid> http://lexx.delysid.org/Minimax.hs
03:00:02 <Heffalump> all your type signatures use > not ->
03:00:31 <delYsid> hu?
03:01:03 <shapr> you're missing a bunch of dashes
03:01:06 <Heffalump> are you having a problem distinguishing the two things I just said?
03:01:40 <Heffalump> every single function arrow in your type signature is a right angle bracket on its own, not dash, right angle bracket as it should be
03:01:53 <delYsid> ahh :)
03:01:56 <delYsid> well, it isnt! :)
03:01:59 <delYsid> but it sort of is
03:02:09 <Heffalump> sorry?
03:02:19 <delYsid> pstotext converted the -> to (unknownchar)>, but unknownchar looks like - on my display.
03:02:39 <shapr> oh
03:02:43 <shapr> weird
03:02:47 <delYsid> yeah
03:02:51 <delYsid> tnx for spotting it
03:03:11 * shapr points to Heffalump
03:03:30 <Heffalump> ah :-)
03:04:02 <Heffalump> I did check the source, and it appears that the only character before > is a space in that
03:04:24 <Heffalump> but your web server might be cleaning up the (unknownchar)s
03:07:13 <Jii> a semi-friend of mine said that the primality testing paper mentioned here (and in slashdot) was claimed to have trivial mistakes according to their resident crypto guru
03:12:54 <delYsid> Heffalump: Any idea on perfectGameFromPosition?
03:13:26 <shapr> hey Jii, have you looked at http://www.cwi.nl/htbin/sen1/twiki/bin/view/SEN1/MetaEnvironment yet?
03:14:36 <Jii> hmm no i haven't
03:14:43 <Heffalump> umm, I still don't really understand what it's supposed to do
03:16:31 <delYsid> given a position, a move-generation function, a "who is next" function, and a function to score a position, it should return the final position of that game assuming that each player always plays his best move.
03:17:18 <delYsid> basicly, it should apply play to the result of gameTree moves p recursively till the end is reach... but I dunno how..
03:20:59 <Heffalump> position -> (position -> [position]) -> Player -> (position -> num) -> position
03:21:13 <Heffalump> oh, who is next function
03:21:26 <Heffalump> anyway, basically what you said above
03:21:43 <Heffalump> oh, you need to define it, not give it a type, sorry
03:21:48 <delYsid> the sig is in Minimax.hs already...
03:21:51 * Heffalump wakes up
03:22:11 <delYsid> perfectGameFromPosition :: Real num =>
03:22:11 <delYsid>  (position->[position]) -> (position->num) -> (position->Player) -> position ->
03:22:11 <delYsid>  position
03:22:13 <Heffalump> you need to write a scorePosition function first.
03:22:32 <Heffalump> does your function to score a position only work with final positions?
03:23:04 <delYsid> score only scores a position.
03:23:15 <delYsid> No matter if it's final or not, it scores the static score.
03:23:44 <Heffalump> ok, well if you're planning to write perfectGameFromPosition (which will be computationally infeasible to actually use most of the time), you only need to be able to score final positions
03:24:28 <Heffalump> write a function scorePosition that takes a possible moves function, the whose turn is it function and the score final positions function, and gives the final score assuming best moves by everyone
03:24:53 <Heffalump> in fact you could just tuple the final score with the actual position, then perfectGameFromPosition would be just a case of taking the second element of that tuple
03:25:14 <delYsid> ahhh
03:25:34 <delYsid> I have already everything I need for this abstract impl. of Minimax :)
03:26:24 <delYsid> gameTree generates the tree of possible positions given a initial position and a possible-moves-function
03:26:54 <delYsid> play makes the best move (returns the new position) given a "who-is-next-function", a score function, and a gameTree
03:27:54 <delYsid> perfectGameFromPosition now only needs to return the final position (apply play till we reach the end)
03:28:26 <delYsid> the whole idea there is that score is abstract... So we could provide one scorePosition for chess, only for tic, and so on...
03:28:44 <delYsid> s/only/one/
03:29:00 <delYsid> (read minimax.hs, only the commented out func is missing)
03:29:02 * delYsid goes to eat
04:12:15 <Jerub> shapr: You know how I said there was a project at my uni trying to create a language based editor?
04:14:33 <shapr> yah?
04:15:01 <Jerub> I finally got the cvs details for it, I'm checking it out now.
04:15:07 <shapr> cool
04:15:21 <shapr> any info yet?
04:15:43 <Jerub> shapr: I don't think they have a website.
04:15:45 <shapr> I'm trying to get MetaEnv setup on my system so I can try it out.
04:17:38 <Jerub> coolish
04:19:13 <Jerub> 36k loc.
04:19:18 <shapr> wow
04:19:44 <Jerub> shapr: Put it this way, This was a Ph.D research topic close to 10 years ago.
04:19:48 <Jerub> Its *still* *going*
04:19:52 <shapr> wow
04:21:08 <Jerub> shapr: what does it take to download/install MetaEnv
04:21:14 <Jerub> or are you still trying to figure that out?
04:21:48 <shapr> I've done apt-get install cwi-* which gets most of the dependencies
04:22:13 <shapr> now I'm trying to find the minimum amount of manual installation I can get away with.
04:22:28 <Jerub> ya, it seems like thats a little hard.
04:22:36 <Jerub> all I want is a cvs checkout and a make && make install.
04:22:38 <Jerub> ;)
04:22:48 <Jerub> I'm having trouble with UQ* and autoconf atm.
04:23:05 <shapr> the guy who made the cwi-* packages told me that all of metaenv will be in soon
04:23:54 <shapr> but I want to play with it before soon
04:24:01 <shapr> specifically, now
04:24:41 <Jerub> shapr: Want UQ* cvs? I'm sure they won't mind too much.
04:25:48 <shapr> tell me more about it.
04:26:01 <Jerub> -d:pserver:anoncvs@anoncvs.itee.uq.edu.au:/cvs
04:26:09 <Jerub> As I'm lead to understand, its a language based editor.
04:26:26 <Jerub> I.e. Its designed to detect static and dynamic semantic errors in programming.
04:26:30 <Jerub> As you type.
04:26:38 <shapr> ok, I'll try it.
04:26:40 <shapr> hi jii
04:26:42 <Jerub> Its based on an incremental compiler
04:26:49 <shapr> sounds interesting.
04:27:10 <Jerub> and its language independant. You provide an EBNF grammer + such.
04:27:57 <Jii> is it really "grammer" in english? i thought it was "grammar"?
04:28:04 <shapr> it is grammar
04:28:57 <Jerub> awritgh, rho seitched ym jetyops awroudn?
04:29:15 * shapr grins
04:29:45 <Jerub> I'm doing a grep -irs on /usr
04:31:13 <Jerub> its taking a while
04:32:30 * shapr watches Jii bounce
04:32:54 <Jii> yes, very annoying
04:33:11 <Jii> i really should patch this client 
04:33:21 <Jii> (come up with patch first, though :)
04:33:25 <shapr> wanna try erc? :-)
04:33:55 <Jii> what is it written in? ;-)
04:34:26 <shapr> elisp =)
04:34:28 <Jerub> whats rc?
04:34:30 <Jerub> er erc?
04:35:03 <shapr> http://sf.net/projects/erc :-)
04:35:36 <Jii> well the one i am using is written in python
04:35:56 <shapr> oh, which one?
04:36:40 <Jii> clirc (http://www.s2.org/clirc)
04:37:39 <Jii> mostly, if there's an error of any kind, which are rare, it just spills out the exception on the screen and continues normally, but there are conditions where it crashes (like the one just before my join)
04:38:08 <Jerub> Stupid error -> autoconf: Undefined macros: configure.in:83:AC_PATH_QT
04:38:43 <Jerub> shapr: Thanks to the haskell discussions here over the last week I've come accross as a smartarse git on our subject newsgroup. Thanks :)
04:44:36 * Jerub tries qt2 instead of qt3.
04:44:56 <shapr> Jerub: eh?
04:45:29 <dandelion-> would it be possible to use qt with haskell or is it, in principle, impossible, because qt is a c++ lib?
04:45:30 <Jerub> shapr: Just having autoconf troubles with UQ*.
04:45:39 <shapr> dandelion-: it's possible
04:46:08 <Jerub> shapr: really?
04:46:21 <Jerub> QT is ''nice'' from a C++ point of view, is it ''nice'' for haskell as well?
04:46:29 * shapr dunno
04:50:30 <Jerub> Jii: what client are you using? t-im ?
05:28:26 <delYsid> Prelude TicTacToe> putStr . ticTacToe $ "XX##O##XO"
05:28:26 <delYsid> XXO 136
05:28:26 <delYsid> #OO #28
05:28:26 <delYsid> XXO 754
05:28:29 <delYsid> -- Yay!
05:29:58 <delYsid> hmm, anyone can suggest a better way to write perfectGameFromPosition in http://lexx.delysid.org/Minimax.hs?
05:30:20 <delYsid> Right now I construct the gametree separately for every spet (which isnt the way to go)
05:30:41 <shapr> spet?
05:30:48 <shapr> spet == game move?
05:30:58 <shapr> from spiel/spel maybe?
05:32:22 <delYsid> huh?
05:32:29 <delYsid> Not a better name, a better alogo :)
05:32:33 <shapr> "for every spet" ?
05:32:55 <delYsid> ahh
05:32:57 <delYsid> step
05:33:11 <shapr> oh :-)
05:33:30 <delYsid> perfectGameFromPosition :: Real num =>
05:33:30 <delYsid>  (position->[position]) -> (position->num) -> (position->Player) -> position ->
05:33:30 <delYsid>  position
05:33:30 <delYsid> --
05:33:30 <delYsid> perfectGameFromPosition moves score player p =
05:33:31 <delYsid>   nextPos moves score player (gameTree moves p)
05:33:33 <delYsid>  where
05:33:35 <delYsid>   nextPos moves score player (Plays p xs)
05:33:37 <delYsid>    | null xs = p
05:33:39 <delYsid>    | otherwise = nextPos moves score player (gameTree moves (play (player p) score (Plays p xs)))
05:34:39 <delYsid> I'm sure I can remove the second call to gameTree somehow
05:38:09 <delYsid> But I dunno how...
05:47:56 <delYsid> hmm
05:47:58 * delYsid gives up
05:52:48 <delYsid> hmm
05:53:11 <delYsid> dark: Time to look at a func. and find a better impl.?
05:53:37 <dark> delysid: Sure.
05:54:16 <dark> Hey... GTK+HS is not packaged for Debian.
05:54:33 <shapr> that's true.
05:54:55 <dark> Well, someone fix it!
05:55:01 <shapr> heh
05:55:07 * dark checks the WNPP.
05:55:22 <shapr> talk to michaelw
05:57:03 <dark> shapr: Because he's working on it, or because he might be convinced? :)
05:57:16 <dark> delysid: ... where is it?
05:57:54 <delYsid> dark: http://lexx.delysid.org/Minimax.hs
05:58:07 <delYsid> I'd like to get rid of the second call to gameTree in perfectGameFromPosition
06:00:17 <shapr> dark: because michaelw is the guy who did ghc5-*
06:05:53 * dark studies the code.
06:11:58 <dark> delysid: I think the trick is to make play return not a position but a Game position.  So not just the chosen move, but the subtree corresponding to that move.
06:12:27 <delYsid> ahh
06:12:29 <delYsid> lemme think
06:13:17 * dark thinks too.
06:13:42 <delYsid> hmm, that will change play completely.
06:13:53 <delYsid> It maps itself over gs.
06:16:20 <dark> I don't think I understand what it does, yet :)  Is it supposed to return the next position, or the end position?
06:17:07 <dark> perfectGameFromPosition makes sense if it returns the next position, but I don't see it doing that.
06:18:02 <delYsid> It returns the final position
06:18:30 <delYsid> Actually, It returns the final position given the asumption that each player at every move makes the optimal move he has
06:18:59 <dark> Right... play only returns p if (moves p) is null.
06:19:50 <delYsid> yes
06:19:52 <dark> So what does perfectGameFromPosition do?  I don't see how its call to gameTree can return anything other than (Plays p []), where p is what play returned.
06:19:57 <delYsid> Otherwise it returns the best move of (moves p)
06:20:18 <delYsid> no
06:20:29 <delYsid> gameTree moves p returns the whole gameTree
06:20:36 <delYsid> given a non-final p that is.
06:20:57 <dark> Right, but if p is what play returned, then it's a final p, right?
06:21:25 <delYsid> no
06:21:39 <delYsid> play only returns the position which would result from the best move the player has
06:22:27 <dark> I don't see it doing that.  play PlayerA maps play PlayerB over gs, which descends further... the only p that ever gets actually returned is a final one.
06:22:44 <delYsid> no
06:22:52 <delYsid> look at (minPosition score).
06:22:58 * shapr is entirely missing clue about Minimax.hs
06:23:13 <delYsid> It foldr's the possible moves, so that the maximum/minimum scored move is returned
06:24:03 <delYsid> dark: so it maps over the moves of the opposite player, and then foldr's them into one move, the one with the maximum score.
06:25:18 <dark> But this "one move" is from its input list... the result of the map.  So it's not one of its own moves.
06:25:19 <delYsid> play PlayerA score (Plays p gs)
06:25:19 <delYsid>  | null gs = p
06:25:19 <delYsid> -- So this applies if the gameTree only has one position (final pos)
06:26:05 <dark> shapr: It took me some time of studying to get this far :)
06:27:27 <delYsid> dark: p is the current position.
06:27:38 <Jii> heh, that Primes in P paper has been featured in NY Times and Number Theory mailing list although (couple of friends of mine claim) it doesn't hold (and primes are proved to be in P already)
06:27:39 <delYsid> gs are all possible positions after p
06:27:49 <Jii> i wish i was better in maths
06:28:06 <dark> Jii: I think lots of people think it means factorization is in P.
06:28:21 <dark> i.e. RSA is cracked :-)
06:28:41 <dark> delysid: I'm looking at what (map (play PlayerB score) gs) means.
06:29:15 <dark> delysid: "play PlayerA score" returns a move from that list.
06:29:25 <Jii> they say that it has (major) flaws too 
06:29:28 <delYsid> right
06:29:39 <shapr> Jii: who, the press? or your friends?
06:30:02 <dark> delysid: But what does the list contain?  Apparently, for each move A could make, the best reply for B.  But why would "play PlayerA" return a move for B?
06:30:06 <Jii> shapr, friends
06:30:10 <shapr> ok
06:30:31 <delYsid> its not a move from B
06:30:34 <delYsid> its a move from A
06:30:38 <delYsid> because p is the current position
06:30:45 <delYsid> the result of play must be one of gs
06:31:01 <delYsid> so the map maps over gs to find the best answers B would make...
06:31:11 <delYsid> Its a recursive minimax
06:31:13 <dark> Right, but it isn't.  foldr runs over (map (play PlayerB score) gs), not over gs.
06:31:41 <dark> And (maxPosition score) returns one of its arguments, so the foldr returns an element from its argument list.
06:31:54 <delYsid> yes!
06:32:28 <dark> Is this a frustrated "yes!" or an eureka "yes!"? :)
06:32:45 <Jii> or frustrated eureka? ;-)
06:32:50 <delYsid> It's a frustrated one :)
06:33:02 <delYsid> hmm
06:33:19 <delYsid> I'm not native english, that doesnt help here, but it's perfectly clear to me that it works that way, lemme try again.
06:34:19 <delYsid> (play PlayerB score) p returns the pos after the best move for playerB given p
06:35:21 <delYsid> (map (play PlayerB score) gs) returns a list of positions, all the positions playerB can reach if we choose one of gs.
06:35:30 <delYsid> Then the foldr over that returns our best move.
06:35:51 <dark> That last step is where you lose me.
06:35:54 <delYsid> The whole trick is that play dispatches on PlayerA or PlayerB, and either takes the maximum, or the minimum.
06:37:12 <dark> How can a foldr over positions PlayerB can reach, return a move for PlayerA?  The list of PlayerA's moves is simply not available to it.
06:37:30 <delYsid> er
06:37:30 <delYsid> hmm
06:37:53 <dark> It looks to _me_ like play does what perfectGameFromPosition is supposed to do :-)
06:40:14 <delYsid> oh!
06:40:17 <delYsid> score
06:40:24 <delYsid> it can decide that
06:40:27 <delYsid> er
06:40:28 <delYsid> hmm
06:40:31 * delYsid is confused
06:41:39 <dark> I'm assuming that score returns high values if it looks good for PlayerA, and low values if it looks good for PlayerB?
06:41:59 <delYsid> right
06:43:33 <delYsid> ahhhh!
06:43:40 <delYsid> gs is the list of our moves possible
06:45:24 <delYsid> the map now returns a list of all best replies playerB could make
06:45:39 <delYsid> the maximize takes the pos with the best score...
06:46:27 <delYsid> hmm, I'll go, smoke a cigarette, and try to explain it in a nice english sentence later (except you find it our)
06:46:36 <delYsid> btw, the code is tested and is working, so it's not a bug
06:48:10 <dark> delYsid: I think it works because perfectGameFromPosition returns exactly what play returns :)
06:48:17 <dark> delYsid: Did you test play by itself?
06:51:40 <delYsid> lemme check
07:04:01 <jewel> how does one implement RPC stubs in a functional language?
07:04:38 <jewel> The original implementation language (C), allows you to pass objects by reference and they are modified to contain new values
07:05:14 <Heffalump> objects by reference?
07:05:19 <Heffalump> as in pointers?
07:05:24 <jewel> yes
07:05:54 <jewel> I think the Java approach was to wrap each of these in an object that could have its primitive modified
07:05:56 <Heffalump> use IORefs?
07:06:13 * jewel finds IORefs
07:08:41 <delYsid> dark: You're of course right!
07:08:43 * delYsid blushes
07:08:46 <delYsid> hmm
07:09:37 <delYsid> well, now the question is, how to rewrite move so that it really only returns the next move...
07:09:48 <delYsid> er, play I mean
07:10:10 <Heffalump> but does infinite lookahead?
07:10:15 <Heffalump> s/infinite/unbounded/
07:10:51 <dark> delysid: I went and tested it myself with a very simple game :)
07:10:55 <jewel> erm, where would I look for IORefs?
07:11:39 <Heffalump> in IO?
07:11:49 <dark> delYsid: So you still need a separate play?
07:12:07 <jewel> Where would I find the documentation,  in the Haskell Library Report?
07:12:14 <dark> delYsid: I guess you do if you intend to actually play the game :-)
07:12:23 <delYsid> right :)
07:12:44 <delYsid> bestMove or something...
07:14:17 <Heffalump> http://www.haskell.org/ghc/docs/latest/html/base/Data.IORef.html
07:15:37 <Heffalump> I'm sure using pointers is documented properly in the FFI spec, though
07:17:38 <jewel> Where is the FFI spec?
07:18:17 <jewel> Does doing RPC over network sockets imply use of the FFI?
07:18:49 <dark> delysid: I think that first you need maxGame and minGame, which operate on Game position instead of position.
07:19:05 <dark> delysid: Then have bestMove be just like play but return a Game position
07:19:20 <Heffalump> jewel: oh, maybe not
07:19:37 <dark> delysid: delysid: Then... oops :)
07:19:49 <dark> delysid: I guess the max and min functions must run over the final moves.
07:19:51 <delYsid> dark: I'll try something like that, tnx
07:19:52 <Heffalump> but if you're implementing the protocol yourself you don't need to stick to the same kind of interface that other implementations use
07:20:37 <jewel> Yep, I'll have  to investigate IORef
07:20:59 <Heffalump> well, I don't think you do need IORef
07:21:21 <Heffalump> why do you want to make an interface that modifies objects in-place?
07:21:28 <delYsid> dark: yeah, minGame and maxGame will need to be recursive somehow
07:22:03 <dark> delysid: I don't think you can get around operating on a list of pairs.  One part contains the "next move" (an element from gs), and the other part contains the final move or score or whatever.  Then you can max or min on the list of pairs, and extract the game position you want.
07:22:24 <dark> delysid: But this gets ugly because it means the max or min function needs to take and return a pair.
07:23:19 <Heffalump> hmm, there's a paper on the subject you should read, but I don't think it's online anywhere
07:23:37 <dark> delysid: Are you familiar with the zip function?
07:24:48 <dark> delysid: One thing I've been wondering about is that perfectGameFromPosition uses a player function to get the player, but plays assumes that players must make alternating moves.
07:27:40 <delYsid> yes
07:27:51 <delYsid> the players function is only used to determine who is next
07:28:01 <delYsid> play just alternates, as minimax.hs assumes a two-player game
07:28:16 <dark> Yeah but some games let you make two moves in a row sometimes :)
07:28:23 <dark> I guess you can collapse this in the moves function.
07:28:25 <delYsid> well, right
07:28:32 <delYsid> thats not abstracted right now ...
07:28:46 <delYsid> hmm
07:28:58 <dark> I think if you reuse the players function, you can get this automatically.
07:28:59 <delYsid> whyfp describes a completely different approach to minimax...
07:29:00 <delYsid> hmm
07:29:19 <dark> It seems that there's always lots of ways to do things :)
07:29:28 <delYsid> yeah
07:29:40 <delYsid> whyfp's way is lazy, so it's probably alot better
07:29:45 <jewel> Heffalump: I don't need to make interface that modifies objects in-place, I just need a way of calling methods and returning multiple values
07:29:55 <Heffalump> jewel: a tuple?
07:30:02 <jewel> preferably with some kind of formal interface ensuring the types are correct
07:30:22 <Heffalump> aren't the types only determined at runtime?
07:30:36 <delYsid> jewel: if you call RPC from within Haskell, the resulting type must be IO, or not?
07:30:39 <jewel> No, stubs are generated from an IDL file
07:30:41 <delYsid> After all, it's an IO operation
07:31:20 <jewel> Can I have tuple defined with specific types at the various indices?
07:31:45 <Heffalump> yes
07:31:53 <delYsid> (Int, Char, Bool)
07:31:53 <Heffalump> (Int,Char,Bool) is a tuple type
07:31:56 <jewel> Cool, and in python?
07:31:58 * dark notes that GTK+HS doesn't like the c2hs version number format.
07:31:59 <Heffalump> eeek!
07:32:33 <jewel> Heffalump: seen a snake?
07:32:57 <jewel> I know some elephants are scared of snakes
07:33:44 <Heffalump> no, it was delYsid making up the same example that scared me
07:33:55 <Heffalump> so it wasn't a snake unless delYsid is a snake
07:34:02 <dark> jewel: I was just reading the TODO file for GTK+HS, which complains: It is inconvenient that there is no *cheap* & *portable* way to return multiple values from an external routine
07:34:34 <Heffalump> presumably because unboxed tuples are GHC only?
07:34:35 <delYsid> Heffalump: Only the spaces were different :)
07:35:33 <delYsid> well, now my head hurts...
07:35:53 <delYsid> minimaximinimisation!
08:06:04 <jewel> Can you explicitly set the types for method arguments in python the way you can in haskell?
08:06:46 <Heffalump> I don't think python is typed
08:07:31 <jewel> Erm
08:07:42 <jewel> It certainly has some runtime concept of type
08:07:48 <jewel> is the language untyped?
08:07:58 <Heffalump> sorry, no static types
08:08:12 <jewel> that kind of sucks
09:01:09 <dark> Ooh, the end-of-game bug is fixed in cgoban 1.9.12.
09:01:32 <dark> I'll need to play against someone to test the new package :-)
09:09:58 <delYsid> anyone german here?
09:16:16 <dark> No... but I can read some of it.
09:19:04 <buggs> delYsid, me
09:26:16 <delYsid> buggs: http://www.bsvh-treff.de/wissen.mp3 (OT, but I have to pass that on :) )
09:26:47 <delYsid> It's a very short kabarett from a blind guy explaining to the sighted how stupidly they usually behave.
09:28:21 <buggs> ok :)
10:10:02 <shapr> delYsid: does that mean there aren't any generic alpha-beta modules available?
10:10:51 * shapr bounces
10:11:43 <delYsid> shapr: I didnt find one
10:12:30 <shapr> delYsid: have you looked at Edison?
10:14:57 <delYsid> A little bit.
10:41:56 * shapr bounces
11:10:13 <delYsid> shapr: You have that haskelllibs sf project, right?
11:20:37 <dark> Game of Go, anyone?  I need to test the new version of cgoban :-)
16:17:31 * shapr bounces
17:11:19 * shapr bounces
17:11:27 <dark> Still awake? :)
17:11:41 <shapr> yes still.
17:11:42 <dark> I'm about to go read to me girl.  Not sure if I'll be back after that.
17:11:50 <shapr> I got up late today.
17:11:52 <shapr> I should sleep
17:12:03 <dark> I get up late every day :)
17:12:06 <dark> But it's back to work on Monday.
17:12:32 <dark> shapr: I uploaded cgoban 1.9.12-1 today, it fixes the end-of-game bug on IGS.
17:13:15 <shapr> you're cgoban maintainer?
17:13:20 <dark> Yes, for Debian.
17:13:29 <shapr> oh, spiffy!
17:13:53 <shapr> well, what else is important? ;)
17:14:01 <shapr> there is no world outside of debian. :-P
17:14:06 <dark> Way back when when I was still an active Go player, someone told me that it was a good client and the author was very nice.  So I packaged it :)  I've maintained it in a low-key way even though I stopped playing.
17:14:40 <shapr> hey, the MetaEnvironment is coming to debian.
17:14:40 <dark> shapr: Well sometimes there is, when you notice a package exists but is NOT in Debian.  That's always disconcerting.  For example with GTK+HS.
17:15:04 <shapr> dark: I've been dodging becoming a DD for years...
17:15:23 <dark> Actually I might be an active Go player again.  It all started two weeks ago when someone asked me to teach her :)
17:15:33 <dark> The irony is that I still haven't taught her, she kept canceling.
17:15:39 <shapr> are you going to package gtk+hs?
17:16:08 <dark> shapr: Bad for you, becoming a developer has gotten more difficult :)  All sorts of bureaucracy around it these days.
17:16:30 <shapr> it'll happen to me sometime soon anyways.
17:16:31 <dark> shapr: I don't know, I haven't gotten it to compile yet, which is a bad sign :)  Maybe a hint to michaelw will save me a lot of effort :)
17:16:52 <shapr> could be, he seems to have amazing familiarity with ghc
17:16:56 <dark> (I'm sort-of retired wrt Debian, I maintain my current set of packages but I don't plan to become involved in large things again)
17:17:00 <shapr> otoh, ghc5-hopengl appears broken.
17:17:27 <dark> A pity, I was looking at it before I decided that GTK was really what I wanted.  And GTK+HS uses hopengl.  (Yeah I'm capitalizing inconsistently)
17:17:58 <shapr> I consider irc to be an informal medium, so inconsistent capitalization doesn't bother.
17:18:05 <dark> I still want to make one or more strategy games :)  Problem is I hate user interfaces.  I hoped that maybe doing them in haskell would make it bearable.
17:18:35 <shapr> if you make an unofficial gtk+hs I'd love to play with it.
17:18:39 <shapr> I suspect dandelion- would also.
17:18:46 <dark> (On the other hand my girlfriend offered to do the user interface... but she would program in Java)
17:18:56 <dandelion-> yes, but i have just compiled gtk2hs and i like it
17:19:01 <dark> So now I'm thinking, engine in Haskell, interface in Java :)
17:19:04 <shapr> dandelion-: oh, excellent :-)
17:19:08 <ChoJin> is there a glade module for haskell ?
17:19:11 <dandelion-> why use gtk+hs when gtk2hs is available... could you explain to me?
17:19:29 <shapr> dandelion-: have any screenshots online?
17:19:34 <dark> dandelion-: I don't know, what's the difference?  gtk+hs was the most visible project on google :)
17:19:46 <shapr> gtk2hs is for gtk2
17:19:50 <shapr> afaiu
17:19:58 <dark> Oh... gtk+hs is for gtk+1.2
17:20:12 <dark> The <<--==*STABLE*==-->> version.
17:20:15 <shapr> dandelion-: one advantage of gtk+hs is simpler windows portability (until gtk2 hits win32)
17:20:18 <dandelion-> yes, and i thought that gtk1.2 would be replaced by gtk2, therefore obsolete
17:20:24 <shapr> that's true.
17:20:26 <dark> Heh, I completely not care about windows portability.
17:20:38 <ChoJin> no one did a hs module for glade ?
17:20:41 <shapr> nor do I, but dandelion- might.
17:20:49 <shapr> ChoJin: I've not heard of one.
17:20:56 <dark> Anyway, I must go now!
17:21:00 <dandelion-> shapr: there is only one very rudimentary demo program included. i can give you a screenshot of that, if you want to
17:21:03 <shapr> cya
17:21:09 <shapr> dandelion-: sure :-)
17:21:20 <dandelion-> no, sorry, i did not make module or sth like that
17:21:26 <dandelion-> shapr: one moment, pls
17:30:16 <shapr> dandelion-: hah, cute screenshot :-)
17:33:05 <ChoJin> I wanna see
17:35:51 <shapr> hi gabor
17:35:57 <ChoJin> thx
17:36:00 <gabor> hi
17:36:13 <shapr> gabor: are you new to Haskell? or an experienced user?
17:36:30 <gabor> jou have a better permute than
17:36:54 <gabor> stash y xs = let l = length xs in map (\n -> take n xs ++ [y] ++ take (l - n) (drop n (cycle xs))) [0 .. l]
17:36:54 <gabor> perm (x:xs) = concat (map (stash x) (perm xs))                              
17:36:54 <gabor> perm [] = [[]]
17:37:23 <ChoJin> what is it ?
17:37:27 <ChoJin> a arabic translator ?
17:37:30 <gabor> well, I know it a bit although more theoretically
17:38:05 <Pseudonym> Here's the one I use:
17:38:15 <Pseudonym> permutations :: (MonadPlus m) => [a] -> m [a]
17:38:16 <Pseudonym> permutations [] = return []
17:38:16 <Pseudonym> permutations (x:xs)
17:38:16 <Pseudonym>   = do  xss <- permutations xs
17:38:20 <Pseudonym>         insertNondet x xss
17:38:25 <Pseudonym> insertNondet :: (MonadPlus m) => a -> [a] -> m [a]
17:38:25 <Pseudonym> insertNondet a [] = return [a]
17:38:25 <Pseudonym> insertNondet a (x:xs)
17:38:25 <Pseudonym>   = return (a:x:xs) `mplus`
17:38:25 <Pseudonym>         (insertNondet a xs >>= \xs' -> return (x:xs'))
17:38:32 <Pseudonym> Works for any MonadPlus.
17:38:45 <ChoJin> gabor: why don't you use "where" ? 
17:38:58 <ChoJin> it should be a little more beautiful I think
17:39:02 <gabor> because I am a newbie
17:39:16 * Pseudonym is a MTL junkie
17:39:38 <gabor> yep, I wanted to start out first
17:39:57 * shapr falls over asleep
17:40:03 <ChoJin> stash y xs = map fun [0 .. l] where l = length xs ....
17:40:15 <gabor> MTL (== C++ hack)
17:40:26 <Pseudonym> No!
17:40:31 <Pseudonym> MTL is beautiful!
17:40:51 <gabor> expression templates and stuff
17:41:08 <Pseudonym> I think you're thinking of the STL.
17:41:13 <Pseudonym> MTL = Monad Template Library
17:41:56 <Pseudonym> Although I think "Monad Transformer Library" might be more appropriate.
17:42:05 <ChoJin> stash y xs = map foo [0 .. l]
17:42:05 <ChoJin>   where
17:42:05 <ChoJin>   l = length xs
17:42:05 <ChoJin>   foo n = take n xs ++ [y] ++ take (l - n) (drop n (cycle xs))
17:42:16 <ChoJin> gabor: no ?
17:42:20 <gabor> OK, I thought Matrix Template Library
17:42:29 <gabor> which is C++
17:42:38 <Pseudonym> Ah.  This is #haskell, so MTL means Monad Template Library here. :-)
17:42:50 <gabor> certainly
17:43:20 <Pseudonym> Actually, I have a question.
17:43:22 <gabor> then I like MTL better
17:43:35 <Pseudonym> Combining type constraints.
17:44:11 <Pseudonym> I need to combine a few constraints into one to make my type signatures look better (and be easier to get right).
17:44:19 <Pseudonym> For example:
17:44:53 <Pseudonym> foo :: (Monad m, Ord t, Show t) => Foo t -> TransformerMonad m t
17:45:15 <Pseudonym> Just about every function in this module has a combination of constraints like that.
17:45:24 <Pseudonym> Only way I've found to do it so far is:
17:45:44 <Pseudonym> class (Monad m, Ord t, Show t) => Constraints m t where { }
17:45:49 <Pseudonym> instance (Monad m, Ord t, Show t) => Constraints m t where { }
17:45:54 <Pseudonym> Then I can write:
17:46:03 <Pseudonym> foo :: (Constraints m t) => Foo t -> TransformerMonad m t
17:46:18 <Pseudonym> Only problem is it requires -fallow-undecidable-instances under GHC.
17:46:26 <Pseudonym> Does anyone know a way which avoids that?
17:47:20 <gabor> ChoJin: took it
17:47:51 <ChoJin> took what ?
17:48:50 <gabor> is there a combined take&drop?
17:49:07 <gabor> your stash
17:49:18 <ChoJin> I don't understand ?
17:49:24 <ChoJin> "my stash" is your but using "where"
17:49:38 <gabor> yep
17:49:52 <gabor> thanks
17:52:20 <ChoJin> why are you doing "cycle xs" ?
17:53:54 <gabor> ok I could (++ take 1 xs) at the end
17:54:12 <gabor> what is the line comment token?
17:54:21 <ChoJin> stash y xs = map foo [0 .. l]
17:54:21 <ChoJin>   where
17:54:21 <ChoJin>   l = length xs
17:54:21 <ChoJin>   foo n = take n xs ++ [y] ++ drop n xs
17:54:34 <ChoJin> why don't you do just this ?
17:55:11 <ChoJin> Main> stash 42 [1,2,3,4]
17:55:12 <ChoJin> [[42,1,2,3,4],[1,42,2,3,4],[1,2,42,3,4],[1,2,3,42,4],[1,2,3,4,42]]
17:55:17 <ChoJin> seems to do exactly the same thing
17:55:19 <gabor> good idea
17:55:34 <ChoJin> you make the thing a little more complicate than it should :)
17:55:56 <gabor> happens me often
17:56:00 <gabor> :-)
17:56:31 <gabor> but I saw "cycle" in :names
17:56:37 <gabor> and liked it
17:56:38 <ChoJin> I wonder if using split would be more efficient
17:56:40 <ChoJin> anyone know ?
17:56:51 <gabor> to print endlessly
17:57:28 <gabor> efficiency is secondary for now...
17:57:40 <ChoJin> yes but can be interesting to see
17:57:44 <gabor> ++ is certainly horrible
17:58:10 <ChoJin> I wonder this because when we call take, and drop, in both it has to read the n first element of list
17:58:24 <ChoJin> whereas maybe using split, it will need only to do it once
17:58:27 <Pseudonym> stash a [] = [[a]]
17:58:28 <Pseudonym> stash a (x:xs) = (a:x:xs) : [ x:xs' | xs' <- stash a xs ]
17:58:31 <Pseudonym> No ++ there.
17:58:54 <ChoJin> :)
17:59:34 <ChoJin> beautiful :)
18:00:09 <gabor> {- comment? -}
18:00:18 <Pseudonym> Think about how you would construct stash recursively, and that's it, basically.
18:00:20 <gabor> and for one liner?
18:01:05 <Pseudonym> I don't have a one liner without using { }.
18:01:26 <ChoJin> and I think it is more efficient
18:01:59 <gabor> I mean comment token like "//" in C++
18:02:20 <Pseudonym> {- block comment, like /* */ in C -}
18:02:26 <Pseudonym> -- line comment, like // in c++
18:02:32 <gabor> thanks!
18:02:39 <Pseudonym> Or use literate scripts.
18:02:48 <gabor> >
18:02:50 <gabor> ?
18:03:02 <Pseudonym> Yes, but > prefixes _code_, not comments.
18:03:10 <gabor> sure
18:03:23 <gabor> filename *.lhs
18:03:26 <Pseudonym> BTW, I think there's only one other way to get a more efficient permutation operation, and that's to share suffixes.
18:03:41 <Pseudonym> But that's kinda dubious, because you can easily blow your memory doing that.
18:04:33 <Pseudonym> You trade off memory for reductions.
18:04:48 <Pseudonym> Oh, and don't forget that stash can work for all MonadPlus monads if you get rid of the list-specific stuff.
18:04:54 <Pseudonym> stash a [] = return [a]
18:05:13 <Pseudonym> stash a (x:xs) = return (a:x:xs) `mplus` (stash a xs >>= \xs' -> return (x:xs'))
18:06:15 <Pseudonym> That's particularly useful if you're using something like a nondeterministic monad transformer.
18:06:18 <gabor> makes your permute smaller probably?
18:06:44 <Pseudonym> permutations [] = [[]]
18:07:02 <Pseudonym> permutations (x:xs) = permutations xs >>= insertNondet x
18:07:08 <Pseudonym> Sorry.
18:07:11 <Pseudonym> permutations (x:xs) = permutations xs >>= stash x
18:07:29 <Pseudonym> Can also do it without the monad notation, of course.
18:07:56 <gabor> i understand >>= a bit
18:08:05 <Pseudonym> Think of it like this:
18:08:36 <Pseudonym> permutations (x:xs) = [ stash x xs' | xs' <- permutations xs ]
18:08:39 <Pseudonym> Only in reverse order.
18:08:57 <Pseudonym> Oh, you need a concat out the front, too.
18:09:05 * Pseudonym duhs
18:09:25 <Pseudonym> Using bind eliminates the concat.
18:10:11 <Pseudonym> (xs >>= f) on lists is the same as concat (map f xs)
18:10:49 <gabor> cool stuff. I made my degree in math, but working in sw development.
18:11:02 <gabor> have to go to sleep now
18:11:05 <Pseudonym> Hope you know some category theory. :-)
18:11:13 <gabor> I'll sure come back
18:11:23 <Pseudonym> FP researchers try to "one up" each other on how much category theory they know.
18:11:33 <Pseudonym> Or it sometimes seems that way.
18:11:37 <Pseudonym> Sleep well.
18:11:50 <gabor> well, natural transformations are easy
18:12:13 <gabor> cohomology is harder
18:13:31 <gabor> I understand that fancy stuff by Meijer and Co. rather well
18:13:45 <ChoJin> good night
18:13:55 <gabor> Bye
18:14:06 <Pseudonym> Night.
18:45:06 <Pseudonym> OK, that's ugly code.
21:53:15 --- topic: 'We put the Funk in Funktion || See logs @ http://tunes.org/~nef/logs/haskell/ || HOpenGL 1.03 released - http://haskell.org/HOpenGL || looking for team members for a #haskell ICFP contest entry, more info when the HaskellWiki returns.'
21:53:15 --- topic: set by shapr on [Fri Aug 02 14:15:19 2002]
21:53:15 --- names: list (clog jagular Pseudonym dblack shreya Jii delYsid smkl Chilli pertsa ibid liiwi shreya_ hornby jewel Igloo Ig arete rozzin Heffalump jens)
22:56:51 <Jii> good morning
23:34:44 <Pseudonym> Cool!  I think I just discovered a new idiom.
23:35:57 * Pseudonym has never seen it before, anyway.
23:42:24 <Jii> yes?
23:44:19 <Pseudonym> Well, suppose you're doing something with state.
23:44:25 <Jii> or do you have to patent it first ;-)
23:44:33 * Pseudonym laughs
23:44:45 * Pseudonym suspects there's no money in a Haskell idiom
23:45:05 <Pseudonym> OK, so you have some state which you want read/write and some you want read only.
23:45:19 <Jii> yes
23:45:22 <Pseudonym> But creating the read only state would modify the read/write state.
23:45:50 <Pseudonym> The example I have is I'm building a FiniteMap in my read/write state, and I want to point directly to a couple of entries in it.
23:46:08 <Pseudonym> So I want to cache a couple of read only values.
23:46:44 <Jii> (i have programmed and read about haskell now few hours total btw :-)
23:46:47 <Pseudonym> So how do you make read only state where you actually need the read/write state to be able to create it?
23:47:03 <Pseudonym> Oh, OK. :-)
23:47:09 <Pseudonym> Have you come to the ST monad yet?
23:47:18 <Pseudonym> Or have you not even seen monads yet?
23:47:39 <Jii> i have seen monads :)
23:47:45 <Pseudonym> Oh, good. :-)
23:47:55 <Pseudonym> Well the idiom works like this:
23:48:01 <Pseudonym> >  = do (inits, initr) <- runReaderT (evalStateT boostrap initState) initRead
23:48:01 <Pseudonym> >       runReaderT (evalStateT m inits) initr
23:48:30 <Pseudonym> The idea is you fake the read only state, then run some boostrap code which creates the "real" read only state.
23:48:41 <Pseudonym> Then re-run the code you really wanted to run using that state.
23:49:23 <Pseudonym> The result of the bootstrap code is shared between runs, so fully lazy evaluation kicks in and you share the results between calls.
23:49:38 <Pseudonym> Did that mean anything?
23:51:00 <Jii> i don't think i have yet had need for such idiom, so it doesn't meen much to me (yet) :)
23:51:24 <Jii> i'll come back to this later
23:53:00 <Jii> i'm just trying to twist my mind from python to haskell right now ;-)
23:54:30 <Pseudonym> Oh, I think the reason I've never seen it is I don't think anyone has tried to compose a state monad transformer with a reader transformer monad where the states are circularly dependent before.
23:54:45 <Pseudonym> Or at least if they've tried it, they don't like to talk about it.
23:55:17 <Pseudonym> One of the things I like about Haskell development is you get to discover new design patterns as you go.
23:55:28 <Pseudonym> All the interesting ones in, say, C++, are already found.
23:56:16 <Jii> that might be, yes
23:56:54 * Pseudonym is going home
23:56:57 <Pseudonym> Farewell all.
