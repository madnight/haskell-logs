01:05:44 <shapr> good morning Haskellers.
01:06:40 <Zet> heil
01:08:41 <shapr> hiya Zet
01:09:07 <Zet> shapr
01:09:16 <shapr> Zet: got any haskell questions?
01:10:02 * shapr reads tom moertel's icfp 2001 entry
01:11:31 <Zet> shapr: not yet... can't start learning it ;)
01:11:45 <shapr> can't start?
01:12:22 <shapr> I wish I could see all the intermediate code between tom's journal entries.
01:12:40 <Zet> yes... i want to become familiar with it (i like such languages)
01:12:49 <shapr> I think the compare and contrast would be interesting.
01:13:10 <shapr> Zet: I also like such languages.
01:13:33 <Zet> shapr: tcl, prolog, ruby? ;)
01:13:53 <shapr> python
01:14:15 <shapr> I get money to write Java and Python, but I don't think they as "such languages"
01:14:24 <shapr> Joy is closer.
01:14:41 <Zet> well, i like python too
01:14:46 <shapr> speaking of which, I wrote a bit of Joy code yesterday that I'm not sure about.
01:15:01 <Zet> never heard of it
01:15:45 <shapr> http://www.latrobe.edu.au/philosophy/phimvt/joy.html
01:16:00 <shapr> here's what I wrote yesterday:
01:16:02 <shapr> DEFINE approxEqual == 100.0 / rotate [0 =] [pop] [dup rolldown - swap /] ifte > .
01:17:52 <Zet> looks strange %)
01:18:00 <shapr> yah, it's unusual stuff.
01:20:31 <Zet> hm
01:20:56 <Zet> funny %)
01:21:45 <Zet> there was MK-52 programmable calculator, it used the same conception for programing ;)
02:12:19 <delYsid> eeeek
02:12:29 <delYsid> That really looks unreadable to me right now ::)
02:13:40 <shapr> delYsid: have you written any Joy?
02:25:52 <shapr> hi ChilliX
02:25:54 <shapr> what's up?
02:26:42 <ChilliX> Compiling the proceedings for the Haskell Workshop
02:27:03 <shapr> cool :)
02:28:15 <Jii> chilli, does it compile cleanly? no syntax errors? ;-)
02:28:54 <ChilliX> Jii: not yet
02:39:43 * shapr has a sudden hamburger craving
03:13:41 <Heffalump> you're compiling them from TeX source?
03:15:01 <ChilliX> me?
03:16:28 <Heffalump> you :-)
03:17:11 <ChilliX> only two
03:17:30 <ChilliX> where the authors went on vacation before I had the isbn etc from ACM
03:17:35 <ChilliX> the rest are in ps
03:18:00 <ChilliX> but I have to check that the page nums are ok , do a table of contents etc
03:21:30 <Heffalump> ah, right
03:25:51 <delYsid> shapr: I gave up on Joy.
03:25:56 <delYsid> It was to obscure for me :)
03:30:22 <shapr> delYsid: If you get the urge to play with it again, I can show you cool stuff.
03:30:50 <shapr> Joy is more fun if you learn it with someone else
03:31:49 <delYsid> well, I decided that Haskell is my primary "cool-language"
03:31:57 <shapr> yah, I agree.
03:31:59 <delYsid> I dont think I need another "strange thing" :)
03:32:14 <shapr> Haskell is strange? ;-)
03:32:22 <delYsid> nah
03:32:25 <delYsid> haskell is wonderful
03:32:39 <shapr> yah, it's beautiful...
03:32:46 <delYsid> But still, I'm coming from 8 years of imperative programming, so it's still not native to me :)
03:32:51 <shapr> yah, same here.
03:33:04 <shapr> today I realized that showS aren't in other languages.
03:33:18 <delYsid> er
03:33:28 <delYsid> hmm, I think CL can do it.
03:33:33 <shapr> oh
03:33:34 <shapr> cool :-)
03:33:45 <delYsid> but show is a good thing
03:33:54 <delYsid> I use it in my timesheet parser quite extensively.
03:33:55 <shapr> I wrote some string code in Python, and realized I have to do string accumulation manually.
03:34:22 <shapr> showS is about returning string bits that get concatenated all at once to save CPU
03:34:26 <shapr> it's nice
03:34:39 <delYsid> ahh
03:34:47 <Heffalump> how does Python concatenate lists?
03:34:47 <delYsid> I confused that with Show instances
03:35:04 <shapr> Heffalump: just like "foo" ++ "bar"
03:35:04 <Heffalump> (or strings)
03:35:09 <Heffalump> sorry, I meant internally
03:35:22 <dark> I don't know about Python, but in Java it's up to the compiler to optimize string concatenations.
03:35:25 <Heffalump> does it take linear time in the size of the first argument to do it?
03:35:46 <dark> Of course in some languages string concatenation is constant time :)
03:35:55 <shapr> with 'a' + 'b' + 'c' two operations are done
03:36:00 <delYsid> shapr: any docs/examples on showS?
03:36:01 <dark> It all depends on how you represent strings.
03:36:12 <shapr> the speedy way in python is to use "%s%s%s" % ('a','b','c')
03:36:19 <dark> Actually it shouldn't be hard to make something like TreeString in Haskell.
03:36:23 <shapr> that way it all happens in one op
03:37:00 <shapr> delYsid: I first ran across them with the showHex and showBin functions in ... NumExts I think.
03:37:16 <delYsid> where?
03:37:26 * delYsid is still not good with finding definitions
03:37:41 <delYsid> It would be cool if we had a Prelude as web-page, with all the definitions
03:37:50 <shapr> there is...
03:37:53 <shapr> on haskell.org
03:37:58 <shapr> but it's not as friendly as it could be...
03:38:05 <delYsid> er, that one is not complete :)
03:38:05 <shapr> Haddock is better
03:38:13 <dark> And I gather from the mailing list that it's not entirely accurate :)
03:38:20 <dark> It's great for grepping though.
03:38:34 <dark> Haddock is bad for grepping, on the other hand.
03:39:07 <shapr> aha
03:39:15 <shapr> now it's called Numeric
03:39:23 <shapr> http://www.haskell.org/ghc/docs/latest/html/base/Numeric.html
03:39:43 <dark> I'll make a note of that, I'll probably need showHex in my program :)
03:46:24 <dark> Disadvantages of table driven approach:
03:46:25 <dark>   , ([ byte 0x37 ], gen_AAA)                          -- AAA  
03:46:51 <shapr> well, table driven means easy modification
03:46:56 <dark> There's no place to explain what AAA means without interrupting the table layout :)
03:47:10 <shapr> that's true.
03:47:14 <shapr> you could do .lhs :-)
03:47:25 <dark> Hmm... that would still interrupt the table layout :-)
03:47:44 <Heffalump> what's a TreeString?
03:47:52 <dark> Though... I wonder if .lhs is flexible enough to make it an actual table.
03:47:59 <dark> With footnotes to explain what the opcodes mean :)
03:48:30 <dark> Or else I could write a preprocessor for it, I guess.  But I dislike layers of indirection on top of my source code.
03:48:44 <shapr> dark: what about lambdaTeX + .lhs ?
03:49:19 <dark> I guess I could also not lay it out as a table, but instead have the table entry appear as a kind of header at the place where I explain gen_AAA.
03:50:07 <shapr> or you could do  -- AAA [see docs after the table]
03:50:26 <dark> Well there's a line length limit :)  The -- AAA is offset so far because most table entries are longer.
03:50:46 <dark> Of course gen_AAA has a comment explaining what AAA does.
03:51:03 <shapr> maybe a single table header that says read docs after the table?
03:51:10 <dark> (Ascii Adjust after Addition, for the curious :) It's an assembler opcode.
03:51:22 <shapr> I thought AAA was just for cars.
03:52:17 <dark> cars?
03:52:49 <shapr> in the US the AAA club will come and fix your car if you break down on the highway.
03:53:00 <shapr> or they'll tow your car to the nearest mechanic
03:53:09 <dark> Oh, automobiles :)  I was thinking of the list operation.
03:53:13 * shapr grins
03:53:28 <shapr> car cdr?
03:54:57 <dark> I've been programming in scheme earlier this year.
03:55:07 <dark> No pattern matching :)
04:01:36 <dark> I like the way the pseudocode in the Intel reference manual translates directly to Haskell :)
04:14:52 <ChilliX> dark: What ref manual?
04:31:05 <Igloo> Hi guys
04:39:03 <delYsid> how can I use readFile with stdin?
04:40:00 <ChilliX> you can't
04:40:16 <ChilliX> need to use IO.openFile + IO.hGetContents
04:40:31 <ChilliX> urgh, no
04:40:41 <ChilliX> just IO.hGetContents on IO.stdin
04:44:47 <Igloo> Or just getContents
04:45:17 <ChilliX> true :-)
04:45:18 <delYsid> hmmm
04:45:19 <delYsid> main = getArgs >>= \args ->
04:45:19 <delYsid>        if null args then
04:45:19 <delYsid>            hGetContents stdin
04:45:19 <delYsid>        else
04:45:19 <delYsid>            openFile args!!0 >>= \fh
04:45:21 <delYsid>            hGetContents fh
04:45:23 <delYsid>        >>= \cont ->
04:45:25 <delYsid>        parsework cont
04:45:27 <delYsid> What's wrong there?
04:46:04 <ChilliX> missing brackets
04:46:14 <ChilliX> you are not using the do notation
04:46:22 <delYsid> right
04:46:24 <ChilliX> so the identation isn't meaningfull
04:46:24 <delYsid> I dont want to :)
04:46:29 <ChilliX> I'd write it like
04:46:33 <ChilliX> main = do
04:46:40 <ChilliX>   args <- getArgs
04:46:57 <ChilliX>   cont <- if null args
04:47:08 <delYsid> hmm
04:47:09 <ChilliX>          then hGetContents stdin
04:47:17 <ChilliX>       else  ...
04:47:21 <ChilliX>   parsework cont
04:47:31 <ChilliX> (ident of else is wrong)
04:47:41 <ChilliX> (ident = indent)
04:48:30 <delYsid> well, and how without do?
04:48:53 <ChilliX> if you want to write it without do, the way you dit it is fine
04:48:57 <shapr> hiiii Igloo!!
04:48:59 <ChilliX> but why not use do?
04:49:12 <shapr> Igloo: ltns! wassup?
04:49:26 <delYsid> ChilliX: Well, but ghci complains about parse error at >>=
04:49:31 <delYsid> (the last >>=)
04:49:44 <delYsid> ChilliX. And I think it's better for my mind if I dont hide imperatives
04:50:10 <Igloo> shapr: I was about to resume my hunt for a decent make replacement
04:50:16 <ChilliX> the imperatives are not more or less hidden in both versions
04:50:20 <shapr> Igloo: would you like some scons?
04:50:24 <ChilliX> GHC translates one into the other anyway
04:50:34 <Igloo> That's on my list to look at  :-)
04:50:42 <ChilliX> you forgot a -> after the variable fh btw
04:50:48 <Igloo> I looked at jam and, well, I'm going to keep looking  :-)
04:50:50 <delYsid> ChilliX: OK, put in another way, the lambda notation makes it easier to think about what actually happens.
04:51:01 <shapr> scons and jam
04:51:03 * shapr laughs
04:51:15 <shapr> is there also butr or something?
04:51:34 <Igloo> Heh, hadn't noticed that
04:52:01 <shapr> it must be teatime.
04:52:27 <Igloo> Isn't it 2am there?
04:52:30 <shapr> um
04:52:30 <Igloo> pm rather
04:52:36 <shapr> 3pm
04:52:39 <Igloo> Ah, OK
04:52:40 <shapr> what time is teatime anyway?
04:52:48 <shapr> I've never figured that out.
04:52:51 <Igloo> I thought it was 4, but 3 is pretty close  :-)
04:52:53 <Igloo> at knows I think
04:53:01 <shapr> really? 4pm is teatime?
04:53:11 <shapr> hm, I thought it was just whenever you wanted tea.
04:53:16 <Igloo> Yes - "You may also specify midnight, noon, or teatime (4pm)"
04:53:24 <shapr> spiffy.
04:53:45 * shapr learned something useful today.
04:53:50 <Igloo> Oh?
04:53:57 <shapr> yah, what time teatime is!
04:53:59 <shapr> oh, hey...
04:54:05 <shapr> scons and jam, and ant!
04:54:07 <Igloo> Oh, right  :-)
04:54:13 <shapr> it must be a picnic at teatime.
04:54:32 <shapr> make scons and jam, get an ant?
04:54:48 <Igloo> Hmmm  :-)
04:55:02 <shapr> what are the other make replacements on your list? this getting to be fun :)
04:55:17 <shapr> hm, I suspect a lack of focus on my part.
04:55:23 * shapr remedies that situation.
04:57:16 <Igloo> make, maketool, makeme, xmake, jam, ant, cmake, cons, cook, icmake, scons, tmake
04:57:37 <delYsid> make itself is nice enough methinks
04:57:56 <delYsid>     Couldn't match `GHC.IOBase.Handle' against `IO GHC.IOBase.Handle'
04:57:56 <delYsid>         Expected type: GHC.IOBase.Handle
04:57:56 <delYsid>         Inferred type: IO GHC.IOBase.Handle
04:57:56 <delYsid>     In the first argument of `hGetContents', namely `fh'
04:57:57 <delYsid>     In the first argument of `(>>=)', namely `hGetContents fh'
04:58:01 <delYsid> -- hmmmmmm?!
04:58:26 <shapr> With make, scons, jam, cook, and ant; I suspect I could come up with some amusing setences.
04:59:14 <shapr> delYsid: you have foo :: a -> Handle
04:59:22 <delYsid> shapr: If you cook an Ant, that will make you scons?
04:59:23 <shapr> where it should be foo :: a -> IO Handle
04:59:49 <delYsid> shapr: That, I understood
04:59:53 <delYsid> But I still dunno why...
05:00:01 <delYsid> I only use openFile and hGetContents
05:00:15 <shapr> what's the type of hGetContents?
05:00:55 <delYsid> Handle -> IO String
05:00:59 <ChilliX> *MPTC> :t IO.hGetContents
05:01:00 <ChilliX> GHC.IOBase.Handle -> IO String
05:01:31 <delYsid> ohhhh!
05:01:34 <delYsid> I forgot an arg!
05:01:50 * shapr has a few arghs left over from some handy java source.
05:02:27 <delYsid> er, where do I get ReadMode from?
05:03:14 <ChilliX> *MPTC> :i IO.IOMode  
05:03:14 <ChilliX> -- GHC.Handle.IOMode is a type constructor
05:03:14 <ChilliX> data GHC.Handle.IOMode
05:03:14 <ChilliX>     = GHC.Handle.ReadMode |
05:03:14 <ChilliX>       GHC.Handle.WriteMode |
05:03:15 <ChilliX>       GHC.Handle.AppendMode |
05:03:17 <ChilliX>       GHC.Handle.ReadWriteMode
05:03:45 <shapr> wow, I gotta start using :i
05:03:59 <delYsid> yeah, :i is cool, tnx
05:04:24 <ChilliX> :-)
05:07:04 <delYsid> /usr/lib/ghc-5.04/libHSrts.a(Main.o): In function `main':
05:07:04 <delYsid> Main.o(.text+0x7): undefined reference to `__stginit_Main'
05:07:04 <delYsid> Main.o(.text+0x1e): undefined reference to `Main_zdmain_closure'
05:07:05 <delYsid> collect2: ld returned 1 exit status
05:07:08 <delYsid> WTH does this mean?
05:07:40 <ChilliX> do you have a "Main" module?
05:07:42 <shapr> means that ld couldn't find a run time system function
05:07:56 <delYsid> a Main module?
05:08:04 <shapr> actually, that's what it *says* not what it *means*
05:08:05 <delYsid> I thought it was enough if I had a main function?
05:08:08 <shapr> I was answering the wrong question.
05:08:16 <ChilliX> in Haskell, a complete program must include a module called "Main" that has a function called "main"
05:08:33 <ChilliX> no, the main function must be in module Main
05:08:42 <delYsid> so I need a second module, just to be able to link?
05:09:01 <delYsid> hmm
05:09:09 <shapr> I usually make one module Main and one 'library' module
05:09:10 <delYsid> Can I put the module Main into the same .lhs?
05:09:41 <delYsid> Its really just a minimal wrapper, I dont want a separate file for that
05:10:10 <shapr> I haven't seen anyone do that.
05:10:26 <delYsid> hmm
05:10:29 <delYsid> ok
05:10:41 <delYsid> well, then I need to do further include tricks for my literatue stuff... suckage
05:11:38 <shapr> heh, you said suckage :-)
05:16:52 <delYsid> -rwxrwxr-x    1 mlang    mlang      433744 Aug 13 14:16 Stunden
05:16:53 <delYsid> Ugh!
05:16:58 <delYsid> This is huge
05:17:18 <delYsid> shapr: And? Is that a forbidden word or something?
05:17:42 <delYsid> Are compiled haskell programs always *that* huge?
05:17:47 <shapr> huh?
05:17:57 <ChilliX> strip it
05:18:06 <delYsid> ChilliX: I did! :)
05:18:13 <shapr> how do you strip it?
05:18:15 <delYsid> before that, it had 630k
05:18:22 <delYsid> shapr: strip :)
05:18:26 * shapr grins
05:18:28 <delYsid> remember the UNIX-sex session...
05:18:34 <shapr> um.
05:18:35 <shapr> well.
05:18:37 <shapr> no.
05:18:39 <ChilliX> one problem with ghc generated code is that it pulls in lots of libraries
05:18:50 <ChilliX> of which only little is used in a small program
05:19:05 <delYsid> shapr: find;talk;strip;mount;fsck;umount;sleep
05:19:09 <ChilliX> (has been discussed on the list recently; ghc users list, I think)
05:19:35 * shapr grins
05:19:40 <shapr> that's amusing.
05:19:48 <delYsid> ChilliX: Any dynamic lib usage in sight? Or will they continue to link staticly...
05:20:09 <delYsid> shapr: I forgot touch...
05:20:12 <ChilliX> it's not very high on the priority list, I think
05:20:20 <ChilliX> this was discussed too
05:20:20 <delYsid> :(
05:20:25 <ChilliX> there are various reasons
05:20:51 <delYsid> hmm
05:21:00 <delYsid> But it isnt pretty...
05:21:14 <delYsid> to waste (in my case) I guess around 50% of binary code
05:21:36 <ChilliX> wastes some HD space
05:21:55 <delYsid> not only.
05:21:57 <delYsid> Also load time...
05:22:15 <ChilliX> I'd assume it is demand paged anyway
05:22:28 <ChilliX> on Linux anyway
05:22:54 <delYsid> well, sure, it isn't a real showstopper
05:23:04 <delYsid> But if I'd written the thing in C, it would be 10 times smaller.
05:23:25 <delYsid> But i'd also stoped doing it throughh frustration :)
05:23:28 <delYsid> So well ...
05:23:33 <ChilliX> one the bright side, if you add more code, it doesn't grow as quickly
05:23:50 <delYsid> haha
05:26:23 <ChilliX> :-)
05:26:50 <Heffalump> demand paging is all very well, but if you pull 100 bytes out of each 4K page then the whole thing will get loaded
05:27:49 <shapr> I think the recent discussion on ghc-users concluded with "would you rather have dynamic linking, or stuff like Template Haskell?"
05:28:21 <shapr> or something along those lines.
05:28:27 <Igloo> Can the performance issues be overcome then?
05:28:41 <delYsid> well, I dunno template haskell, so I vote for dynamic linking!
05:28:45 <ChilliX> shapr: that's the point indeed
05:28:56 <ChilliX> Template Haskell is suuuuuuper cool
05:29:15 <delYsid> What is it?
05:29:18 <ChilliX> Heffalump: same with a dyn lib
05:29:29 <ChilliX> Heffalump: only slower
05:29:48 <shapr> Template Haskell won't affect dynamic linking at all, it is a powerful new tool though.
05:29:48 <Heffalump> true, but at least you get sharing between different executables that way
05:30:11 <Heffalump> and it's more likely that you'll make efficient use of each page since more of the library is likely to be used overall
05:30:21 <ChilliX> Heffalump: That's true!  Only that few people run that many haskell executables concurrenbtly
05:30:30 <Heffalump> only cos Haskell isn't used enough :-)
05:30:54 <delYsid> ChilliX: If they can't dynlink, many people will not start to do so
05:31:10 <ChilliX> so, let's say, if it is used enough, we'll put in the time to add dyn linking
05:31:29 <delYsid> ahh, the devil's wheel
05:31:30 <delYsid> well
05:31:39 <shapr> toefelsknutten?
05:31:42 <delYsid> er, circle that is
05:31:42 <shapr> er, no...
05:31:53 <ChilliX> Teufelskreis
05:31:57 <shapr> ah, thanks.
05:31:59 <delYsid> right
05:32:18 <ChilliX> anyway, so, somebody has to get down to it and implement it
05:33:23 <ChilliX> btw, I am not sure, but NHC might link dynamically
05:34:13 <ChilliX> (dyn linking is supported on win32 btw)
05:42:22 <delYsid> shapr: btw, since yesterday, I'm officially dd
05:42:27 <shapr> awesome!!
05:42:30 <shapr> congrats!
05:42:34 <delYsid> tnx
05:42:40 <delYsid> already uploaded my first pkg today :)
05:42:46 <shapr> cool, what is it?
05:42:55 <delYsid> brltty 3.0 :)
05:43:10 <shapr> spiffy
05:43:13 <delYsid> And I took ofer erc maintainership
05:43:28 <delYsid> This will be my next upload, erc 2.93 cvs 14082002
05:43:36 <delYsid> s/ofer/over/
05:43:39 <shapr> excellent :)
05:44:15 <delYsid> Any XEmacs related stuff you'd like to see go in before the next sid upload?
05:44:36 <Heffalump> erc?
05:44:46 <shapr> Heffalump: irc client written in elisp
05:44:50 <Heffalump> ah
05:45:00 <shapr> at least 60% of the current codebase written by delYsid
05:45:06 * Heffalump remembers apt-cache show
05:45:14 <shapr> and the irc client I use.
05:46:57 <shapr> delYsid: nah, I don't have the motivation to clean up erc-xemacs-track.el into something worth submitting.
05:49:17 <delYsid> I'm using ERC 2.93 $Revision: 1.294 $ with Emacs 21.3.50.1!
05:49:28 <delYsid> shapr: ok, Lathi found at least one erc-stamp bug...
05:50:16 <shapr> oh, I haven't tried erc-stamp lately.
05:50:45 * delYsid couldn't be without
05:50:54 <delYsid> I grew very fond of -right hand timestamps
05:51:19 <delYsid> ok, enough OT, sorry guys
05:51:40 <shapr> heh :-)
05:52:06 <ChilliX> on irc, irc is never OT ;-)
05:52:24 <shapr> I'd like to have an irclib in haskell.
05:53:54 <Heffalump> hmm, that shouldn't be too hard to do
06:15:12 <delYsid> shapr: the lib is easy, the interface isn't
06:15:28 <delYsid> I imagine handlers based on pattern matching
06:15:56 <shapr> that would be cool.
06:16:06 <delYsid> handleEvent (JOIN nick ch) = outputMsg nick ++ " joined " ++ ch
06:16:08 * shapr thinks of an IRCMessage type constructor
06:16:28 <shapr> handleEvent :: IRCEvent -> a
06:16:50 <delYsid> data IRCMessage = JOIN String String | PART String STRING | ...
06:17:17 <shapr> what about including the numeric event numbers in an IRCMessage?
06:17:17 <delYsid> And then a parsec parser which returns a IRCMessage
06:17:32 <delYsid> hmm
06:17:43 <delYsid> data ... = ... | 301 String STring
06:17:49 <delYsid> -- This doesn't work in Haskell, right?
06:17:54 <delYsid> oh, no
06:18:06 <delYsid> data ... = ... | Int [String]
06:18:16 <delYsid> then we can match on that
06:18:16 <shapr> if IRCMessage has a type constructor that takes all those bits
06:18:31 <delYsid> handleEvent (201 [a b]) = ...
06:18:36 <shapr> then you could match on any part of it.
06:18:39 <shapr> right
06:19:04 <delYsid> hmm, a bot based on hirclib should be easier for starters...
06:19:12 <Igloo> I'd have thought you wanted (Int, String) for the response and a function that converts that to your original IRCMessage
06:19:27 <Igloo> Remember that replies can come in multiple parts
06:19:50 <delYsid> not really
06:19:59 <Igloo> not really what?
06:20:00 <delYsid> Every irc message is self-containing
06:20:16 <delYsid> some commands produce more than one message, yes.
06:20:17 <Igloo> I mean like 301- foo\n301- bar\n301 baz
06:20:35 <delYsid> ahh, ya mean the list e.g.
06:20:36 <delYsid> right...
06:20:36 <Igloo> (I may have the syntax slightly off)
06:20:44 <shapr> too bad jens is away, he'd probably enjoy this discussion.
06:20:46 <delYsid> hmmm
06:21:02 <delYsid> well, list is a problem anyway
06:21:09 <delYsid> because some irc servers dont send the list header/fooder
06:21:31 <delYsid> handleEvent (301 [a]) = accumulateList a
06:21:36 <Igloo> That's not really a problem, the client just deals with what it does get
06:21:42 <delYsid> and then figure out when it stops and process the complete list...
06:22:25 <Igloo> I'm fairly sure with what I'm thinking of you can tell when you reach the end as there are -s or something on all but the last line
06:23:04 <delYsid> -s?
06:23:05 <delYsid> no
06:26:23 <delYsid`> delYsid: Ghost!
06:26:31 <delYsid`> delYsid: You, go away!
06:28:24 <delYsid> Igloo: Which plural did you mean?
06:28:32 <Heffalump> dashes
06:28:38 <delYsid> AFAIK, the LIST numreply has no -s appended...
06:28:58 * Igloo finishes looking with ethereal - I muse be thinking of another protocol
06:28:58 <Heffalump> the MOTD seems to have some
06:29:06 <delYsid> yeah, motd has
06:29:07 <Heffalump> but prepended not appended
06:29:13 <delYsid> but the irc servers all send end-of-motd
06:29:16 <delYsid> that, they do
06:29:19 <delYsid> but not end-of-list
06:29:22 <delYsid> ircnet e.g., doesnt do that
06:31:15 <Igloo> Ah, SMTP has them
06:38:14 <delYsid> irc doesnt. :)
06:38:41 <delYsid> It was already quite tricky to implement notify.
06:38:50 <delYsid> That's really a fun thing ...
06:39:01 <Igloo> No, but that just makes the library easier, because each server response can just be passed back to the client
06:41:42 <Heffalump> instead of having callbacks?
06:41:49 <Heffalump> you need some callbacks, obviously
06:43:16 <Igloo> I mean you don't have to worry about collecting up multi line responses
06:43:46 <Igloo> although a layer on top of that that collated list results would be nice
06:44:42 * Igloo gets to scons and finds it is python based and ponders shapr's bias  :-)
06:45:07 * shapr grins evilly
06:45:07 <Igloo> Ooo, claims built-in support for TeX and LaTeX
06:45:25 <shapr> Igloo: actually, python is my former bias.
06:45:25 <Igloo> Do you know if scons is related to cons?
06:45:56 <shapr> scons used to be SC-cons from software carpentry
06:46:17 <shapr> if that's the cons you speak of, scons is the same thing with a different backing.
06:47:02 <delYsid> Igloo: right, every event a single call to the client.
06:47:04 <delYsid> Thats my thought
06:47:10 <Igloo> cons is another build tool in which the "Makefile" is essentially a perl script. scons looks similar with python. (based on only a quick scan of both of them)
06:47:36 <delYsid> Igloo: A Perl script!?
06:47:38 <shapr> Igloo: read the description on the front page: http://www.scons.org/
06:47:51 <shapr> SCons began life as the ScCons build tool design which won the Software Carpentry SC Build competition in August 2000. That design was in turn based on the Cons software construction utility
06:48:15 <Igloo> Ah, right
06:48:43 <shapr> btw, I really like the post Shawn Garbett just sent to haskell@haskell.org
06:48:46 <Igloo> del: I haven't looked in detail, but I guess you call functions to do things like register dependencies
06:49:12 <shapr> I think his post outlines why Python is my former bias, and why Haskell is my current bias.
06:51:05 * Igloo goes to see if it's in the archive yet
06:51:45 <shapr> Igloo: want me to forward it to you?
06:52:28 <Igloo> That wouldn't help - it's reading mail that's difficult  :-)
06:52:33 <shapr> ah
06:52:46 * Igloo goes to read it with less
06:53:19 <Heffalump> what on earth are you doing with your email?
06:53:24 <Igloo> What subject?
06:53:32 <Igloo> It's sitting on the
06:54:45 <Heffalump> and you can't run mutt there why?
06:56:22 <shapr> Igloo: Subject: Re: Newbie question on "statefullness"
06:56:24 <Igloo> I'm not sure what it'll do to message flags
06:57:39 * Igloo finishes reading
07:05:46 <dark> Igloo: I often use mutt to read mail that hasn't been popped yet.  If you exit with ^C it doesn't touch the mailbox.  But I sometimes forget to exit with ^C :-)
07:05:55 <dark> Igloo: I think there's a way to tell it the mailbox is read-only, though.
07:06:27 <Igloo> It's not significantly simpler than less for the odd e-mail anyway
07:06:52 <Igloo> I tend to have more of a problem remembering where a given mail will end up  :-)
07:07:29 <Heffalump> if you just use fetchmail to get your mail anyway you can just tell it to get all mail
07:07:36 <Heffalump> and it'll even preserve read flags, then
07:11:04 <Igloo> If I thought I would be doing this lots I'd look at it, but for just a few more days (hopefully) it's not worth the hassle
07:14:19 <Igloo> It looks like now would be a good time to learn Python
07:15:17 <shapr> I suspect I can assist you there.
07:53:33 <dark> Heffalump: fetchmail doesn't preserve read flags for me, because it goes through the local MTA.
07:57:50 <Heffalump> ah, ok
08:23:13 <hdaume> has anyone used hIDE?
08:24:27 <dark> Not me.
08:24:37 <shapr> I haven't, but it's on my list of things to try.
08:24:40 <dark> But then, the last IDE I used was the one for Borland Pascal :-)
08:24:46 <hdaume> :)
08:24:54 <dark> Unless you count emacs...
08:24:58 <shapr> yah, I have emacs.
08:25:17 <hdaume> it doesn't seem to like cpp directives, which renders it basically useless for me (i was wondering if anyone had hacked it to work with cpp)
08:25:46 <shapr> the author seems very friendly, I've exchanged some email with him.
08:26:08 <hdaume> yes, he does
08:27:23 <dark> What do you use cpp for in Haskell, anyway?
08:27:52 <ibid> conditional compilation?
08:28:04 * shapr realizes for loops now confuse him.
08:28:15 <dark> Conditional on what?
08:28:34 <dark> Maybe I've been indoctrinated by Debian, I can't imagine any setting that you would want to configure compile-time instead of run-time :)
08:29:03 <Heffalump> there's some stuff that really does need to be configured at compile-time, though
08:29:27 <dark> shapr: The Iron Rule of for loops: the header assigns only to the loop counter, and nothing else does.
08:29:35 <dark> shapr: All else leads to madness.
08:29:36 <hdaume> the two biggest things are (1) import Control.Monad.ST in ghc 5.04 and ST in <5.04 and (2) i often have #ifdef #GHCi ... clauses that contain "working definitions" (in my .ghci file I define that var)
08:29:54 <hdaume> i do some stuff other than that, but nothing major
08:30:09 <shapr> dark: I just tried to write a for loop in Java... but I can no longer remember the syntax.
08:30:16 <dark> Oh... did ghc change incompatibly?  Or is Control.Monad.ST just nicer?
08:30:31 <shapr> actually, I wrote "map(" and the realized that won't work.
08:30:32 <dark> shapr: Oh... Java for loops had something creepy about them :)
08:30:46 <hdaume> i'd imagine eventually the old stuff will be gone...but also if you import FiniteMap you need -package data; if you import Data.FiniteMap, you don't
08:32:36 <dark> shapr: I remember now, for loops introduced a new variable scope before their block actually began.
08:33:29 <shapr> any language that doesn't have map really irritates me.
08:33:33 <dark> hdaume: Well, I don't plan to give up my new freedom from cpp lightly :-)
08:33:35 <shapr> manual loop declaration is such a waste of time.
08:33:47 <dark> shapr: Yeah especially if you have to use the Iterator interface.
08:34:02 <shapr> right.
08:34:19 <dark> shapr: I ended up using arrays instead of Collection because of that :-)
08:34:43 <shapr> I'm used to Python, so I use Vectors and cast like a fly fisher.
08:35:06 <dark> shapr: Usually the collection only changes while you build it anyway, so the constructor might as well convert to an array when it's done.
08:36:00 <dark> Frankly, I think cpp is the cause of much of the incompatibilities between unix platforms.  It was just too easy to say "Let them use ifdef".
08:36:22 <dark> Of course, it also helped to deal with the incompatibilities :)
08:36:58 <dark> shapr: Vector is deprecated, though!
08:37:02 <shapr> really?
08:37:06 * shapr looks at javadoc
08:38:24 <shapr> dark: I can't find that in the jdk1.4 docs
08:46:53 <dark> shapr: Oh, you're right, it's not deprectated, it's a Legacy Implementation :)  I guess that's different.
08:48:12 <dark> I've always avoided it for that reason, though.
08:49:12 <shapr> probably because Vector completely avoids type safety?
08:49:24 <shapr> since Vector is pretty much an array of type Object
08:49:48 <Heffalump> all Java collection classes completely avoid type safety, don't they?
08:50:14 <shapr> s/collection classes//
08:50:30 <Heffalump> that's not true...
08:50:51 * shapr grins
08:51:31 <shapr> ok, Java isn't Forth... I admit it.
08:52:57 <dark> I think it's just that Vector doesn't fit the new scheme they introduced in 1.2 :)
08:53:08 <dark> The Collection framework, that is.
08:53:15 <shapr> yah, that's true.
08:53:40 <dark> I think it handles concurrency differently than ArrayList does.
08:54:26 <dark> But I think Heffalump is right, once you use the Collection classes, types are out the window.  That's one of the things I disliked about Java :)  At least in Haskell you can say what your lists are lists of.  Unfortunately the price is that you can't have polymorphic lists.
08:54:55 <Heffalump> well, Haskell doesn't have inheritance
08:54:59 <dark> Or rather... that if you want them, you have to code them that way explicitly :)
08:55:13 <Heffalump> and if you had implicit polymorphic lists you'd lose static type safety
08:55:16 <dark> I think I like Haskell's emphasis on efficiency.
08:56:22 <shapr> I like both the Python and the Haskell approach, as long the user knows when to use which. Imho, Java is a painful mixture of the two.
08:56:28 <dark> Heffalump: Haskell has just enough inheritance for me :)  I think it tends to be abused in Java.  Inheritance should be an "is a" relationship, not a "shares code with" or "would like to fiddle with private fields" relationship.
08:56:41 * shapr snickers
09:01:31 <dark> I like the list layout that goes:
09:01:32 <dark>   [ foo
09:01:33 <dark>   , bar
09:01:35 <dark>   , gnu
09:01:36 <dark>   ]
09:01:52 <dark> The only wart is dealing with the [ if I move a different element to be first.
09:02:42 <shapr> python allows [\n foo,\n ]
09:02:49 <dark> And sometimes it would be nice to be able to have the [ on the preceding line, to make it clear that whatever is defined there is not yet complete.
09:03:17 <shapr> does haskell allow [foo,] for a single item?
09:03:19 * shapr tries
09:03:37 <hdaume> nope
09:03:45 <shapr> nope
09:03:56 <delYsid> what would that mean?
09:03:58 <shapr> well, worth trying..
09:04:11 <shapr> delYsid: would mean a list of the single item foo
09:04:18 <Heffalump> why not [foo] for a single item?
09:04:20 <delYsid> [foo]
09:04:25 <hdaume> though interestingly it allows that on export list 'module Foo (x,y,z,) where' is valid
09:04:25 <shapr> Heffalump: for layout purposes
09:04:30 <Heffalump> oh, you want to be able to avoid removing ,s, right
09:04:44 <delYsid> ouch
09:04:49 <delYsid> [foo,] looks ugly imho
09:04:58 <shapr> delYsid: it does, but not when you're doing vertical layout.
09:05:03 <shapr> [
09:05:05 <shapr>  foo,
09:05:06 <shapr> ]
09:05:15 <delYsid> that looks ugly too :)
09:05:34 <delYsid> [ foo
09:05:36 <delYsid> ]
09:05:36 <shapr> well, since each of the lines ends in a comma, automatically processing lists is easier.
09:05:36 <hdaume> "[foo,]" to me looks like a left section, i.e., you could write '[foo,] [bar,baz]' to get '[foo,bar,baz]'
09:05:43 <delYsid> [ foo
09:05:45 <delYsid>  ,bar
09:05:46 <delYsid> ]
09:06:14 <shapr> when I get the code flowing, I don't want to think about nitpicky issues like, "did I just put a new item on the end of that list? then I need to add a comma on the line above"
09:06:38 <delYsid> er, not really
09:06:40 <delYsid> [foo
09:06:41 <delYsid> ,bar
09:06:44 <delYsid> ,baz
09:06:45 <delYsid> ]
09:06:48 <Heffalump> hdaume: that's what : and ++ are for :-)
09:06:59 <delYsid> in a line without [ you put ,, otherwise you put just the id.
09:07:00 <Heffalump> but yeah, I see your point
09:07:02 <shapr> delYsid: right, that's how the whole discussion got started, when dark pasted that.
09:07:21 <shapr> I agree it's the best option available.
09:07:36 <shapr> but then the first line is the one picky line.
09:07:47 <delYsid> it's a list-starting line
09:07:48 <shapr> er, "first item" not first line.
09:07:49 <dark> ... which is what I was complaining about :)
09:07:59 <delYsid> for me, that makes much more sense than having to look at [ foo, ]
09:08:01 <dark> It might work to have:
09:08:02 <dark> func = [
09:08:04 <dark>     foo
09:08:05 <dark>   , bar
09:08:06 <shapr> right, but in python, I always put [ and ] on their own line, and every item has a comma after it.
09:08:06 <dark>   , gnu
09:08:07 <dark>   ]
09:08:08 <shapr> and that's all.
09:08:09 <hdaume> Heffalump: yeah, but arguably with (+1) you could say that's what \ and -> are for :)
09:08:17 <dark> But then that first line has weird indentation.
09:09:09 <dark> At least the technique generalizes :)
09:09:09 <shapr> are there any disadvantages to having [1,] == [1] ?
09:09:13 <dark> data newtype
09:09:15 <dark>   = Foo
09:09:17 <dark>   | Bar
09:09:18 <dark>   | Gnu
09:09:37 <shapr> lexical or other weirdness to [1,] ?
09:09:40 <dark> But still, I prefer to put the = on the preceding line, to make clear that the definition of newtype is incomplete.
09:09:42 <Heffalump> hdaume: true :-)
09:10:25 * dark actually uses (foo :) sections in a number of places.  Smileys in the code :)
09:10:26 <delYsid> shapr: It prevents people from inventing cool things based on : and ++ :)
09:10:36 <dark> But it doesn't go with ++, it goes with .
09:11:08 <shapr> delYsid: huh? how so?
09:11:09 <delYsid> hehe (foo :)
09:11:09 * hdaume thinks sections are the coolest things ever :)
09:11:23 <delYsid> shapr: nm
09:11:25 <shapr> sections?
09:11:31 <Heffalump> ...after Haskell itself, of course?
09:11:42 <hdaume> are sections a haskell invention?
09:11:46 <hdaume> shapr: the (+1) syntax
09:11:50 <shapr> oh
09:11:56 <shapr> currying / partial evaluation ?
09:12:05 <shapr> schönfinkelling?
09:12:06 <dark> Well currying is everywhere in haskell :)
09:12:22 <dark> There have been so many languages that I doubt anything is a Haskell invention.
09:12:32 <dark> But Haskell might be the first FP language where currying is the default?
09:12:32 <shapr> I love that word... schönfinkelling. mmmm!
09:12:32 <hdaume> true
09:12:35 <hdaume> typeclasses....
09:12:54 <hdaume> i mean, they existed before, but not really in the same manner...
09:13:05 <shapr> it's just that -> is right associative, and every function in Haskell takes one argument, and returns one argument.
09:13:07 <dark> I mean, "first established FP language" :)  No doubt there were endless numbers of small projects.
09:13:26 <shapr> so (+) :: Int -> Int -> Int is actually (+) :: Int -> ( Int -> Int )
09:13:27 <dark> shapr: Yeah but if that argument is a tuple, it's sort of cheating :)
09:13:28 <Heffalump> currying happens in ML too
09:13:36 <shapr> and truly, that is unbelievably sexy.
09:13:46 <delYsid> shapr: What language is that?
09:13:47 <dark> I mean, foo :: (Int, Int) -> Int is really a function taking two arguments.
09:13:50 <shapr> delYsid: haskell.
09:14:21 <delYsid> shapr: schönfinkelling?
09:14:23 <shapr> yup.
09:14:28 <Heffalump> what ifyou have type Point = (Int,Int)
09:14:32 <Heffalump> and foo :: Point -> Int
09:14:35 <delYsid> shapr: It is also (Int -> Int) -> Int -> Int :)
09:14:35 <shapr> delYsid: that's just a bigger word for currying
09:14:41 <Heffalump> is foo still really a function taking two arguments?
09:14:54 <dark> Heffalump: No.  Play nice. :)
09:15:03 <shapr> btw, will someone explain to me the difference between currying and partial evaluation?
09:15:29 <shapr> I recently heard that Haskell uses currying, and that somehow accomplishes partial evalution, not the other way around.
09:15:54 <Heffalump> they're essentially completely diferent
09:15:57 * shapr laughs
09:16:06 <Heffalump> if anything partial evaluation generalises currying, but not really.
09:16:13 <shapr> ok, I'll just reread the section on currying in the Thompson book :-)
09:16:17 <dark> I think currying is so basic in Haskell that you don't see it:)
09:16:25 <dark> But in a language where functions normally take more than one argument,
09:17:00 <Heffalump> partial evaluation is taking a program that takes multiple arguments, giving a value to some of those parameters, and then doing as much computation as possible with those parameters to save work later (when the rest of the parameters are given)
09:17:03 <dark> curry is the operation that converts a two-argument function to a one-argument function-that-returns-a-function.
09:17:08 <Heffalump> so if you define f a b = (a+a) + (b+b)
09:17:18 <shapr> Heffalump: ok, does Haskell/GHC do that?
09:17:20 <Heffalump> no.
09:17:24 <shapr> oh.
09:17:31 <shapr> why not?
09:17:38 <shapr> lemme guess... no one wrote it?
09:17:50 <Heffalump> you can give a the value 1, and a decent partial evaluator would produce a specialised version of f that was something like f' b = 2 + (b+b)
09:17:54 <dark> Heffalump: Isn't that exactly what ghc's inlining and unfolding accomplishes?
09:18:14 <Heffalump> dark: umm, oh, I suppose so, sort of
09:18:48 <Heffalump> but you really can't rely on that
09:19:10 <shapr> ok, so currying I can rely on, but partial evalution is not a standard feature, right?
09:19:14 <dark> Heffalump: Depends on the value of 'rely' :)  I mean, it's an efficiency issue, and efficiency always means tuning, anyway.
09:19:25 <hdaume> you can force partial evaluation by using seq...
09:19:44 <Heffalump> hdaume: errm, how?
09:19:51 <Heffalump> seq won't force evaluation under a lambda
09:20:02 <Heffalump> shapr: right.
09:20:04 <dark> And I'm fairly sure that if you use pattern matching, and call a function with constant arguments that fit one pattern, ghc will call that case directly.
09:20:17 <Heffalump> shapr: and IMO it's not really what happens inside GHC at all.
09:20:28 <hdaume> as i understand it with your f definition, if you do (f 2) `seq` ..., this will be reduced to (\b -> 4+(b+b))
09:20:33 <Heffalump> dark: well, that's inlining
09:21:01 <Heffalump> hdaume: no, seq forces reduction to weak head normal form, and (\b -> (2+2) + (b+b)) is already in WHNF
09:21:34 <dark> Heffalump: What more could partial evaluation do, though?  Or do you mean unfold the whole program as far as you can without getting input?  Could be difficult in a lazy language :-)
09:22:27 <Heffalump> well, for one thing a partial evaluator formalises the two stages of input more, I think
09:22:27 <hdaume> Heffalump: ah, you're right :)
09:23:34 <Heffalump> and a partial evaluator will probably look more for optimisation opportunities at places where the known input parameter(s) occur
09:24:55 <shapr> so...
09:25:07 <shapr> would a partial evaluator be in the RTS?
09:25:40 <Heffalump> a proper partial evaluator for Haskell programs would probably get applied to a module or something
09:25:44 <Heffalump> I don't really know
09:26:00 <shapr> hm
09:26:12 <shapr> my friend wrote a partial evaluator in scheme, I'll have to see how he did it.
09:26:24 <hdaume> somewhat related is spj and robert ennal's paper on optimistic evaluation
09:26:43 <shapr> I think my boss did that when he hired me ;-)
09:26:51 <hdaume> :)
09:27:42 <Heffalump> that description sounds very similar to what Eager Haskell does
09:27:48 * Heffalump reads the paper
09:27:51 <dark> I would expect partial evaluation to be a place where Haskell can shine compared to imperative languages.
09:27:56 <shapr> dark: I agree.
09:28:02 <hdaume> he contrasts it with eager hs in the paper
09:28:13 <shapr> but then, I thought it was tightly connected to currying.
09:28:34 <dark> shapr: I think the term with currying is "partial application"
09:29:11 <shapr> ah
09:30:01 <dark> Another place where I think Haskell can outdo C is on VLIW architectures like ia64.  In Haskell it's much easier to arrange for computations to happen in parallel.
09:31:01 <shapr> dark: check out the Nepal project on Nested Data Parallelism in Haskell.
09:31:03 <dark> And beating C at its own game is my main interest :)  I don't think C will ever be replaced except by something that's faster, and I think we'll be drowning in buffer overflows until that happens.
09:31:06 <hdaume> dark: it may be *easier*, but there are thousands of pages of research on how to do it for C, and comparatively nothing for languages like haskell
09:31:36 <shapr> actually, Haskell on Itanium EPIC would rock.
09:32:08 <Heffalump> yes, calling currying "partial application" shows up the difference very well
09:32:09 * shapr notes that people have started calling the Itanium the Itanic
09:32:13 <Heffalump> lol
09:32:34 <dark> hdaume: hmm I'm not thinking of general concurrency for imperative programs here (i.e. threading), but making use of a processor that can execute five instructions at once, iff they don't conflict.  The scale is very different.  
09:33:00 <dark> shapr: They're just disappointed it isn't Sexium :)
09:33:42 <delYsid> shapr: That joke is about 8 months old :)
09:33:50 <shapr> Nepal can take advantage of both SMP and distributed boxes with MPI
09:33:51 <hdaume> dark: right, i know...i think high-level parallelism is much easier in haskell than in C...i think it's the fine grained parallelism that's hard in general and there's just a lot more work on how to do it for C...also, the fact that C is such a lower-level language can't hurt
09:34:01 <delYsid> I've heard it the first time the itanium was "released"
09:34:24 <dark> hdaume: Actually I do think it hurts :)  For example it's much harder to predict aliasing effects in C, because any pointer could point to anything.
09:34:27 <shapr> I can't find prices on Itanium hardware anymore, so I guess it's officially dead.
09:34:55 <delYsid> Itanium was neverr really alive :)
09:35:04 <dark> shapr: I think Itanium was never really sold separately, you basically had to get a HP machine.
09:35:18 <delYsid> They started to talk about the "break-through" Itanium II already a month after the release or so.
09:35:28 <shapr> I have four running boxes in my room, though only three on the lan. I gotta make time to play with Nepal.
09:35:31 <hdaume> it's harder, but it's not impossible...as long as people don't do weird pointer arithmetic, most alias analysis can handle it...
09:35:31 <delYsid> So people got suspicious, and no body really bought it...
09:35:34 <dark> Anyway, the Debian/ia64 folks will be extremely annoyed if Itanium dies before it's released, Intel would never risk their wrath :)
09:35:43 * shapr grins
09:36:06 <shapr> x86-64 looks more likely to succeed.
09:36:18 <dark> shapr: Unfortunately, I'd say.
09:36:38 <delYsid> Itanium was never really planned for PC usage.
09:36:43 <dark> Though... it would be cool if the next generation of processors can run linux natively but windows only in the slow 32-bit mode :)
09:36:43 <delYsid> x86-64 is somehow.
09:36:48 <delYsid> so I think it's logical
09:37:09 <delYsid> shapr: Nepal?
09:37:21 * dark wonders if x86-64 means one more layer of overlapping registers.
09:37:32 <shapr> delYsid: http://www.cse.unsw.edu.au/~chak/nepal/
09:37:39 <dark> objdump code talks about "rax", at least.
09:37:51 <delYsid> dark: as far as I understood it, yes
09:37:54 <shapr> hey, cool...
09:38:26 <dark> delysid: My uncompiler is going to break down and cry :)
09:38:50 --- topic: set to 'We put the Funk in Funktion || See logs @ http://tunes.org/~nef/logs/haskell/ || parr 0.1.0 released http://www.cse.unsw.edu.au/~chak/nepal/ || looking for team members for a #haskell ICFP contest entry, more info if the HaskellWiki returns.' by shapr
09:38:52 <delYsid> uncompiler?
09:39:02 <delYsid> Does that mean it does more than just disassemble?
09:39:09 <dark> delysid: Yep, it's supposed to generate C code.
09:39:13 <shapr> parr 0.1.0 released.
09:39:13 <Heffalump> decompiler is the standard name for that
09:39:40 <dark> Heffalump: Yeah but people tend to think of bytecode decomiplers.
09:39:41 <delYsid> cool
09:39:45 <delYsid> sounds very interesting
09:40:02 <dark> delysid: That's what I thought too, but it's progressing slowly :)
09:40:43 <dark> I'm just working on the disassembling parts now.  Except that I disassemble to expression trees, not to strings.
09:40:51 <delYsid> well, I hope I find time to start my first largish haskell project soon
09:40:59 <hdaume> delYsid: cool, what?
09:41:23 <delYsid> hdaume: I'd like to write hChess
09:41:37 <delYsid> In a literate form, to explain the game internals also...
09:42:21 <hdaume> cool'
09:42:59 <delYsid> my timesheet parser is already nearly finished, and was a good learning platform...
09:47:10 * dark tends to dive right into big projects for his learnign platforms :)
09:47:20 <dark> This tends to leave a trail of unfinished projects, but it's effective on the learning side...
09:48:04 <delYsid> well, I get a really unsatisfied feeling if I write code that never actually does something useful.
09:48:11 <delYsid> So I have to try to avoid that :)
09:48:50 <dark> I got a bit frustrated rewriting my code all the time, so now I'm just littering it with FIXME notes :)
09:49:16 <shapr> I do that too.
09:49:35 <shapr> and then I make myself go back and fix some stuff before writing new functionality.
09:49:54 <shapr> but I try to limit myself to fixing things that will make my new functionality easier or faster to write
09:50:21 <shapr> much like XP refactor before development, but refactor in the direction of what you're about to write.
09:54:49 <dark> shapr: Sounds good.
11:29:59 <delYsid> pfft
11:30:04 <shapr> hey redcrosse, ltns
11:30:07 <delYsid> just finished reading the Make manual :)
11:30:14 <delYsid> Took me 3 years of Linux usage to do that :)
11:30:18 * shapr laughs
11:30:22 <redcrosse> heya
11:45:23 <Jii> how many of you have given donation(s) to OPN?
11:45:40 <shapr> I have.
11:45:45 <shapr> five bucks.
11:46:14 <shapr> I'll probably give more in the future.
11:46:15 * Heffalump wouldn't unless the way it ran change significantly
11:47:20 <hornby> Heffalump: Whats your primary complaint? 
11:47:28 <Heffalump> lilo control-freakery
11:47:38 <shapr> hey hornby, wassup?
11:48:24 * delYsid thinks it's funny how split the groups are about lilo
11:48:46 <hornby> shapr: company's coming, so I'm supposed to be cleaning up. instead, I'm going through SICP and taing NOTES this time, so when I have to start from scratch again, I won't have to read the early chapters for the 10th time
11:48:54 <delYsid> methinks he's done a great job, and without him opn wouldnt exist
11:49:11 <hornby> Heffalump: Any examples of bad things he's done? 
11:49:51 <Heffalump> lots of stuff a few weeks ago when people started complaining about his requests for personal donations - juping #brits, making #openprojects +m
11:50:44 <hornby> hm
11:51:11 <hornby> well if people were being assholse in #openprojects, then it might make sense? I dunno, I wasn't there :)
11:52:19 <Heffalump> the #openprojects thing was more understandable, but juping an entire channel against the wishes of its inhabitants (from what I'm told from various sources, anyway) seems rather unreasonable
11:52:36 <Jii> donations are just so far from the contribution goal
11:52:45 <delYsid> Heffalump: which channel?
11:52:50 <Heffalump> #brits
11:53:05 <delYsid> heh, ok, but I understand that.
11:53:20 <delYsid> If a entire channel would play with me like they did, I'd just jup them
11:54:21 <delYsid> and openprojects was +m because too many kiddies wanted to show how cool they are and how fast they can throw bad words
11:54:45 <delYsid> #kernelnewbies was +m because riel actually wanted that.
11:56:21 <delYsid> And I still dont understand why people complain about someone asking for donations. That's just silly, just dont give anything if you dont want to.
11:57:05 <Heffalump> well, it was the intrusiveness of the messages that people objected to, I think
11:57:18 <delYsid> then they should learn about /ignore
11:57:20 <delYsid> and shut up
11:57:52 <delYsid> like with a hord of little children, always crying...
11:57:57 <delYsid> well, me goes to sleep
11:58:12 <Heffalump> night :-)
12:02:13 <shapr> g'night delYsid
12:45:57 <dark> Mmm, pancakes with maple syrup.
12:46:30 <eivuokko> Yea, that's real delicious :)
14:56:57 <jadrian> hello
14:57:02 <hdaume> hi
14:57:09 <jadrian> hi hdaume
14:57:16 <Heffalump> hiya
14:57:22 <jadrian> hello Heffalump
14:57:55 <jadrian> there is a new haskell icon available in here: http://www.kde-look.org/content/show.php?content=2722
14:58:28 <jadrian> it's a kde icon theme, but you can download it and extract the icons to use in another DE/WM.
15:05:27 <hdaume> i don't see the haskell one in either of the screenshots...
15:05:35 <redcrosse> me either
15:05:40 <jadrian> hdaume: it's not on the screenshots but it is on the icon theme
15:07:04 <hdaume> ah
15:12:12 <hornby> kde is pretty
15:12:51 <jadrian> yeap, it would be nice if it had an haskell mime type with syntax highlight and all by default
15:13:31 <jadrian> I think some people have already made some syntax highlight files. 
15:14:15 <jadrian> But they were not submited to the Kate homepage...
15:14:51 <jadrian> s/homepage/team
23:55:49 <delYsid> is a ShowS always a composed function?
