03:53:30 <delYsid> hey shapr
03:53:46 <shapr> hiya delYsid, what's up?
03:59:24 <delYsid> well, not much
03:59:41 <delYsid> Completely fucked my first erc upload :)
03:59:55 <shapr> suckage
04:00:07 <delYsid> hehe, well...
04:00:13 <delYsid> I've corrected it immediately...
04:00:43 <delYsid> How is Java-hell?
04:00:49 <shapr> still burning :-/
04:01:03 <shapr> my deadline is on friday, hopefully I won't burn out before then.
04:01:31 <delYsid> erc had quite alot of xemacs progress recently.
04:01:41 <delYsid> Alex fixed around 3 xemacs bugs for my birthday :)
04:01:58 <shapr> heh cool!
04:02:15 <delYsid> at least erc-button.el should work again in x too...
04:02:24 <shapr> cool, I'll update and try it.
04:03:10 <delYsid> And now two clients want into standard emacs, I fear this will be a fight :/
04:03:38 <shapr> huh?
04:03:53 <delYsid> yeah, the ZenIRC guys want to do it also I think.
04:03:55 <shapr> erc is competing with something else to be the standard irc client?
04:04:09 <shapr> wow
04:04:19 <delYsid> yeah, Alex raised the issue and is collecting copyrgith assignments for erc-workers.
04:04:28 <delYsid> If he has everything, we'll probably submit it for inclusion
04:04:33 <shapr> nifty :-)
04:04:52 <shapr> now if only we had an elisp refactoring browser.
04:04:59 <shapr> refactoring emacs would be fun.
04:05:20 <delYsid> well, why do you need a browser for that :)
04:05:24 <delYsid> use ya brain :)
04:05:28 <shapr> that's true
04:05:39 <shapr> add a bunch of unit tests and just go for it.
04:05:57 <delYsid> well, you'd need a plan first what you wanna change I guess.
04:06:10 <delYsid> we are at 56mb elisp source right now, thats quite alot for refactoring :)
04:07:20 <shapr> that is rather a lot.
04:07:24 <shapr> hi dark
04:07:37 <delYsid> Mr. Braakman, hello!
04:07:39 <dark> Hello :)
04:07:58 <shapr> hoi, hoe gaat?
04:08:17 <delYsid> hehe, I love this language :)
04:08:24 <shapr> what, dutch?
04:08:28 <delYsid> yes
04:08:29 <dark> It's okay :)  I'm wondering whether to code or kill monsters.
04:08:45 <shapr> delYsid: my all-time favorite word is gezeik
04:08:49 <delYsid> well, you could code a game where you can kill monsters :)
04:08:56 <shapr> but graag gedann comes close to being as much fun to say.
04:09:19 <shapr> the dutch g is almost too much fun.
04:09:26 <delYsid> graag gedann I think I understand, but the other one :)
04:09:36 <delYsid> I like the double-a's :)
04:09:40 <shapr> graag gedann is "thank you"
04:09:54 <delYsid> er, ok :)
04:10:07 <shapr> gezeik is literally "horse piss" but is like saying bullshit in english.
04:10:49 <delYsid> well, there are similarities, but only 1/3...
04:11:00 <dark> No, "gezeik" doesn't specify a species :)
04:11:06 <shapr> dark: oh I didn't know that.
04:11:14 <shapr> my command of dutch is microscopic.
04:11:25 <shapr> iirc, the technical name of Dutch is "Low German"
04:11:37 <dark> Er, no... Low German is Low German :)
04:12:01 <dark> That's what they speak in the non-mountainous area of Germany.
04:12:07 <delYsid> well, I simply love hearing dutch girls speaking. :)
04:12:11 <shapr> oh ok, I thought I read that it was called Low German, and that "low" had something to do with altitude.
04:12:42 <shapr> I always thought reclaiming land from the sea was very resourceful.
04:12:49 <dark> I know someone whose favourite word was 'woonwinkel'
04:12:55 <shapr> oh, that's a great word!
04:12:57 <shapr> what does it mean?
04:13:12 <shapr> delYsid: bea speaks dutch almost fluently
04:13:18 <shapr> it's great fun to hear her talk.
04:13:38 <delYsid> hmm, this year I didnt manage to visit the holy-land :(((
04:13:44 <dark> It's a kind of furniture store.  The word was made up by marketing people, I think.
04:14:21 <delYsid> ahh
04:14:24 <delYsid> Wohn winkel :)))
04:14:41 <delYsid> cool, the similarities are really fun sometimes...
04:15:49 <shapr> Bea had guessed that woonwinkel might be "estate agent"
04:15:55 <shapr> "life shop"
04:16:19 <shapr> delYsid: holy land? .nl ?
04:16:51 <delYsid> yeah, nl is the holy-land for me
04:17:01 <dark> delysid: Strange religion :)
04:17:13 <delYsid> delYsid: Jah is one of my gods :)
04:18:30 <dark> Hmm, Haskell is flexible enough that it should be possible to program in dutch :)
04:18:46 <shapr> nifty idea
04:18:50 <dark> I have no idea how to translate "map" though.
04:19:02 <shapr> een neu map
04:19:06 <shapr> map is folder in dutch
04:19:24 * shapr notes that several computers in his house have a Dutch BIOS and Dutch win95
04:19:48 <delYsid> er, but map and map are not the same :)
04:19:58 <dark> shapr: Isn't that the other way around?  Dutch "map" is sometimes translated as "folder".
04:20:23 <delYsid> a german "mappe" is a folder where you put something in.
04:20:23 <dark> I'm talking about the function though :)
04:20:47 <dark> Dutch "map" is also abused as a translation for "directory", which doesn't really have a translation :)
04:20:51 <shapr> my clue factor in not high when it comes to dutch.
04:21:03 <shapr> I do know what to click to make stuff work though :-)
04:21:35 <dark> One thing I have found while trying to translate programs to dutch is that often the english words don't make sense :)  People have just grown used to them.
04:22:17 <delYsid> well, there are alot technical english terms which dont really make sense :)
04:22:39 <dark> For example I was once faced with the help text "Change local directory".  Now it's obvious what it means.  But look at the words, and then tell me what it means :)
04:23:17 <delYsid> well, local is simply wrong there, it should say current...
04:23:31 <dark> delysid: No, this was in an ftp program.
04:23:43 <delYsid> oh :)
04:33:45 <dark> Maybe my dutch is just getting rusty :)
04:33:57 <dark> But I really can't think of a translation for 'map'.
04:34:44 <dark> On the other hand, 'filter' can probably be used as-is :)
04:35:13 <shapr> my american is getting rusty
04:35:14 <dark> Hmm, no, it would be 'filtreer' if it's a verb.  But it's not clear whether Haskell function names are supposed to be nouns or verbs :)
04:37:20 <dark> Actually it's inconsistent... "take" is a verb while "tail" is a noun.
04:37:47 <dark> Hmm... I just realized that english is so flexible that "take" can be a noun and "tail" can be a verb :)  Depends on the intended meaning.
04:37:55 <shapr> in english, it's easy to "verbize" a noun
04:38:09 <shapr> verbize :: Noun -> Verb
04:38:21 * shapr thinks up examples
04:38:25 <shapr> what's your take on the problem?
04:38:45 <shapr> american for "do you see any unmentioned factors?"
04:39:07 <shapr> "driver, tail that car in front of us"
04:39:25 <dark> Does that "tail" have any relationship to the noun, though?
04:39:29 <shapr> yes
04:40:01 <shapr> "he's on our tail." means "he's following us"
04:40:14 <dark> I always wondered if that was a garbling of "trail" :)
04:40:17 <shapr> nah
04:41:12 <shapr> I'd like to see a programming language where's it that easy to switch between verb and noun
04:41:36 <dark> Isn't Haskell an example?
04:41:47 <shapr> I think so.
04:41:55 <dark> There's very little distinction between functions and data :)
04:41:58 <shapr> that's true.
04:42:16 <shapr> I think it could be more explicit though.
04:42:45 <shapr> in Joy, it's far more explicit.
04:42:58 <dark> Pattern matching is nounish, even though what it matches are "data constructors", not "data" :)
04:43:10 <shapr> that's a good point.
04:43:20 <dark> But I think if you allow arbitrary expressions in the patterns, then you get something like Prolog.
04:43:47 <shapr> I was just thinking about Joy where lists are program fragments that you can operate on and then execute.
04:44:05 <shapr> that's somewhat true in Haskell, but the structure of a function isn't explicit.
04:44:41 <shapr> I'd like to have a language where I can open up a function and see the S & K combinators that make it work.
04:45:04 <shapr> I know that would allow for function equality/subset/etc
04:45:15 <shapr> but I'm not sure if function comparison like that would be useful.
04:45:54 <dark> It would still be possible for functions that behave the same to be unequal.
04:46:44 <shapr> really?
04:47:00 <shapr> I think it would
04:47:18 <shapr> it would be fun to write an optimizer for a language like that.
04:47:22 <dark> Well, for a simple example, how would you tell that (id . id) and (id) are the same?
04:47:22 * delYsid thinks a natual-lang interface to computing could be fun.
04:47:37 <delYsid> I think the most practical approach would be to create a mud-like interface for things you do daily.
04:47:49 <dark> delysid: Simply parsing natural language is still problematic :)
04:48:14 <delYsid> right
04:48:23 <delYsid> But if we narrow the domain a bit, it should be doable
04:48:45 <dark> shapr: For a more complicated example, consider two different sorting algorithms :)
04:48:48 <shapr> dark: I think a transparently reflective language like that would be good for deforestation
04:49:07 <shapr> that's a good point, multiple sorting algorithms.
04:49:17 <dark> delysid: I know some mud addicts who had aliased 'look' to 'ls'.
04:49:28 <Jii> it is funny though that contrary to the common belief natural language has a low expressive power
04:50:15 <dark> Jii: Redundancy to cope with noisy channels and incompatible protocols :)
04:50:21 <delYsid> well, the first problem I saw is that you'd need to implement questions and commands :)
04:50:36 <delYsid> people tend to either ask for something, or command something.
04:50:51 <delYsid> Like in "Can you give me the real name of ..." and "give me the real name of..."
04:50:51 <dark> delysid: Not in my experience :)
04:51:20 <dark> delysid: People tend to muse about their personal experiences, and give opinions about how other people should do things.
04:54:10 <dark> delysid: Actually I think the command-as-question is typically english.  It doesn't happen a lot in dutch or finnish, at least.
04:55:09 <delYsid> true
04:55:20 <delYsid> (german)...
04:56:18 <dark> My favourite example was in the small print on an airline ticket, it had a sentence that started with "U gelieve...".  This is an ancient verb form which means something like "You shall be pleased to..."
04:57:31 <dark> Apparently it's supposed to be a polite form, but I don't see why :)
04:58:41 <shapr> suomi is a nifty language.
05:00:35 <shapr> it feels kinda lispish to me
05:01:03 <dark> So the words are actually lists?  That explains a lot :)
05:01:44 <shapr> maybe it's closer to Joy?
05:01:45 <delYsid> suomi?
05:01:51 <shapr> suomi == finnish
05:02:00 <delYsid> er, ah :)
05:02:10 <delYsid> lispy language?
05:02:13 <delYsid> Why is that
05:02:17 <shapr> sauna = sauna, saunani = my sauna
05:02:37 <shapr> out of my sauna = saunanista ?
05:02:43 <ibid> saunastani
05:02:49 <shapr> ah, thanks :-)
05:02:59 <delYsid> er, looks like latin to me :)
05:02:59 <shapr> I never got figured out what order endings get put on.
05:03:09 <ibid> there is a rule :-)
05:03:15 <dark> It's even a simple rule :)
05:03:20 <shapr> ok, what's the rule?
05:03:23 <ibid> delYsid: latin does not have over ten noun cases
05:03:49 <delYsid> ibid: correction, it looks as ugly as latin :)
05:04:12 * delYsid has a latin-aversion which school.
05:04:13 <shapr> I think finnish has seventeen cases
05:04:22 <shapr> I did the math some months ago
05:04:42 <delYsid> s/which/since/
05:04:51 <ibid> auto, autoa, auton, autoksi, autona, autossa, autosta, autoon, autolla, autolta, autolle, autoine(en), ... i missed some here
05:05:02 <ibid> shapr: not seventeen officially, something like twelve
05:05:14 <shapr> hm, I wonder where I got seventeen from.
05:05:43 <ibid> there are some guys on the internet listing some cases that are not "officially" recognized, like prolative
05:05:44 <shapr> I do remember coming up with something like forty three basic forms
05:06:10 <ibid> shapr: have you seen fred karlsson's list of all forms of the word "kauppa"? there are more than a thousand...
05:06:20 <shapr> yikes
05:06:25 <shapr> that's amazing.
05:07:28 <dark> Imagine writing a finnish spelling checker :)
05:07:38 <shapr> I read about a finnish grammar checking program.
05:07:50 <shapr> something like seven years and fifteen people of much brain.
05:09:01 <dark> shapr: I can't find the rule in my grammar book :)  But there's like four types of ending, and they always go in the same order.
05:09:06 <ibid> http://www.cs.tut.fi/~jkorpela/finnish-cases.html
05:09:12 <dark> It's different for nouns and for verbs.
05:10:01 <shapr> wow
05:10:08 <delYsid> kauppa?
05:10:53 <shapr> shop?
05:10:55 <ibid> http://www.ling.helsinki.fi/~fkarlsso/genkau2.html
05:10:56 <shapr> I think
05:11:23 <shapr> delYsid: efe.scape.net :-)
05:12:29 * delYsid talossa
05:12:52 <delYsid> heh, this is fun :)
05:17:20 <ibid> i was once working on a finnish spell checker... this is an experiment i did: ftp://ftp.jyu.fi/private/antkaij/reduce.tar.gz
05:19:15 <dark> The most interesting word in my grammar book is 'prahassakäymättömyyskompleksi': complex about not having been to Prague.
05:19:45 <ibid> that has to be wrong
05:20:14 <ibid> Praha is a proper noun, it should probably be Prahassa-käymättömyyskompleksi
05:20:20 <ibid> but i'm not sure
05:21:48 <dark> Should I complain to the author? :)
05:22:36 <ibid> dunno
05:24:27 <dark> Hmm what would a "Danish cookie" be in finnish?  Don't you make it into a single lowercased word?
05:26:10 <ibid> a direct translation would  be: tanskanpikkuleipä
05:26:28 <ibid> but i don't know what a Danish cookie is
05:26:34 <delYsid> ugh :)
05:26:39 * delYsid just read dict woman
05:26:46 <delYsid> and found the devil's dictionary entry :)
05:26:51 <delYsid> nothing for bea, really nothing :)
05:28:04 <ibid> well, try man, too
05:28:23 * shapr grins
05:28:47 <dark> WordNet definitions never make sense to me.
05:29:37 <dark> Or rather, its examples don't make sense.  They tend to be for some other word than is being defined :)
05:30:10 <ibid> the examples use synonyms
05:30:19 <ibid> which is annoying
05:31:19 <dark> I find it a stretch to consider 'char' a synonym for 'woman'.  It would certainly upset a lot of my C coding :)
05:31:51 <dark> Heh, the "felis pugnans" used at the end means "fighting cat".
05:31:55 <delYsid> yeah, I've noticed that too :)
05:31:59 <delYsid> char, well :)
05:32:19 <ibid>   char
05:32:20 <ibid>        n 1: a human female who does housework
05:32:42 <delYsid> ... (_felis pugnans_), is omnivorous and can be taught not to talk.
05:32:44 <delYsid> *lol*
05:48:18 <Verbophobe> Morning all.
05:49:41 <shapr> hi Verbophobe
05:50:02 <Verbophobe> How are you?
05:51:34 <shapr> not bad, how are you?
05:51:49 <Verbophobe> Wonderful!  Thanks for asking.
05:51:55 <shapr> :-)
05:51:55 <Verbophobe> Business is slow?
05:52:07 <shapr> I have far too much business.
05:52:12 <shapr> what about you?
05:52:26 <Verbophobe> Nothing at all.  And I mean nothing.
05:52:38 <shapr> Are you a haskell programmer?
05:52:46 <Verbophobe> A "wanna be"
05:52:55 <shapr> This is a good place to learn.
05:53:00 <Verbophobe> I'm looking for some good solid simple example code...
05:53:27 <Verbophobe> You know, to look at?
05:53:33 <shapr> http://pleac.sourceforge.net/pleac_haskell/
05:53:38 <shapr> I found that yesterday.
05:53:47 <shapr> it's not terribly idiomatic, but it's ok.
05:53:58 <Verbophobe> Nice.  I'll check it out right now.
05:54:04 <Verbophobe> Thanks, by the way.
05:54:08 <shapr> sure, no problem.
05:55:25 <Verbophobe> Kick ass.  I've got a pirated version of the perl cookbook.  It's all in nice HTML, too.
05:57:31 <delYsid> The links on the haskell.org/bookstore page also are bettern then some months ago.
05:57:42 <delYsid> Thereare at least 2 or 3 web-reachable tutorials which are quite good.
05:58:20 <delYsid> and the YAHT is also great!
05:58:58 <Verbophobe> YAHT?
05:59:55 <delYsid> Yet Another Haskell Tutorial by Hal Daume III et al.
06:00:10 <delYsid> see http://haskell.org/bookshelf/ for a link
06:00:59 <Verbophobe> Nice!
06:01:34 <Verbophobe> Oh, and a polemic question: Where's the sector where functional programming really shines?
06:01:43 <Verbophobe> ...in your opinion, of course.
06:02:49 <shapr> side effects and input/output are easier in procedural languages.
06:03:40 <shapr> everything else seems better in Haskell :-)
06:03:47 <Verbophobe> Hehe...
06:04:14 <Verbophobe> I'll almost have to agree.  The little I've written up to now was pretty powerful.
06:33:56 <delYsid> yup, and you can write cool parsers in haskell.
06:34:03 <delYsid> http://lexx.delysid.org/STunden.ps :)
06:34:19 <delYsid> er, Stunden.ps that is
06:35:38 <shapr> yah, haskell is good at parsing.
06:36:07 <Verbophobe> Would it be too much to ask you guys yet another question?
06:36:15 <Verbophobe> I can't get this to go through:
06:36:16 <Verbophobe> adds x = x : adds (x+1)
06:36:17 <Verbophobe> mylist y = [ x | x <- adds 1 ,x<=y]
06:36:17 <Verbophobe> main = do map putStrLn (mylist 10)
06:36:29 <Verbophobe> Course, I'm pretty sure it's somthing stupid...
06:36:42 <delYsid> dont you need mapM there?
06:36:46 <delYsid> and ignore the do completely...
06:36:53 <Verbophobe> Will do.
06:36:57 * delYsid is newbie too...
06:37:16 <delYsid> anyway, the do is useless, as you have only one call to map in your function.
06:37:34 <Verbophobe> Hmmm...  Still blocks on the same error.
06:37:42 <Verbophobe> Oh, believe me, I'm a bigger newbie.
06:37:51 <delYsid> whats the error?
06:37:58 <Verbophobe> ERROR "test.hs":3 - Unresolved top-level overloading
06:37:58 <Verbophobe> *** Binding             : main
06:37:58 <Verbophobe> *** Outstanding context : Num [Char]
06:38:59 <delYsid> er, hugs, hmm
06:39:03 <delYsid> I dont know hugs error msgs...
06:39:25 <Verbophobe> Lemme try ghc, in that case...
06:40:09 <delYsid> btw, how can mylist work anyway?
06:40:11 <delYsid> x is not bound...
06:40:37 <delYsid> er, nm
06:40:39 <delYsid> I'm an idiot
06:41:13 <Verbophobe> Well dammit.  I don't have ghc installed...  Would've sworn I had it...
06:41:41 <Verbophobe> There it goes a-compiling!
06:42:10 <Verbophobe> Anyway, I'll figure it out, eventually.
06:42:16 <Verbophobe> Thanks for the help.
06:42:28 <delYsid> oh, I think I found it
06:42:36 <delYsid> result of mylist is [Char], right?
06:43:11 <delYsid> well, mapM putStrLn needs [[Char]]
06:43:23 <Verbophobe> I have no idea...  I thought it was int.
06:43:44 <Verbophobe> Ahh..
06:43:46 <Verbophobe> I get ya.
06:43:50 <delYsid> er, well, you cant putStrLn that type
06:43:59 <delYsid> You need to have a list of strings to map over with putStrLn
06:44:52 <delYsid> mapM putStrLn ["abc","bcd"]
06:44:54 <delYsid> -- works for me
06:45:33 <Verbophobe> How can I "cast" from Integer to String?
06:45:48 <delYsid> You cant :)
06:45:52 <delYsid> er, you could use show
06:45:57 <Verbophobe> I tried...
06:46:00 <delYsid> show 5 results in "5"
06:47:28 <delYsid> mapM putStrLn . map show $ [1..9]
06:47:37 <delYsid> -- Lists all numbers from 1 to 9 on a separate line.
06:49:20 <Verbophobe> Hmm...  Would you mind explaining the logic behind your example?  I get the [1..9], but not the "." nor the "$"...
06:49:38 <delYsid> well, . is function composition
06:49:44 <delYsid> I could have written it differently, wait.
06:50:01 <delYsid> mapM putStrLn (map show [1..9])
06:50:06 <delYsid> -- This version is equivalent
06:50:07 <Verbophobe> Ah.  Alright.
06:50:18 <Verbophobe> Now I get it!  Hehe...
06:50:45 <Verbophobe> And how do the "." and "$" work, exactly?
06:50:45 * delYsid cant believe it
06:50:54 <delYsid> I'm actually teaching haskell :)
06:50:57 <delYsid> 2 weeks ago, I didnt know a bit about the language :)
06:51:00 * shapr laughs
06:51:21 <Verbophobe> Wee!  Should be about the same for me...  I started a damned day ago.
06:51:22 <delYsid> . composes a new function out of two functions
06:51:26 <shapr> delYsid: imho, you learn fast.
06:51:32 <delYsid> $ is just another way to say "this is an argument" to avoid ()
06:51:38 <Verbophobe> Ahhh...
06:51:41 <Verbophobe> Wonderful.
06:52:29 <delYsid> Function composition is cool
06:52:34 <delYsid> currying is too :)
06:52:43 <delYsid> map (1+) [1..9]
06:53:10 <delYsid> so (1+) actually generates a function which now only takes one argument
06:53:17 <delYsid> The other argument to + is already supplied
06:53:25 <Verbophobe> Hell, functional programming is cool.  I've been a C man all my life.  Hell, I just got off a relatively large C program...
06:53:29 <Verbophobe> Yeah, read about that.
06:54:15 <Verbophobe> Anyway, I shall now go back to practicing...
06:54:21 <delYsid> and the reason for mapM in my example is that putStrLn is actually a monadic function (for IO) which doesnt work with normal map
06:54:32 <delYsid> so you need mapM for those (M is for Monad)
06:54:49 <Verbophobe> That's why it output: "[<<IO action>>,<<IO action>>,..."
06:55:11 <Verbophobe> Well, thank you.  I am now a wiser man.
06:55:31 <delYsid> explaining stuff helps understanding it for the explainee too :)
06:55:42 <Verbophobe> Oh, by the way, where can I find a manpage-type refrence for Haskell functions?
06:55:45 <Verbophobe> Hehe...  Amen.
06:56:31 <delYsid> hmm, didnt find such a thing yet, I think the haskell prelude and library report are used primarily to lookup definitions
06:56:44 <delYsid> You can also use :t to find the type of a certain function in ghc (and probably hugs too)
06:57:22 <delYsid> Prelude Monad> :t mapM
06:57:23 <delYsid> forall a m b. (Monad m) => (a -> m b) -> [a] -> m [b]
06:57:52 <Verbophobe> That's great.
06:57:54 <Verbophobe> Thanks man.
06:57:59 <delYsid> np
07:24:16 <dark> Hmm, something like a man command for standard haskell functions would actually be useful :)
07:24:23 * shapr bounces
07:24:24 <dark> But it would be a lot of work to write all the docs.
07:24:30 <shapr> dark: emacs has one already
07:24:53 <dark> For each function, it could explain what it's useful for, give a definition and some examples, and related functions.
07:25:02 <shapr> it shows one-line docs in the minibuffer when you hover over a keyword it recognizes.
07:25:11 <shapr> oh, that would be much better.
07:25:22 <shapr> I want to see the *examples* part
07:25:31 <shapr> related functions would be spiffy also.
07:25:38 <shapr> we could do it on the HaskellWiki
07:25:41 <shapr> if it ever comes back.
07:26:50 * pesco drops a tear on the HaskellWiki
07:27:15 <pesco> hey shapr, can you update me on the status of the ICFP contest?
07:27:42 <shapr> oh look!
07:27:44 <shapr> the wiki is back!
07:27:46 <shapr> yay!
07:27:51 <pesco> Are you serious? Wooh!
07:28:08 <shapr> hey, where's the IcfpContest page??
07:28:33 <pesco> Yah right, nothing's back. It's all dead as before. :(
07:29:06 <shapr> RecentChanges is back
07:29:12 <shapr> http://haskell.org/wiki/wiki?RecentChanges
07:29:16 <pesco> Oh, I never noticed it was gone.
07:30:06 <pesco> Anyway, we need to coordinate some stuff about the contest.
07:30:11 <shapr> I agree.
07:30:24 <pesco> How many of us are there?
07:30:52 <shapr> you, loom2, and me are the three I'm sure of.
07:31:17 <pesco> Alright, that's equal to my internal listing.
07:31:43 <shapr> I know jewel is interested, dunno if he's had time to become familiar with the tools and stuff.
07:31:59 <pesco> Ah.
07:32:21 <shapr> jens is on the list, I think he said he's not sure he'll have time.
07:32:21 <pesco> loom2 and I will go into full-scale preparation next week.
07:32:36 <shapr> Igloo and Heffalump said they might have time, no definites.
07:32:43 <pesco> Hm.
07:33:11 <shapr> I'll send a confirm or cancel message to the list.
07:33:20 <pesco> That's a good idea.
07:34:17 <delYsid> icfp?
07:34:45 <shapr> delYsid: http://icfpcontest.cse.ogi.edu/
07:34:56 <delYsid> btw, the wiki is back since about a week :)
07:35:04 <shapr> oh, I didn't know :-)
07:35:08 <shapr> I've been burning in Java Hell.
07:35:09 * Igloo is more likely than I was now I think
07:35:13 <shapr> yay!
07:35:30 <Igloo> But I might be busy writing a make replacement  :-)
07:35:36 <shapr> heh
07:35:40 <delYsid> hmm
07:35:50 <shapr> think of how much fun it'll be to join the #haskell team for the contest :-)
07:35:51 <delYsid> I've looked at the winner last year, this stuff is far above my head.
07:35:53 * Heffalump is about 50% likely to do it
07:35:54 <delYsid> have fun guys :)
07:36:23 <shapr> delYsid: each contest is different :-)
07:36:42 <shapr> here's the mailing list url if anyone wants to join: http://alicorna.net/mailman/listinfo/icfp-team
07:36:51 <shapr> hm, archives are broken
07:37:16 <delYsid> I'd be more interested in how groupwork programming works
07:37:26 <delYsid> but not really participate, I'm too looserish for that still
07:38:04 <shapr> delYsid: I probably am also, I want to test myself to see how far I have to go.
07:39:29 <Igloo> The requested URL /cgi-bin/mailman/private/icfp-team/ was not found on this server.
07:39:45 <shapr> yah, I can't get to the archives either
07:39:50 <shapr> I'll mail Pseudonym about that.
07:40:09 <Igloo> I don't particularly care unless I missed anything interesting  :-)
07:45:48 <shapr> things you need to participate: CVS access, familiarity with HUnit and QuickCheck
07:45:51 <shapr> not sure what else...
07:46:40 <shapr> well, subscribe to list also, I guess.
07:47:51 <shapr> pesco: what stuff needs coordinating?
07:49:59 <pesco> Oh, I was basically wanting to know who'll be participating.
07:50:49 <shapr> things we have: cvs, mailing list, irc channel, testing software
07:50:54 <shapr> anything else we might need?
07:51:00 <pesco> Will you be on the channel regularly next week?
07:51:07 <shapr> yes.
07:51:19 <shapr> my big deadline is friday, and then I start vacation.
07:51:30 <pesco> :)
07:51:32 <pesco> Great.
07:51:52 <pesco> Do we have someone with parsec experience?
07:52:03 * shapr points to delYsid
07:52:14 <shapr> I've used it a bit.
07:52:27 <pesco> I've read a good bit of the docs but not used it to date.
07:52:46 <pesco> I think it's pretty likely we'll need it.
07:53:13 <shapr> I agree.
07:53:26 <pesco> What else is there. Graphs!
07:53:33 <pesco> Have you ever used the FGL?
07:53:50 <shapr> I've read the docs some, but haven't used it.
07:53:51 <delYsid> yeah, I know parsec :)
07:54:24 <delYsid> Parsec is fun, but still too limited imo
07:54:35 <pesco> delYsid: Great, you'll be our man to feed us the data. :)
07:54:43 <pesco> shapr: same here.
07:54:47 <delYsid> k
07:55:11 <shapr> ok, next week I'll spend some time on Parsec and FGL
07:55:25 <shapr> other suggestions?
07:55:44 <pesco> I'll do FGL as well. Parsec maybe.
07:56:02 <shapr> I'd like to look through the Edison library, try to build a mental list of the useful libraries there.
07:56:15 <pesco> Edison? What's that?
07:56:28 <shapr> it comes with GHC
07:56:34 <pesco> What does it do?
07:56:44 <shapr> Chris Okasaki wrote the Edison library to go with his book Functional Data Structures
07:57:04 <shapr> supposedly it has lots of good stuff, but I've not spent much time looking at it.
07:57:30 <shapr> hm, my icfp-team email bounced....
07:57:37 <shapr> looks like mailman choked.
08:00:40 <pesco> *grm*
08:01:02 <shapr> hi malc
08:01:19 <malc> lo shapr
08:01:30 <Igloo> Something that might be worth looking at is the new hat which apparently isn't written in Java (hooray!)
08:01:45 <shapr> hat 2.00 ?
08:01:50 <shapr> hat is nifty
08:01:54 <pesco> What is hat? (I feel dumb)
08:01:57 <shapr> kind of troublesome though
08:02:03 <shapr> hat is the tracing debugger
08:02:26 <shapr> hat 2.00 is the latest release
08:02:29 <pesco> For Haskell? And it was written in Java? urk
08:08:41 <Igloo> Yeah - it's Haskell with a bit of C via the FFI apparently
08:08:56 * Igloo might manage to actually use it now  :-)
08:33:32 * delYsid isn't fond of all those preprocessed haskell variants.
08:33:40 <delYsid> Seems like a bit of a ugly hack to me.
08:35:26 <Igloo> FFI isn't a preprocessed Haskell variant
08:35:31 <shapr> Hat is though
08:35:39 <shapr> Hat is a bit cheesy in spots.
08:35:55 <Igloo> Not really. Your code is real Haskell '98
08:36:06 <Igloo> Hat just needs to amngle it a bit to work
08:50:33 <pesco> Wooh, HUnit actually makes sense to me. JUnit didn't.
08:50:44 <shapr> hi redcrosse
08:50:54 <redcrosse> hey
08:51:06 <shapr> pesco: I like the xUnit stuff, I've been using it for years. I agree with your opinion of JUnit.
08:51:14 <shapr> I like PyUnit a lot.
08:51:45 <shapr> if you've checked out the icfp cvs, you'll see I added the PyUnit style display code that the HUnit author wrote for me
08:52:03 <pesco> After the first few paragraphs of the HUnit documentation I was thinking, what kind of crazy structure is this?
08:52:14 <shapr> there's some interesting discussion the hunit-users list also
08:52:56 <pesco> But then he just explained that a test is a recursive structure, which forms a tree, with optional labels at the nodes and test cases at the leaves.
08:53:18 <shapr> I just pretend I'm  using PyUnit, and it all works :-)
08:53:34 <shapr> I still have one question actually
08:53:39 * shapr suddenly remembers
08:54:06 <shapr> here's how my tests look so far:
08:54:09 <shapr> testNegDecode = let d = "neg int decode" in
08:54:09 <shapr>                     TestLabel d (TestCase (assertEqual d (BananaNeg (-1015),"") (decode encNegOneZeroOneFive)))
08:54:10 <pesco> Now it all makes sense. And all of a sudden I find that that's all there is of the docs (except the syntactic sugar).
08:54:38 <shapr> thing is, I haven't figured out where both TestLabel and assertEqual have a text string that goes with them
08:54:56 <shapr> er "why"
08:54:58 <shapr> not "where"
08:55:54 <pesco> Hm. In this case it does seem a bit redundant, let me think of an example where it makes sense...
08:56:14 <pesco> Ah, I know.
08:56:16 <shapr> I'm used to PyUnit, where the tests are pulled from functions that start with a certain pattern. I use test*
08:56:58 <shapr> building a TestList bugs me because I forget to add the new tests to the list
08:57:05 <pesco> An assertion can be a combination of many such, each of which would use its own error message.
08:57:09 <shapr> Dean suggested that I define them all inline
08:57:22 <shapr> oh, good point!
08:57:27 <shapr> I hadn't thought of that.
08:59:25 <shapr> pesco: have you tried QuickCheck also?
09:03:38 <pesco> No.
09:03:55 <shapr> it's cool :-)
09:04:22 <shapr> I wonder if anyone has done design by contract stuff for Haskell.
09:04:25 <shapr> should be pretty simple.
09:04:29 <pesco> I just scanned through the list of "Libraries and Tools for Haskell", middle-clicking (open in new tab) on everything of interest.
09:04:44 <shapr> any hits?
09:04:55 <pesco> QuickCheck is in the queue.
09:04:58 <shapr> cool :-)
09:05:01 <shapr> what else?
09:05:45 <pesco> Hat, FGL, Strafunski, GetOpt
09:05:54 <shapr> ah, Strafunski
09:06:21 <pesco> Some non-ICFP-related things too: haskell-corba and FunGEn
09:06:23 <shapr> I can see some of the potential of Strafunski, but most of it is still a "deeper art"
09:06:58 <pesco> :) I'm looking forward to looking at it.
09:07:20 <pesco> What happened to http://www.haskell.org/lego/ ?
09:07:26 * shapr dunno
09:08:16 <pesco> I have a set of mindstorms and was eager to try Haskell on it.
09:08:25 <shapr> that would be cool :-)
09:08:30 <shapr> I gave my mindstorms to my uncle.
09:08:30 <Heffalump> what was at /lego/ ?
09:08:43 <pesco> I suppose Haskell-controlled Mindstorms.
09:09:44 <pesco> Well, there is GCC for the H8300 (I think that's the name of the chip) though.
09:10:13 <shapr> I thought it was running the 68HC11 ?
09:10:26 <Heffalump> there is gcc for whatever it is running
09:10:48 <Heffalump> (Igloo and I have used it)
09:11:17 <pesco> shapr: Nah. Although I have never heard 68HC11, I know it's not the Mindstorms chip. Or they changed it.
09:11:19 <Igloo> More importantly there is a GCC cross compiler for that arch for x86
09:11:28 <Heffalump> oh, yes, that's what I meant :-)
09:14:43 <pesco> I'm very bad at imagining low-level things like that.
09:15:19 <pesco> I'm trying to make the connection H8300-Haskell.
09:15:31 <delYsid> hmmm!
09:15:45 <delYsid> Does anyone have an idea for a lazy pi?
09:15:55 <shapr> neat idea
09:16:13 * Igloo gets a pile of Python crap when trying to subscribe to the icfp list and decides to blame shapr
09:16:19 <shapr> uh oh
09:16:21 <delYsid> hehe
09:16:39 <shapr> Pseudonym: hey, you awake?
09:16:42 <pesco> There is this chip. GCC takes a C program and produces code that will run on it. GHC produces some sort of C.
09:16:56 <shapr> good point.
09:17:24 <pesco> Will GCC be able to transform GHC's output into H8300 code?
09:17:25 <shapr> Igloo: the icfp list is slightly broken at the moment, I'll tell you when it's back.
09:17:29 <Igloo> You need to add code to GHC for each arch AIUI
09:17:39 <Igloo> Heh, np   :-)
09:17:59 <pesco> Igloo: I think so, too, but what kind of code?
09:18:03 * pesco breaks into tears.
09:18:08 <shapr> ?
09:18:20 <pesco> I feel so stupid when confronted with low-level programming.
09:18:28 <Igloo> I'm not really sure
09:18:58 <pesco> It's about time I take my lessons in Sparc assembly next semester...
09:19:15 <pesco> Maybe then I'll get a clearer picture of the world below the compilers.
09:19:51 <pesco> Oh and I should read Tanenbaum's books about operating systems.
09:19:52 <delYsid> (TestLabel "foo" (TestLabel "bar" (TestLabel "baz" return ())))
09:19:55 <delYsid> -- hmm :)
09:19:59 <delYsid> I'm in a crazy mood
09:20:02 * shapr grins
09:20:19 <pesco> Cool Test, delysid. You will be a successfull programmer. ;-)
09:20:50 <delYsid> yeah, I am :)
09:20:59 <pesco> Just tested it, huh?
09:21:28 <pesco> Sorry, I don't mean to sound cynical.
09:21:55 * delYsid is just browsing the HUnit manual
09:22:11 <delYsid> And I noticed that in theory it should be possible to construct useless tests like that :)
09:22:24 * shapr always sounds cynical after working on Java for many hours.
09:22:38 <delYsid> data Test = TestCase Assertion
09:22:38 <delYsid>           | TestList [Test]
09:22:38 <delYsid>           | TestLabel String Test
09:22:53 <Igloo> You can write useless program in Haskell too, but I wouldn't recommend expending much time and effort doing so  :-)
09:23:05 <delYsid> lol
09:24:44 <pesco> Too bad there is an infinite number of useless programs.
09:25:15 <dark> id, id . id, id . id . id, ...
09:25:27 <pesco> Sounds useless to mee.
09:25:30 <Heffalump> hmm, and only a finite number of useful programs
09:25:42 <Heffalump> so it's all a waste of time, proportionately :-)
09:25:44 <pesco> Heffalump: Are you sure?
09:25:56 <Heffalump> yes, finite number of humans with a finite lifetime, and a finite life of the universe
09:26:43 <Igloo> Huh?
09:26:53 <pesco> Then, what you're saying is there is a finite number of useful programs that can be written. But the same holds for the useless programs.
09:28:16 <Heffalump> no, I meant there's a finite number of programs that can be useful
09:28:35 * Igloo finishes RL discussion and tries to think if I agree that there are a finite number of useful programs
09:28:39 <pesco> Oh.
09:28:48 <Heffalump> but a conversation with Igloo has led me to modify that to there is a potentially infinite number of useful programs, but we can only ever make use of a finite subset of them
09:29:05 <Igloo> I don't
09:29:22 <pesco> OK, with that I agree.
09:29:57 <Igloo> But I think you could write a single program that could do anything useful given  suitable input
09:30:14 <Igloo> Because you could reimplement the machine you run it on
09:31:51 <Heffalump> yes, that program is known as hugs
09:35:41 <dark> Hah, as long as "anything useful" does not include making coffee.
09:36:02 <Heffalump> you merely need suitable hardware
09:39:18 <Igloo> Making coffee isn't useful, anyway
09:41:47 <pesco> Cool, I've just received a mail of appreciation for my GHC Gentoo ebuild.
09:42:14 <Igloo> ebuild?
09:42:28 <pesco> The Gentoo Linux equivalent of BSD ports.
09:43:07 <Igloo> Why the name?
09:43:32 <pesco> No clue.
09:43:41 <pesco> electronic build.
09:43:42 <pesco>  :)
09:43:49 <redcrosse> yeah, i think that's it
09:44:09 <pesco> It's cool, as long as it's got electrons in it.
09:44:49 <dark> After all, where would we be without electrons?
09:45:36 <pesco> We'd all be programming positron machines of course!
10:39:47 <pesco> loom2: Moin!
10:39:52 <pesco> Heh, QuickCheck is cool.
10:40:16 <pesco> It says "Falsifiable!". I enjoy that.
10:42:58 <loom2> ho pesco!
10:43:25 <Heffalump> :-)
10:53:40 <delYsid> woo!
10:53:45 * delYsid just discovered quickCheck
10:54:02 <delYsid> This will be fun for Chess.hs
11:26:02 <delYsid> hmm, I wonder about haskell compiler optimisation.
11:26:26 <delYsid> If I have a data Something = A | B, is it theoretically possible that it gets optimized into one bit?
11:27:12 <delYsid> Or differently, say I have a tuple of Ints which usually only hold values from 1 to 16, isn't that a terrible waste of space?
11:48:44 <dark> delYsid: well, remember, most data will be represented as thunks until it's actually used, after which it's discarded :)
11:50:03 <delYsid> hmm, in some cases that's certainly true, but if we are talking about large lists or trees of data it is quite relevant I think...
11:59:36 <dark> delysid: I think ghc has "packed tuples"
11:59:46 <dark> delysid: But I don't know if that packs any deeper than the tuple itself.
12:00:37 <dark> delysid: I do think ghc tries to optimize away boxedness, but I suspect that it will fail with exactly the kind of long-term data structure you have in mind.
12:01:42 <dark> delysid: If space savings is important, then you could try representing your data as UArray.
12:01:50 <ibid> strict constructors ought to help
12:01:57 <dark> delysid: This will probably cost execution speed though.
12:02:42 <ibid> but not in that one bit case...
12:02:47 <dark> On the other hand, maybe not -- UArray are strict in all their elements, which makes accessing those elements a bit faster.
12:03:20 <dark> I don't know if anyone has done a BitArray for GHC :)
12:09:08 <dark> delysid: I think the size of the structures doesn't matter, what matters if how often they're accessed.
12:09:49 <dark> delysid: If a structure is only accessed once then it will be discarded right after so there's no point in packing it.
12:12:42 <ibid> assuming, of course, that it's not kept around - i don't know how good ghc is at eliminating dead root references
12:14:10 <delYsid> hmm, ok.
12:14:18 <delYsid> I guess I have to try it with realworld code first.
12:14:43 <ibid> yes - premature optimization and all that
12:14:54 <ibid> measure first, then optimize
12:17:11 <delYsid> yup, AFAIR yes.
12:17:19 <delYsid> oops, wrong window
