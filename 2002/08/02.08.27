01:59:29 * shapr boings
01:59:38 <shapr> hi delYsid
01:59:56 <andersca> shapr: you were right about that happy problem
02:00:03 <andersca> I used the wrong type for the error handler
02:00:20 <shapr> wow, I was right :-)
02:00:47 <shapr> hi andersca, how are you?
02:01:01 <andersca> I'm fine, thank you
02:01:26 <Heffalump> morning
02:01:28 <shapr> are you taking a class at chalmers?
02:01:40 <shapr> g'morning Heffalump, what's up?
02:01:43 <andersca> shapr: lots of classes :)
02:01:50 <shapr> nifty :)
02:02:06 <andersca> john hughes's a good lecturer
02:02:27 <shapr> I'd love to take classes that were taught by him.
02:02:50 <andersca> once he brought a phone catalog
02:02:57 <shapr> ?
02:03:01 <shapr> for what reason?
02:03:03 <andersca> when he was going to describe the divide and conquer algorithm
02:03:09 * shapr grins
02:03:09 <Heffalump> :-)
02:03:29 <Heffalump> he was my external examiner
02:05:58 * shapr is looking forward to the contest this weekend
02:17:24 <delYsid> grrrr, I cant even kibitz
02:17:50 <shapr> kibitz?
02:18:03 <delYsid> er, chess slang :)
02:18:09 <shapr> oh
02:19:33 <delYsid> I ment, I am occupied at the weekend
02:19:43 <delYsid> But I wanted to observe how such a contest goes ... :(
02:20:01 <shapr> oh, ok
02:20:15 <delYsid> but well, maybe, maybe, she'll undestand it :)
02:20:26 <delYsid> but highly unlikely
02:20:45 <shapr> :)
02:23:35 <delYsid> heh, you're lucky, your girl actually knows what a geek is :)
02:23:54 <delYsid> and she *accepts* it as part of you.
02:24:15 <shapr> that's true
02:28:27 <Igloo> Sounds like you need a new girl, del  :-)
02:35:53 <Igloo> Bah, hugs doesn't have a Directory library. That's a pain.
02:37:38 <Heffalump> a what library?
02:38:51 <Igloo> http://research.microsoft.com/Users/simonpj/haskell98-revised/haskell98-library-html/directory.html
02:39:25 * Igloo discovers it will find a file called Directory with no extension and creates dummy funtions and types in there
02:40:47 <Heffalump> ah
03:07:09 <jewel> shapr: morning
03:20:08 <delYsid> Igloo: If it were that simple... Love is strange sometimes
03:20:35 <Igloo> Ho hummm
03:23:56 * Heffalump notices that Chilli appeared
03:49:47 <shapr> g'mornin jewel
03:56:53 <jewel> alive and well?
04:17:35 <delYsid> shapr: pass that on to bea please (reliably :) ): http://www.eu-luxor.org
04:17:44 <delYsid> maybe her stuff is on time to be a part of that
05:53:36 <pesco> $ `:'   .g#S$$"$$S#n. s#S$$$ `"":::::::::::::::::
05:53:36 <pesco>  $$$$$$_,$$$S'rE.g#S$$$ $$$$$$ssn    $$$$$$ $$$$$$ $$$$$$"$$S#n.`:::::::::::::
05:53:36 <pesco>  $$$$$$`"$$SSn. $$$$$$$ $$$$$$ gg#S$ $$$$$$ gggggn $$$$$$ $$$$$$ ::::"````````
05:53:36 <pesco>  $$$$$$  $$$$$$ $$$$$$$ $$$$$$ $$$$$ $$$$$$ $$$$$$ $$$$$$ $$$$$$ ::: Greets To
05:53:36 <pesco>  $$$$$$  $$$$$$ $$$$$$$ $$$$$$ $$$$$ $$$$$$ $$$$$$ $$$$$$ $$$$$$ ::: Trench
05:53:36 <pesco>  $$$$$$ $$$$$$ $$$$$$$ $$$$$$ $$$$$ $$$$$$ $$$$$$ $$$$$$ $$$$$$ ::: Lifendel
05:53:45 <pesco> Now you know.
05:55:43 <shapr> pesco: what was that?
05:56:04 <shapr> pesco: obfuscated haskell?
05:56:20 <pesco> No, xterm accident.
05:56:30 <shapr> pretty nifty looking
05:57:26 <pesco> I guess it was part of the BitchX logo, accidently pasted by my pressing the middle mouse button.
06:37:04 * Heffalump waves
06:37:22 <ChilliX> Hi Heffalump :-)
06:37:32 * ChilliX waves back from the other side of the planet.
06:37:45 <jewel> This guy was at my university
06:37:46 <jewel> http://www.cse.ogi.edu/~diatchki/
06:37:48 <Heffalump> how's the jetlag? :-)
06:37:55 <jewel> and I see he's organising the icfp comp
06:38:19 <ChilliX> Heffalump: it's ok in the evenings, as this is when my body thinks I should be awake
06:38:29 <ChilliX> yesterday I slept half the day
06:38:35 <ChilliX> that helped, too ;-)
06:38:45 <Heffalump> :-)
06:39:53 <ChilliX> Any idea how the Generics School is going?
06:40:06 <Heffalump> nope, haven't been near it
06:41:21 <ChilliX> would have liked to go there
06:41:32 <ChilliX> also to see Ralf and Martin again
06:41:45 <Heffalump> yeah, me too, but I've got other stuff I should be doing too :-)
06:42:35 <ChilliX> yeah, that's *the* problem
06:52:29 <delYsid> How was the summer school?
06:53:05 <ChilliX> hmm, I can't talk about my lectures, but the rest was interesting
06:53:19 <ChilliX> also a good mix of students
06:53:44 <ChilliX> with different backgrounds and different motivations to come to the school
06:53:57 <Heffalump> it was good
06:54:07 <Heffalump> (as were ChilliX's lectures :-)
06:54:15 <Heffalump> almost all of the lectures were good
06:54:30 <ChilliX> but there knowledge of FP was also quite diverse, which made it quite hard to pitch the lectures at the right level (at least that's the feeling I had)
06:54:43 * ChilliX bows gracefully towards Heffalump.
06:56:11 <ChilliX> it's a pity, SPJ didn't give a lecture
06:56:19 <ChilliX> he is an extremely good speaker
07:11:41 <delYsid> hmm, I'd have loved to be there.
07:41:54 <shreya> Hey, can someone help me with one problem, I haven't done haskell for a while so my debugging skills has gone to 0 level
07:41:57 <shreya> mystery :: Int -> [[Int]]
07:41:59 <shreya> mystery n = take n (iterate f [0 .. n])
07:42:01 <shreya>             where f xs = tail xs ++ [head xs]
07:42:41 <Heffalump> what's the problem?
07:42:47 <shreya> Doesn't work :(
07:42:51 <shreya> I'll show you the errro
07:42:52 <Heffalump> what's it supposed to do?
07:43:08 <shreya> Wtf, it works now
07:43:10 <shreya> Very sorry
07:43:12 <shreya> lol
07:43:39 <Heffalump> :-)
07:43:44 <shreya> Main> mystery 5
07:43:45 <shreya> [[0,1,2,3,4,5],[1,2,3,4,5,0],[2,3,4,5,0,1],[3,4,5,0,1,2],[4,5,0,1,2,3]]
07:43:45 <shreya> Main> 
07:44:03 <shreya> eek, need to do (n + 1)
07:49:57 <Igloo> Has anyone got some nice code to deal with a variety of IO errors tidily?
08:16:36 <pesco> ChilliX: I'm reading your Fast Arrays paper. Could there be a typo in section 3.2 (page 7) in the following line of code?
08:17:13 <pesco> [:e1 | p <- e2, q:] = listArray bnds [e1 | p <- elems e2, q']
08:17:29 <pesco> What is q'?
08:17:39 <ChilliX> This is *very* informal
08:17:57 <ChilliX> q' means the similarily transformed version of q
08:18:46 <ChilliX> this is very informal (and imprecise) indeed 
08:19:00 <ChilliX> and should probably be changed for the final version
08:19:48 <pesco> Ah, ok.
08:20:51 <pesco> q depends on p. It doesn't depend on either of the e's, so why does it have to be transformed{
08:21:30 <pesco> Oh, sorry, of course it can depend on e2.
08:22:46 <ChilliX> on p to be precise
08:23:27 <pesco> Hm? But p isn't transformed.
08:24:17 <ChilliX> nothing would change in p
08:24:22 <ChilliX> but e2 might actually
08:24:29 <ChilliX> as I said, very imprecise...
08:24:41 <ChilliX> ok, I am going to sleep now
08:24:43 <pesco> OK, but I think I get the point.
08:24:47 <pesco> Good night.
08:24:54 <ChilliX> if you have suggestion on improving the paper, feel free to email me
08:25:06 <pesco> If successfull, I'll have more questions for you tomorrow. :)
08:25:20 <pesco> Alright, I'll be happy to.
08:25:25 <ChilliX> :-)
08:25:27 <ChilliX> 'night
08:55:37 --- topic: set to 'We put the Funk in Funktion || See logs @ http://tunes.org/~nef/logs/haskell/ || parr 0.2.3 released http://www.cse.unsw.edu.au/~chak/nepal/ || #haskell ICFP contest next weekend.' by pesco
09:56:54 --- topic: set to 'We put the Funk in Funktion || See logs @ http://tunes.org/~nef/logs/haskell/ || parr 0.2.3 released http://www.cse.unsw.edu.au/~chak/nepal/ || ICFP 2002 contest starts on Friday.' by shapr
09:58:04 <Heffalump> what time does it start?
09:59:05 <shapr> 12:00 Noon (PDT)
09:59:14 <shapr> Pacific Daylight Savings time, which is UTC - 7
10:00:04 <Heffalump> on /Friday/ ?
10:00:11 <Heffalump> hmm.
10:00:12 <shapr> that's what it says.
10:00:18 <Heffalump> so that's 8pm for me
10:01:01 <shapr> 9pm for me
10:01:11 <shapr> is there some kind of DateTime type for Haskell?
10:01:20 <eivuokko> 9 or 10? daylight savings?
10:01:23 * shapr is considering building a web calendar in Haskell
10:01:27 <shapr> eivuokko: good question
10:01:47 <eivuokko> afaict .fi is in +3 atm, but I am not sure.
10:02:35 <shapr> `date -u` is Tue Aug 27 17:01:29 UTC 2002
10:02:39 <jewel> hey shapr
10:02:47 <jewel> are we practicing tonight?
10:02:49 <shapr> compared to Tue Aug 27 20:01:44 EEST 2002
10:03:11 <shapr> jewel: I'm interested, how's your time schedule?
10:03:24 <shapr> eivuokko: so, yes, it looks like we're +3
10:03:28 <jewel> I'm free from now for a few hours
10:04:29 * shapr gives up on the web calendar
10:04:38 <jewel> are you available/
10:05:02 <shapr> yah, sure :-)
10:05:23 <shapr> for at least an hour, maybe more
10:06:54 <jewel> starting now?
10:07:37 <shapr> sure, let's go
10:07:57 <jewel> you wanna play more with yaml or start something fresh?
10:08:40 <shapr> I'm more interested in starting something fresh, but if you prefer yaml, we can continue with that.
10:08:54 <jewel> Any ideas?
10:09:37 <shapr> well, at this instant I'd like to have something like java.util.Calendar for Haskell
10:09:46 <shapr> that's just a random idea though
10:10:12 <shapr> I have no idea how difficult that would be to implement.
10:10:14 <jewel> providing what kind of functionality?
10:11:16 <shapr> I'm not sure.
10:11:42 <shapr> I've been thinking about how to make a web calendar for making appointments for one of my paying jobs.
10:12:02 <shapr> do you have any ideas?
10:12:10 <jewel> for clients or internally etc?
10:13:48 <shapr> the appt calendar is for clients
10:14:08 <shapr> I was just wondering if it would be easier in Haskell.
10:14:23 <jewel> what would you use to generate html/speak http?
10:14:41 <shapr> python 2.3 is adding a DateTime class to their standard libraries, I was wondering if Haskell already has one.
10:15:04 <shapr> for Haskell, I'd probably use the html generation in WASH
10:16:16 * jewel finds WASH
10:17:47 <jewel> Ah, I've seen this before
10:19:03 <jewel> is it CGI?
10:19:30 <shapr> there's WASH-CGI and WASP-HTML
10:19:43 <shapr> currently, WASH-CGI won't compile with ghc5.04
10:20:00 <shapr> I haven't figured out why, though I'm almost sure it's a compiler bug
10:20:26 <Heffalump> what happens?
10:20:29 <jewel> and with debian ghc?
10:20:34 <shapr> jewel: yah, ghc5.04
10:20:43 <shapr> Heffalump: it runs out of stack space, remember this discussion?
10:20:55 <shapr> it's specifically the CGIInternals.hs file
10:20:56 <Heffalump> oh, yes, sorry
10:21:16 <shapr> I ran it out of 300MB of stack space, I'm positive it's a ghc5.04 bug.
10:21:35 <shapr> it took 24minutes or so to run out of that much stack space
10:21:44 <shapr> jewel: on the other hand, the HTML generation library will probably work fine.
10:21:56 <jewel> static html?
10:22:23 <shapr> with bits of javascript
10:26:47 <jewel> Ok
10:26:55 <jewel> So you want to transform what into what?
10:26:59 <shapr> I'm having trouble getting WASP to compile...
10:27:58 <shapr> does it work for you?
10:29:16 <jewel> I haven't tried yet
10:29:19 <jewel> I was reading the docs
10:29:24 <jewel> I'll grab it ...
10:30:13 <shapr> ah, it did finish compiling.
10:31:42 <jewel> busy compiling now
10:31:53 <shapr> takes awhile
10:32:29 <jewel> looks very similar to the HaXml stuff we were looking at
10:33:21 <shapr> yah, I wonder what the differences are...
10:33:35 <shapr> imho, WASP is more intuitive
10:33:46 <jewel> finished
10:34:47 <shapr> I'm looking at Example.hs
10:35:13 <jewel> Helloworld.hs
10:35:24 <shapr> ?
10:35:29 <jewel> HelloWorld.hs
10:36:06 <jewel> mmm, did you download WASH-CGI.tgz?
10:36:47 <jewel> ah, you're busy with the other one
10:36:55 <jewel> which one did you get, the extended or base one?
10:37:26 <shapr> I have both of them, dunno what good the extend one with automaton checking is...
10:38:39 <jewel> It only has these 4 files? HTMLBase.hs
10:38:39 <jewel> HTMLTypedBase.hs
10:38:39 <jewel> HTMLPrelude.hs
10:38:39 <jewel> Version
10:39:20 <shapr> yup
10:39:54 <shapr> aha
10:40:06 <shapr> if you've opened Example.hs
10:40:17 <shapr> and then C-c C-l to run it in ghc
10:40:21 <jewel> Where is that?
10:40:48 <shapr> Example.hs is one of three files in the WASP-Examples.tgz
10:45:00 <jewel>  why is there so much stuff in the example?
10:45:10 <jewel> it looks like a library
10:45:19 <shapr> yah it does.
10:45:32 <shapr> but at least parts of it are really just example code
10:45:48 <shapr> like the functions, hlink, signature
10:46:17 <jewel> what is ##
10:46:25 <shapr> it concats two tags
10:47:13 <shapr> at least, I think that's what it does
10:48:51 <jewel> can you compile it?
10:49:07 <shapr> yup
10:49:24 <jewel> there's no main in the example
10:49:33 <shapr> oh, I'm using it in ghci
10:50:26 <shapr> I ended up doing ghc -c to each of the three library files, because they take so long to run interpreted
10:50:47 <shapr> if you hit C-c C-l in Example.hs, and it drops into ghci
10:50:54 <shapr> then you can type "show_html doc"
10:53:38 <jewel> <interactive>:1: Variable not in scope: `show_html'
10:54:18 <shapr> *Example> show_html doc
10:54:19 <shapr> "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http
10:54:23 <shapr> lots more stuff after that
10:55:07 <shapr> show_document appears to work the same way
10:55:13 <shapr> they're both from HTMLTypedBase.hs
10:55:32 <jewel> now it works
10:56:23 <jewel> How does it guarantee that it only produces well-formed HTML?
10:56:40 <shapr> the whole thing is type checked
10:56:49 <shapr> at least, that's what the documentation claims.
10:59:08 <jewel> What does the calendar look like?
10:59:45 <shapr> a table holding all of the days?
10:59:53 <shapr> like the one month pages of wall calendars
10:59:59 <shapr> sounds good to me at least :-)
11:00:08 <jewel> With the Sundays arranged on the left?
11:00:13 <shapr> sure
11:01:13 <jewel> So it's a table with 7 columns
11:01:24 <jewel> and a header with content for Sun,Mon,Tue etc
11:01:43 <shapr> right
11:02:48 <shapr> hm, what's wrong with this:
11:02:49 <shapr> show_html $ build_document ((head (title (text "title"))) ## (body (table (tr (td (text "foo"))))))
11:03:15 <jewel> dunno
11:03:46 <shapr> shall I create a new dir in our cvs tree?
11:03:53 <jewel> go for it
11:07:44 <shapr> wow
11:07:48 <shapr> ghc-5.04: fatal error: scavenge_stack: weird activation record found on stack: 0
11:07:54 <shapr> cool
11:08:29 <jewel> TBODY
11:08:39 <shapr> ohh
11:09:54 <jewel> </address\n><table><tbody><tr><td>george</td\n></tr\n></tbody\n></table\n></body\n></html\n>
11:10:01 <jewel> does such a tag exist?
11:10:22 <shapr> I'm not sure
11:11:23 <shapr> ok, I've checked in prototypes/protoWebPage.hs
11:11:29 <redcrosse> ie supports it
11:11:30 <shapr> and it works here
11:11:31 <redcrosse> tbody
11:12:01 <redcrosse> and there's a corresponding thead
11:12:20 <jewel> and in mozilla too
11:12:27 <shapr> interesting
11:15:56 <shapr> sometimes ghci craps out with that scavenge error
11:15:56 <shapr> very strange
11:16:04 <jewel> gc
11:16:16 <shapr> I should probably file a bug about it
11:18:49 <shapr> jewel: ok, so we can make tables
11:19:05 <jewel> well, let's make the column headings
11:19:09 <shapr> right
11:19:17 <shapr> isn't there something like theader?
11:19:21 <shapr> ttitle?
11:19:29 <shapr> I forget the actual tag name
11:20:13 <shapr> I'll check in protoTable.hs
11:21:14 <shapr> couldn't I use foldr1 (.) [many_tags] ?
11:21:36 <shapr> hi ChilliX
11:21:42 <ChilliX> Hi shapr
11:21:46 <shapr> what's up?
11:21:53 <jewel> yeah
11:22:00 <ChilliX> fscking jet lag...
11:22:04 <shapr> :)
11:22:16 <shapr> it is surprising to see you online this early.
11:22:35 <ChilliX> 4:20am here
11:22:40 <shapr> ouch
11:22:54 <ChilliX> I slept too much yesterday
11:23:02 <ChilliX> that's the price
11:23:03 <shapr> ChilliX: hey, do you know if Haskell has Calendar/DateTime/etc type/library?
11:23:53 <jewel> well, let's make the column headings
11:23:57 <shapr> ok
11:24:13 * shapr runs off to borrow an HTML book from his SO
11:24:57 <ChilliX> GHC has http://haskell.org/ghc/docs/latest/html/base/System.Time.html
11:25:13 <jewel> where does hOpenFile come from?
11:25:38 <ChilliX> hOpenFile?  or do you mean openFile (comes from IO)
11:26:41 <jewel> er  openFile ...
11:28:40 <jewel> what's wrong with this?
11:28:41 <jewel> myfile <- openFile "afile.html" WriteMode
11:28:41 <jewel>        hPutStr myfile mydoc
11:29:02 * shapr dunno
11:29:04 * shapr tries
11:29:16 <jewel> main = do
11:29:16 <jewel>        mydoc <- show_html $ build_document ((head (title (text "title"))) ## (body (table (thead (tr (t\
11:29:16 <jewel> d (text "Col"))) ## (tbody (tr (td (text "foo"))))))))
11:29:16 <jewel>        myfile <- openFile "afile.html" WriteMode
11:29:16 <jewel>        hPutStr myfile mydoc
11:30:29 <ChilliX> what happens?
11:32:18 <jewel>  Couldn't match `[]' against `IO'
11:32:21 <jewel>         Expected type: [t]
11:32:21 <jewel>         Inferred type: IO Handle
11:32:21 <jewel>     In the application `openFile "afile.html" WriteMode'
11:33:24 <shapr> it works here
11:33:35 <shapr> *Main> myfile <- openFile "foo.txt" WriteMode
11:33:35 <shapr> *Main> :t myfile
11:33:35 <shapr> Handle
11:33:52 <jewel> commit your code
11:36:07 <shapr> ok
11:36:20 <ChilliX> looks good to me...
11:36:42 <jewel> how do you do that at the prompt?
11:36:47 <jewel> how do you import IO first?
11:37:07 <shapr> I wrote "import IO" into a file and then hit C-c C-l
11:37:24 <shapr> I think you can use :a IO
11:37:29 <shapr> but I haven't tried that
11:39:30 <ChilliX> use :m IO
11:40:40 <shapr> bah, type error with: doc_body = foldr1 (.) [body,table,tbody,tr,td,text "foo"]
11:41:07 <jewel> slow, but it works
11:51:00 <shapr> this isn't working:
11:51:01 <shapr> doc_body = body . table . tbody . tr $ foldr1 (td . text) weekDays
11:51:16 <shapr> I would expect that to work.
11:51:36 <jewel> hmm
11:52:17 <shapr> jewel: I checked it in
11:52:35 <jewel> thanks
11:53:40 <shapr> oh, I think I figured it out... needs ##
11:55:44 <jewel> doc_body = (body . table . tbody . tr . td . text) "foo"
11:55:47 <jewel> that compiles
11:56:31 <shapr> I think that you'll need to put ## between two td tags
11:56:45 <jewel> yeah
11:57:07 <shapr> body . table . tbody . tr $ foldr1 ( ## ) $ map (td . text) weekDays
11:57:09 <shapr> that doesn't work though
12:02:06 <shapr> looks like map needs an instance of something to be able to run a function across it
12:03:18 <jewel> those are partial applications
12:03:28 <jewel> so you can just map straight onto weekdays
12:03:42 <jewel> can't
12:03:59 <shapr> I don't understand
12:05:32 <jewel> urm
12:05:40 <shapr> what are partial applications?
12:05:51 <shapr> the td/text/tr guys?
12:06:04 <jewel> hmm, maybe they aren't
12:06:12 <jewel> the xml stuff was though
12:06:38 <shapr> WASP looks easy at first...
12:06:59 <jewel> yeah, all these things take two arguments
12:07:06 <jewel> but we only give them  1
12:07:13 <jewel> so they are partial applications
12:08:44 <jewel> text isn't one of those
12:09:00 <jewel> it only takes 1 argument
12:09:40 <shapr> looks like it takes two
12:09:49 <shapr> text :: forall a. (AddTo a CDATA) => String -> ELT a -> ELT a
12:10:10 <jewel> where's that?
12:10:15 <shapr> :i text
12:10:29 <jewel> in the library stuff?
12:10:54 <shapr> I have all three of the WASP modules loaded
12:11:25 <shapr> it looks like map text ["f","g"] works
12:11:34 <jewel> text str = add' (ELT (cdata_ [] str) :: ELT CDATA)
12:11:41 <jewel> in HTMLTypedBase
12:11:48 <jewel> is the only place I see text being defined
12:12:19 <jewel> which may expand to what you have
12:14:58 <shapr> um, how do I do import as?
12:15:06 <jewel> Isn't the thing which text returns of type "ELT a -> ELT a" ?
12:15:06 <shapr> I need to import Prelude.map as something else
12:15:10 <shapr> yup
12:15:21 <shapr> map td (map text weekDays) should work
12:15:36 <shapr> but, there's an html map that shadows Prelude.map
12:18:31 <shapr> aha
12:18:40 <shapr> er, no
12:19:48 <shapr> ah
12:20:01 <shapr> import Prelude hiding (map, span, div, head)
12:20:02 <shapr> import qualified Prelude
12:20:08 <shapr> then I can still get to Prelude.map
12:23:32 * shapr blinks
12:23:40 * jewel compiles
12:23:42 <shapr> it looks like it works interactively, but won't compile
12:29:03 <shapr> jewel: is anything working for you?
12:29:20 <jewel> trying to piece together a sequence  of calls
12:29:25 <jewel> not compiling for me yet
12:29:51 <shapr> map td (map text weekDays) works for me interactively
12:29:55 <shapr> but won't compile
12:33:06 <jewel> this compiles:
12:33:08 <jewel> piece1 = foldr1 ( ## ) [td (text "mon")]
12:33:09 <jewel> doc_body = body ( table ( tbody ( tr ( piece1 ))))
12:34:19 <jewel> and therefore this:
12:34:20 <jewel> piece1 = foldr1 ( ## ) [td (text "mon"), td (text "tue")]
12:34:20 <jewel> doc_body = body ( table ( tbody ( tr ( piece1 ))))
12:34:38 <shapr> so, we have to explicitly apply td and text
12:34:44 <shapr> they won't map for whatever reason
12:35:26 <jewel> using Prelude.map?
12:35:39 <shapr> yup
12:35:44 <shapr> still won't map
12:37:00 <jewel> and this:
12:37:02 <jewel> piece1 = foldr1 ( ## ) [td (text "mon"), td (text "tue")]
12:37:03 <jewel> doc_body = (body . table . tbody . tr) ( piece1 )
12:37:03 <jewel> works
12:39:04 <shapr> fails for me...
12:39:11 <shapr> do you have a type sig on doc_body?
12:39:21 <jewel> no
12:39:31 <jewel> what are your imports?
12:39:34 <shapr> aha
12:39:40 <shapr> works with type sig from Example.hs
12:40:14 <shapr> weird
12:41:09 <shapr> yay :-)
12:41:11 <jewel> how did you alias map?
12:41:12 <shapr> we have headers
12:41:19 <shapr> import Prelude hiding (map, span, div, head)
12:41:19 <shapr> import qualified Prelude
12:41:22 <shapr> pmap = Prelude.map -- html has "map" also
12:42:36 <jewel> is that one line?
12:42:42 <shapr> is what?
12:42:49 <jewel> import qualified Prelude
12:42:50 <jewel> <shapr> pmap = Prelude.map -- html has "map" also
12:42:51 <shapr> I'll check in WebCalendar.hs
12:43:47 <shapr> checked in
12:44:26 <shapr> does that help?
12:44:30 <jewel> thanks
12:45:01 <shapr> I think I might be able to use map if I understood what's up with these type signatures.
12:45:17 <jewel> whoah, that worked
12:45:21 <shapr> what??
12:45:24 <jewel> wdays = ["mon", "tue","wed"]
12:45:25 <jewel> piece1 = foldr1 ( ## ) (pmap (td . text) wdays)
12:45:25 <jewel> doc_body = (body . table . tbody . tr) ( piece1 )
12:45:35 <shapr> ?!?
12:45:48 <shapr> oh, I think I understand the type sigs!
12:46:06 <shapr> how did you get the pmap to work?
12:46:11 <jewel> ><body><table><tbody><tr><td>mon</td
12:46:12 <jewel> ><td>tue</td
12:46:12 <jewel> ><td>wed</td
12:46:23 <shapr> amazing
12:46:24 <jewel> I'll check in
12:46:28 <shapr> cool :-)
12:46:52 <jewel> in protoTable.hs
12:47:02 <shapr> right
12:47:41 <jewel> we're making high speed progress ! :-P
12:47:51 <shapr> heh
12:47:56 <shapr> I'm amazed you got that to work...
12:48:53 <jewel> just did it by making small modifications
12:49:04 <jewel> unfortunately ghci takes ages to reload the file
12:49:10 <jewel> I might try just ghc instead
12:49:27 <shapr> have you use ghci -c on the HTML*.hs files?
12:49:33 <shapr> that way you get .o files that load much faster
12:49:40 <jewel> Yeah I did
12:49:44 <jewel> But I'm suspicious
12:49:49 <shapr> ?
12:50:05 <shapr> it's still slow on my really fast machine
12:50:20 <jewel> It's much slower than the Haxml stuff I was compiling
12:50:25 <shapr> yah, same here
12:51:52 <jewel> doesn't compile much faster
12:53:57 <shapr> that works in WebCalendar.hs
12:54:00 <shapr> no idea why
12:54:59 <shapr> checked in WebCal
12:59:06 <jewel> ok, let me add the numbers
12:59:17 <shapr> [ (x,y) | x <- wdays , y <- [8.5,9 .. 17]]
12:59:27 <shapr> that wasn't quite what I was trying to do, but it is cute :-)
13:00:46 <jewel> hehe
13:02:25 <jewel> mm, it can't find the main
13:02:30 <jewel> what compile line do you use?
13:02:31 <shapr> ?
13:02:36 <shapr> hi ski, ltns
13:02:48 <ski> hi shapr
13:02:51 <shapr> for what? WebCalendar.hs ?
13:02:53 <ski> (ltns ?)
13:03:02 <shapr> ski: long time no see
13:03:07 <ski> aha.
13:03:13 <Heffalump> hi ski
13:03:18 <jewel> yes
13:03:22 <ski> Hi Heffalump
13:03:45 <shapr> jewel: I didn't have one, create one?
13:03:58 <ski> hopefully i can irc a bit more often now when courses begin
13:04:03 <shapr> yay, skirc
13:04:38 <ski> :-)
13:05:06 <jewel> ok committed
13:06:02 <jewel> now how do we know when the first sunday is in a month?
13:07:12 <shapr> good question
13:07:29 <ski> Isn't there formulas for computing such things ?
13:07:31 <redcrosse> http://www.smart.net/~mmontes/ushols.html#ALG
13:08:16 <jewel> redcrosse: you around next weekend?
13:08:29 <redcrosse> for parts
13:09:53 <redcrosse> this is a good resource for dates too: http://www.pauahtun.org/CalendarFAQ/cal/calendar24.html
13:11:10 <shapr> I think I found one
13:11:42 <jewel> Er, how do we know what month we are displaying?
13:11:51 <shapr> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/nofib/spectral/calendar/
13:12:39 <jewel> age 6 years?
13:14:23 <shapr> jewel: seems to work
13:14:30 <jewel> it never ceases to amaze me how short haskell programs can be
13:15:36 <shapr> it even includes building rows and columns
13:15:41 <shapr> dunno how hard to port that to html
13:16:33 <shapr> there are several nifty programs in the spectral directory there
13:17:57 <shapr> jewel: shall I stash it into our CVS tree and we can hack on it?
13:18:06 <jewel> atoi s    = foldl (\a d -> 10*a+d) 0 (map toDigit s) 
13:18:07 <jewel> !
13:18:14 <jewel> yeah ok
13:18:30 * shapr tries to read that line
13:20:51 <shapr> that line still looks like asm to me
13:20:57 <jewel> haha
13:21:01 <shapr> checked in
13:21:03 <jewel> it's quite simple actually
13:23:12 <Heffalump> jewel: isn't that roughly what instance Read Int does?
13:23:49 <jewel> I don't know, can imagine it's similar
13:23:52 <shapr> what's wrong with this: fail (userError "Usage: cal year\n")
13:25:24 <jewel> userError?
13:25:38 <shapr> strange stuff
13:25:58 <ski> brb
13:26:11 <shapr> weird thing is that it compiles fine
13:26:50 <Heffalump> doesn't fail take a string?
13:27:40 <shapr> time for me to watch TV with my woman
13:27:51 * shapr bails out to return lateron
15:49:02 <dark> Hi!  I'd like to say that I'm very impressed by the Foreign Function Interface.  I've never thought that hooking up to a C library could be so easy.  Particularly one as finicky as ncurses :)
15:49:45 <dark> The only thing that bothers me is that hsc2hs won't work when cross-compiling.
15:51:56 <Igloo> There are unfortunately fundamental problems when trying to use the FFI, that needs something concrete, with curses, which is an abstract specification
15:52:06 <Igloo> hsc2hs helps to an extent but I don't think it is perfect
15:52:46 <dark> Igloo: You mean things like curses not specifying the type of chtype?
15:54:32 <dark> Igloo: Yes, I think the only way to make it work with cross-compiling is to preprocess and parse the header file yourself, and deal with potentially hairy C expressions in it.  That gets ugly.  Perl tries to work around that problem with a header-scanner utility that picks up simple constants, but I think it'll fail miserably on curses.h
15:54:37 <Igloo> Yeah
15:55:43 <Igloo> I'd have thought you could handle cross compilation reasonably easily by giving additional flags to hsc2hs
15:55:53 <dark> Igloo: Actually, another way around it, potentially much simpler, would be to write a little C file that provides wrapper functions for accessing the problematic constants and types.  That has a speed cost, but I think it'll stay simple that way.
15:56:49 <dark> Igloo: No, hsc2hs actually generates a C program that outputs the .hs file when it runs.  When cross-compiling, the generated C file would either not work (wrong architecture), or work unreliably (wrong platform's header file)
15:57:06 <Igloo> I'm not sure if the standard would allow, say, 128bit integers. If so you are screwed
15:57:52 <dark> Ooh, hadn't thought of that.  Yeah then there would need to be a Word128 type.  Not necessarily a problem, though.  It needn't be implemented as a primitive Word128# type, it could be based on Integer.
15:58:36 <dark> Anyway... 128bit integers aren't currently part of the C calling standard of any platform I know of :)  And once such a platform exists and GHC is ported to it, I expect it to acquire Int128 and Word128 types too.
15:58:37 <Igloo> Oh, true, I was thinking of just cpping headers with different defines in a program for this architecture, but that wouldn't necessarily be general enough
15:59:12 <Igloo> Yes, but what type do you use in your wrappers? If you use Word64 and someone comes along with an implementation that uses 128bit integers then you have a problem
16:00:07 <dark> Igloo: Oh, I see.  You mean when writing a little .c file to cope with ncurses strangeness?
16:01:04 <dark> IIRC there was some support for a .c file returning an Integer.  Of course that's an even bigger speed cost :)
16:01:14 <Igloo> curses, yes. I meant the wrapper program you mentioned above
16:01:25 <Igloo> Hmmm  :-)
16:01:54 <dark> Hmm I wonder how the FFI currently deals with cross-compiling.  It would have to know that it should use the calling convention of a non-native architecture.  Is FFI implemented entirely by generating C code, or does it do magic?  (if -fvia-C)
16:02:31 <Heffalump> DYM GHC FFI, or in general?
16:02:37 <Heffalump> (since the latter is unlikely to be specified)
16:02:49 <dark> Heffalump: GHC FFI is the only one I have experience with :)
16:03:12 <dark> Yeah, I read the general FFI document, and it seems to assume that "C calling convention" is a well-defined notion.
16:04:37 <dark> The way GHC works, I guess it can implement FFI directly as C function calls, so there isn't any problem with cross-compiling there.
16:05:13 <dark> On the other hand... I never tried using ghc as a cross-compiler :)  It might get into trouble when it tries to reserve %eax on a sparc.
16:05:46 * dark hunts for the "cross-compiling with GHC" document.
16:08:38 <dark> Igloo: By the way, it was more than just speculation that simply parsing constant #defines from curses.h would be enough :)  It has definitions like: #define ACS_ULCORNER    (acs_map['l'])
16:09:48 <Igloo> Yeah, I had a discussion with the ncurses maintainer about whether that fulfilled the standard (which requires it to be a "constant")
16:11:51 <dark> Igloo: Hmm... I just checked, and the ncurses manpage calls them "variables" :)
16:13:01 <Igloo> He said the standard was failing to document existing practise and that the other major implementation (the SGI one possibly) did the same thing
16:15:13 <dark> Hmm, if I can rely on them being variables instead of constants, then I could access them with "&" imports.
16:15:35 <dark> ...maybe.
16:19:44 <dark> Hmm I wonder if Unicode has these ACS_ characters somewhere.
16:24:09 * dark bravely ignores the possibility that noecho() might return ERR.
16:32:38 <dark> Is there any way to avoid the warning about an unused data constructor when I define an opaque Ptr type?
16:32:45 <dark> data WINDOW = Window
16:32:45 <dark> type WINDOWptr = Ptr WINDOW
16:33:05 <dark> Curses.hsc:11: Warning: Defined but not used: Window
16:33:52 <dark> It doesn't matter what type Ptr is applied to here, as long as it's unique... but I don't know how to define a unique type without defining a constructor for it :)
16:35:17 <Igloo> I couldn't think of one and neither could the list
16:35:36 <ski> one can define a type without any constructor like : data WINDOW  but i'm not sure if this will work/is what you intend in this case
16:35:37 <Igloo> I think hugs and GHC allowed data WINDOW, but nhc doesn't
16:35:55 <ski> not sure if it's haskell98 , though
16:39:13 <Igloo> It's not; otherwise nhc not supporting it would just be a bug  :-)
16:42:15 <ski> i suppose so .. :(
16:43:44 <dark> I'd rather not turn on -fglasgow-exts just to avoid a warning :)
16:44:08 <ski> can understand that.
16:47:20 <Igloo> I doubt you'd need to do so
16:48:09 <dark> Well I don't want to turn off the whole class of warnings either.
16:48:49 <dark> I'm trying to pretend it's used, but GHC is too smart :)
16:51:36 <Igloo> I mean you could probably use data WINDOW without -fglasgow-exts. But you'd have to live with the guilt of doing so, too
16:52:11 <Heffalump> lol
16:52:31 <ski> heh
16:58:11 <dark> Igloo: No, I tried that and it complained :)
16:58:31 <dark> An actual error.
16:58:55 <dark> Interesting, there's an OPTIONS pragma that's not listed in the users guide.
16:59:24 <dark> Or rather, it is, but hidden in the wrong section.
16:59:46 <Igloo> Ah, OK
17:00:38 <dark> It says it "prepends" the options to the command line, though.  That means the -Wall on the command line overrides the -Wno-warn-unused-binds :(
17:05:22 <dark> Oddly, it does work :)  I had to put the OPTIONS pragma all the way at the top of the file, though, even before any comments.
17:05:52 <dark> And it's -fno-warn-unused-binds, duh.
17:05:58 <dark> I'm too used to gcc flags :)
17:06:30 <Igloo> Ah, cool
17:21:04 * dark hugs throwIfNull.
17:33:23 <dark> Hmm... hsc2hs inserts a -#include "curses.h" in Curses.hs, but Main.hs inlines a function from it, and then I get a warning when compiling Main.hc.
17:35:56 <dark> Looks like I can fix it by giving '-#include "curses.h"' as a global option... but that scares me :)  There's so much junk in that header file.
19:30:23 <ski> hello, Chilli
19:32:04 <Chilli> Hi ski
19:33:50 <ski> not much talk here, right now, it seems ..
19:34:47 <Chilli> seldom is at this time, I think
19:34:58 <ski> I probably should go to bed now (it's 4 o'clock in the night here, local time), but i'm downloading a file
19:35:06 <ski> yes
19:35:09 <Chilli> Pretty late already in EU
19:35:30 <ski> i'm in sweden. you are in ?
19:35:48 <Chilli> Australia, Sydney to be precise
19:35:54 <ski> ok
19:36:00 <Chilli> it's 12:30 here
19:36:25 <ski> are you often here ?
19:36:36 <Chilli> since a couple of weeks, yes
19:36:44 <Chilli> how about you?
19:37:24 <ski> i haven't been here much during the summer, but hopefully i'll spend more time here in the coming autumn
19:38:24 <ski> so, are you relatively new to haskell and/or functional programming ?
19:38:38 <Chilli> not really
19:38:54 <ski> ah,ok
19:38:58 <Chilli> I guess, I am kind of a hardcore Haskell hacker ;-)
19:39:10 <Chilli> and you?
19:39:10 <ski> nice :-)
19:39:38 <ski> well, haskell's my favourite Functional Programming Language :)
19:40:15 <ski> i think i have grasped most language concepts ..
19:40:30 <Chilli> how did you learn it? self study?
19:41:06 <ski> well, i learned it from university, and fell in love almost directly :-)
19:41:16 <ski> when taking a prog. course
19:41:59 <ski> i read "Haskell The craft of Functional programming" from cover to cover in a few weeks :)
19:42:16 <Chilli> :-)
19:42:55 <Chilli> are you studying computer science?
19:43:41 <ski> yes, more or less. i started studying math, but now i'm mostly reading CS courses.
19:44:07 <Chilli> ic
19:45:39 <ski> i also spend much time on the net reading usenet programming groups and various papers about type systems,partial evalution,continuations,etc ..
19:46:16 <ski> though i can't say i understand all things in the papers, some are quite technical
19:46:48 <Chilli> yeah, research papers can be quite dense
19:47:13 <Chilli> but things usually get clearer after you are through a few in a field
19:48:24 <ski> but the various discussed things are so exciting so i can't stop reading and learning more by osmosis :)
19:48:37 <ski> haroldh: hi
19:49:15 <haroldh> hi
19:51:58 <ski> Chilli : right now, i'm playing with a toy implementation of a logic prog. lang. with implication , universal,existensial quantification 
19:53:05 <ski> somewhat inspired by LambdaProlog, if you know about that
19:53:22 <Chilli> yeah, I know lambdaProlog
19:53:37 <Chilli> so, you have higher-order pattern unification?
19:54:33 <ski> no,no, i haven't implemented such yet (if i indeed will)
19:55:17 <ski> the idea that set it off was : the types of FP program correspond to theorems in logic, ok
19:55:54 <ski> and the FP program code (implementation) correspond to proofs in logic
19:56:12 <Chilli> yes, curry howard isomorphism
19:56:26 <ski> (this is called the Curry-Howard isomorphism, do you know about it ?)
19:56:29 <ski> yes
19:57:35 <Chilli> so, how does that tie in with your implementation?
19:57:51 <ski> well, i thought, LP (logic prog.) programs is formulas (theorems) and their execution is (automatic) derivation of a proof for asked questions (formulas)
19:58:43 <ski> so, what happens if we record the proof constructed when executing LP prog ? what FP prog will it produce ?
19:59:04 <ski> that was the idea i was interested in.
19:59:15 <ski> you understand ?
20:01:06 <Chilli> the interesting part about the exec of the logic programming is cut elimination
20:01:21 <Chilli> cut elimination (by curry howard iso) corresponds to reduction in functional programs
20:01:24 <ski> so  (p0 :: a) , (p1 :: b :- a) |- ? :: b   what is ?
20:01:27 <ski> hmm ?
20:01:51 <ski> is cut elimination == resolution ?
20:01:55 <Chilli> sorry, I have to dash of to a meeting now
20:02:01 <ski> ok
20:02:02 <Chilli> but I'll come into IRC again from my laptop
20:02:21 <ski> i will propably disconnect soon
20:02:38 <ski> but we'll probably meet later ..
20:02:46 <ski> bye
20:03:10 <ski> (or did you mean irc from the meeting ?)
20:05:29 <ChilliX> re
20:05:39 <ski> that same you ?
20:05:52 <ChilliX> yep :-)
20:05:55 <ChilliX> from my laptop
20:06:14 <ski> ok
20:06:40 <ski> well, imagine a *very* simple LP prog :
20:06:47 <ski> p0 :: a.
20:06:50 <ChilliX> cut elim is basically modus podens as a inference rule
20:06:58 <ski> p1 :: b :- a.
20:07:12 <ski> is cut elim == resolution ?
20:08:19 <ChilliX> resolution implements cut elimination for predicate logic
20:08:30 <ski> well, the pX :: is my way of giving a name to the premise in the LP prog, if not given my system will automatically generate a name
20:08:39 <ski> ah,ok
20:09:08 <ski> so imagine a question ?- b.
20:09:39 <ski> this will both (if it succeeds) give a subst set and a proof
20:10:02 <ski> subst set is empty in this case
20:10:26 <ski> proof is (i think) = app(p1,p0)
20:11:46 <ski> if we ask ?- c => c. the proof is lambda(X :: c,X)
20:12:44 <ski> if we ask ?- c => c => c. there are two proofs : lambda(X::c,lambda(Y::c,X)) and lambda(X::c,lambda(Y::c,Y))
20:13:12 <ski> (where => is implication as in LambdaProlog)
20:13:22 <ChilliX> you can usually canonicalise this
20:13:23 <ski> you see ?
20:13:37 <ski> what do you mean ?
20:14:32 <ski> so in these simple cases the LP eninge finds FP programs given an FP type
20:15:08 <ski> (though, i don't think my engine is complete or any such thing, at least not for more complex things)
20:17:11 <ChilliX> there is a paper about the idea of Uniform Proofs
20:17:27 <ChilliX> (the lambdaProlog guys are coauthors of that)
20:17:46 <ski> but what happens in more complicated cases where the predicates (corresponding. to types) are parameterized by data objects (i.e dependent types ??) ?
20:17:51 <ChilliX> it describes how there is a canonical derivation for logic programs
20:18:07 <ChilliX> yes, for concrete data, you get dependent types
20:18:43 <ski> i supposed so (but what if we model the data at the type level, is that possible ?)
20:19:48 <ski> so, briefly, what constitutes a canonical proof ? does it correspond to a normal-form lambda-term ?
20:20:29 <ChilliX> the idea with uniform proofs is basically the following
20:21:13 <ChilliX> often for one formula, there is more than one way to do a proof inference where all these different proofs are in fact equivalent
20:22:02 <ski> you mean like \x.x and \x.(fst x,snd x)  "eta-expanding" ?
20:22:28 <ChilliX> uniform proofs is a theory that demonstrates how to restructure your inference system, so that you pick one of these equivalent proofs as a representative for the whole set
20:22:43 <ski> ok
20:22:55 <ChilliX> the paper actually argues
20:23:09 <ChilliX> that the process of making a logic into a logic programming languages
20:23:41 <ChilliX> is, in essence, a matter of finding a sequent style inference system for the logic that fulfills the criteria for uniform proofs
20:24:05 <ChilliX> it's a good paper, which goes to the essence of what logic programming is (IMHO)
20:25:24 <ski> i don't recall what sequent style inference system is now (though, i recalling reading something about it)
20:26:31 <ski> could you enlighten me ?
20:28:12 <ski> (though, ITYM \x.\y.x and \x.\y.y isn't equivalent proofs)
20:30:32 <ChilliX> check out http://www-theory.dcs.st-and.ac.uk/~rd/logic/mac/docs/sec4.3.html
20:30:44 <ChilliX> for desc of what the sequent style proofgs are
20:30:55 <ski> (my system generates the fully "eta-expanded" version of proofs, because it first divides the goal to be solved into atomic goals and then try to derive that goal from the premises)
20:33:37 <ski> hm
20:35:58 <ski> the paper i think i saw the words "sequent style" used (IIRC) a form with an optional formula to the right of the => (equivalent to _|_ on the right of => IIRC)
20:36:34 <ski> IIRC, the proofs constructed seemed to jump about (continuation jump)
20:36:36 <ChilliX> sequent calculus is just a form of presenting proofs
20:36:42 <ChilliX> introduced by Gentzen
20:37:17 <ski> ok,never mind right now, then
20:37:34 <ski> tnx for the link, btw
20:38:31 <ski> the implementation is a "quick and dirty" one in prolog (for built-in non-determinism (backtracking))
20:39:46 <ski> and I *know* that the handling of universal quantification goals is worng, i don't check that the new constant doesn't escape :(
20:40:09 <ChilliX> oops
20:41:06 <ski> well, i have implemented object variables by meta-variables (hmmmmm), so i'm not sure if i can check that with that kind of implementation
20:42:06 <ski> and Prolog doesn't have "bound variables in data-structures" like LambdaProlog or ML\ (MLLambda, in a paper) :(
20:43:47 <ski> so i probably will have to switch to a "object-variables as constants (atoms/string/etc)" or code it in LambdaProlog or ML\ (if there ever was any implementation (?))
20:44:05 <ChilliX> yeah, but will make your interpreter more complicated
20:44:18 <ski> yeah :(
20:44:48 <ski> this one implementation suffice (i think) if i don't use goal universals
20:45:34 <ski> i just added them because LambdaProlog has them and i already added implication goals (easy) and for better symmetry
20:46:47 <ski> i miss local predicates also ! i have to pass around arguments that are never or almost never changed just because of that
20:47:07 <ski> i'm used from haskell to make local function with non-locla variables
20:47:59 <ski> but i'm not sure if there is some problem/trap with having local predicates (at least with non-local variables, i.e. closures)
20:49:29 <ski> in LambdaProlog one can (i think) (dynamically scoped) add clauses to a module-level defined predicate from inside a predicate and capturing non-local variables
20:51:10 <ski> but the syntax is not very good for this and the predicate is not really local (unknown outside) and is only usable in the dynamic scope of the implication that introduced it (i.e. no real closure)
20:51:33 <ski> perhaps enough whining for now, :)
20:52:05 <ChilliX> I am off for lunch now
20:52:08 <ChilliX> cu
20:52:12 <ski> ok
21:02:18 <Pseudonym> ski: You probably don't want to know this, but I have almost finished a monad transformer with Prolog pruning.
21:02:32 <Pseudonym> Cut, soft cut, commit and so on.
21:03:09 <Pseudonym> Given that pruning is basically a performance hack in Prolog, I'm not sure why I bothered. :-)
21:04:01 <Pseudonym> (Except for soft cut in logical if-then-else, of course.)
21:22:07 <ski> aha !
21:22:22 <eivuokko> Whoa!
21:22:29 <ski> why would i probably not wan't to know that ?
21:22:42 <ski> (responding to Pseudonym)
21:28:56 <Pseudonym> It reflects badly on me. :-)
21:29:12 <ski> bye
21:29:16 <Pseudonym> I don't think that encouraging Prolog programming style in Haskell is necessarily a good thing.
21:29:19 <Pseudonym> Bye.
21:29:20 <ski> or brb
23:02:36 <ski|away> Pseudonym: no, but it could be interesting in it's own right. and IIRC some parser combinator libs effectively implement a 'once' feature
23:27:06 <Pseudonym> Oh, I'm going to submit it to the MTL, as it's MTL-compliant.
23:27:21 <Pseudonym> Though it tickles a bug in ghci/
23:32:50 <Heffalump> Pseudonym: the monad transformer adds list-of-successes to the existing monad?
23:34:38 <Pseudonym> Not quite.
23:34:51 <Pseudonym> I don't use lists except when explicitly getting all solutions.
23:35:04 <Heffalump> ok, but the equivalent thereof?
23:35:11 <Pseudonym> The list-as-nondeterminism idea doesn't work if you want a monad transformer.
23:35:29 <Heffalump> it doesn't?
23:35:47 <Pseudonym> class (MonadPlus m) => MonadNondet m where
23:35:48 <Pseudonym>     solutions :: m a -> m [a]
23:35:52 <Heffalump> oh, I've stacked a state monad on top of a list monad, not the other way around
23:35:54 <Pseudonym> That's what you meant?
23:36:16 <Heffalump> I think so, though I only just got up so my brain isn't quite sure :-)
23:37:12 <Pseudonym> The other interesting typeclasses are:
23:37:18 <Pseudonym> class (MonadNondet m) => MonadCommit m where
23:37:19 <Pseudonym>     commit :: m a -> m a
23:37:21 <Pseudonym> and:
23:37:39 <Pseudonym> class (MonadCommit m) => MonadCut m where
23:37:39 <Pseudonym>     choicepoint :: m a -> m a
23:37:39 <Pseudonym>     cut :: m ()
23:37:40 <Pseudonym>     softcut :: m a -> (a -> m b) -> m b -> m b
23:38:04 <Pseudonym> I should probably stick in some negation-as-failure stuff, too.
23:38:11 <Pseudonym> Like logical not.
23:41:06 <Heffalump> hangon, how are those monad transformers?
23:41:32 <Heffalump> or you mean you have monad transformers that obey those classes?
23:46:23 <Pseudonym> Yes.
23:46:36 <Pseudonym> I have transformer and non-transformer versions.
23:47:06 <Pseudonym> The non-transformer version of MonadNondet could easily be a list, for example.
23:50:24 * Heffalump gradually wakes himself up
23:50:55 <Heffalump> I don't think I've ever heard of soft cuts, and what does choicepoint do?
23:55:13 <Pseudonym> Choicepoint makes a place for cut to cut to.
23:55:19 <Pseudonym> Soft cut is kinda subtle.
23:55:22 <Pseudonym> Do you know Prolog?
23:56:49 <Heffalump> yeah, but not brilliantly
23:57:30 <Heffalump> shouldn't the type of choicepoint actually indicate that a choice is being made?
23:58:01 * Heffalump googles for soft cut and gets the idea
23:58:09 <Pseudonym> OK, first soft cut.
23:58:22 <Pseudonym> Soft cut in this case is logical if-then-else.
23:58:53 <Heffalump> yeah, so it just prunes either the then or the else branch
23:59:07 <Pseudonym> Right.
23:59:08 <Heffalump> I think I get that
23:59:32 <Pseudonym> Choicepoint is because of the non-obvious behaviour of cut.
23:59:56 <Pseudonym> In prolog, cut only cuts to the previous _clause_, not the previous disjunction.
