02:52:54 <delYsid> http://www.research.avayalabs.com/user/wadler/topics/monads.html
02:55:06 <ChilliX> Good stuff
02:55:22 <ChilliX> but not all easy to digest
02:58:43 <delYsid> yeah.
02:59:10 <ChilliX> Have you read any of the papers yet?
02:59:27 <delYsid> The essence of Functional Programming...
02:59:42 <delYsid> Well, I *think* I got it :)
02:59:48 <ChilliX> :-)
03:01:00 <delYsid> ChilliX: About comp-intro: Very good, thanks.  IMO it's missing \ . $ and =>>.  Any plans on chapters in that dir?
03:01:38 <ChilliX> "=>>"?  Do you mean classes?
03:01:50 <Heffalump> \ ?
03:01:59 <ChilliX> \ = lambda, I guess
03:02:02 <Heffalump> oh, yes
03:02:10 <Heffalump> didn't recognise it out of context :-)
03:03:01 <delYsid> ChilliX: Isn't =>> some other form of do?
03:03:15 <delYsid> Excuse me, I just know it from sample source...
03:03:20 <Heffalump> >>=
03:03:29 <delYsid> er, that one
03:03:29 <ChilliX> Do you mean >= ?
03:03:47 <Heffalump> he means monad bind, so >>=
03:03:57 <ChilliX> Hmm, >>= is really only needed when defining monads
03:04:10 <Heffalump> unless you don't like do notation for some reason
03:04:13 <ChilliX> which is a bit beyond an intro, I think
03:04:32 <ChilliX> but I agree with \ . $
03:05:15 <delYsid> good :)
03:05:27 <ChilliX> there needs to be a chapter on advanced higher-order programming
03:05:35 <delYsid> OK; now I need a digital book between an intro and the Report :)
03:06:04 <ChilliX> I'll put a remark in my todo list that these are the things that you would like to see in comp-intro
03:06:08 <ChilliX> thanks for the suggestion
03:06:21 <delYsid> np
03:06:25 <delYsid> thanks for the material...
03:06:32 <Heffalump> the Chalmers AFP courses are about the right level, I think
03:06:33 <ChilliX> delYsid: that's difficult, digital or not
03:06:39 <Heffalump> and a lot of the material for them are online
03:06:42 <Heffalump> s/are/is/
03:06:47 * Heffalump --> have a look
03:06:54 <ChilliX> no problem, I am always happy if my writings are of use :-)
03:07:06 <Heffalump> oh, my proxy server is broken, have to wait a bit
03:07:17 <delYsid> AFP?
03:07:27 <Heffalump> Advanced Functional Programming
03:07:33 <ChilliX> problem with between intro and report is that most of the stuff is not in the form of text books
03:07:56 <Heffalump> yeah, you just sort of have to figure it out as you go along
03:08:11 <delYsid> Is there some kind of CHAN?
03:08:14 <Heffalump> what sort of level do you cover in your book?
03:08:15 <ChilliX> but its a serious problem, I think
03:08:30 <delYsid> I mean some sort of haskell source archive?
03:08:41 <Heffalump> delysid: the libraries project, I guess
03:09:12 <delYsid> Heffalump: http://www.functional-programming.org/afp/afp4, that one?
03:09:15 <ChilliX> libraries project and the http://haskell.org/libraries/
03:09:32 <Heffalump> delysid: no, there's a course at Chalmers every year
03:09:44 <Heffalump> I quite often find useful material in the notes when randomly googling for things
03:10:18 <Heffalump> the AFP summer schools are interesting, but mostly random research material rather than a useful tutorial that fits between intro stuff and the report
03:10:39 <delYsid> ok
03:11:05 <ChilliX> the problem with books is that it takes so long to write them :-(
03:11:31 <delYsid> The problem with books is, that it take so long to OCR them :)
03:11:41 <ChilliX> :-)
03:11:43 <Heffalump> hmm, a project for #haskell? :-)
03:12:00 <Heffalump> it's a shame more books aren't available electronically in the first place
03:12:07 <ChilliX> point taken, but I meant books in the general sense (digital or not)
03:12:21 <Heffalump> but I guess the DRM issue rears its ugly head then
03:12:49 <ChilliX> it's a shame and it's like all the other problkems that we have copyright etc due to greedy companies trying to ignore digital content
03:15:06 * Heffalump discovers http://www.math.chalmers.se/~rjmh/tutorials.html
03:15:46 <Heffalump> and in particular http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/ is their AFP course
03:16:46 <ChilliX> Heffalump: maybe it would be a project for #haskell
03:17:12 <ChilliX> I could imagine a coordinated set of short articles, each covering a specific topic
03:17:20 <Heffalump> yeah.
03:17:39 <ChilliX> something like that would probably work as a community project
03:18:50 <ChilliX> if it's all put under the GFDL, it's guaranteed to remain available electronically
03:20:18 <ChilliX> delYsid: How long does it take to OCR a 200 page book?
03:21:02 <delYsid> Well, all that depends on more than just the plain scan times...
03:21:15 <ChilliX> fonts and stuff, I guess
03:21:39 <delYsid> OCR still has problems with special chars and different fonts in some situations. And after you OCR'ed it, you still need to correct it.
03:21:54 <delYsid> And correcting a ocr'ed book without seeing the original is some kind of puzzle game..
03:22:01 <ChilliX> sure
03:22:02 <delYsid> so I try to avoid it whenever possible...
03:22:33 <ChilliX> fait enough
03:22:38 <ChilliX> fait = fair
03:39:00 <delYsid> ChilliX: BTW, the Chapter about Formal Reasoning resulted in virtually unreadable ascii... But I think it's not that important for real world?
03:39:15 <delYsid> Or would you have the time to make something readable out of that chap?
03:50:38 <Heffalump> how about running detex over the sources (if they are in tex, that is)?
04:04:18 <ChilliX> it's in LaTeX
04:04:33 <ChilliX> I guess, the problem is that the chapter uses a lot math mode
04:04:41 <delYsid> yup
04:04:58 <ChilliX> can you usually read math mode somehow?
04:05:08 <delYsid> You dont wanna give me the Tex chap itself, do you?
04:05:20 <ChilliX> (it's a mix of math mode and tt if you know LaTeX)
04:05:26 <ChilliX> I don't mind
04:05:31 <delYsid> Yes I can, at least, it's easy than reading crippled ascii
04:05:34 <ChilliX> if you think, the source is useful
04:09:26 <ibid> morning
04:09:35 * ibid slept for 12 hours. feels good :-)
04:10:52 <liiwi> yup
04:10:55 <liiwi> btdt
04:11:07 * Heffalump slept for 17 hours once
04:39:51 <delYsid> Ahem, does haskell have a stringtoint fun?
04:40:20 <Heffalump> read
04:40:46 <Heffalump> Prelude> read "55" :: Int
04:40:46 <Heffalump> 55
04:45:04 * dblack is away: I'm busy
04:45:30 * dblack is away: out
04:48:47 <pesco> *bump*
04:48:52 <Heffalump> ouch
04:48:59 * Heffalump pushes pesco off him and gets up
04:49:23 <pesco> I'm sorry, don't know why my client's in such a rush today.
04:52:04 <delYsid> Another silly newbie question: Is there a prelude thingy for summing up a list of ints?
04:52:12 <pesco> sum
04:52:20 * pesco grins broadly
04:54:14 <Heffalump> real men use foldr (+) 0
04:54:34 <Heffalump> but yeah, what he said :-)
04:56:36 <pesco> Yeh, never get out of practice on your folds.
04:59:04 <delYsid> wow!
04:59:08 <delYsid> My first working haskell prog :)
04:59:19 <delYsid> module Stunden where
04:59:19 <delYsid> import Parsec
04:59:20 <delYsid> type Minutes = Int
04:59:20 <delYsid> time :: Parser Minutes
04:59:20 <delYsid> time = do h <- count 2 digit
04:59:20 <delYsid>           char ':'
04:59:22 <delYsid>           m <- count 2 digit
04:59:24 <delYsid>           return ((read h)*60+(read m))
04:59:26 <delYsid> duration :: Parser Minutes
04:59:28 <delYsid> duration = do t1 <- time
04:59:30 <delYsid>               char '-'
04:59:32 <delYsid>               t2 <- time
04:59:34 <delYsid>               return (t2-t1)
04:59:36 <delYsid> durations :: Parser Minutes
04:59:38 <delYsid> durations = do mins <- sepBy duration (char ',')
04:59:40 <delYsid>                return (sum mins)
04:59:52 <delYsid> Stunden> parse durations "" "08:12-09:13,17:30-18:30"
04:59:52 <delYsid> Right 121
04:59:57 <ChilliX> :-)
05:00:04 <ChilliX> Are you German?
05:00:09 <delYsid> yup
05:00:22 <ChilliX> the module name gave you away
05:01:01 <delYsid> yeah :)
05:01:37 <ChilliX> (ich "ubrigens auch :-)
05:02:11 <delYsid> hmm, any idea why I need to do do mins <- ...; return (sum mins)
05:02:23 <delYsid> Cant I just write durations = sum (sepBy ...)
05:02:44 <ChilliX> I guess sepBy has a monadic result type
05:02:51 <ChilliX> you could do the following
05:03:03 <ChilliX> liftM sum $ sepBy ...
05:03:13 <ChilliX> where liftM is from the standard library Monad
05:03:39 <ChilliX> liftM            :: Monad m => (a -> b) -> (m a -> m b)
05:03:52 <delYsid> there it is again! A lonely $, and me no idea what it means..
05:04:05 <ChilliX> simple
05:04:16 <ChilliX> ($) :: (a -> b) -> a -> b
05:04:21 <ChilliX> f $ x = f x
05:04:32 <ChilliX> same as function application, just has a different precedence
05:04:48 <ChilliX> normal function applications binds the strongest, $ the weakest
05:04:56 <ChilliX> I could have written
05:05:10 <ChilliX> liftM sum (sepBy ...)
05:05:16 <ChilliX> but I prefer to avoid the paranethesis
05:05:52 <delYsid> oh well, a matter of taste then...
05:06:06 <ChilliX> yes
05:06:54 <ChilliX> only when you want to explicit get at the function implementing function applications you do need it
05:07:41 <delYsid> okok, this is a good exercise...
05:07:54 <Heffalump> if you're Richard Bird then you'd write that as (liftM sum . sepBy durations . char) ','
05:08:02 <ChilliX> consider: zipWith ($)
05:08:04 <Heffalump> which also means the same thing
05:08:52 <ChilliX> I would use: liftM sum . sepBy durations . char $ ','
05:09:02 <ChilliX> (you see, I like $ a lot)
05:09:07 <delYsid> eeeew
05:09:15 <Heffalump> yeah, eewew :-)
05:09:18 <ChilliX> this is weird at first
05:09:27 <Heffalump> mixing . and $ like that is ugly, I reckon
05:09:33 <delYsid> esp. if you are used to lisp and parenthesis all over the place :)
05:09:33 <ChilliX> but believe me, when you get used to it, it makes a *lot* of sense
05:09:46 <Heffalump> why not just use $ everywhere?
05:09:54 <delYsid> why not just use ()  ?
05:09:59 <ChilliX> Heffalump: don't think so, this is one of the reasons $ was introduced
05:10:10 <Heffalump> () are annoying cos you have to close them afterwards
05:10:23 <ChilliX> observe the structure of liftM sum . sepBy durations . char $ ','
05:10:30 <ChilliX> . is like a reverse | in Unix
05:10:33 <delYsid> well, I accept that if it gets more readable...
05:10:45 <ChilliX> so it is a reverse pipeline into which you feed something with $
05:11:00 <Heffalump> hmm, I suppose so
05:11:17 <Heffalump> but Haskell ain't UNIX :-)
05:11:57 <ChilliX> but haskell is an FP language, so function app (ie, $) and function composition (ie, .) *are* special
05:12:33 <Heffalump> yeah, I just think mixing them in that particular way is a bit ugly
05:12:43 <ChilliX> I don't know, maybe the fact that I got hooked on FP after reading Bird&Wadler twisted my mind...
05:12:58 <Heffalump> :-)
05:13:05 <delYsid> well, I still think its most readable with any kind of . or $
05:13:19 <delYsid> s/with/without/
05:13:37 <delYsid> So for liftM I need import Monad?
05:13:40 <ChilliX> you get used to . pretty quickly
05:13:41 <Heffalump> Bird was the internal examiner for my PhD, and one chapter had $ all over the place - I was expecting him to complain about it, but he didn't :-)
05:13:57 <ChilliX> it is a matter of thinking in terms of functions instead of function results and function arguments
05:14:06 <ChilliX> mathematicans call it point-free notation
05:14:11 <Heffalump> delysid: yep
05:14:26 * ibid_ likes . and $
05:15:14 <Heffalump> point-free notation is ok, but I think it gets taken to extremes too much
05:15:38 <ChilliX> maybe
05:16:28 <delYsid> durations = liftM sum . sepBy duration . char $ ',' -- OK; It looks cool, just need to get used to it...
05:16:40 <delYsid> Why cant I leave out the $?
05:16:54 <Heffalump> operator precedences
05:17:08 <Heffalump> the space for function application binds tighter than anything else
05:17:21 <Heffalump> so if you left out the $ you'd be composing sepBy duration with char ','
05:17:29 <Heffalump> which isn't what you want
05:17:40 <Heffalump> $ binds weaker than anything else
05:17:48 <delYsid> btw, can I somehow get the type of such a loong expression ?
05:17:49 <ChilliX> it would get parsed as  liftM sum . sepBy duration . (char ',')
05:17:53 <Heffalump> :t foo 
05:17:56 <Heffalump> in hugs or ghci
05:17:59 <ChilliX> yep 
05:18:11 <Heffalump> where foo is any expression you like
05:19:00 * ibid has sometimes bitten by the fact that one cannot remove the parens from f (a b c) d using $
05:19:03 <delYsid> ahh, not the final type. I thought I can see the whole structure somehow...
05:19:27 <Heffalump> delysid: ah, you have to look at each bit for that, sorry
05:19:52 <Heffalump> (afaik)
05:20:54 <Heffalump> type inference means that seeing the whole structure isn't quite as simple as you might think
05:21:08 <Heffalump> because the types of things around an subexpression can affect the type of that subexpression too
05:22:57 <ChilliX> the only way to represent it is a type inference tree
05:23:39 <ChilliX> but that gets messy quite quickly
05:23:39 <Heffalump> well, what you really want to know is the most general type of each subexpression and the type it got instantiated to
05:23:51 <Heffalump> so you could just make a tree of subexpressions annotated with the two types
05:24:18 <Heffalump> and you can figure out what's going on by following the most general types upwards and the instantiated types downwards
05:24:43 <ChilliX> I guess, what is needed is a Haskell type browser
05:25:17 <delYsid> Yez!
05:25:29 <delYsid> HTB sounds good, but in text-mode plz!
05:27:31 <ChilliX> now, we only need somebody who volunteers to write it
05:28:03 <delYsid> durations = liftM sum . sepBy duration . char $ ','
05:28:04 <delYsid>          -- liftM sum (sepBy duration (char ','))
05:28:06 <ChilliX> after the type checking phase, GHC's AST would have all the info needed 
05:28:10 <delYsid> -- Is this true (equiv?)
05:28:19 <ChilliX> yes
05:33:36 <delYsid> anyone good with Parsec?
05:33:51 <delYsid> Can I use .. also, like in char '0' .. char '9' ?
05:34:11 <delYsid> instead of char '0' <|> ... <|> char '9'
05:34:49 <Heffalump> you could use map char ['0'..'9']
05:35:08 <Heffalump> or rather foldr1 (<|>) $ map char ['0'..'9']
05:35:47 <delYsid> ChilliX: And you didn't explain fold, foldr1 ... iirc
05:36:16 <ChilliX> delYsid: true, but that would belong in the same chapter as \ $ .
05:36:43 <delYsid> true
05:36:58 * delYsid feels the urge to fill a knowledge gap
05:37:13 <ChilliX> it's really that more advanced higher-order stuff is missing
05:43:35 <delYsid> A tutorial on the universality
05:43:35 <delYsid> and expressiveness of fold
05:43:35 <delYsid> Graham Hutton
05:43:35 <delYsid> University of Nottingham, UK
05:43:35 <delYsid> http://www.cs.nott.ac.uk/ ~ gmh
05:43:42 <delYsid> That looks good.... (reading...)
05:44:03 <delYsid> hey shapr !
05:44:04 <ChilliX> delYsid: it's not untough ;-)
05:44:13 <ChilliX> delYsid: have a look at http://www.informatik.uni-bonn.de/~ralf/teaching/Hskurs_7.html#SEC47
05:44:21 <Heffalump> folds are good.
05:44:34 <delYsid> ChilliX: Well, any Gentle introduction to folding :)?
05:47:28 <ChilliX> delYsid: specifically on fold not really
05:47:34 <shapr> hey delYsid!
05:47:47 <ChilliX> the above link has some more advanced stuff (and very briefly also fold)\
05:47:54 <delYsid> shapr: wanna see my first parsec/haskell prog? :)
05:48:42 <shapr> yes!
05:49:46 <shapr> coool!
05:50:01 <shapr> hey, I could probably hack that into Itime.hs ;-)
05:50:06 <shapr> that's spiffy!
05:50:34 <shapr> that's cool stuff
05:50:43 * shapr thinks of more parser ideas
05:50:46 <delYsid> Well, it's only the beginning.
05:51:13 <delYsid> I wanna write an evaluator for my worktime file...
05:51:55 <delYsid> It should check if weekdays are in proper order, and if the dates specified are valid...
05:52:12 <delYsid> And return the time I've worked too much or too less...
05:53:11 <delYsid> An entry look slike: 'Mo 05.08.: 09:00-17:00,18:00-19:30'
06:05:11 <delYsid> liftM read . count 2 . digit -- What is rong there?
06:05:25 <delYsid> s/rong/wrong/
06:06:10 <ChilliX> What's `digit' and `count'?  Parsec functions?
06:06:15 <delYsid> yup
06:06:40 <ChilliX> hmm, I don't know Parsec much.  What's their type?
06:08:04 <delYsid> forall a. Int -> Parser a -> Parser [a]
06:08:42 <delYsid> -- count
06:08:53 <delYsid> Stunden> :t digit
06:08:54 <delYsid> Parser Char
06:09:17 <ChilliX> the problem is count 2 . digit
06:09:28 <ChilliX> you can't combine two parsers by .
06:10:11 <ChilliX> oops sorry
06:10:15 <ChilliX> what you meant to write was maybe
06:10:34 <ChilliX> liftM read . count 2 $ digit  ?
06:10:42 <delYsid> ahh, yeah
06:13:44 <delYsid> did I get this right, if I use do and <-, liftM is implicit?
06:14:21 <ChilliX> in a way, yes
06:14:42 <ChilliX> when you use a monad, like Parser
06:14:59 <ChilliX> then you compute "within" the monad with do and <-
06:15:44 <ChilliX> you can use non-monadic functions either in arguments of operations used in do or in the argument to return
06:16:05 <ChilliX> alternativel;y, you can use liftM to lift non-manadic functions into the monad
06:16:18 <ChilliX> (and so turn them into monad functions, in a way)
06:16:54 <delYsid> well, what is considered better style of those two variants:
06:16:55 <delYsid> time :: Parser Minutes
06:16:56 <delYsid> time = do h <- count 2 digit
06:16:56 <delYsid>           char ':'
06:16:56 <delYsid>           m <- count 2 digit
06:16:56 <delYsid>           return ((read h)*60+(read m))
06:16:57 <delYsid> time = do h <- liftM read . count 2 $ digit
06:16:59 <delYsid>           char ':'
06:17:01 <delYsid>           m <- liftM read . count 2 $ digit
06:17:03 <delYsid>           return (h*60+m)
06:17:42 <ChilliX> yep
06:18:02 <ChilliX> in the first version, you use read in the arg of return (ie, non-monadic context)
06:18:24 <ChilliX> in the 2nd, you make it into a monadic function by way of liftM and now you can directly use it with the <-
06:18:30 <delYsid> yeah, but which is favourable?
06:19:09 <ChilliX> it's to a certain extent a matter of personal coding style (at least in this example)
06:19:44 <ChilliX> in other cases, where you don't return the result of applying the function
06:19:59 <ChilliX> but use it further in the monad
06:20:12 <ChilliX> the style in the 2nd version somtimes is more concise
06:20:31 <ChilliX> but still a question of style
06:20:33 <ChilliX> consider
06:20:40 <ChilliX> time = do h <- count 2 digit
06:20:55 <ChilliX>          let h' = read h
06:21:03 <ChilliX>           char ':'
06:21:17 <ChilliX>           m <- count 2 digit
06:21:24 <ChilliX>          let m' = read m
06:21:35 <ChilliX>           return (h'*60+m')
06:21:56 <ChilliX> you can always replace this kind of use of liftM by a let
06:22:09 <ChilliX> the liftM version is more compact
06:22:23 <ChilliX> but requires to know a bit more about Haskell
06:22:30 <ChilliX> that's essentially the trade of
06:22:41 <ChilliX> of = off
06:22:49 <delYsid> hmm
06:24:11 <delYsid> oh well, there it is, I dunno about let either.
06:24:27 <delYsid> same story with layout, that went completely wrong with pstotext...
06:25:21 <ChilliX> but you seem to have got the layout right in your code
06:25:41 <delYsid> yeah, I've understood how do is layouted...
06:25:43 <ChilliX> the let in do is nonessential, but very useful
06:26:06 <ChilliX> the layout rule for all cosntructs is the same
06:26:23 <delYsid> ChilliX: Thats because the Parsec docs do layout in html and it works...
06:26:33 <delYsid> So I've learned the rules from their examples...
06:26:54 <ChilliX> because lynx (or whatever you use) preserves the spacing in HTML?
06:27:02 <delYsid> why is the let one char to the left?
06:27:08 <delYsid> And why doesnt it have an in?
06:27:13 <ChilliX> that's a mistake
06:27:23 <delYsid> ChilliX: right.
06:27:24 <ChilliX> I cut'n'pasted it in my IRC client
06:27:43 <ChilliX> let doesn't have an in in do
06:27:52 <ChilliX> because it scopes over all the rest of that do
06:28:06 <delYsid> ok
06:28:22 <ChilliX> rule of thumb
06:28:25 <delYsid> how are the let supposed to be indented then, same with m <-..., or same with do?
06:28:30 <ChilliX> <- and let = in do are related
06:28:33 <ChilliX> but
06:28:40 <ChilliX> <- is for monadic funcs
06:28:46 <ChilliX> and let = for non-monadic ones
06:29:01 <ChilliX> (whether a fun is monadic or not you see at its result type)
06:29:14 <delYsid> aha!
06:29:16 <ChilliX> same as with m <-...
06:29:40 <delYsid> So it's supposed to look like this:
06:29:41 <delYsid> time = do h <- count 2 digit
06:29:41 <delYsid>           let h' = read h                                      [15:21]
06:29:41 <delYsid>           char ':'
06:29:42 <delYsid>           m <- count 2 digit
06:29:42 <delYsid>           let m' = read m
06:29:43 <delYsid>           return (h'*60+m')
06:30:05 <ChilliX> minus the [15:21]
06:30:27 <ChilliX> and for completeness sake
06:30:35 <ChilliX> such a let can have multiple equations
06:30:38 <ChilliX> eg
06:30:41 <ChilliX> do
06:30:45 <ChilliX>   x <- ...
06:30:50 <ChilliX>   let y = ...
06:30:58 <ChilliX>       z = ...
06:31:05 <ChilliX>   v <- ...
06:31:09 <ChilliX>   return ...
06:31:15 <delYsid> ok, I think I like this notation best.
06:31:44 <ChilliX> (such a let can even introduce new local functions!)
06:32:11 <delYsid> btw, are let and where equivalent in haskell?
06:32:19 <ChilliX> nearly
06:32:22 <delYsid> I'd like to avoid where whenever I can, it's against the way I work...
06:32:40 <ChilliX> you need where when you bind variables that you want to use in guards
06:32:42 <ChilliX> example:
06:32:47 <delYsid> grrrr
06:32:53 <delYsid> where is soooo confusing!
06:32:58 <ChilliX> foo x | y < 0     = ...
06:33:11 <ChilliX>       | y > 5    = ...
06:33:14 <ChilliX>   where 
06:33:20 <ChilliX>     y = bar x
06:33:31 <delYsid> :(
06:33:34 <ChilliX> let won't work here, because, where do you want to put it
06:33:44 <delYsid> well... I'll write some elisp trickery then...
06:34:07 <ChilliX> is it that bad?
06:34:25 <delYsid> well, imagine, you just look two lines down and know whats going on.
06:34:50 <delYsid> I just see a unknown varname at first, and am confused... If it were a let, I'd already have seen the binding,
06:34:55 * delYsid reads sequencially
06:35:37 <ChilliX> yes, but the idea is not to scan forward
06:35:47 <ChilliX> I mean whethe to use let or where
06:35:57 <ChilliX> depends on whether you need to look forward or not
06:36:02 <delYsid> Maybe I just need to get used to it, but `where' is definitely the most confusing thing in Haskell I found so far (when reading code)
06:36:21 <ChilliX> the idea is to treat it like abstraction
06:36:56 <ChilliX> but I still understand your point
06:38:07 <delYsid> ChilliX: Well, is there really difference if I write the abstraction before or after the code which uses it?
06:38:34 <ChilliX> sometimes, I don't want to be bothered with the concrete definition yet
06:38:40 <ChilliX> I want to know what it is used for
06:38:55 <ChilliX> after that, I look at how it is exactly realised
06:39:07 <delYsid> hmm
06:39:16 <ChilliX> examples:
06:39:22 <ChilliX> qsort [x] = [x]
06:39:35 <delYsid> Yes, qsort is a good example of where...
06:39:44 <delYsid> It really makes the algo more readable, you're right there.
06:40:18 <ChilliX> qsort xs = qsort [x | x <- xs, x < median] ++ [median] ++ [x | x <- xs, x > median]
06:40:20 <ChilliX>   where
06:40:29 <ChilliX>   median = head xs
06:40:36 <ChilliX> but it could also be
06:40:52 <ChilliX>   median = xs !! (length xs `div` 2)
06:41:00 <delYsid> yeah
06:41:14 <delYsid> btw, I forgot, did you explain list comprehensions in comp-intro?
06:41:16 <ChilliX> that's how where should be used
06:41:25 <ChilliX> no, no list comprs
06:41:42 <ChilliX> in the course for which we wrote the book, there is no time for list comprehensions
06:42:10 <ChilliX> could also go in some further advanced chapter at the end
06:42:15 <delYsid> shapr: Do you have a scanner? :)
06:42:44 <ChilliX> I guess, list comprs are explained in A Gentle Intro to Haskell
06:48:23 <shapr> delYsid: I do, why?
06:49:23 <shapr> list comprehensions are nifty
06:50:23 <delYsid> ahem, isn't forall not h98?
06:50:38 <ChilliX> that's right
06:50:48 <ChilliX> (all foralls are implicit in H98)
06:50:53 <delYsid> but gentle intro to haskell uses it?
06:51:02 <ChilliX> really?
06:51:04 <delYsid> What is forall about?
06:51:25 <delYsid> 			    2.1  Polymorphic Types
06:51:25 <delYsid>    Haskell also incorporates polymorphic types---types that are universally
06:51:25 <delYsid>      quantified in some way over all types. Polymorphic type expressions
06:51:25 <delYsid>   essentially describe families of types. For example, (forall a)[a] is the
06:51:25 <delYsid> family of types consisting of, for every type a, the type of lists of a. Lists
06:51:25 <delYsid> ...
06:51:26 <ChilliX> head :: [a] -> a
06:51:53 <ChilliX> ok, but that's not really meant to be Haskell code
06:51:54 <shapr> delYsid: hey, I patched haskell-mode.el for ghc5.04, did you already notice that?
06:52:08 <delYsid> notice what?
06:52:16 <shapr> that C-c C-l fails sometimes?
06:52:18 <delYsid> I'm still @ 5.02, didnt update in a long time...
06:52:21 <shapr> oh, ok
06:52:36 <shapr> comint-prompt-regexp should be changed for 5.04
06:52:40 <shapr> I changed it.
06:52:41 <ChilliX> true
06:52:48 <ChilliX> I tripped across that recently, too
06:52:58 <ChilliX> the * in front of module names confuses it
06:53:05 <shapr> the examples in the docs for the prompt are incorrect alos
06:53:15 <shapr> they show it separated by commas, but it's actually separated by spaces.
06:53:41 <shapr> ChilliX: are you using haskell-mode from debian?
06:53:43 <ChilliX> that was an intermediate version in the 5.03 series, I think
06:53:55 <ChilliX> no, just downloaded from haskell.org
06:54:00 <ChilliX> (I am running Red Hat)
06:54:14 <shapr> oh, ok
06:54:26 <ChilliX> but I had the same problem
06:56:17 <shapr> ah, it's changed in cvs
06:56:49 <ChilliX> ic
07:12:37 * Heffalump remembers something about the Redhat GHC rpm
07:13:23 <Heffalump> chillix: there was a comment in your spec file a while ago about something being ugly (I think it was to do with the file list generation). I remember fixing it and sending you an email about it - do you remember?
07:13:45 <ChilliX> yes, vaguely
07:13:56 <ChilliX> I still have stuff on the rpm todo list
07:16:07 <Heffalump> ah, it wasn't quite about the ugly thing, it was about listing directories in the file list
07:17:18 <ChilliX> ic
07:19:11 <Heffalump> otherwise they get left over when you remove it/upgrade
07:20:02 <Heffalump> but you have to use %dir to stop it including all the contents of said directories too
07:20:15 <ChilliX> hmm, ok
07:20:47 <pesco> May I change the topic back to the qsort from above for a second?
07:21:10 <shapr> I think it's okay to have multiple threads running all the time.
07:21:24 <shapr> module #Haskell where import Concurrent
07:21:27 <pesco> Is the motivation for using median = xs !! (length xs `div` 2) the assumption that the list might be sorted already?
07:21:27 <Heffalump> anyway, I'm happy, since I have my own local version that does what I need :-)
07:22:38 <pesco> shapr: Right, just wanted to make the transition into the old topic a little less abrupt.
07:23:01 <shapr> pesco: otoh, maybe I need to learn to do that :)
07:23:09 <ChilliX> pesco: sorted or at least not too far away from sorted
07:23:24 <pesco> Chilli: Yeh, but that's all, correct?
07:23:35 <ChilliX> yes
07:23:51 <pesco> OK.
07:25:01 <ChilliX> (the point above was that the decision about the median is independent from the structure of the rest of qsort)
07:25:20 <pesco> Right.
07:40:36 <delYsid> Does anyone here know Richard Bird in person?
07:40:51 * Heffalump does
07:41:24 <delYsid> Heffalump: I just sent a request for a digital version of his book, what do you think, how much chances do I have to succeed?
07:41:37 <Heffalump> I'd have thought a reasonable amount
07:41:56 <Heffalump> he'll probably have the same copyright issues ChilliX does
07:42:22 <Heffalump> but my guess would be he'd be prepared to supply one on the same understanding, though I could be wrong
08:13:23 <ChilliX> I am tired now
08:13:25 <ChilliX> g'nite
08:13:48 * ChilliX is away: Not at the machine...
08:14:34 <shapr> g'nite ChilliX
08:14:47 * shapr uploads QuickCheck and HUnit to the ICFP2002 cvs
08:38:05 <Heffalump> isn't QuickCheck in Hugs/GHC now?
09:04:47 <shapr> Heffalump: it's in GHC, but not Hugs
09:04:53 <shapr> afaik
09:05:31 <Heffalump> it's definitely in hugs, I've used it there
09:05:34 <shapr> oh
09:05:46 <shapr> well then :-)
09:05:59 <shapr> Heffalump: hey, did you send that QuickCheck feature request to John Hughes?
09:08:15 <Heffalump> nope.
09:08:33 <shapr> think you will? or should I?
09:08:40 <Heffalump> I won't
09:08:43 <shapr> ok
09:08:47 <shapr> I will then.
09:08:48 <Heffalump> I don't actually use it, so it'd be a bit silly
09:09:11 <shapr> I think it's a good feature to have.
09:55:16 <delYsid> shapr?
09:55:21 <shapr> yes?
09:55:26 <delYsid> Is bea still around?
09:55:40 <shapr> yah, she is...
09:55:47 <shapr> on the phone at the moment though
09:55:58 <delYsid> ah, as usual :)
09:56:12 <delYsid> If she's still talkative, I'm back...
09:56:21 <shapr> I'll ask her...
10:01:23 <delYsid> shapr: Already figured out where that tex source is?
10:01:50 <shapr> kind of...
10:02:09 <shapr> should be in cvs.haskell.org under papers/tutorial
10:02:24 <shapr> I can't remember my cvs.haskell.org password though, and that dir doesn't show up in cvsweb
10:05:10 <delYsid> :(
10:06:14 <pertsa> hi all. i was a week in Glasgow. didn't meet any Haskell people there, though
10:06:25 <shapr> hi pertsa, what's up?
10:06:37 <shapr> relaxing after your trip?
10:06:41 <pertsa> nothing special. i catched a flu in Scotland.
10:06:51 <shapr> that sucks
10:07:12 <pertsa> i saw blu sky about two or three times during that trip.
10:07:32 <pertsa> otherwise, just different kinds of water drops
10:07:38 <shapr> hah
10:07:40 <shapr> too much rain
10:08:37 <pertsa> but now i have nothing to complain about the Finnish weather
10:09:25 <shapr> hey delYsid, a fold tutorial: http://www.cs.nott.ac.uk/~gmh/fold.ps
10:10:47 <delYsid> shapr: jup, found that already, looking at YAHT right now
10:11:57 <pertsa> what's the status of ICFP team?
10:12:22 <pertsa> IFPC
10:12:31 <shapr> pertsa: there's a mailing list, and a 'net accesible cvs repository
10:12:38 <shapr> ICFP is correct :-)
10:12:46 <pertsa> whatever :)
10:13:05 <shapr> pertsa: currently, our standards are ghc5.04, QuickCheck, and HUnit
10:13:05 <pertsa> just thought of International Functional Programming Contest
10:13:19 <shapr> that's actually better...
10:14:16 <pertsa> i could be interested in participating, but i do not know if i have time
10:14:48 <delYsid> shapr: What is QuickCheck?
10:14:53 <shapr> if you want to, join the mailing list
10:15:04 <shapr> delYsid: it's testing software, lemme find the url
10:15:27 <pertsa> shapr: how can i join?
10:15:48 <shapr> http://alicorna.net/mailman/listinfo/icfp-team
10:15:52 <shapr> I think that's the correct url
10:16:14 <pertsa> it works, thanks.
10:17:10 <shapr> cool
10:17:36 <shapr> delYsid: http://www.cs.chalmers.se/~rjmh/QuickCheck/
10:17:43 <shapr> delYsid: it comes with GHC and Hugs nowadays.
10:18:48 * shapr tries to figure out how to port some python code to haskell
10:19:11 <shapr> I've been staring at jelly.py for a week now, and I'm still not really sure how to approach it.
10:19:39 <shapr> what's the best way to get a function to switch by types?
10:19:50 <shapr> make a type class and make instances?
10:20:35 <delYsid> fun Sometype = ...
10:20:39 <delYsid> fun Othertype = ...
10:20:55 <shapr> does that really work?
10:21:04 <delYsid> I've seen code that does that.
10:21:08 <pesco> shapr: Won't there probably a 4-person limit on the teams?
10:21:10 <shapr> got an example handy?
10:21:15 <shapr> pesco: I don't know.
10:21:27 <pesco> shapr: I think it was that way in earlier years.
10:21:39 <shapr> pesco: I didn't know, that, do you have an url?
10:21:57 * shapr looks for the icfp2001 url
10:22:17 <dark> delYsid: What would be the function's type?  There'd have to be a more general type that includes Sometype and Othertype.
10:22:23 <shapr> oh cool, the 2002 contest has a web page! finally!
10:22:27 <pesco> shapr: no, try google.
10:22:51 <delYsid> dark: Right, I'm confused.
10:22:56 <delYsid> But there was something like that...
10:23:25 <shapr> pesco: http://icfpcontest.cse.ogi.edu/ "teams of any size"
10:23:53 <shapr> aha, a contest mailing list
10:24:50 <pesco> shapr: Yes, I see it now.
10:25:27 <shapr> wow cool, they have money prizes!
10:25:39 <shapr> actually, free registration for ICFP2002 would ROCK
10:26:08 <shapr> oh, I'm not a student.
10:26:10 <shapr> f00
10:27:02 <shapr> pesco: organizationally speaking, I don't think our team should be over six people
10:27:13 <shapr> and, I do think four people would be best.
10:27:29 <shapr> pesco: are you on the mailing list?
10:27:46 <pesco> which?
10:27:55 <pesco> shapr: I think so, too.
10:27:56 <shapr> the #haskell team mailing list.
10:28:02 <pesco> Just subscribed.
10:28:07 <shapr> excellent :-)
10:28:18 <shapr> if we get eight or more people on the #haskell team, I suggest we split into two.
10:28:30 <pesco> Very good suggestion.
10:28:37 <shapr> but I don't think that's very likely ;-)
10:28:51 <pertsa> was "Haskell Carrots" the last year's #haskell team?
10:29:19 <pesco> I don't think so, shapr?
10:29:22 <shapr> I don't know
10:29:35 <pesco> Was there a #haskell last year? :)
10:29:39 <shapr> I think so...
10:29:52 <shapr> yes, there was.
10:29:59 <shapr> but far less people.
10:29:59 <pesco> Yeah, but the channel isn't _much_ older, or is it?
10:30:03 <shapr> like, two or three
10:30:20 <pesco> yup. I remember 5 or so when I entered. The good ole days.
10:30:21 <shapr> -ChanServ-   Registered: 1 year 13 weeks 4 days (19h 7m 16s) ago
10:30:23 <shapr> hah
10:30:25 <pesco> heheh
10:30:33 <shapr> I think more people is better.
10:30:59 <pesco> Yeah, 23 is ok. ;)
10:31:30 <shapr> well, we have one logbot, and one duplicate.
10:32:01 <shapr> actually, I think more signal is the goal, no matter the number of people.
10:32:03 <pesco> Oh, right. BTW, where are the logs? The tunes.org URL didn't work the other day.
10:32:15 <shapr> I'd put the wrong url into the topic
10:32:20 <shapr> the current url should be correct.
10:32:48 <pesco> Oh, yah. Thanks.
10:33:13 * shapr tries to figure out how to port Python code to Haskell
10:37:15 * pesco fast-forwards through the logs.
10:37:22 <pesco> Where do I show up?!
10:41:37 <shapr> pesco: found yourself yet? :-)
10:42:03 <pesco> shapr: No, but I own a small purple stuffed pterodactyl myself. :)
10:42:42 <pesco> Ah, no, I don't sorry.
10:42:45 <pesco> It's not a pterodactyl.
10:43:00 <shapr> hah
10:43:11 <shapr> where does that show up in the logs? =)
10:43:41 <pesco> 2002-01-22 ~11:30
10:43:50 <pesco> You're telling the story of the cardboard wookie.
10:44:04 <shapr> ohhh
10:45:44 * shapr laughs
10:45:52 <shapr> I found that story on TheWiki somewhere
10:46:13 <pesco> :)
10:46:47 <shapr> my pterodactyl is still at work, I need to take her home.
10:47:02 <pesco> *g*
10:51:30 * shapr reads "Programming It In Haskell" by Simon Thompson
10:51:46 <shapr> how do I make union types again?
10:52:14 <shapr> if I want a list to be able to contain both Int and Char for example...
10:52:28 <shapr> type TwoType = Int | Char
10:52:31 <shapr> something like that...
10:52:35 <pesco> I'd think so.
10:53:25 <dark> I don't know if you can do it with a type, I think you need a data declaration.  data Elem = IntElem Int | CharElem Char
10:54:12 <dark> I think if an actual Int | Char type were allowed, the whole type system would come crashing down :)
10:54:38 <shapr> I'm pretty sure you can do something like Int | Char
10:54:40 <pesco> Right, it must be data, I didn't look at the keyword :)
10:54:41 <shapr> but I've forgotten how.
10:55:12 <shapr> well, I'll try it like you suggested first.
10:55:14 <pesco> Either Int Char would be another option.
10:55:55 <dark> I never figured out how to use Either.  Seems easier to define my own type :)
10:56:05 <shapr> dark: your code works, thanks!
10:56:21 <pesco> Huh? Isn't Either just data Either a b = Left a | Right b ?
10:56:39 <shapr> how do you use that?
10:56:44 <pesco> Either?
10:56:59 <pesco> xs :: [Either Int Char]
10:57:00 <shapr> yah, what do you do with it?
10:57:13 <shapr> hm
10:57:24 * shapr looks for Either in his haskell books.
10:57:34 <pesco> xs = [Left 5, Right 'a', Left 6, Left 1, Right 'z']
10:57:42 <pesco> i'm pretty sure that's how it works.
10:58:00 <pesco> Isn't there a Dynamic type in the GHC libs?
10:58:15 <dark> And then something like: map (either intfunc charfunc) xs
10:58:28 <dark> ... but what would intfunc and charfunc do?
10:58:35 <pesco> dark: No, what is 'either'?
10:58:51 <dark> pesco: It's a function defined in the Prelude.
10:59:00 <pesco> Oh, didn't know it, sorry.
10:59:10 <pesco> Then you're most probably right.
10:59:12 <dark> either               :: (a -> c) -> (b -> c) -> Either a b -> c
10:59:12 <dark> either f g (Left x)  =  f x
10:59:12 <dark> either f g (Right y) =  g y
10:59:23 <pesco> right.
10:59:38 <dark> I haven't yet encountered a case where that's easier (or more readable) than defining your own type.  But I don't have much experience yet :)
11:00:09 <delYsid> type Action x = Square x
11:00:10 <delYsid>               | Sqrt x
11:00:18 <delYsid> -- what is wrong there? Something is!
11:00:47 <pesco> dark: The only advantage of a custom type is that you can have more descriptive names for the ctors.
11:01:08 <pesco> And for the type, too, of course. If that's applicable.
11:01:11 <shapr> delYsid: if you use data instead of type
11:01:29 <delYsid> ahhh
11:04:49 <dandelion-> shapr: would you want to help me getting started with hopengl?
11:06:48 <delYsid> data Action x = Square x
11:06:49 <delYsid>               | Sqrt x
11:07:02 <delYsid> -- How can I now dispatch on those two subtypes in a function?
11:08:34 <pesco> delYsid: With pattern matching.
11:08:40 <pesco> foo (Square x) = ...
11:08:44 <pesco> foo (Sqrt x) = ...
11:09:25 <pesco> A case can be used, too, right? I'm not familiar with the syntax of case.
11:10:05 <shapr> urf
11:10:07 <shapr> I was afk
11:10:30 <pesco> {case a in (Square x) = x^2; (Squrt x) = sqrt x} or something.
11:11:05 <dark> case a of
11:11:05 <dark>   Square x -> foo x
11:11:05 <dark>   Sqrt x -> bar x
11:11:05 <dark>   otherwise -> gnu x
11:11:20 <pesco> Ah, thanks
11:11:36 <dark> I use cases a lot in my current program :)
11:11:56 <pesco> Strange, isn't otherwise = False ?
11:12:37 <shapr> nah, it's just the last fall through case
11:12:58 <shapr> if a is a String or something
11:12:59 <dark> Nope, otherwise = True
11:13:10 <pesco> Er, right, of course.
11:13:13 <shapr> huh?
11:13:19 * shapr is confused
11:13:28 <dark> shapr: The True case catches everything :)
11:13:38 <dark> Oh, wait.
11:13:41 <pesco> /usr/share/hugs/lib/Prelude.hs lines 468-470
11:13:50 <shapr> oh, I see
11:13:52 <shapr> nifty
11:13:53 <dark> otherwise is True, but it's not what you would use for cases.
11:14:04 <dark> otherwise is for guards :)
11:14:34 <dark> Cases would use a pattern that matches everything, such as _
11:14:44 <pesco> Ah, yes, that's what I was looking for.
11:14:55 <shapr> hi Hal
11:14:59 <hdaume> hey all
11:15:16 <dark> getEndianness :: Binary -> Endianness
11:15:16 <dark> getEndianness b =
11:15:16 <dark>     case (b !! elf_EI_DATA) of 
11:15:16 <dark>       e | e == 1 -> LittleEndian
11:15:16 <dark>         | e == 2 -> BigEndian
11:15:17 <dark>         | otherwise -> error ("ELF: unsupported data format " ++ (show e))
11:15:19 <shapr> are the Latex sources for YAHT still on cvs.haskell.org?
11:15:38 <hdaume> let me check where they are
11:15:57 <hdaume> i think so...let me try checking them out :)
11:16:38 <hdaume> yeah...
11:16:52 <shapr> cool
11:16:53 <hdaume> cvs.haskell.org:/home/cvs/root, checkout papers/tutorial
11:17:18 <shapr> any idea who I can contact about a forgotten password? :-/
11:17:31 <hdaume> jeffrey...uhm...hold on, i'll check
11:17:35 <shapr> ok, thanks.
11:18:19 <hdaume> Jeff Lewis, jeff@galconn.com
11:18:28 <shapr> cool, thanks.
11:24:27 <shapr> can that case trick be used to switch on standard Prelude types as well?
11:24:49 <delYsid> t.hs:6:
11:24:49 <delYsid>     Couldn't match `* -> *' against `Type bx'
11:24:50 <delYsid>         Expected kind: * -> *
11:24:50 <delYsid>         Inferred kind: Type bx
11:24:50 <delYsid>     When checking that `Action' is a type
11:24:50 <delYsid>     In the type: Action -> Int
11:24:52 <delYsid>     While checking the type signature for `doit'
11:24:56 <delYsid> Thats what I get when I use
11:25:01 <delYsid> doit (Square x) = ...
11:25:22 <shapr> kinds are metatypes...
11:26:23 <shapr> not sure if that helps any =)
11:26:44 <delYsid> well, back to YAHT...
11:26:48 <shapr> delYsid: another possibility is to make a typeclass
11:27:07 <shapr> typeclasses work somewhat like Java interfaces.
11:28:02 <shapr> class CharExts a where
11:28:03 <shapr>     isVowel     :: a -> Bool
11:28:03 <shapr>     isConsonant :: a -> Bool
11:28:08 <shapr> instance CharExts Char where
11:28:08 <shapr>     isVowel a     = elem a "aeiouAEIOU"
11:28:08 <shapr>     isConsonant a = elem a (filter (not . isVowel) ['A'..'Z'] ++ ['a'..'z'])
11:28:24 <shapr> that's a useless demo typeclass I wrote..
11:29:19 <shapr> in short, you can define function names, then define a separate implementation for each type.
11:29:55 <shapr> I'm using that in Banana.hs to do type serialization differently for each type, but all happen with a single "encode" method.
11:33:10 <shapr> delYsid: hey, can you mail me the correction for YAHT?
11:36:50 <hdaume> shapr: i just read through it a couple of days ago; there are a lot of corrections :)
11:37:12 <shapr> I've found two today :-)
11:37:18 <hdaume> i'll probably go through it seriously some time this week (on of my friends is going to try to learn haskell) so hopefully he'll give good feedback
11:38:24 <shapr> cool
11:39:02 <pesco> please expand YAHT.
11:39:12 <shapr> Yet Another Haskell Tutorial
11:39:18 <pesco> oic
11:39:27 <shapr> Hal Daume is the lead organizer for YAHT
11:39:38 <pesco> Oh.
11:39:39 <shapr> you can get DVI, PS, and PDF versions from him home page
11:39:41 <shapr> er "his"
11:39:57 <shapr> and you can get a cvs.haskell.org account if you want to work on it yourself
11:40:15 <hdaume> i just uploaded a few changes to cvs
11:40:26 <shapr> cool
11:40:29 <hdaume> (web page is http://www.isi.edu/~hdaume/htut/)
11:40:36 <pesco> Hehe, tricking people into work with cheap cvs accounts... ts ts
11:40:48 <pesco> ;-) j/k
11:40:49 <shapr> hah
11:41:03 <shapr> hdaume: does that have the latest from cvs?
11:41:20 <shapr> I can't seem to get papers/tutorials even with anonymous co
11:41:41 <hdaume> the dvi is the latest; i don't know about the ps and pdf :)...i'll rebuild them right now
11:41:48 <shapr> ok, thanks :-)
11:41:49 <pesco> shapr: Have you set up the ICPF cvs at haskell.org?
11:42:10 <shapr> pesco: nah, Andrew Bromage set it up on his server
11:42:19 <pesco> Ah
11:42:23 <shapr> hdaume: hey, what are you doing for ICFP 2002?
11:43:35 <hdaume> i don't have any plans
11:43:50 <hdaume> okay, it's all updated
11:43:58 <shapr> we're putting together a #haskell team
11:44:26 <shapr> mailing list: http://alicorna.net/mailman/listinfo/icfp-team
11:44:51 <shapr> Andrew Bromage, aka Pseudonym, is hosting the mailing list and the cvs repository.
11:45:07 <hdaume> has the task been annoucned yet?
11:45:23 <shapr> nope, it gets announced 72 hours before the deadline...
11:45:25 <shapr> that's the fun part =)
11:45:30 <hdaume> when's the deadline?
11:45:53 <shapr> there's also the lightning category, where your entry must be submitted in less than 24 hours after the task has been announced.
11:46:00 <shapr> http://icfpcontest.cse.ogi.edu/
11:46:09 <shapr> Contest entrants will have exactly 3 days, from Friday, August 30 beginning at 12:00 noon PDT through Monday, September 2 at 12:00 noon PDT. ("Lightning" entrants will have 1 day, until Saturday, August 31 at 12:00 noon PDT.)
11:46:31 <hdaume> ...i'll be out of town then
11:46:37 <shapr> aw :-(
11:46:45 <shapr> maybe next year :-)
11:47:13 <hdaume> yeah
11:48:14 <hdaume> remind me how to add files to teh cvs rep?
11:48:56 <pesco> cvs add file
11:49:14 <pesco> cvs commit -m "Added file"
11:49:48 <hdaume> got it :)
11:50:32 <pesco> (1) (error/warning) Error in `post-command-hook' (setting hook to nil): (void-variable imenu--index-alist)
11:50:39 <pesco> Has anyone else run into this problem with XEmacs?
11:51:08 <pesco> The message appears every time I the Haskell Doc mode is entered on a buffer.
11:51:25 <hdaume> nope, sorry...i'm off
11:55:16 <ibid> yes
11:56:43 <ibid> pesco: which version of xemacs?
12:00:33 <delYsid> module T where
12:00:33 <delYsid> data Action a = Square a
12:00:34 <delYsid>               | Sqrt a
12:00:34 <delYsid> doit :: Num a => Action a -> a
12:00:34 <delYsid> doit (Square x) = x*x
12:00:35 <delYsid> doit (Sqrt x) = sqrt(x)
12:01:01 <delYsid> t.hs:8:
12:01:01 <delYsid>     Could not deduce (Floating a) from the context (Num a)
12:01:01 <delYsid>     Probable fix:
12:01:01 <delYsid>         Add (Floating a) to the type signature(s) for doit
12:01:02 <delYsid>     arising from use of `sqrt' at t.hs:8
12:01:02 <delYsid>     In the definition of `doit': sqrt (x)
12:01:17 <delYsid> -- Is there a way around this? I dont understand the type inference there.
12:02:29 <ibid> sqrt returns a floating-point number, but Num a => a can also be an integer
12:02:42 <ibid> i think:-)
12:02:53 <ibid> the way around it depends on what you really want to do
12:05:18 <delYsid> well, if I type doit :: Floating a => Action a -> a
12:05:28 <delYsid> I no longer can use Int's with Square...
12:05:29 <delYsid> T> doit (Square (1 :: Int))
12:05:29 <delYsid> <interactive>:1:
12:05:29 <delYsid>     No instance for (Floating Int)
12:05:29 <delYsid>     arising from use of `doit' at <interactive>:1
12:05:31 <delYsid>     In the definition of `it': doit (Square (1 :: Int))
12:07:32 <ibid> can't you do doit :: (Num a, Floating a) => Action a -> b?
12:07:37 <ibid> bah
12:07:40 <ibid> can't you do doit :: (Num a, Floating b) => Action a -> b?
12:08:34 <delYsid> ok
12:08:44 <delYsid> but 2*2 isn't a float :)
12:09:12 <ibid> ok, then you might want to use type classes instead of generic polymorphism
12:09:46 <ibid> or...
12:10:17 <ibid> data Data = IntData Integer | FloatData Float (or whatever)
12:10:26 <ibid> and then have doit :: Action Data -> Data
12:10:43 <delYsid> ahh, ok
12:11:01 * delYsid is just playing with aspects of the language to get a feel for it
12:11:40 <ibid> sauna world championships
12:19:17 <pesco> ibid: You're taking part?
12:19:34 <ibid> no
12:19:40 <ibid> just was in the news
12:19:48 <dark> shapr: 3 days?  That's better than the two-hour contests I've seen, where the main issue was typing speed :)
12:19:57 <pesco> Bah.
12:20:50 <pesco> Which reminds me: Must produce a Gentoo ebuild for typespeed.
12:21:24 * dark played "The Typing of the Dead"
12:21:47 <dark> Unfortunately it didn't work right with Finnish keyboards, so some symbols couldn't be typed :)
12:22:53 <pesco> Oh. I don't have Umlauts on my keyboard anymore (I'm german).
12:23:18 <pesco> They take up too much room and I never type German anyway. :)
13:02:49 * shapr gets frustrated
13:19:17 <pesco> shapr, what's the matter?
13:22:51 <shapr> pesco: I'm still thinking in the wrong programming language
13:23:01 <pesco> Aww, which one?
13:23:04 <shapr> Python ;-)
13:23:25 <pesco> Hm, I don't know Python myself. Is it a good language?
13:23:33 <shapr> yah, it's beautiful...
13:23:49 <shapr> it has beauty much like Haskell, but in an entirely different direction.
13:23:49 <pesco> Mmm, nice.
13:23:58 <pesco> Oh.
13:24:17 <shapr> everything is bits of metal in Haskell...
13:24:21 <shapr> everything is bits of plastic in Python
13:25:40 <delYsid> [(x,y) --- x !- [1..5], y !- [x..7]]
13:25:52 <delYsid> Can anyone correct this, it got wrong through pstotext
13:25:53 <shapr> whoa, what's that?
13:26:07 <shapr> which doc?
13:26:19 <shapr> it looks like a list comprehension
13:26:21 <delYsid> YAHT
13:26:27 <delYsid> And it's a list comprehension
13:26:36 <pesco> [(x,y) | x <- [1..5], y <- [x..7]] must be the correct form.
13:26:40 <shapr> should probably be [(x,y) | x <- [1..5], y <- [x..7]]
13:26:47 <shapr> yah, what pesco said
13:26:55 <pesco> yah, what shapr said
13:27:23 <shapr> ;)
13:27:27 <delYsid> :), tnx
13:34:14 <delYsid> shapr: ok, YAHT is really nice.
13:34:18 <shapr> yay!
13:34:38 <shapr> have you finished reading it already?
13:34:43 <delYsid> yup
13:34:58 <shapr> cool
13:35:13 <shapr> do you have time to write up some suggestions/comments/ideas for changing it?
13:35:39 <delYsid> Hmm, right now the changes are obvious, fill the missing chaps :)
13:36:01 <delYsid> But the text which is there is good so far. I've spotted some typos, but woul prefer patch to ltx source for that...
13:36:25 <shapr> can you send me the list of typo?
13:36:28 <shapr> s
13:36:48 <shapr> or at least record them, and ask hdaume_afk about a login...
13:36:59 <shapr> or I can ask this jeff guy if he responds quickly.
13:37:15 <dandelion-> shapr: would you like to help me now? i have install ghc5-hopengl.deb but it seems that it's not set up in the way how the examples in the tutorial require it. do you use debian yourself? what have you done before having been able to compile the first example?
13:37:46 <shapr> dandelion-: yes, I do use debian, but I haven't tried ghc5-hopengl with the examples, I'll try that right now.
13:37:58 <delYsid> shapr: As I said, I'll correct the typos I see via latex diff, but I dont wanna collect them now in some clumsy way...
13:38:08 <shapr> delYsid: ok, cool.
13:42:27 <delYsid> data Day = Mo | Di | Mi | Do | Fr | Sa | So
13:42:31 <delYsid>            deriving (Eq,Ord,Enum,Show)
13:42:41 <delYsid> [Mo..So] -- shouldn't that work? It doesnt
13:43:00 <shapr> yup
13:43:03 <shapr> what happens?
13:43:07 <Heffalump> what type does [ .. ] notation work on?
13:43:12 <Heffalump> s/type/type class/
13:43:16 <delYsid> <interactive>:1: parse error on input `Mo..'
13:43:20 <shapr> Enum
13:43:34 <Heffalump> hmm.
13:43:50 <dandelion-> [Mo::Day..] <--- does that work?
13:43:59 <Heffalump> that wouldn't.
13:44:02 <Heffalump> oh, sorry
13:44:08 <Heffalump> ignore me
13:44:15 <shapr> dandelion-: that might work
13:44:24 <shapr> explicitly typing Mo as Day
13:44:26 <delYsid> It doesn't
13:44:30 <shapr> oh
13:44:31 <shapr> hm
13:44:41 <Heffalump> are you sure .. notation is based on Enum?
13:45:31 <delYsid> I remember reading it in ChilliX's comp-intro, lemme look
13:45:40 <shapr> Heffalump: I'm 97% sure it is.
13:45:49 * Heffalump reads the report
13:46:52 <shapr> ohhh
13:47:01 <shapr> delYsid: put spaces after Mo, and before So
13:47:04 <delYsid> comp-intro says it works that way
13:47:18 <shapr> does that fix it?
13:47:44 <delYsid> haha, spaces did it
13:47:46 <shapr> dandelion-: what error do you get when building hopengl examples??
13:47:57 <delYsid> Stunden> [Mo .. So]
13:47:58 <delYsid> [Mo,Di,Mi,Do,Fr,Sa,So]
13:47:59 <dandelion-> shapr: it cannot find the libs
13:48:12 <Heffalump> ah, yes, cunning
13:48:54 <Heffalump> we need Igloo, he's the Haskell syntax expert
13:49:05 <shapr> dandelion-: I'm having the same problem.
13:49:42 <shapr> dandelion-: "ghc --make -package GLUT TestGLUT.hs" should work...
13:50:28 * shapr tries manually inserting the settings from "ghc-pkg -s GLUT"
13:51:35 <shapr> dandelion-: if you try that command above, exactly what error do you get?
13:51:50 <dandelion-> shapr: i cannot try it right now, i would have to reboot first
13:51:55 <Heffalump> you don't need the space before So in either hugs or ghci, btw
13:51:58 <dandelion-> does it work for you?
13:52:02 <shapr> dandelion-: no..
13:52:36 <shapr> dandelion-: but, I had a hand compiled HOpenGL installed before, so if our error message are different, that would mean my ghc-pkg config could be a problem...
13:52:39 <shapr> at least, maybe..
13:53:09 <dandelion-> these are the things which drive me away from haskell
13:53:24 <shapr> yah, it's picky stuff.
13:53:47 <delYsid> zip [Mo .. Fr] [8*60..] ++ zip [Sa .. So] [0..]
13:54:07 <delYsid> hehe, can I use this to create a data Week =  somehow?
13:55:18 <delYsid> data Week = Day Int
13:55:27 <delYsid> and initialize it with the code above?
13:56:02 <delYsid> Or would one use some alist thing for that?
13:59:07 <dandelion-> shapr: pls tell me when and how you get it running. (i hope you go on trying with the deb pkg)
14:00:12 <shapr> I will
14:00:15 <shapr> I'm still trying.
14:01:18 <dandelion-> tx
14:01:20 <shapr> yikes
14:01:33 <shapr> ghci isn't happy with HOpenGL
14:01:50 <dandelion-> oh shit... nothing has changed
14:02:09 <shapr> hopefully ghc will be happier.
14:03:13 <shapr> hmm
14:03:35 <dandelion-> what?
14:03:56 <shapr> the problem is with "import GLUT"
14:04:23 <shapr> I would expect "ghc --make -package GLUT protoHOpenGL.hs" to work
14:06:25 <shapr> I think the GLUT module should be imported when it finds the GLUT.hi file... I think that's true.
14:08:59 <shapr> dandelion-: I suspect a bug
14:09:11 <shapr> dandelion-: if you run ghci
14:09:25 <shapr> and then ":set -package OpenGL"
14:09:26 <shapr> it works
14:09:36 <shapr> but with ":set -package GLUT" ghci crashes
14:09:49 <shapr> I'll file a bug on the debian package.
14:10:25 * shapr looks at the mailing list archives
14:10:32 <dandelion-> i hope you get any response
14:10:42 <shapr> me too :-)
14:13:17 <shapr> dandelion-: have you seen the HOpenGL tutorial?
14:13:53 <dandelion-> not thoroughly, but i have taken a first look at it. why?
14:14:24 <shapr> I was just wondering if you already knew about it :-)
14:16:05 <dandelion-> why do you like python?
14:17:01 <shapr> because it's easy to learn, and yet very powerful, and it's good at getting stuff done.
14:17:29 <dandelion-> we can't say that about haskell?
14:17:31 <dandelion-> -?
14:18:02 <shapr> most people I've spoken to think that Haskell is harder to learn than Python.
14:18:08 <dandelion-> exactly
14:18:18 <shapr> I think that might be because I don't know any Functional Programmers though.
14:18:31 <dandelion-> maybe they are just right?
14:18:32 <shapr> Heffalump said that Python seems harder than Haskell to him.
14:18:37 <shapr> That's possible.
14:18:38 <Heffalump> but I would :-)
14:19:24 <dandelion-> why not give up on the FP paradigm altogether? what is it that keeps us tied to it?
14:19:29 <shapr> so the question is, if functional programming were taught first, would Python be hard, and Haskell easy?
14:19:35 <shapr> dandelion-: heh, not tied ;-)
14:19:38 <dandelion-> i find all these "why FP is superior" articles not convincing
14:19:49 <dandelion-> zillions of developers can't be wrong
14:19:53 <shapr> yes they can
14:20:02 <shapr> look at how many programmers use windows.
14:20:15 <shapr> most people are lemmings, and don't make choices for themselves.
14:20:29 <dandelion-> shapr: have you ever used the Monad and MonadPlus libs?
14:20:36 <shapr> I've used Monads a bit, yes.
14:20:40 <shapr> have you used them?
14:20:50 <dandelion-> i have used Monadic IO, but never the libs
14:21:05 <dandelion-> i am curious what kind of brainfuck awaits me there
14:21:07 <shapr> heh
14:21:17 <shapr> monads are elegant once you understand them :-)
14:21:23 <shapr> getting to that point was hard for me.
14:22:17 <dandelion-> are they elegant? or useful?
14:22:27 <dandelion-> shapr: do you really and honestly find them useful?
14:22:32 <shapr> yes, very much so.
14:22:46 <dandelion-> and... when you use them, do you ever reach a point where you forget the imperative thinking altogether?
14:22:53 * shapr considers that
14:22:56 <dandelion-> i mean, that would be the point of it, wouldn't it?
14:23:03 <dark> I thought the point of Monads was to use imperative thinking?
14:23:26 <dandelion-> dark: maybe it is. but if, then why do we need FP at all?
14:23:43 <shapr> FP is the opposite of imperative
14:23:44 <dandelion-> dark: i mean, if we want to program imperatively, then why not use imperative languages?
14:23:45 <dark> dandelion: I do it for the laziness :)
14:24:09 <shapr> Monads give you imperative power in a purely functional language.
14:24:41 <shapr> well, if it's about wanting...
14:24:48 <shapr> I want to program in Haskell =)
14:24:53 <dark> dandelion: I also expect that functional programming has potential to be faster (execution) than imperative on modern architectures.
14:25:09 <dandelion-> i wonder if a 6-year-old can be made understand what a monad is
14:25:17 <shapr> yes, I think so.
14:25:23 <shapr> I think it would be easier for a six year old.
14:25:30 <hornby> Can someone explain a monad in 6-year-old terms?
14:25:40 <shapr> monads aren't complicated, they're just far away from procedural.
14:25:47 <dark> I don't have any 6-year-olds handy to try it with.  I've met 14-year-olds who couldn't understand the concept of a variable, though.
14:25:48 <shapr> hornby: sure, monads are wormholes.
14:26:07 <hornby> shapr: portals, like?
14:26:13 <shapr> yes, exactly.
14:26:41 <hornby> dark: most 14 year olds can
14:26:53 <hornby> shapr: so if a monad is a wormhole, whats FP?
14:27:02 <shapr> an equation.
14:27:17 <hornby> so a monad is a wormhole out of an equation?
14:27:24 <Heffalump> monads the appropriate algebraic abstraction for defining an imperative program as an equation.
14:27:24 <shapr> yes.
14:27:28 <Heffalump> s/the/are the/
14:27:45 <hornby> Heffalump: I don't think a 6 year old would follow that
14:27:50 <Heffalump> this is true.
14:27:55 * shapr grins
14:28:13 <Heffalump> but I think knowledge of what an equation and an imperative program are is pretty much a prerequisite
14:28:16 <hornby> I still think I'm missing something about monads. 
14:28:24 <shapr> most of the six year olds I knew in the USA watched Star Trek...
14:28:27 <Heffalump> and a 6 year old that understood them might follow that too.
14:28:31 <hornby> Because they seem simple ... but everyone makes such a big deal about them
14:28:47 <shapr> hornby: they are simple
14:28:59 <shapr> just like continuations are very simple
14:29:19 <shapr> but the current programming culture assumes certain constants
14:29:31 <shapr> and continuations and monads are outside of that culture.
14:29:43 <hornby> hm
14:30:02 <hornby> continuations are simple ... but they can be used in exotic ways?
14:30:05 <shapr> right!
14:30:11 <hornby> maybe its just that these tools are unfamiliar
14:30:14 <shapr> do you know continuations?
14:30:35 <hornby> I'm not sure. I think so :)
14:30:45 <shapr> want me to explain them to you? =)
14:30:57 <hornby> or I could explain them to you? 
14:31:00 <shapr> yes!
14:31:02 <shapr> much better idea
14:31:05 * hornby thinks
14:31:48 <hornby> hrm
14:32:13 <hornby> nevermind, you want to explain it? :)
14:32:17 <shapr> sure :-)
14:32:27 <shapr> function calls are not atomic
14:32:31 <shapr> they can be broken into two pieces
14:32:34 <shapr> the call, and the return
14:32:37 <hornby> right
14:33:00 <shapr> a continuation is something like a closure
14:33:11 <shapr> you stop things right where they are
14:33:18 <shapr> like, half way through a function
14:33:43 <shapr> then you can edit values in that function, and restart the function
14:33:48 <Heffalump> errrm.
14:33:59 <shapr> ?
14:34:08 <Heffalump> you can edit values in that function?
14:34:19 <shapr> well, with first class continuations you can
14:34:51 <shapr> nb: this is based on my experience with Stackless Python which had first class continuations
14:35:19 <hornby> brb
14:35:36 <shapr> Heffalump: is your experience with continuations different?
14:36:09 <Heffalump> hmm, I could be confused, but it doesn't strike me as a natural thing to do with them
14:36:34 <shapr> ok, quoting from: http://c2.com/cgi-bin/wiki?ContinuationsAndCoroutines
14:36:48 <shapr> A continuation is a pointer to an instruction within a stack frame. Holding this pointer keeps the frame from being garbage collected. This pointer can be used to return control to the stack frame.
14:37:05 <shapr> that's a more technical description
14:37:33 <shapr> in effect, you save everything that's required to restore the function as it was when you saved it.
14:37:59 <shapr> in Stackless, you can also call a saved continuation
14:38:06 <dark> The explanation that made the most sense to me was, you can see the "return" as a function that does something, namely it evaluates what the rest of the program does if this function returns the argument of the "return".  A continuation is a "closure" for that "function", you can use it to "call" that return action.  It makes more sense in a language which has an actual return statement :)
14:38:39 <shapr> oh that's an excellent explanation.
14:38:42 <shapr> far better than mine!
14:38:43 * hornby thinks gotos
14:38:46 * shapr saves that
14:38:48 <shapr> hornby: exactly!
14:38:51 <shapr> it's goto
14:39:05 <hornby> but ... ?>
14:39:09 <dark> shapr: I hope you'll improve the grammar if you reuse it :-)
14:39:46 <shapr> hornby: there isn't really a but
14:39:47 <delYsid> Is there something like filter-only-first
14:39:52 <shapr> delYsid: huh?
14:39:59 <dandelion-> i understand nothing of the above because i have abandoned all imperative thinking. could you explain it to a functional kid?
14:40:13 <hornby> darks explanation just seems to mean that there are multiple places you can do "return" ?
14:40:13 <shapr> dandelion-: you are evolved far beyond me ;-)
14:40:20 <delYsid> I'm trying to iterate over a list and return the first element where f yields True
14:40:42 <shapr> delYsid: what about using until?
14:40:44 <dark> hornby: More than that, you can pass the option to return to other functions, store it in data structures, etc.
14:40:58 <dandelion-> head (filter list)
14:40:59 <shapr> takeUntil = (take . until) I think
14:41:05 <dandelion-> oops
14:41:07 <shapr> oh, I like dandelion-'s solution better
14:41:08 <dandelion-> sorry :)
14:41:11 <hornby> mmm bbl
14:41:13 <hornby> thanks
14:41:27 <shapr> I keep forgetting that everything is lazily evaluated in Haskell
14:41:35 <dark> dandelion: My explanation was an attempt to do just that :)
14:42:02 <shapr> hi DorkPunk
14:42:06 <DorkPunk> Greetings, shapr.
14:42:10 <shapr> how ar ya?
14:42:19 <DorkPunk> shapr - Just fine, thank you.  And yourself?
14:42:29 <shapr> I'm doing well.
14:42:34 <dark> shapr: I keep forgetting that too :)  It warps all my efficiency-thinking.
14:42:55 <shapr> dark: yah, as soon as I figure it out, all of my Python and Java code will start sucking hard
14:43:03 <DorkPunk> Has anybody tried to write an operating system for i386 in Haskell?  Is it possible?
14:43:07 <shapr> DorkPunk: do you need info on Haskell? any questions I can help you with?
14:43:20 <DorkPunk> shapr - I know a little bit of Haskell, but I am most proficient in C.
14:43:25 <dark> DorkPunk: Well Haskell requires garbage collection, that can make it difficult.
14:43:44 <DorkPunk> shapr - I am writing an operating system.  I am trying to figure out if it is possible to write any pieces in Haskell.
14:43:57 <shapr> yes, it's possible.
14:43:58 <Heffalump> yes, all of it :-)
14:44:06 <DorkPunk> Does Haskell have any inline assembly capabilities?
14:44:10 <shapr> yup
14:44:14 <delYsid> dayParser :: Parser Day
14:44:15 <delYsid> dayParser = head (filter (\x -> do try (string (show x)); return (x)) [Mo .. ])
14:44:17 <dark> You can't even write all of an operating in C, how could you possibly do it in Haskell?
14:44:18 <shapr> GHC does native code generation
14:44:24 <delYsid> -- I'm confused, how is this supposed to work?
14:44:37 <shapr> also, GHC is more like a compiler assembly kit, so you can swap out bits, and rewrite bits.
14:44:47 <Heffalump> delysid: it seems to be missing some { }s
14:44:53 <DorkPunk> And is the Hugs compiler capable of compiling code to start running at a certain memory address (similar to the ld scripts, for C)?
14:44:56 <Heffalump> though I could be wrong
14:45:00 <Heffalump> Hugs isn't a compiler
14:45:09 <Heffalump> it's an interpreter
14:45:15 <delYsid> Heffalump: I think the {} arent missing...
14:45:21 <DorkPunk> Heffalump - Ok, what is a good Haskell compiler for Linux, then?
14:45:32 <Heffalump> not sure about GHC, you'd probably need some C stubs to do the really low-level stuff
14:45:35 <Heffalump> GHC
14:45:42 <Heffalump> delysid: errm, ok...
14:45:46 <DorkPunk> Heffalump - Ok.  I will look into it.
14:46:04 <DorkPunk> OS development is very easy in C...  But I would like to try it in Haskell, because I think that Haskell is a much "prettier" language.
14:46:16 <delYsid> I want to parse a string into and return the appropriate type
14:46:32 <delYsid> So : parse dayParser "" "Di" should return
14:46:34 <delYsid> Di
14:46:38 * Heffalump would recommend using C for all the low-level or peformance critical sections
14:46:45 <Heffalump> and Haskell for the high-level stuff
14:46:50 <shapr> delYsid: can you use "read" for that?
14:47:00 <DorkPunk> Heffalump - Can GHC create elf binaries?
14:47:07 <dandelion-> DorkPunk: if you succeed to write an operating system in haskell, the whole haskell community, which isn't very large, will adore you
14:47:33 <DorkPunk> dandelion- - I know a lot about i386, and I know a lot about C...  But only a little about Haskell.  But Haskell is by far my favorite language.
14:47:45 <delYsid> shapr: ahem, yes.  but I'm inside Parsec... so...
14:47:55 <delYsid> using read would give away the parsing error message, wouldnt it?
14:48:03 <Heffalump> DorkPunk: yes
14:48:18 <Heffalump> you shouldn't use read inside Parsec, no
14:48:32 <dandelion-> DorkPunk: still i think it could be very difficult... when you are, pls notify the public
14:48:37 <dandelion-> when you are done, i mean
14:49:08 <DorkPunk> dandelion- - Yes.  I will notify the public, even if I only write it in C.  :-)
14:51:19 <delYsid> Well, I hope my floods dont anoy already, but here I have a ver for better understanding what I want.
14:51:21 <delYsid> dayParser :: Parser Day
14:51:21 <delYsid> dayParser = do try (string "Mo"); return (Mo)
14:51:22 <delYsid>           <|> do try (string "Di"); return (Di)
14:51:22 <delYsid>           <|> do try (string "Mi"); return (Mi)
14:51:22 <delYsid>           -- ...
14:51:26 <delYsid> --dayParser = head (filter (\x -> do try (string (show x)); return (x)) [Mo ..])
14:51:39 <delYsid> The commented version tries to do the above in a better way, any ideas how to fix it?
14:54:21 <Heffalump> singleDayParser (str,day) = do try (string str) ; return day
14:54:55 <Heffalump> oops, duh
14:55:07 <Heffalump> singleDayParser day = do try (string (show day)) ; return day
14:55:08 <delYsid> str is actually (show day)
14:55:12 <Heffalump> yeah
14:55:27 <Heffalump> dayParser = foldr1 (<|>) $ map singleDayParser $ [Mo ..So]
14:56:00 <Heffalump> I'm not quite sure what you were trying to do with head and filter above, but what I wrote is equivalent to your original definition of dayParser
14:56:17 <delYsid> wow, now I need to reunderstand $
14:56:50 <Heffalump> dayParser = foldr1 (<|>) (map singleDayParser [Mo ..So])
14:56:52 <Heffalump> is equivalent
14:57:17 <Heffalump> you could inline singleDayParser using \ like you did earlier if you prefer, too
14:57:37 <delYsid> or with where I suppose?
14:58:00 <delYsid> foldr1? What does the 1 mean there?
14:58:18 <Heffalump> you know what foldr does, right?
14:58:35 <delYsid> It's right-associative version of fold
14:58:44 <Heffalump> yeah
14:59:03 <Heffalump> it starts with a "seed" and applies an operation to the elements of the list and the seed
14:59:07 <Heffalump> so foldr f e [] = e
14:59:14 <Heffalump> foldr f e (x:xs) = f x (foldr f e xs)
14:59:43 <Heffalump> so foldr on any (finite) list will eventually make use of the value e
14:59:58 <Heffalump> foldr1 is like foldr but it doesn't work on empty lists and it doesn't require an e
15:00:03 <Heffalump> foldr1 f [x] = x
15:00:11 <Heffalump> foldr1 f (x:xs) = f x (foldr1 f xs)
15:00:20 <delYsid> ahh, thanks, got it!
15:22:39 <delYsid> Is there any way around the Maybe type of lookup?
15:22:47 <delYsid> I just need the return value itself, how to get that?
15:23:36 <Heffalump> fromJust IIRC
15:24:11 <Heffalump> yeah, but you'll need to import Maybe
15:24:13 <delYsid> fromJust not in scope...
15:24:21 <delYsid> ahh
15:24:26 <Heffalump> and if the item isn't in your list, then your program will terminate with an error
15:29:27 <dark> I don't understand the "Just" name.  "Indeed" would have been more logical.
15:38:51 <delYsid> Well, http://212.17.102.236/Stunden.hs, for my first haskell code that actually does something!
15:39:02 <delYsid> comments welcome, I'm sure it's ugly as hell...
15:46:24 <dandelion-> it's very imperative
15:46:31 <delYsid> grrr :)
15:46:57 <delYsid> well, any idea how to functionalize it?
15:47:42 <dandelion-> i have not yet figured out what your task was
15:47:56 <dandelion-> i don't understand your descriptive comment above
15:52:30 <dandelion-> Fr 14.06.: 09:30-17:20 -00:10 <--- what is this supposed to mean?
15:52:50 <delYsid> Fr is a day (friday)
15:52:59 <delYsid> nn.nn.: is day.month
15:53:00 <dandelion-> okay, i figrued
15:53:05 <delYsid> and the rest are time-intervals...
15:53:19 <dandelion-> "-00:10" <--- what is this?
15:53:32 <delYsid> Its the one thing the code currently doesnt handle :)
15:53:47 <dandelion-> i can't handle it, either
15:53:53 <delYsid> It's the difference from the amount of time one is supposed to work at that day.
15:53:55 <dandelion-> even me, a human, cannot decode it
15:54:23 <delYsid> See, Fr is a normal weekday, so one needs to work 8 hours.
15:54:43 <dandelion-> let me guess: does it mean that you are supposed to work 8 hours, and "-00:10" means that you have worked 10 mins too little?
15:54:45 <delYsid> If one works 09:00-16:00,17:00-18:00, the result would be 00:00
15:54:53 <dandelion-> i see
15:55:37 <delYsid> And thats all workday is about, it returns this balance...
16:00:46 <dark> delysid: Hmm... instead of the zip and lookup stuff, I would recommend something like:
16:00:47 <dark> towork :: Day -> Minutes
16:00:47 <dark> towork day | day `elem` [Mo .. Fr] = 8 * 60
16:00:47 <dark> towork _ = 0
16:01:33 <Heffalump> something written with a monadic parser library is bound to look fairly imperative
16:01:34 <dark> Having   | otherwise = 0   might be more elegant than the wildcard match :)
16:03:37 <dark> A helper function workday :: Day -> Bool might make it nicer to read.
16:04:20 <dark> Oh, I guess the "workday" name is already taken :)
16:07:51 <pesco> I don't even feel the monadic code to look so imperative.
16:08:26 <pesco> Although it is.
16:19:18 <delYsid> dark: thanks for the sugg.
17:25:54 <hornby> [Mo .. Fr] works?
17:26:26 <hornby> I guess Mo = 1, etc?
17:26:44 * hornby withdraws his question
17:30:14 <delYsid> http://212.17.102.236/Stunden.hs (updated)
17:31:49 <delYsid> hornby: [Mo .. Fr] actually really does work.  It's deriving from Enum
17:35:14 * dandelion- is looking forward to HaskellOS
17:54:04 <Heffalump> it's deriving Enum, not deriving from Enum
17:54:25 <Heffalump> (as in an instance of the Enum class is being automatically derived for it)
18:14:48 * rjljr waves.
20:22:16 * ChilliX is back (gone 00:00:04)
