00:39:17 * shapr awakens
00:52:39 <Jii> good morning to shae
00:53:31 <shapr> hyv‰‰ huomenta
00:53:51 <Jii> :)
00:53:52 <shapr> kuis kulkee
00:53:59 <Jii> hyvin kulkee ;-)
00:54:02 <Jii> kuis sulla
00:56:25 <hornby> is that finnish?
00:56:33 <Jii> yes
00:56:42 <Jii> spoken finnish, though
00:56:51 <hornby> looks written to me
00:56:53 <ibid> informal finnish
00:57:09 <hornby> how different is formal finnish from informal finnish?
00:57:13 <ibid> (everything in irc is written:-)
00:57:24 <ibid> hornby: noticably but not hugely
00:57:36 <hornby> same roots, different endings?
00:57:50 <hornby> shapr: you didn't sleep very long?
00:57:51 <ibid> hornby: more than that
00:58:12 <Jii> written-spoken finnish ;-)
00:58:31 <Jii> ibid, how's your thesis doing, ready?
00:58:56 * ibid is battling fixpoints currently
00:59:08 <ibid> no, it's not finished yet
00:59:11 <hornby> ibid: whats your thesis on?
00:59:54 <ibid> a certain formal method
01:00:17 <hornby> what method?
01:00:22 <ibid> it describes the method and a starting point for an independent reimplementation
01:00:25 <ibid> B
01:00:45 <hornby> of?
01:01:14 <ibid> of?
01:02:16 <shapr> hornby: what's very long?
01:02:26 <Jii> You read a scroll of Haskell code. You feel purified.
01:02:31 * shapr laughs
01:02:41 <hornby> shapr: well it was less than 6 hours
01:02:51 <hornby> ibid: reimplentation of what? 
01:02:57 <shapr> Jii: actually, today is "write inline SQL into JSP pages" day.
01:03:08 <ibid> hornby: the B method (or rather, it's tool support)
01:03:12 <Jii> shapr, uh :)
01:03:31 <shapr> hornby: I think I got at least six hours... 6.5 or so ... seems to be most efficient for me.
01:04:14 <hornby> shapr: Oh, nevermind, I can't add. 
01:04:23 <hornby> ibid: oh
01:05:09 <shapr> Jii: what are you working on today?
01:06:19 <Jii> shapr, school stuff mostly, i'll dive into our fine library soon now
01:06:52 <shapr> yay library
01:38:20 * shapr tries to write purely functional JSP pages.
01:44:12 <shapr> hey cool... jadrian wrote an x-symbol-haskell.el
02:18:37 <shapr> hei eivuokko
02:19:02 <eivuokko> hiya
02:19:32 <shapr> learned anything cool lately?
02:20:15 <eivuokko> How lately? ;)  I've been mainly comparing c++ template engine against functional languages.
02:20:50 <shapr> how's that comparison going?
02:21:12 <shapr> I saw an article on lambda.weblogs.com that claims that C++ templates are a functional language of some power.
02:21:17 <eivuokko> Depends how you look at it ;)  I haven't got any new innovations really.
02:21:31 <eivuokko> c++ template engine is compiletime, ehm pure functional language.
02:21:58 <shapr> I know very little about C++, can you explain?
02:22:37 <Heffalump> is it really a pure functional language?
02:22:45 <shapr> hey Jerub
02:24:47 <eivuokko> I dunno what should I say about c++ templates here ;)  It's lazy, it has not side effects (except compiler diagnostics), everything is done through recursion and pattern matching normally.
02:25:09 <Heffalump> oh, ok
02:26:43 <eivuokko> Maybe most impressive piece of work : http://www.mywikinet.com/mpl/  that even contains (limited) lambdas.
02:26:51 <Jerub> heya shapr.
02:29:40 <eivuokko> Btw, about the lazyness, again.  Is it specified that result of function call is not evaluated more than is neccesary by the use of return value?  I know it should not make semantic diffrence, but I would like just to know for the sake of efficiency (atleast once) ;)
02:30:22 <Heffalump> I don't think it's specified
02:30:30 <shapr> I think that things can be returned and still not evaluated.
02:30:32 <Heffalump> Haskell isn't actually specified to be a lazy language, IIRC, it's just "non-strict"
02:32:01 <Jerub> Isn't the difference between laziness and eagerness, that a lazy algorithm will always find the solution?
02:32:22 <Jerub> I had weird thoughts earlier about how to use a language based, non-textual editor.
02:32:38 <Jerub> s/use/create/
02:32:40 <Heffalump> syntax-directed, you mean?
02:32:49 <Jerub> uhh, AST based?
02:32:57 <Jerub> yeah, syntax-directed.
02:33:10 <Heffalump> it's been done (several times) before
02:33:14 <Jerub> oh I know.
02:33:21 <shapr> Heffalump: tell me more...
02:33:26 <shapr> I've been thinking about the same thing.
02:33:28 <Jerub> I'm doing a subject with some guys whose major research topic is language based editors.
02:33:30 <Heffalump> shapr: well, IP had one
02:33:34 <Jerub> Gandalf does it.
02:33:35 <shapr> hmm
02:33:35 <Heffalump> jerub: ah, ok :-)
02:33:39 <shapr> what's gandalf?
02:33:57 <Jerub> I have no idea, its just been mentioned in the subjject alot.
02:33:59 * Jerub laughs
02:34:03 <shapr> ok :-)
02:35:41 <Jerub> but my idea was basically, instead of making a syntax directed/ast based editor -> and instead of using symbol names.
02:35:50 <Jerub> Doing stuff like.
02:36:37 <Jerub> Function, 2 inputs, labelled times_and_square
02:36:58 <Jerub> you take a 'times' operator, and put the two inputs into it.
02:37:24 <shapr> ?
02:37:27 <Jerub> make another * operator, and put the previous times operator in it twice.
02:37:29 <Jerub> hrhm.
02:37:32 <Heffalump> so a graphical thing, basically?
02:37:35 <Jerub> might have to draw a diagram.
02:37:52 * Jerub gimps
02:41:14 * Jerub isn't doing so well with the visualisation.
02:41:27 <shapr> what do you have so far?
02:42:24 * Jerub has to rethink for a moment.
02:42:44 <Jerub> actually, my major conceptual issue is, loops are impossible.
02:42:50 <Jerub> thus a functional language is more suited to this.
02:43:26 <shapr> loop are impossible in what context?
02:43:34 <Heffalump> what about recursion, though?
02:44:38 <Jerub> shapr: the way I'm visualising this, is an enviroment with the only ''variables'' being function inputs.
02:45:06 <Jerub> and to do something to those variables, you just ''wrap'' them in something.
02:45:37 <Jerub> like a * operator, would wrap 2 subvariables.
02:46:05 <Jerub> then you just drag and drop (copy or move) that construct around.
02:46:28 <Jerub> and the translation to variable names/textual code is done by the enviroment rather than the user.
02:47:09 <Jerub> I'm just having issues with tree based editors basically trying to map directly to the textual language, when you're probably better off just typing.
02:47:20 <Jerub> I think I'm ranting
02:47:29 <shapr> it's an interesting rant.
02:47:52 * Jerub laughs.
02:47:59 <Heffalump> I think tree based editors offer more advantages for the compiler and for version control systems than for the initial coding
02:48:13 <Heffalump> they can also make editing code quite nice, once you've got the hang of them
02:49:09 <shapr> Jerub: one of your points there seems to be that variables should be named almost as an afterthought...
02:49:10 <Jerub> I just got around a conceptual hurdle! all functions are objects! thus calling any function is merely a matter of summoning the language concept 'call', with the function as the first argument.
02:49:31 <Heffalump> why?
02:49:53 <Jerub> shapr: Why do we need variables? without them, the enviroment can refactor our code better than we can ;)
02:50:28 <shapr> Heffalump: have you used tree based editors?
02:50:35 <Heffalump> yes, IP had one
02:50:43 <shapr> I'd like to use one.
02:51:02 <Jerub> I've seen a language based editor for a workflow modelling language, but that doesn't count.
02:51:06 <Jerub> its not programming, its management.
02:52:07 <shapr> afaiu, the basic structure of a tree based editor is an incremental parser hooked into your buffer, right?
02:52:26 <Heffalump> it depends on how it's implemented
02:52:55 <Heffalump> there might not be any parser at all, in the sense that you might have to hit different keys to indicate where you are moving in the syntax tree as you go
02:53:11 <shapr> ah, direct syntax tree editing.
02:53:16 <shapr> that sounds addictive.
02:53:47 <Heffalump> I dunno about addictive
02:53:58 <Jerub> shapr: thats a language based editor - an ast editor takes it a step further and doesn't use text.
02:54:14 <Jerub> ast == abstract syntax tree.
02:54:17 <shapr> I think that's what Heffalump was talking about, directly editing the ast
02:54:30 <Jerub> shapr: 'uq star' is a language based editor being developed by some postgrads
02:54:35 <Jerub> it does some things really really really well.
02:54:37 <Jerub> like segfault.
02:54:39 <shapr> heh
02:55:07 <shapr> I've been looking at the stuff on http://www.program-transformation.org/
02:55:25 <shapr> emacs has semantic bovinator, and it's very powerful...
02:55:35 <Jerub> semantic bovinator?
02:55:53 <shapr> it's a parser generator
02:55:56 <shapr> written in elisp
02:56:21 <shapr> it's not quite to the point of allowing refactoring, but it could be with a bit of work.
02:56:51 <shapr> I'd like to have an editor that is at least ast aware
02:57:08 <shapr> that would give me nice autocomplete features, quick access to documentation
02:57:28 <shapr> hopefully even refactoring browser abilities.
02:57:39 <shapr> Heffalump: what kind of stuff did the IP editor have?
02:57:45 <shapr> anything unusual or extra spiffy?
02:58:17 <shapr> I must try some tree based editors.. any freely available ones that can give me a feel for it?
02:58:28 <Jerub> shapr: Care to help me write one ?
02:58:46 * Heffalump can't really remember too well
02:58:57 <shapr> Jerub: that's a very tempting idea....
02:59:40 <Jerub> shapr: One of my other ideas is actually dependancy.
02:59:40 <shapr> Jerub: you have my interest piqued at the very minimum
03:00:05 <shapr> last night I was reading about the HSX haskell source transformer written in stratego-language
03:00:06 <Jerub> being able to say on the very highest level 'these two branches must complete, but I don't care if they're done concurrently'
03:00:27 <shapr> purely functional code has that promise already...
03:00:43 <shapr> you *could* transparently parallelize Haskell.
03:01:04 <shapr> though at the moment, I'm more interested in Chilli's Nested Data Parallelism stuff in the Nepal project.
03:01:29 <Jerub> shapr: yes, but could you compile haskell to python, c++ or java?
03:01:32 <shapr> Jerub: look at this: http://c2.com/cgi-bin/wiki?AdvantagesOfFp
03:01:35 <delYsid> woha, that *was* a netsplit!
03:01:40 <shapr> re delYsid
03:02:00 <Jerub> shapr: I give that to people who want to know what haskell is when I'm ranting.
03:02:03 <shapr> Jerub: sure, ghc can already compile to C, and there's work on compiling to java bytecode.
03:02:11 <shapr> Jerub: heh, excellent :-)
03:03:03 <delYsid> No instance for (Fractional Int)
03:03:03 <delYsid> arising from use of `/' at /home/mlang/haskell/Stunden.hs:29
03:03:03 <delYsid> In the first argument of `show', namely `(m / 60)'
03:03:06 <delYsid> hmmmmm!
03:03:21 <delYsid> shapr: Since I made a newtype out of my minutes, I only have problems.
03:03:26 * Jerub sighs
03:03:35 <Jerub> how do I get a listing of a cvs server?
03:03:39 <Heffalump> shapr: the work on going to Java bytecode is incomplete and not being worked on, AIUI
03:03:45 <Heffalump> jerub: listing of what modules it has?
03:03:48 <shapr> oh
03:04:01 <Jerub> actually, what cvs shares it has.
03:04:07 <Heffalump> cvs "shares"?
03:04:11 <shapr> delYsid: suckage, going to switch back to a type synonym for an early release?
03:04:17 <Heffalump> shapr: there's work on a .NET backend but I think that's been discontinued too
03:04:24 <shapr> hmm
03:04:30 <shapr> why?
03:04:36 <Heffalump> delysid: well, Int isn't fractional :-)
03:04:43 <Heffalump> shapr: they got bored, AIUI :-)
03:05:03 <shapr> I can understand that.
03:05:11 <delYsid> Heffalump: Any idea how I can teach my Minutes newtype to be dividable?
03:05:15 <Heffalump> delYsid what type is m?
03:05:29 <Heffalump> you need to make it an instance of Fractional
03:05:36 <delYsid> shapr: nah, it's a good sample on class instance overloading when it's finished :)
03:06:05 <delYsid> newtype Minutes = Minutes Int
03:06:17 <Heffalump> and what do you want the result type of m / 60 to be?
03:06:40 <delYsid> an Int
03:06:52 <Heffalump> so you want it to be rounded?
03:07:01 <delYsid> yeah
03:07:07 <Heffalump> look at the div function then, instead of /
03:07:12 <Jerub> No dice.
03:07:16 <delYsid> In fact, I do m / 60 ++ m `mod` 60
03:07:25 <Heffalump> errm, why?
03:07:30 <Jerub> Theres an anon cvs server I'm trying to login to, but I don't have the path to the share
03:07:40 <Heffalump> jerub: oh, I don't think you can do anything then
03:08:23 <Heffalump> delysid: and you'll have to make an instance of Integral for Minutes
03:08:47 <Heffalump> which should be easy, you just take off the constructor, call the instance for Int, and put the constructor back on again
03:09:05 <Heffalump> so for example (Minutes n) `div` (Minutes m) = Minutes (n `div` m)
03:10:14 <dark_> That reminds me, is it defined anywhere what Haskell does with x `mod y if x is negative?
03:11:31 <Heffalump> umm, I think there was a discussion on the list about this
03:11:41 <Heffalump> check the latest version of the library report
03:12:16 <dark_> Ah, it's in 6.4.2 :)
03:12:17 <dark_> (x `div`  y)*y + (x `mod` y) == x
03:12:24 * dark_ does some arithmetic.
03:14:16 <dark_> Looks like I need to choose between `mod` and `rem` for this.  Now I wonder which one I actually want :)
03:14:50 * Jerub thinks for a moment.
03:15:20 <Jerub> no, Web Applications are unsuited to tree based programming.
03:15:39 <shapr> really?
03:16:12 <Jerub> shapr: uhh, a web application enviroment as the editor, not as the target projejct.
03:16:18 <shapr> oh
03:16:45 <dark_> Such as posting example code to kuro5hin?
03:17:08 <dark_> I think someone made an emacs mode for that :-)  It turns indentation into &nbsp; sequences.
03:17:14 <Heffalump> using a web application environment to write code strikes me as a silly idea anyway
03:17:14 * Jerub has a sigh of relief.
03:17:19 <Jerub> my tax return jjust came in.
03:17:34 * Jerub pays off the credit card.
03:17:55 <dark_> Jerub: So the tax man gives you money?  How do you arrange that?
03:18:12 <Jerub> dark_: I pay too much tax during the year due to a clerical error.
03:18:24 <Jerub> which I've yet to fix.
03:18:30 <Heffalump> what's the clerical error?
03:18:34 <dark_> Jerub: Think of it as delayed savings? :-)
03:18:37 <Heffalump> just that they over-withhold?
03:18:46 <Jerub> dark_: yes, I do.
03:18:58 <Jerub> Heffalump: well, its not really a 100% clerical error.
03:19:07 <Jerub> its a beucratic doing.
03:19:27 <Heffalump> is it that you only work a few months of the year?
03:19:37 <Jerub> I have to fill out forms and stuff to make a change to a checkbox I had to tick because I was working two jobs.
03:19:42 <Heffalump> ah
03:19:53 <dark_> "clerical error" always makes me think of people in chain mail accidentally casting 'cause serious wounds' on a companion.
03:19:59 <Jerub> When you work 2 jobs, one pays attention to the tax threshold, the other doesn't.
03:20:03 * Heffalump remembers getting a nice refund after working in the US for a few months
03:20:13 <Heffalump> dark_: lol
03:21:36 <Jerub> I stopped working the previous job a week after starting at the next.
03:21:43 <Jerub> I never thought I had to fix it.
03:22:14 <dark_> Heh, the finnish approach is the opposite... one job withholds the normal percentage, the other withholds an extra-high one just to be sure.
03:22:18 <delYsid> I there any easy way to 0-pad a Int?
03:22:32 <dark_> delYsid: when printing?
03:22:38 <delYsid> So, 2 ) "02"
03:23:13 <delYsid> dark_: I'd use it in (show ... ++ show ...)
03:24:21 <shapr> I think I saw a Haskell printf implementation on the mailing list recently
03:25:16 <dark_> delYsid: I don't see any predefined way.  You could change the Show instance for your Minutes type fairly easily :)
03:25:18 <Heffalump> yeah, there was one
03:25:30 <delYsid> zeropad :: Int -> String
03:25:30 <Heffalump> I think it used type classes cunningly
03:25:31 <delYsid> zeropad x | x < 10 = "0" ++ show
03:25:31 <delYsid>           | otherwise = show x
03:25:36 <delYsid> That appears to work.
03:26:04 <dark_> You forgot an x at the end of the second line?
03:26:06 <shapr> I just found Printf.hs locally, want me to email you a copy?
03:26:51 <delYsid> shapr: yes, plz
03:26:56 <delYsid> dark_: cutnpaste error.
03:27:45 <delYsid> *Stunden> testMe
03:27:46 <delYsid> Remaining time 07:05!
03:27:49 * delYsid bounces happily
03:28:10 <shapr> sent
03:29:01 <dark_> delYsid: I tend to forget x's like that :)
03:29:08 <dark_> For example in definitions like this:
03:29:09 <dark_> dwordreg state = oper (disReg 32 (state_reg state)) state
03:29:38 <dark_> I always forget the final "state".  dwordreg is a state transformer, and I think of it as a specialization of "oper" (which just pushes any operand).  
03:29:53 <dark_> I don't see why I have to repeat the 'state' part just because I use it as an argument :)
03:30:11 <delYsid> well, then dont do it.
03:30:17 <delYsid> leave the arg out, doesnt that work?
03:30:22 <shapr> I tend to forget boundary cases in pattern matches...
03:30:26 <dark_> No, because I need the "state_reg state" part.
03:30:35 <shapr> I had a function "foo (x:xs) = ..."
03:30:50 <delYsid> dark_: er, forget it.
03:30:59 <dark_> delYsid: Yeah, I tend to ;-)
03:31:05 <shapr> a bug that eluded me for many hours was that I was calling foo like: foo ""
03:31:14 <dark_> shapr: Hmm, ghc warns me about that.  Maybe use -Wall?
03:31:20 <shapr> and that was dropping right through the pattern match
03:31:25 <shapr> eh?
03:31:31 <dark_> shapr: It says when a pattern match is "non-exhaustive"
03:31:43 <Heffalump> in many cases the base case is more important than the inductive case
03:31:48 <shapr> right, but I couldn't figure out *why* it was non-exhaustive...
03:31:52 <delYsid> Anyone know if Parsec has a Warning fascility also?
03:31:57 <shapr> I'm used to having an arg bound, no matter what it is...
03:32:04 <shapr> it's just always there in other languages :-)
03:32:05 <delYsid> From what I can see in the tutorial, it only has critical errors, but no warnings.
03:32:09 <Heffalump> because without the inductive case at least it'll work for one value, but without the base case it won't work at all (if the function does structural recursion)
03:32:26 <shapr> Heffalump: huh?
03:32:43 <dark_> shapr: How could it elude you for hours, though, if you had a warning pointing at foo? :)
03:33:24 <shapr> because it never occurred to me that an empty string wouldn't match that pattern
03:33:43 <shapr> I really do think like a procedural programmer most days.
03:33:45 <dark_> I got confused once when I had a pattern with a guard, and didn't realize that the guard could still be true in the next (wildcard) pattern, because the pattern might have failed instead of the guard.
03:34:18 <shapr> sadly, I spend five or six days a week getting paid to write java or python
03:34:31 <Heffalump> shapr: think of length
03:34:31 <shapr> that's better than starving of course =)
03:34:34 <dark_> (I was using the guard to eliminate a case and handle it separately, but that handling required the list to have at least one element)
03:34:36 <Heffalump> length [] = 0
03:34:42 <Heffalump> length (x:xs) = 1 + length xs
03:34:53 <Heffalump> if you leave out length [], then length will never produce a result, for *any* list
03:34:55 <shapr> Heffalump: yah, I think I've got it now, but it just passed me by at that time.
03:35:04 <shapr> is that the base case?
03:35:07 <Heffalump> yes
03:35:15 <shapr> and the next one is the inductive case?
03:35:21 <Heffalump> yes
03:35:25 <shapr> ok, cool.
03:35:29 <shapr> thanks :-)
03:35:43 <dark_> Heffalump: I'm not convinced... this is like the argument that a stopped watch is better than one that's 1 minute off :)
03:35:58 <Heffalump> dark_: well, not quite :-)
03:37:56 <dark_> I'll note that if the list is infinite, you'll never need the base case anyway :-)
03:38:18 <Heffalump> yes, but in my (carefully chosen :-) example length wouldn't produce a result then either
03:38:46 <shapr> re Chilli
03:39:02 <Heffalump> end of netsplit, that's all (probably)
03:39:22 <shapr> what can I say, I'm an ircbot at heart.
03:41:01 * dark_ wonders if Maybe monads are a bad habit.
03:41:17 <Jii> shapr, you don't do much recursion in python or java then? ;-)
03:41:26 <dark_> They show up in more and more places in my code :)
03:41:41 <shapr> Jii: actually, I've tried to... but it can be a bad thing in those language.
03:41:59 <shapr> it's better to use map and filter in Python, and just hold your nose and write code in Java
03:42:14 <dark_> That the main thing that turned me off on Java... no map and filter :)
03:42:32 <shapr> you can write your own, but your coworkers won't like it much.
03:42:36 <dark_> I guess it's possible to construct some, by defining a Functor interface of some kind.
03:42:49 <dark_> And then use anonymous local classes, yay :)
03:43:01 <dark_> shapr: I see your point about the coworkers :)
03:43:03 <shapr> dark_:  http://c2.com/cgi-bin/wiki?BlocksInJava
03:43:05 <shapr> that's a better way.
03:44:44 * shapr considers stopping ion and going back to gnome for awhile
03:47:05 <hornby> aw, but ion is so cool
03:48:11 <shapr> actually, I rememebered I wrote xmms-shell.el long ago, so I think I'll stay in ion for a bit longer.
03:52:57 * shapr finds bugs in his old elisp code
03:53:09 <shapr> if only I could write this in haskell >:-/
03:53:22 <shapr> there must be some cheesy way I can script emacs in Haskell....
04:00:57 <dark_> shapr: Write hmacs :)
04:01:11 <shapr> believe me, I want to!
04:01:22 <dark_> Step 1: Write an elisp interpreter in Haskell.
04:01:38 <shapr> and I think it should centered around editing abstract syntax trees, which is why Jerub's thought are so interesting to me.
04:01:51 <shapr> yah, an elisp interpreter is the first step, I agree.
04:01:56 <dark_> Actually I think the emacs core is not much bigger than that.  Elisp interpreter, some builtins and some windowing stuff.
04:02:13 <shapr> actually, it is much bigger than that :-(
04:02:29 <shapr> emacs is a large and scary codebase.
04:02:47 <dark_> Well it's got this "dumping" stuff :)
04:03:39 <dark_> Hmm.  You might be in a similar tangle, if you want to mix interpreted haskell with compiled haskell.
04:03:54 <Heffalump> well, ghci does it
04:04:11 <dblack> hi
04:04:17 <dark_> Oh... I never used ghci :)  I guess that's a Solved Problem, then.
04:04:26 * dblack is working on a problem in ruby which cries out to be written in haskell :-)
04:04:44 <shapr> hi dblack!
04:04:53 <dark_> dblack: What makes something cry out to be written in Haskell?
04:05:00 <shapr> yah, I'm curious also.
04:05:06 <dblack> dark_: partly that i want to work on something in haskell :-)
04:05:15 <dark_> dblack: So far that's been my reason too :)
04:05:27 <dark_> Actually the "in Java" part made it cry out.
04:05:32 * shapr laughs
04:05:42 <dblack> and partly that i seem to be solving it by recursing with ever-smaller arrays
04:06:03 <dark_> quicksort!
04:06:03 <dblack> so it reminds me of any number of thompson examples, etc.
04:06:06 <shapr> I still don't know how ghci does runtime loading...
04:06:32 * shapr tries to stay focussed on JSP pages that need finishing.
04:07:16 <dark_> Is there a ghc type that acts as an Array, but which allows you to take subarrays efficiently?
04:09:49 <dark_> Currently I'm representing binary files as [Word8] :)  Though maybe that's the best approach in the long run.
04:10:12 <shapr> there are fast arrays, but I don't remember the details
04:10:34 <shapr> iirc, it's a ghc type that keeps the array contents as unboxed ints
04:10:37 <dark_> There's DiffArray, but I don't think it lets you change the bounds of the array.
04:11:34 <dark_> shapr: Yeah, UArray.
04:12:11 <dark_> shapr: Unfortunately there doesn't seem to be a fast way to say "I need an array consisting of elements 513 through 708953 of this UArray" :-)
04:13:30 <shapr> dark_: I think hdaume was talking about that on the haskell list sometime in the last few months.
04:13:47 <shapr> I think he did find some solution for it...
04:14:29 <dark_> I was thinking of creating a type that's either an UArray or a reference to part of an UArray, and making it an instance of Array.  I just hope it's been done already :)
04:15:19 <Heffalump> are UArrays immutable?
04:15:25 <dark_> Heffalump: Yes.
04:15:28 <Heffalump> good :-)
04:15:41 <dark_> Heffalump: Immutable and unboxed.
04:15:54 <dark_> Heffalump: What I'd need next is an IO function that reads a file into an UArray Word8 :-)
04:16:09 <dark_> Heffalump: Currently I'd have to read it as [Char] first and then convert.
04:16:39 <Heffalump> you could read it a character at a time, surely?
04:16:43 <Heffalump> or is that horribly inefficient?
04:16:58 <dark_> Heffalump: Well it's not that bad.
04:17:12 <dark_> Heffalump: something like 1 second for 500kB
04:17:28 <Heffalump> anyway, if you read it as a [Char] and are careful it won't actually eat up RAM (since it'll be lazy)
04:17:50 <dark_> Heffalump: I'm using IOExt to force binary mode.  It annoys me that I have to separately convert [Char] to [Word8] and hope no-one changes the IO functions to use Unicode.
04:19:21 <dark_> Heffalump: I don't think I'll be able to avoid eating up RAM anyway :)  I'll have to do quite a bit of cross-referencing.
04:19:25 <dark_> Several passes through the code.
04:19:38 <Heffalump> ok, extra RAM :-)
04:19:46 <dark_> Heh, perhaps :)
04:20:08 <dark_> I got 768MB last summer, though.  If that's not enough I'll complain to whoever's in charge.
04:21:01 <dark_> And seriously... the biggest input I expect is about a megabyte, with most of that being discarded soon after reading.
04:21:10 <Jii> but that still doesn't hold an infinite list! ;-)
04:21:16 <dark_> (Then again, programmers tend to be wrong about this sort of expectation)
04:21:27 <dark_> Jii: You're right!  I need More Memory!
04:22:26 <dark_> Doing bit twiddling in Haskell feels vaguely perverse :)  But perhaps not more perverse than writing a compiler in it.
04:23:52 <dark_> This tradition of writing compilers in the language they compile, is it just because it takes a language fanatic to write a compiler?
04:24:45 <Heffalump> gcc is all written in C, isn't it?
04:25:09 <dark_> Yes, at least most of it.
04:25:19 <Heffalump> and that compiles lots of languages
04:25:20 <dark_> I think some small stuff in libgcc is in assembler.
04:25:32 <dark_> Yeah but it _started_ as a C compiler :)
04:25:41 <Heffalump> true :-)
04:26:25 <eivuokko> ada part of gcc is written in ada, is it not.
04:27:46 <Heffalump> oh, ok
04:28:12 <dark_> eivuokko: I never looked... but the Java part is written in C.
04:29:55 * eivuokko considers that issue is not worth lookin up at this time.
04:41:14 <dark_> shapr: By the way, you did inspire me to make this code much more readable than it was before :)
04:54:24 <shapr> yay!
04:54:33 * Jerub is back from dinner
04:54:36 <shapr> readability is good
04:54:56 <Jerub> readability is more important than funcationality.
04:55:02 <shapr> welll
04:55:14 <shapr> if it doesn't work, there's not much point reading it...
04:55:27 <Jerub> if it doesn't work, you don't want to have a hard time reading it ;
04:55:28 <Jerub> ;)
04:55:41 <shapr> hmm
04:55:43 <shapr> interesting point
04:56:21 <Jerub> maintainability is far more important than getting the product out the door.
04:56:33 <shapr> hmm
04:56:42 <shapr> business people will disagree with you.
04:56:57 <shapr> but from a long-term profitability perspective, I understand your viewpoint.
04:57:58 <Jerub> ""business people"" meaning the people who want the product out the door now? the product fixed now? or their company reputation renewed by the blood of the lamb because the software is unfixable.
04:58:03 <eivuokko> Jerub, that statement is only neccesary is those two exclude each other, which lead to that statement.
04:58:18 <eivuokko> Err, that the problem is that you got to make that statement.
04:59:10 <Jerub> ""business people"" want things, and they don't know what the things are, they just know that they have to have them. Its your job to make sure they think they're getting in the way, when they aren't.
04:59:17 <shapr> Jerub: well, programmers have to eat... until the industry at large realizes that programming is a service, people will continue to sell crappy products.
05:00:05 <dark_> Haskell programmers have it easy that way.
05:00:10 <dark_> food = cookie : food
05:00:47 <shapr> yah, if you're writing a client app in haskell, the client already realizes it's a service.
05:00:52 <delYsid> well, anyone know if parsec can be modified to report parser warnings too?
05:01:38 <shapr> does a failing parser inside a try still print its message?
05:01:45 <shapr> if so, you could use that to do warnings
05:02:23 <delYsid> no, it wouldnt afaics
05:03:16 <delYsid> er, offtopic, but does anyone know how I can fgure out IDE chipset on my board without looking at it?
05:03:39 <shapr> delYsid: lspci
05:04:00 <Jerub> delYsid: cat /proc/pciinfo
05:04:04 <Jerub> or just /proc/pci
05:05:26 <delYsid> ahh, lspci did it.
05:05:38 <delYsid> Well, no problems know with this ide chipset and linux.
05:05:47 <delYsid> And still, the technician said he thinks it's a OS problem
05:06:00 * Jerub laughs
05:06:03 <dark_> delYsid: That's what they always say if you don't run windows.
05:06:09 <Jerub> delYsid: that argument works for windows.
05:06:14 * Jerub blinks.
05:06:36 <Jerub> The number of problems I've seen ''solved'' by a windows reinstall continue to astound me.
05:06:40 <dark_> Jerub: See, it works both ways :)
05:06:50 <Jerub> under linux, you can usually find the problem, and patch it.
05:06:59 <Jerub> in fact, a reinstall probably won't save you.
05:07:20 <dark_> The thing to do is, if they ask you if you use "windows" without qualifier, just say yes.  xterms count.
05:07:54 <Jerub> I have an xterm
05:08:00 <shapr> I have eshell
05:08:10 <Jerub> I love channels like this.
05:08:18 <shapr> how so?
05:08:26 <shapr> like what?
05:08:26 <delYsid> well, I'm still absolutely clueless what is going on here.
05:08:32 <Jerub> the clue quotient is so much higher than say.... #debian
05:08:48 <shapr> Jerub: that's true.. and the comparison to #java is far more entertaining.
05:08:53 <shapr> delYsid: what's the problem?
05:08:57 <Heffalump> isn't #debian mostly filled with people joining and asking inane questions?
05:09:00 <Jerub> never stuck around in java.
05:09:05 <shapr> Heffalump: yah, mostly...
05:09:14 <dark_> Heffalump: Wouldn't know... haven't been there for years.
05:09:14 <delYsid> shapr: My disk does random spin-downs while read/write
05:09:16 <shapr> I like to show up and bartend questions sometimes.
05:09:20 <Jerub> in fact, I've not talked in #javaish channels since I didn't know what static/nonstatic meant.
05:09:23 <shapr> delYsid: *during* rw???
05:09:26 <Jerub> that was a few years ago now.
05:09:43 <Jerub> delYsid: that sounds like a serious hardware problem, backup your data.
05:09:48 <delYsid> shapr: yes, and *only* *during*
05:09:54 <shapr> that's very scary.
05:10:00 <delYsid> it is
05:10:02 <dark_> delysid: Hmm... flaky power supply?
05:10:09 <delYsid> but I want a working system again, so now I bought a new disk.
05:10:12 <dark_> delysid: It might hit the limit while reading and writing, but not otherwise.
05:10:15 <shapr> I'd bet it's a problem with the disk.
05:10:17 <delYsid> BUt if the controller is the reason, I'll cry
05:10:26 <Jerub> delYsid: flaky power supply would probably cause a system crash, unless you've got a really good regulator on the mobo, backup your data.
05:10:44 <dark_> I mean flaky as in barely sufficient, not as in unstable :)
05:10:53 <delYsid> Its a 300W power supply
05:10:58 <delYsid> So that should work.
05:11:11 <delYsid> And, the kernel locks while the spindown happens, unlocks as soon as the disk is back up
05:11:12 <shapr> for my machine, 350 is far too small
05:11:21 * Jerub laughs
05:11:25 <Jerub> I have a 200W supply!
05:11:46 <shapr> Jerub: well, I have dual Athlon MP 1800+ processors, and four case fans.
05:11:49 <delYsid> well, there is only one disk and a p4 2.2 in thsi machine, so 300W *should* really be enough
05:12:01 <shapr> what's your IDE chipset?
05:12:05 <dark_> shapr: Cool, where did you get those?
05:12:11 <shapr> dark_: I bought 'em
05:12:14 <Jerub> I have a k62 450, 2x10gig, 1x40gig, 1xcdrom, g400.
05:12:15 <Jerub> :)
05:12:23 <shapr> dark_: they're fun, but not very stable...
05:12:23 <dark_> shapr: I was hunting for an Athlon MP system last year but couldn't find a local source for the power supply.
05:12:31 <delYsid> shapr: IDE interface: Intel Corp. 82801BA IDE U100 (rev 05)
05:12:45 <shapr> delYsid: what kernel version? any ide specific boot params?
05:12:48 <Jerub> delYsid: backup your data, did I mention that?
05:13:03 <shapr> dark_: my case has room for another power supply, and I *need* it desperately...
05:13:07 <delYsid> Jerub: Well, I have a 9 day old backup.
05:13:23 <shapr> I also need more case fans, my machine still overheats at full usage.
05:13:31 <Jerub> delYsid: heres an idea, install bsd, see what happens.
05:13:37 <dark_> shapr: Or _better_ fans :)
05:13:43 <Jerub> shapr: or better ducting.
05:13:44 <shapr> yah, that's a possibility.
05:13:50 <delYsid> But backing up a disk which spins down at read/write isnt easy.
05:13:56 <shapr> Jerub: truly, if I close the windows, it all crashes anyway.
05:14:08 <dark_> delysid: Is it at the start of read/write, or randomly?
05:14:14 <shapr> yah, good question
05:14:28 <Jerub> shapr: Good ducting and good fan management.
05:14:34 <Jerub> shapr: your case fans are intakes?
05:14:37 <delYsid> dark_: It's so random, I'd qualify it as a good source for /dev/random
05:14:51 <shapr> Jerub: nah, I have one intake and three blowing out the back
05:15:25 <shapr> delYsid: have you tried to use hdparm to see if your disk has a new firmware available?
05:15:36 <Jerub> shapr: The paradigm has changed since cpus got so damn hot, but the concept still holds. All fans in a case should be intakes, while the only outtake fan is in the power supply.
05:15:39 <delYsid> how do I do that?
05:15:54 <shapr> Jerub: hmm
05:15:56 <Jerub> The collarary is, if you duct air for the cpus, do whatever you damn well please.
05:15:59 <delYsid> and, how do I enable/check SMART under Linux?
05:16:06 <shapr> hdparm can do all of that
05:16:27 <shapr> well, I know it can check SMART, dunno about enabling it with hdparm
05:16:32 <shapr> I enable SMART in the BIOS
05:19:01 <dark_> Hmm, Debian has smartsuite and ide-smart packages.
05:19:01 <dark_> I remember using ide-smart until I got bored looking at the little numbers :)
05:22:04 <delYsid> well, ide-smart says my disk passes all tests
05:22:29 <delYsid> damndamndamn, I want a fully working workstation again!
05:35:19 <delYsid> well, reboot with all ide chipsets enabled didnt help :(
05:40:27 * shapr tries to subscribe to comp.lang.haskell
05:41:13 <hornby> tries?
05:41:23 <shapr> sure, see what happens when you try it.
05:42:00 <Heffalump> I've got a fairly good newsfeed, and it doesn't seem to exist
05:42:13 <shapr> that's the problem ;-)
05:42:31 <Heffalump> what makes you think it should?
05:42:39 <shapr> because I want it!
05:42:43 <shapr> what better reason? ;)
05:42:57 <Heffalump> well, the mailing list exists
05:43:16 <shapr> that's true.
05:43:48 <ibid> shapr: propose it. that's how they create newsgroups. remember to familiarize yourself with the procedure, though.
05:44:16 <dark_> Bah!  shift is only defined for Int, not Integer.
05:44:47 <shapr> ibid: it was proposed last year, and didn't make it...
05:44:54 <ibid> oh
05:44:59 <Heffalump> Integers are unbounded, and therefore not the kind of thing that are obviously bit-vectors
05:45:00 <ibid> i never noticed...
05:45:17 * Heffalump wouldn't support it, the variety of mailing lists that currently exist are more appropriate I think
05:45:34 * ibid prefers newsgroups over mailing lists any day
05:45:41 <ibid> mailing lists are clumsy
05:45:45 <shapr> I prefer newsgroups also.
05:45:46 <Heffalump> yeah, but several are needed
05:45:59 <ibid> alt.haskell? :-)
05:46:04 <Heffalump> so unless a comp.lang.haskell, comp.lang.haskell.discuss, comp.lang.haskell.ghc, etc was created
05:46:10 <Heffalump> the current system would be better
05:46:42 <ibid> there's nothing saying that the discussion would move from the lists, so it's better start with one and create more as the newsgroup gets filled with stuff
05:47:07 <Heffalump> if the discussion didn't move, then I'd just have to watch both the lists and the group, which would be even worse
05:47:29 <Heffalump> you're right that groups are technically nicer, but not by so much that it's worth upsetting an arrangement that's working ok
05:48:31 <ibid> well, one could try creating an alt group first
05:48:51 <dark_> Actually shift works with Integer on the left side, just not on the right.
05:49:35 <Heffalump> oh, ok
05:49:52 <Heffalump> what is the shift operator?
05:49:54 <ibid> besides, what's wrong with multiiplication :-)
05:50:28 <shapr> ibid: or, we could just post lots of stuff to comp.lang.functional and then create a group when people start complaining.
05:51:05 <ibid> heh
05:51:45 <shapr> that's probably the best route actually...
05:51:54 <ibid> yes
05:51:59 <shapr> then lots of non-haskell people will vote for c.l.h also =)
05:52:05 <ibid> true
05:52:27 <ibid> in at least sfnet, that's about the only way to get a group created
05:52:53 <shapr> yah well, suomi geeks are just more entertaining.
05:53:17 <delYsid> how do I do a if ... then ... ;
05:53:22 <delYsid> clause in haskell in a do statment?
05:53:26 <ibid> if ... then ...
05:53:30 <shapr> else ...
05:53:30 <Heffalump> the same way as anywhere else
05:53:31 <pesco> *g*
05:53:39 <shapr> hey pesco
05:53:50 <delYsid> It tells me possible indentation problem...
05:53:55 <ibid> you just need to reintroduce the do in the then and the else if you want to use it there
05:54:17 <pesco> yay shapr
05:55:01 <delYsid> I have
05:55:04 <delYsid> do ...
05:55:06 <delYsid>                 t <- time
05:55:06 <delYsid>                 if t /= balance
05:55:06 <delYsid>                  then do fail "Error!"
05:55:06 <delYsid>                 if s == '-' then return (-t) else return t
05:55:20 <delYsid> And it complains about the first if, why?
05:55:25 <ibid> no else?
05:55:43 <Heffalump> you need an else
05:55:53 <Heffalump> every if needs a then and an else
05:55:58 <delYsid> gah!
05:56:03 <Heffalump> your else could be return ()
05:56:03 <delYsid> Is there a conditional without else too?
05:56:04 * shapr grins
05:56:26 <ibid> delYsid: what would it evaluate to if the condition is false?
05:56:27 <shapr> the required else confused me also
05:56:45 <shapr> you could do it with case
05:56:46 <Heffalump> return () is the identity operation in monadic code
05:56:50 <delYsid> ibid: Nothing, go to the next conditional.
05:56:51 <shapr> or with guards
05:57:11 <Heffalump> delysid: ok, and return () is the way to do that
05:57:37 <Heffalump> you could define ifthen :: Bool -> m a -> m a as ifthen b t = if b then t else return ()
05:57:40 <Heffalump> if you wanted
05:58:50 <ibid> delYsid: trhat
05:58:53 <ibid> argh
05:59:06 <ibid> delYsid: that's your confusion: everything evaluates to something :-)
05:59:54 <Jii> wasn't it so that evaluating to nothing is conceptually same as non-termination of program (or something like that ;-)
05:59:58 <Heffalump> shapr: how could he do it with guards?
06:00:15 <Heffalump> (or with case, for that matter)
06:00:34 <ibid> Jii: well, if the program nonterminates, then it evaluates to bottom :-)
06:00:56 <Heffalump> I can't see how guards would do it at all, syntactically, and if you used case and left out some cases then the program would abort if the condition was false
06:16:16 * shapr wonders if the possibility of evaluating to bottom makes Haskell a Bondage&Discipline language.
06:16:31 <shapr> I think I spent too much time in Seattle...
06:16:42 <ibid> shapr: all sufficiently powerful langauages give that option
06:18:11 <Heffalump> bottom is really a theoretical construct, an implementation should never explicitly decide "this value is bottom", right?
06:18:39 <eivuokko> What's "evaluating to bottom"?
06:18:57 <ibid> bottom denotes evaluations that don't terminate or that abort
06:19:20 <ibid> so, if a compiler sees error "Foo", it decides this is bottom :-)
06:19:32 <ibid> conceptually
06:19:58 <Heffalump> well, if a compiler sees error "Foo", it compiles it to code that will abort the program if executed
06:20:39 <pesco> On the practical side. But in concept, this is just a "pretty-printed" form of eval to bot, right?
06:20:42 <eivuokko> Hmmm.
06:21:02 <ibid> Heffalump: yes, and that's evaluating to bottom
06:21:28 <pesco> Where do exceptions fit into the picture?
06:21:30 <ibid> pesco: i don't follow
06:21:39 <eivuokko> Ehhem, care to give good guess about sentence to feed into google?
06:21:57 <Heffalump> pesco: they don't, really
06:22:04 <pesco> Doesn't error raise an exception?
06:22:13 <Heffalump> oh, does it?
06:22:19 * Heffalump --> look
06:22:30 <ibid> pesco: not in haskell 98, iirc
06:22:40 <ibid> pesco: ghc may implement it that way
06:22:45 <pesco> Hm, does the report mention exceptions at all?
06:22:59 <ibid> io monad exceptions yes iirc
06:23:14 <pesco> Yes, that's right I think.
06:23:47 <ibid> pesco: actually, if error is catchable then it does not evaluate to bottom
06:24:01 <ibid> i think
06:24:13 <pesco> Yes it does.
06:24:26 <pesco> Remember that you can only catch exceptions in an IO monad.
06:24:35 * Heffalump thinks about things
06:24:52 <Heffalump> you can catch NonTermination too
06:24:56 <Heffalump> (presumably this isn't reliable)
06:25:02 <ibid> Heffalump: how?
06:25:11 <pesco> That means the evaluation really didn't terminate.
06:25:19 <Heffalump> ibid: in IO again
06:25:24 <Heffalump> I guess you can look at this two ways
06:25:36 <Heffalump> either (a) IO gives you an opportunity to detect (some) bottom values
06:25:42 <ibid> i don't think it is possible to decide whether an expression evaluated to bottom or not within the system
06:26:10 <Heffalump> or (b) if wrapped in a catch, only undetected nontermination is really a bottom value - but that makes bottom rather hard to reason about
06:26:20 <Heffalump> ibid: that's why I said "presumably this isn't reliable"
06:26:37 <Jii> forget i said anything ;-)
06:26:43 <Heffalump> http://www.haskell.org/ghc/docs/latest/html/base/GHC.Exception.html#NonTermination
06:27:16 <shapr> Jii: I like reading lots of discussion :-)
06:27:31 <ibid> Heffalump: ok, i'll qualify my comments with "in haskell 98, " :-)
06:27:52 <Heffalump> :-)
06:28:06 <pesco> Heffalump: That's something else though, isn't it? A computation going into an infinite loop is different from evaluating to bottom, isn't it?
06:28:32 <ibid> i would consider using the ghc exception technique as going outside the system
06:28:47 <Heffalump> pesco: no
06:28:52 <ibid> bus time, bbl
06:28:55 <Heffalump> an infinite loop is bottom
06:29:12 <Heffalump> the easiest way to "define" bottom is
06:29:15 <Heffalump> undefined = undefined
06:29:24 <pesco> Heffalump: Oh, ok. But not every bottom is an infinite loop, or is it?
06:29:37 <Heffalump> no, program abortion is bottom too
06:29:47 <pesco> Alright.
06:30:00 <pesco> Heffalump: What would be other ways to define bottom?
06:30:05 <dark_> afaik ghc's exceptions aren't bottom.
06:30:17 <Heffalump> dark_: but do they *detect* bottom values?
06:30:36 <Heffalump> pesco: undefined=undefined' ; undefined'=undefined :-)
06:30:47 <Heffalump> basically any non-terminating program
06:30:49 <dark_> length ones :-)
06:31:04 <pesco> Heffalump: Hm. ok.
06:31:05 <Heffalump> :-)
06:35:37 <shapr> this channel is far too interesting for me to think about Java and Visual Basic at the same time :-/
06:36:17 <dark_> shapr: Besides, your brain might explode.
06:38:24 <Jii> i just advocated haskell to a guy who works here and is doing some formal stuff
06:38:40 <dark_> Ooh, advocacy.
06:38:48 <Jii> evil? ;-) 
06:38:52 <dark_> Jii: Now you'll be forever responsible for teaching him Haskell and fixing his programs :)
06:39:41 <Jii> he implemented the (relatively simple) algorithms needed for his thesis in C and got quite frustrated with unmaintainability and segmentation faults ;-)
06:40:04 <Jii> dark, well, i bet he'll be teaching me haskell soon :)
06:40:10 <dark_> Well... C is one of the hardest languages to learn :)  Way harder than Haskell.
06:40:29 <dark_> Its danger lies in _seeming_ to be easy to learn :)
06:40:42 <Jii> he has studied CS for six years or so
06:42:11 <dark_> Jii: Well... I studied CS for nine years, the question is, how much did I learn? :-)  I spent most of that time ignoring the courses and hacking on my own projects.
06:42:59 <Jii> he is teaching a course on derivation of algorithms (based on the book named derivation of algorithms, anyway) this autumn
06:43:11 <Jii> dark, that's true
06:44:09 <Heffalump> what book is that?
06:44:23 <dark_> Heffalump: "Derivation of Algorithms", presumably :-)
06:45:08 <Heffalump> by who? :-p
06:45:25 <Jii> anne kaldewaij
06:45:34 <Heffalump> oh, that one.
06:45:52 * Heffalump looks up and spots it on his bookshelf :-)
06:46:11 <Jii> heh :)
06:46:52 <Heffalump> that's all about formal derivation of imperative programs
06:47:10 <dark_> So it's not the algorithms that are being derived? :)
06:47:41 <Heffalump> well, it is the algorithms, but none of them are very complicated really
06:47:51 <Jii> (i was only kinda trying to give some context :)
06:48:12 <Jii> but you are assumably not so eager to sell haskell to anyone then?
06:48:19 <Heffalump> who, me?
06:48:23 <Heffalump> depends
06:48:28 <Heffalump> if I think it'd actually help them
06:48:44 <Heffalump> or that they are being dogmatic in their attachment to C (or whatever)
06:50:09 <Jii> by "sell" i mean "advocate"
06:50:10 <Jii> you all, although i know shapr sells haskell ;-)
06:50:57 <dark_> Jii: "make aware of" is enough for me :)
06:52:42 <Jii> the program he implemented was given (some sort of) a net and it had to answer "Yes" or "No", although there were some effiency issues (not too tight)
06:52:47 <delYsid> func (Minutes (m<0)) = ...
06:53:00 <Jii> sounded like a good case for haskell to me ;-)
06:53:00 <delYsid> Isn't that supposed to work, or did I understand something wrongly?
06:53:12 <Heffalump> delysid: no, it won't work
06:53:15 <Heffalump> you might have meant
06:53:22 <Heffalump> func (Minutes m) | m < 0 = ...
06:54:02 <delYsid> ok, tnx
07:30:45 <delYsid> my parser is finished and works!
07:30:50 <dark_> Cool :)
07:31:27 <dark_> Now add features :)
07:31:45 <Jii> what parser?
07:32:11 <delYsid> Jii: A very simple Parsec parser which checks my work-time notes file ...
07:32:33 <delYsid> http://212.17.102.236/Stunden.hs
07:33:01 <delYsid> Improvments-suggestions welcome!
07:38:08 * pesco reads a couple of pages back...
07:38:25 <pesco> Ah, C, the old days again...
07:40:50 * Heffalump spots Chilli's student posting to the Haskell list
07:41:31 <dark_> I think it takes at least a year to become non-dangerous with C :)
07:41:40 <dark_> It's like a learning curve that starts in the negative zone.
07:41:46 <pesco> heheh
07:42:03 <dark_> Of course some people never become non-dangerous :)
07:42:51 <dark_> Those are the ones that go on to write network applications for banks.
07:42:57 <pesco> lol
07:46:57 <dark_> Hmm how well suited is Haskell for network applications?  Is there a socket interface?
07:48:59 <Heffalump> yes
07:49:03 <Heffalump> not Haskell 98 though
07:49:10 <Heffalump> definitely in GHC, not sure about other platforms
07:50:31 <pesco> I still have to try out the CORBA binding.
07:50:39 <pesco> I'm interested in how well that will feel.
07:50:59 <pesco> Although probably alot like the C mapping.
07:55:49 <dark_> Hmm what about database bindings?
07:56:11 <dark_> I wonder how a database should be presented in Haskell :)  Monad city?
07:56:34 <Heffalump> the MySQL binding I saw made some use of unsafePerformIO, which I thought was a bit sick
07:56:51 <Heffalump> (though possibly justified given they wanted to lazily retrieve results from a result set)
07:56:54 <dark_> Heffalump: Not necessarily sick... I think it's reasonable when implementing lazy IO :)
07:57:33 <dark_> Representing rollback in haskell could be tricky.
07:57:49 <Heffalump> that'd be all monadic, though
07:57:53 <dark_> I guess a Transaction could be an operation on a database.
07:59:40 <dark_> Heffalump: Yeah that's what I'm afraid of :)
07:59:43 * delYsid just eliminated all do-statments from his code :)
07:59:59 <delYsid> well, >>= AND >> ARE A BIT UGLY :)
08:00:06 <dark_> Heffalump: I wonder if there's a more functional way of representing a database.  After all it's essentially a collection of list of tuples.
08:01:20 <dark_> delysid: If you eliminated them by converting to >>= and >> then it didn't achieve much :)
08:01:45 <delYsid> dark_: right :)
08:02:01 <delYsid> but I'm trying to get familiar with the syntax of haskell, and so this one was a good exercise :)
08:02:12 <delYsid> besides, I somehow start to like >>= and >>.
08:02:18 <dark_> Yeah it's easy to lose sight of what do really is.
08:02:38 <delYsid> right
08:03:36 <delYsid> although I still dont understand why the -> is needed after >>=
08:03:44 <delYsid> can anyone explain this?
08:04:29 <Heffalump> YM as in foo >>= (\x -> bar) ?
08:05:08 <dark_> delysid: It's part of the lambda expression syntax.  It separates the expression's arguments from its body.
08:06:05 <dark_> delysid: >>= takes a function on its right side, and applies that function to the result of the left side.  So what in the "do" notation looks like defining a variable, is actually introducing a local function.
08:06:58 <delYsid> ahhhh
08:06:59 <delYsid> tnx
08:08:02 <Heffalump> the -> goes with the \
08:08:12 <Heffalump> it just happens that it's common to have a \ expression after a >>=
08:08:25 <Heffalump> you can write something with >>= without a \ expression
08:09:08 <delYsid> YOu mean if I already have a function for it?
08:09:29 <dark_> Yeah, or if you're doing something like foldr (>>=)
08:10:13 <Heffalump> dark_: I'd be impressed :-)
08:10:41 <delYsid> foldr (>>=)
08:10:46 <dark_> printWarnings :: Warnings -> IO ()
08:10:46 <dark_> printWarnings ws = sequence_ (map putStrLn ws)
08:10:53 * delYsid tries to think of a situation where this is used
08:11:00 <dark_> sequence_ is just foldr (>>) (return ()) :)
08:11:04 <Heffalump> delysid: it can't, like that, it's not well typed
08:11:08 <dark_> Oops, that's a smiley, not a : section :)
08:11:14 <Heffalump> dark_: ah, but that's >>, not >>= :-p
08:11:47 * dblack works on list-of-lists problem (as posted to pragprog group)
08:12:04 <dark_> Heffalump: Sounds like a challenge to me :)
08:12:35 <Heffalump> dark_: no, it really really isn't well-typed
08:12:38 <delYsid> right, with >> I can imagine, but with >>=...
08:13:00 <Heffalump> >>= :: m a -> (a -> m b) -> m b
08:13:09 <Heffalump> the first argument of foldr should be of type e -> f -> f
08:13:20 <delYsid> YOu'd need to foldr a list of functions, wouldnt you?
08:13:24 <Heffalump> so for >>= to be the first argument of foldr, you have to have a -> m b = m b
08:13:36 <Heffalump> delysid: yeah, which is reasonable
08:13:43 <Heffalump> e.g. foldr (.)
08:14:12 <delYsid> ahhhh :)
08:14:13 <delYsid> amazing!
08:14:47 <delYsid> hmmm, I'dd really like to work on some large project based on Haskell.
08:14:56 <delYsid> This . and fold stuff is really neat...
08:15:34 <delYsid> Also, since I've read the gametree impl. in whyfp, I'm amazed about what laziness can do
08:15:48 <Heffalump> is that an alpha-beta algorithm?
08:16:26 <delYsid> yes
08:16:34 <Heffalump> dblack: is the length of the second list the same as the length of the first list?
08:18:27 <dblack> Heffalump: yes
08:18:43 <Heffalump> easy then :-)
08:18:52 <dark_> delysid: I jumped right into a large project :)
08:18:52 <dblack> ok....
08:19:07 <dblack> Heffalump: i'm all ears, i mean eyes :-)
08:19:31 * dark_ actually uses : sections that look like smileys.
08:19:48 <Heffalump> listmatch xs xss = or [and zipWith elem xs xss' | xss' <- perms xss]
08:19:55 <Heffalump> sorry, missing some brackets there
08:20:05 <Heffalump> but you get the general idea
08:20:26 <dblack> sort of... but does that presuppose that they'll occur in the same order?
08:20:35 <Heffalump> you need a definition of perms, but that's 4 lines
08:20:41 <Heffalump> and is fairly standard
08:20:54 <dark_> perms generates permutations?
08:20:57 <Heffalump> yeah.
08:21:16 <dark_> This reminds me of slowsort :-)
08:21:28 <dblack> Heffalump: that doesn't scale very well, does it? :-)
08:21:32 <Heffalump> well, except that I think you problem really is of exponential complexity
08:21:36 <Heffalump> s/you/your/
08:23:04 <dark_> What's the problem, anyway?
08:23:20 <Heffalump> given two lists, of type [a] and [[a]], of equal length
08:23:43 <Heffalump> see whether each element of the first list occurs in one of the lists of the second list, but you can only use each list of the second list once
08:25:33 <dark_> Heh, how is "use once" defined in a lazy language?
08:26:44 <dark_> Is that "in at least one" or "in exactly one"?
08:26:59 <Heffalump> in at least one
08:27:06 <Heffalump> "use once" was rather informal
08:27:08 <dark_> In that case why not just flatten [[a]]?
08:27:35 <Heffalump> because if the first list is [1,2,3,4] and the second one is [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]], that's not OK
08:27:48 <Heffalump> each of the lists you chose for the elements of the first list must be different
08:28:42 <dark_> Oh, that kind of "use once" :)  I thought you meant operationally.
08:29:50 <dark_> Yeah that looks intractable.
08:30:05 <Heffalump> well, naturally exponential
08:32:20 <dark_> Hmm, maybe not.  *thinking*
08:33:59 <Heffalump> matching [1,2,3,4] against [[1,2,3,4],[1,2,3,4],[1,2,3,4],[3]] is going to take a lot of backtracking, for example
08:34:28 * dark_ examines [1,3,5] versus [[1,2,3],[3,4,5][5,6,7]]
08:35:40 <dark_> Heffalump: Not if you do it the other way around.  [3] can only be matched to 3.  Eliminating 3 leaves you [1,2,4] against [[1,2,4],[1,2,4],[1,2,4]] which is easy.  I'm thinking of an approach which compares the size of common subsets to the number of lists that share this subset.
08:36:10 <dark_> Heffalump: The final solution has to be a 1:1 mapping so you can construct it in either direction :)
08:37:37 <Heffalump> dark_: sure, but you can't tell that in advance
08:38:04 <Heffalump> for any example I present, you can show me a search strategy that'll find the solution quickly, but equally for any search strategy you suggest, I can show you an example that'll go slowly
08:38:34 <dark_> Heffalump: Just you wait :)
08:38:36 <Heffalump> hmm.
08:38:38 <Heffalump> maybe you're right
08:39:09 <dark_> Let's see... [1,2,3,4] versus [[1,2],[2,3],[3,4],[4,1]]
08:39:25 <dark_> Now each of the lists in xss has two possible matches.
08:40:32 <dark_> ... but I think it doesn't matter which one you pick.  Hmm, is that always true?
08:40:49 <dark_> Both lists being equal length is a useful constraint :)
08:41:42 <Heffalump> yeah :-)
08:41:42 <Heffalump> suppose the last one was [4,2] not [4,1]
08:41:42 <Heffalump> then it would matter which one you picked
08:41:52 <Heffalump> you could see that fast by counting the number of occurrences of 1, of course
08:44:45 <dark_> Heffalump: Yeah but that means looking in both directions at once :)
08:45:18 <Heffalump> yeah
08:45:30 <Heffalump> I'm sure it can be speeded up with heuristics, but I still think the worst-case behaviour is exponential
08:46:44 <dark_> Not if I can some up with a theorem along the lines of "if it does matter which one you pick, then you can always tell which one by looking in the other direction" :)
08:52:11 <delYsid> ha! Now that I've bought a new disk, the problem with the old one is gone.
08:52:28 <dark_> My brain hurts.
08:53:11 <delYsid> no, it isnt :(
08:55:25 <dark_> [1,2,3,4,5] versus [[1,2],[2,3,4],[3,1],[4,5],[4,5]]
08:55:39 <dark_> Nothing to simplify, but if you assign the [2,3,4] one to 4, you get stuck, even though there is a solution.
08:55:52 <Heffalump> I thought there'd be nasty examples like that :-)
08:56:20 <dark_> But I'm not sure it's possible to miss a solution if you always assign to the element with the smallest count :)
08:56:43 <Heffalump> mm, cunning.
08:56:52 <dark_> I'm having a hard time proving it though.
09:01:38 <dark_> My strategy so far: First, remove from xss all elements that aren't in xs at all.  Then, repeately simplify by either deleting a singleton set (and, everywhere, the element it contains) or by deleting a set that contains the only occurrence of an element (and, everywhere, the element it contains).  Fail if you end up with an empty set anywhere.  Succeed if you can't simplify any further. 
09:01:56 <dark_> Proof of correctness of that last step eludes me :)
09:02:18 <dark_> Oh, I invisibly converted the lists to sets at some point.
09:02:22 <dark_> I hope no-one minds :)
09:02:25 <Heffalump> the last step can't possibly be correct
09:02:34 <Heffalump> doesn't your own example disprove it?
09:02:47 <Heffalump> oh, well if you modify the example slightly to be impossible
09:02:58 <Heffalump> hmm.
09:02:59 <dark_> Heffalump: No, the one I gave with [2,3,4] had a solution.  It wasn't necessary to first try the wrong choice :)
09:03:00 <Heffalump> not trivial, that.
09:03:08 <dark_> Heffalump: I think any such modification will make it simplifiable.
09:03:37 <Heffalump> you need to fail if you end up with an element not in any set, too, btw
09:03:55 <Heffalump> otherwise [1,2,3] [[1,2],[1,2],[1,2]] is a success by your rules
09:04:16 <dark_> Heffalump: Hmm, right.  The counterweight to the empty set rule :)
09:08:29 <Heffalump> [1,2,3,4,5] [[1,2,3],[1,2,3],[4,5],[4,5],[4,5]]
09:08:33 <Heffalump> *phew*
09:08:38 <Heffalump> I knew that had to be wrong :-)
09:09:55 <dark_> Hmm :)
09:10:13 <Heffalump> I believe that's the smallest counter-example, though
09:10:41 <Heffalump> you can probably extend your algorithm to eliminate sets of things
09:10:53 <dark_> Yeah, but... at what price? :)
09:10:56 <Heffalump> e.g. [4,5] can be eliminated twice along with 4 and 5, because it occurs twice permuted.
09:10:59 <Heffalump> indeed :-)
09:11:59 <dark_> [1,2,3,4,5] [[1,2,3,4,5],[1,2,3,4,5],[4,5],[4,5],[4,5]] is even harder.
09:13:10 <dark_> You'd need some way to tell that subset [1,2,3] is shared by only two sets.  And that becomes exponential.
09:14:44 <dark_> Actually it's not harder, if you apply the [4,5] rule you mentioned :)  Then it quickly fails when the third [4,5] becomes []
09:14:55 <dark_> But that probably means there's a counterexample that's just larger.
09:15:52 <Heffalump> yeah, the generalisation of the [4,5] rule involves checking all subsets
09:16:05 <Heffalump> actually, all subsets up to half the size of the overall list, possibly
09:16:29 <Heffalump> so it's still exponential, but possibly only half as much so as I thought :-)
09:16:59 <dark_> I wonder if that could be avoided by checking all cases where two sets are equal.
09:17:22 <Heffalump> possibly, but you have to do that after each elimination step
09:17:31 <Heffalump> oh, but that'd only be cubic overall.
09:18:00 <dark_> But now I have a suspicion that it's still not true, it's just that the smallest counterexample is too large for us to think of it :)
09:18:09 <Heffalump> [1,2,3,4,5,6,7] [[1,2,3],[1,2,3],[4,5],[4,5,6],[4,5,7],[6,7],[6,7]]
09:18:11 <Heffalump> so no, you can't
09:18:23 <Heffalump> oh, [6,7] is equal, duh
09:18:28 <Heffalump> [1,2,3,4,5,6,7] [[1,2,3],[1,2,3],[4,5],[4,5,6],[4,5,7],[4,6,7],[5,6,7]]
09:18:52 <dark_> [1,2,3] is equal :)
09:19:20 <Heffalump> [1,2,3,4,5,6,7] [[1,2,3,4],[1,2,3,5],[4,5],[4,5,6],[4,5,7],[4,6,7],[5,6,7]]
09:19:20 <Heffalump> :-p
09:19:55 <dark_> Okay :)
09:20:05 <dark_> And yeah, there's no way to assign all of 1, 2, and 3.
09:37:09 * dark_ wonders if gcc would ever generate statements to test the parity flag.
09:40:55 <dark_> I think there's something wrong with a tool that generates directory names like ,,what-changed.uncc--1.0--patch-3--dark@xs4all.nl--dark
09:53:42 <delYsid> hehe, arch :)
09:53:53 <delYsid> It's ugly
09:54:54 <delYsid> Anyone knows a paper on functional chess programming?
09:55:33 <delYsid> I'd be interested how (in)efficient it gets compared to a bitboard based program.
10:02:21 <dark_> delysid: Yeah but this is my "try new things" project :)  I'd also use cons instead of make, except that ghc --make does all the work.
10:03:07 <delYsid> well, I like make.
10:03:09 <dark_> Hmm is there a way to get the effect of ghc --make, without compiling everything into separate modules?  I'd like to have everything compiled together, and gain optimizations therefrom.  Unless it doesn't make a difference.
10:03:23 <Heffalump> what does cons do?
10:03:31 <delYsid> Heffalump: It's a make replacement
10:03:37 <Heffalump> dark_: ghc aggressively inlines stuff across module boundaries
10:03:47 <delYsid> dark_: Ahem, it links the modules anyway...
10:03:50 <Heffalump> delysid: how does it differ?
10:04:10 <delYsid> Heffalump: no idea, never looked at it because "I like make"
10:04:34 <delYsid> gah
10:04:43 * delYsid should have studied math or physics
10:04:57 <delYsid> Now I have a really cool/powerful language, and no knowledge to use it with...
10:06:10 <dark_> heffalump: cons is designed for multidirectory projects.  It also uses md5sums for old-target detection instead of atimes.
10:20:02 <delYsid> "I recently received the following email:
10:20:02 <delYsid> Sir,
10:20:02 <delYsid> I just spilled soda on my keyboard and now the 9 and 0 keys don't work. I
10:20:02 <delYsid> can still use the 9 and 0 on the numeric keypad, but what should I do about
10:20:02 <delYsid> the parentheses? I can pick up a new keyboard over the weekend, but the
10:20:02 <delYsid> combinator homework is due tomorrow, and it uses parentheses all over the
10:20:04 <delYsid> place!
10:20:06 <delYsid> Respectfully,
10:20:08 <delYsid> Cadet K"
10:20:10 * delYsid laughs
10:20:55 <dandelion-> is that an excuse for not doing homework?
10:21:01 <delYsid> yeah :)
10:21:16 <delYsid> Actually, it's a intro to a paper on how to avoid () and use . :)
10:21:30 <dandelion-> i see
10:31:48 <Heffalump> :-)
10:31:51 <Heffalump> which paper?
10:36:54 <dark_> I had a problem like that once.  Hex editor to the rescue :)  Just write { and } instead, and replace them later.
10:37:24 <Heffalump> :-)
10:37:26 <dandelion-> good idea
10:37:54 <dark_> Another approach is cut and paste :)  I used that once in Sweden when I had a keyboard without an @
10:39:52 <delYsid> Heffalump: Flattening Combinators: Surviving Without Parentheses (JFP 02)
10:40:09 <Heffalump> is JFP online?
10:40:25 <delYsid> http://www.eecs.usma.edu/Personnel/okasaki/pubs.html
10:41:40 <delYsid> (but apart from the jokes, I didnt understand it :( )
10:43:22 <Heffalump> that's sick :-)
10:44:13 <delYsid> what, my understanding, or his way of telling the story? :)
10:45:28 <Heffalump> his solutions :-)
10:54:11 * delYsid wonders how to efficiently design "data ChessBoard = "
10:54:28 <Heffalump> ChessBoard [[Piece]] :-)
10:54:39 <delYsid> How does say ghc map nullary type constructors? bits, bytes, words?
10:54:59 <Heffalump> nullary, or unary?
10:55:18 <delYsid> Heffalump: is [[Piece]] better than a 8-tupel of 8-tupels?
10:55:27 <Heffalump> no idea :-)
10:55:27 <delYsid> nullary
10:55:39 <Heffalump> DYM nullary data constructors?
10:55:48 <delYsid> ah, yeah
10:56:01 <delYsid> data Kind = King | Queen | ...
10:56:04 <delYsid> that type of thing
10:56:22 * Heffalump has no real idea what'd be efficient. Work out what the operations you'll want to do are first.
10:57:30 <delYsid> well, in realworld, they do everything via 64 bit boards, and xor/and/or them and do 45/90 degree rotation and so on.
10:57:42 <delYsid> Thats usually needed for evaluation of a static position score
11:01:14 <delYsid> but most of the time I'll traverse the ChessBoard list of lists either diagonally or horizontally...
11:01:35 <Heffalump> diagonally could be interesting
11:01:38 <Heffalump> surely vertically too?
11:01:44 <delYsid> yeah, sure
11:02:21 <delYsid> first thing I'll need is a function which generate every possible move for a given color.
11:05:44 <dark_> delYsid: Will you need to store many of these positions?
11:06:18 * dark_ notes that GHC has a Word64 type :-)
11:07:26 <dark_> Maybe a 2-dimensional DiffArray of Kind would work.
11:07:51 <Heffalump> if you use an array you'll end up writing fairly imperative code
11:08:02 <Heffalump> which might be OK with you, but just bear it in mind
11:09:07 <dark_> Hmm not necessarily, you can write everything in terms of transformers on the array.
11:10:50 <dark_> You would need five Word64 values, right?  One for each piece plus an "any piece" one.
11:11:00 <dark_> Oh, wait.  White and black :)  So that's nine.
11:11:12 <dark_> Er, sorry, 13.  I can't count.
11:12:31 <dark_> I think a DiffArray-like approach could work.  Construct a board representation however you like, but make it easy to represent small changes to it (such as moving one piece).  Then at critical points (such as when making an actual move) you consolidate the changes into a new board.
11:13:41 <dark_> I think a go-playing program would be more interesting :)
11:14:54 <dark_> You can't minimax that though.
11:16:37 <Heffalump> can't you score positions?
11:18:38 <dark_> Heffalump: Not just by looking at them :)
11:19:17 <dark_> Heffalump: Shifting a single stone by one position can make a difference from "certain win" to "very very bad"
11:19:48 <Heffalump> well, the same can apply in chess
11:19:58 <Heffalump> but you apply scores for pinned pieces, etc
11:21:25 <dark_> The main thing in Go is to figure out if groups are "alive" or "dead".  Unfortunately this is usually not decided on the board and has to be estimated -- it reduces to "can be saved" or "can be killed", with costs for each.
11:21:59 <dark_> Actually, for a computer player, figuring out how to divide the board into groups can be difficult :)
11:23:54 <dark_> There are some common shapes which are known to be alive or dead, that can be useful.
11:24:56 <dark_> And it might be possible to estimate that a group has enough going for it that it's probably alive.
11:26:57 <dark_> Once you have some idea of which groups are live, you can then estimate the territory claimed by each side, and that's a useful score.
11:28:38 <dark_> You have a large exponential base, though.  There are usually several hundred possible moves, so discarding unreasonable ones will have to be done quickly.
11:30:06 <dark_> Fortunately it's easy to redefine Go to use a smaller board, where a computer player has a chance :)
11:54:08 <Jii> i should learn some go
12:03:16 <Jii> or maybe not
12:46:24 <dark_> Jii: It's easy to get started :)
12:52:16 <Jii> well i'm having so much fun with haskell right now ;-)
14:05:13 <dark_> I notice that haskell requires more brain activity than C :)
14:31:17 <pesco> dark_: I'd say that Haskell encourages more brain activity than C.
14:31:53 <dandelion-> it should be possible to program C style in haskell, using the do-notation, no?
14:32:28 <pesco> Pretty much, I guess.
14:33:45 <dark_> dandelion: I don't think you have anything equivalent to C pointers.
14:34:24 <pesco> IORef?
14:35:19 <dark_> pesco: Doesn't help if you want to take the address of an existing symbol
14:37:40 * dark_ wonders where to use PackedString
14:38:34 <delYsid> dark_: For encoding data byte-wise maybe?
14:39:17 <pesco> Nah, you wouldn't want to put binary data into a chars.
14:40:14 <dark_> I've been thinking of using it when I'm using a String just as a label, to be compared or printed out.
14:42:11 <dark_> On the other hand, if the first character is usually different, then comparing Strings might be faster than comparing PackedStrings :)
15:10:29 <delYsid> Does anyone here use Edison?
15:17:19 <delYsid> Hal Daum'e III
15:17:21 <delYsid> Is he here?
15:38:17 <delYsid> ...
15:38:18 <delYsid> updateState (+((-towork dow)+dur)) >>
15:38:19 <delYsid> space >>
15:38:19 <delYsid> if dow == So
15:38:19 <delYsid> then char '=' >> getState >>= \st -> string (show st)
15:38:19 <delYsid> else string (show ((-towork dow)+dur))
15:38:20 <delYsid> many (oneOf " \t\n") >>
15:38:22 <delYsid> ...
15:38:35 <dark_> What happened to the indentation?
15:38:37 <delYsid> -- What is wrong with that if-statment? I get parse error on input `else'
15:39:00 <delYsid> How is it supposed to be indented?
15:41:35 <delYsid> grrr
15:42:04 <delYsid> I'll never understand those layout rules, esp. if all the papers I read are pstotext (without any kind of indent)
15:44:32 <dark_> delysid: I think that at least the then and else have to be indented compared to the if, if you're inside a do statement.  And even if you're not, maybe the lambda expression requires it.
15:51:59 <dark_> The if-then-else inside do rule was the only one I stumbled on :)  Other than that haskell layout has followed my expectations completely.
16:05:51 <shapr> boing
16:06:20 <Jerub> boing
16:06:26 <shapr> y0 Jerub, wassup?
16:06:54 <Jerub> doing some (non-compulsary) uni work before going to see an old friend.
16:08:54 <shapr> interesting work?
16:10:26 <Jerub> no, its thinly disguised probability, in a datacomms subjects
16:10:32 <shapr> oh
16:11:17 <Jerub> but fortunately, I have a maths background, so its merely a matter of dredging up fundamentals and applying them.
16:11:30 <shapr> I'd like to have a math foreground.
16:11:33 <shapr> maybe next year.
16:11:38 <Jerub> however, I think there are simplistic answers to questions where I'm using \Sigma.
16:15:07 <Jerub> bugger.
16:15:21 <Jerub> calculator required for a couple of these questions
16:15:27 <Jerub> I think I'm just going to leave them.
16:16:05 * shapr is man of little math
16:16:16 <delYsid> same here
16:16:43 <shapr> delYsid: I just saw foldr (.) in the logs :-)
16:17:22 <delYsid> well, I have such cool code, gotten from a guy here:
16:17:40 * shapr waits with baited breath
16:17:43 <delYsid> dayOfWeek = foldr1 (<|>) (map isDay [Mo ..])
16:17:43 <delYsid>   where
16:17:43 <delYsid>    isDay x = try (string (show x)) >> return (x)
16:18:12 <shapr> foldr (<|>) makes my brain implode
16:18:32 * shapr reads that recursively
16:18:33 * Jerub blinks
16:18:40 <Jerub> what does <|> do?
16:18:44 <delYsid> well, <|> is a combinator for Parsec, meaning Or
16:19:25 <delYsid> the isDay function simply tests if it can parse its argument as string, if not, it fails.
16:19:31 <shapr> that is extremely cool code.
16:19:50 <shapr> one day, that kind of code will be natural to me...
16:19:57 <Jerub> beginner question -> does it take an argument?
16:20:00 <shapr> and I'll never be profitable with Java again!!!
16:20:11 <delYsid> Jerub: dayOfWeek?
16:20:17 <Jerub> delYsid: yeah.
16:20:40 <delYsid> Jerub: no
16:20:48 <delYsid> dayOfWeek :: CharParser Minutes Day
16:21:06 <delYsid> So, the CharParsers state is Minutes, and it's return value is a Day
16:21:22 <Jerub> I don't grok (.) and ($) yet. Nor do I grok type errors.
16:21:31 <delYsid> . is easy
16:21:33 <shapr> Jerub: (.) means concatenate
16:21:46 <Jerub> I thought it had something to do with arugments.
16:21:56 <shapr> nah
16:22:01 <Jerub> okay, . is cat.
16:22:10 <delYsid> a (b (c 1)) is the same as (a . b . c) 1
16:22:10 <shapr> it's more like | in shell script
16:22:20 <shapr> yah
16:22:23 <delYsid> $ is for arguments
16:22:35 <delYsid> char $ 'x' is same as (char 'x')
16:22:45 <shapr> $ means "lazily apply"
16:22:53 <shapr> usually the space is the most tightly binding operator
16:22:57 <dark_> shapr: all application is lazy :)
16:22:58 <shapr> errr
16:23:14 <shapr> dark_: yah, but...
16:23:27 <shapr> function application is the most tightly binding op in Haskell
16:23:41 <dark_> But $ is useful for getting rid of excess parentheses, like foo (bar (gnu (fnord))) becoming foo $ bar $ gnu $ fnord, which could also be written as (foo . bar . gnu) fnord
16:23:42 <shapr> and the $ means bind very loosely instead
16:23:47 <shapr> fnord?
16:23:54 <shapr> all hail eris!
16:23:59 <dark_> I ran out of names :)
16:24:10 <dark_> I guess fnord makes it difficult for some people to read the example.
16:24:12 <Jerub> I don't get the eris/fnord reference.
16:24:23 <shapr> Jerub: read the pricipia discordia sometime
16:24:27 <dark_> Jerub: But you see the fnords?
16:24:28 <Jerub> shapr: url?
16:24:35 <Jerub> I see the fnords.
16:24:43 <shapr> the print edition from jackson games in my favorite, but any online copy will suffice.
16:25:00 * Jerub blinks
16:25:17 <Jerub> ahh! the circleplus function operator from algebra!
16:25:47 <delYsid> or
16:25:48 <shapr> $ has another use with foldr1 ($) and map ($)
16:25:52 <delYsid> foo . bar . gnu $ fnord
16:25:55 <shapr> but I don't understand what the heck that does...
16:25:55 <delYsid> (iirc)
16:26:12 <Jerub> okay, I'm going to go ride my bike into the city (damn I love living this close)
16:26:35 <shapr> circleplus... hmm
16:26:43 * delYsid vanishes in a cloud of blue smoke
16:26:45 <delYsid> goodnight guys
16:26:48 <shapr> g'night delYsid!
16:26:51 * shapr goes to sleep also
16:26:55 <Jerub> g'night
16:27:15 <Jerub> its 0930 here, so I'm going to go make a day of it :)
16:29:03 <delYsid> ok, tomorrow i need to learn the div. between class and instance declarations...
16:30:37 <dark_> map ($)?  But $ is a binary operator.
16:34:27 <dark_> The principia discordia looks like a pile of nonsense to me.
16:35:08 <dandelion-> what is it?
16:35:54 <dark_> http://www.ology.org/principia/
16:57:14 <delYsid> 		GREATER POOP: Are you really serious or what?
16:57:14 <delYsid>     MAL-2: Sometimes I take humor seriously. Sometimes I take seriousness
16:57:14 <delYsid> 		   humorously. Either way it is irrelevant.
16:57:28 <delYsid> hehe :)
16:57:33 * delYsid likes the thing
21:02:36 <Pseudonym> Grrrrr... anyone who's responsible for the wiki?
21:02:42 * Pseudonym might have to mail them directly
21:07:06 <Jii> yes, very annoying
22:42:40 <Jii> but, good morning anyway
23:02:33 <Pseudonym> Thanks whoever subscribed the icfp-team mailing list.
23:06:25 <Jii> that wasn't me! ;-)
23:07:44 <Pseudonym> :-)
23:07:58 <Pseudonym> I think it was actually jens who isn't here at the moment.
23:08:06 <Pseudonym> So thanks to the ghost of jens.
