05:19:26 <Igloo> Woohoo! My Haskell code is faster than my C code!
05:20:23 <ayrnieu> What is your code doing?  How does memory usage compare?
05:21:45 <Igloo> The reason is that the Haskell code gets unrolled by Template Haskell
05:21:59 <Igloo> oth are constant space, Haskell will be higher
05:22:20 <ayrnieu> Oh, nifty.
05:23:20 <Igloo> I need to inline (by hand) a bit more than is ideal to see it, unfortunately
05:24:20 <ayrnieu> Oh, icky.
05:24:41 <ayrnieu> By (by hand) you mean pragmas?
05:25:04 <Igloo> It requires putting z^2+xy in the inner function rather than passing it as a parameter
05:26:44 <Igloo> Hmmm, (^) isn't strict in its first argument
05:50:05 <BlitzNL> Exists some default function which does this: somefunction [["1","2","3"], ["a","b","c"]] yields [["1", "a"], ["2", "b"], ["3", "c"]] ?
05:51:08 <Marvin--> not for lists... You can use zip :: [a] -> [b] -> ([a],[b]) though
05:51:18 <Marvin--> err, [(a,b)] in the rhs
05:51:32 <ibid> map (\(a,b)->[a,b]) . zip
05:51:33 <ibid> :-)
05:52:02 <BlitzNL> hehe ;)
05:52:03 <Marvin--> duh
05:52:20 <Igloo> You mean  map (\(a,b)->[a,b]) . zip . (\[a, b] -> (a, b))   :-)
05:52:34 <BlitzNL> thnx guys
05:52:35 <Igloo> Oh, and uncurry zip
05:54:07 <ibid> yeah
05:59:19 <BlitzNL> Marvin--, ibid, Igloo: There does exist a function that does exactly what I want: transpose !
05:59:58 <Igloo> Oh, of course  :-)
06:05:09 <Marvin--> oh, right :)
06:18:58 <Igloo> Heff: The library report says 'nub (meaning "essence")'
06:31:26 <BlitzNL> Now we are talking about nub. I don't understand this. When I type: nub [0,1,1,2,3] this works fine (removes duplicates) but nub (union ["Nr", "Artiest", "Liedje"] ["Arties", "Land"]) doesn't work for me in hugs..
06:31:37 <andersca> well
06:31:43 <andersca> Artiest != Arties
06:31:56 <andersca> what does union do?
06:32:05 <BlitzNL> andersca: :( very stupid typo indeed :(
06:32:37 <BlitzNL> andersca: union combines two lists, hugs forgot to copy that to clipboard
06:32:45 <andersca> typo is better than a bug in hugs :)
06:33:07 <BlitzNL> andersca: indeed ;)
06:34:24 <Igloo> If the lists are disjoin to start with then nub after union is pontless
06:34:27 <Igloo> pointless even
06:35:31 <ayrnieu> union = (++) -- ?
06:35:35 <andersca> is union (nub . (++))
06:35:35 <andersca> ?
06:35:58 * ayrnieu reads 'combines two lists' as other than 'combines to lists-as-sets'
06:37:43 <Igloo> union is (\x y -> nub (x ++ y)) except I'm not sure the order will necessarily be the same
06:38:41 <andersca> isn't that the same as (nub . (++)) ?
06:39:21 <Igloo> No, it has a correct type for starters  :-)
06:39:46 <Heffalump> heh, that's an exercise that almost all our first years/MSc students get wrong
06:39:51 * Marvin-- notes that listening to powermetal in headphones is a bad idea
06:40:00 <Igloo> Oh, actually they're not the same anyway, as (\x y -> nub (x ++ y)) doesn't do the same thing if the lists aren't disjoint to start with
06:40:01 <Heffalump> f x y = g (h x y) does not mean f = g . h
06:40:15 <Marvin--> they fall off *g*
06:42:00 <dark> Heffalump: Is there a way to express an operator that does what . does, for an arbitrary number of following arguments?
06:42:38 <Heffalump> possibly with a type class, but I doubt it
06:58:44 <tinus> hmm, might be a dump question, but how can i map a function that takes two parameters?
06:58:49 <tinus> dumb, too
06:59:40 <ayrnieu> You don't do that.
06:59:47 <tinus> oh, ok ...
06:59:49 <ayrnieu> Why do you think that you want to do that?
06:59:54 <Heffalump> zipWith
07:00:38 <tinus> zipWith takes lists
07:00:51 <tinus> ayrnieu: i need to map this function: multiplyIngredient :: Ingredient -> Int -> Ingredient
07:01:08 <ayrnieu> tinus - why do you think that you want to do that?
07:01:43 <tinus> ayrnieu: euhm, because i have a list and the function take a single one ?
07:02:17 <Heffalump> what do you want to map it over?
07:02:26 <ayrnieu> tinus - it *doesn't make sense* to map a function of arity other than two over a list.  This is never done; it *can't* be done.
07:02:33 <ayrnieu> other than one.
07:02:35 <tinus> over [Ingredient]
07:02:52 <Heffalump> map (flip multiplyIngredient 5) ingredients
07:02:54 <ayrnieu> tinus - so please *back up* a little, and explain why you came to think that you wanted 'map'
07:03:04 <tinus> ayrnieu: it needs to be mapped over one list and takes an extra Int paramater
07:03:13 <ayrnieu> Heffalump - that maps a function of arity one
07:03:17 <Igloo> It can be done - in this case it would produce something of type [(Int -> Ingredient)]
07:04:03 <ayrnieu> tinus - I see.  You want to curry a arity-two function into an arity-one function and map that over a list?  What Heffalump said.
07:04:23 <ayrnieu> also:  map (+1) [1..10]
07:04:39 <tinus> yeah, what Heffalump said works
07:04:46 <ayrnieu> map (flip (-) 1) [1..10]
07:04:54 <tinus> the two parameters are not -both- lists if that's what you though
07:04:55 <tinus> t
07:05:23 <ayrnieu> tinus - no, it's just that you were asking to map a function of arity-two over a list, which doesn't make sense.
07:05:45 <ayrnieu> well, what Heffalump said about the list of functions.
07:05:59 <Heffalump> YM Igloo
07:06:15 <ayrnieu> Yes, thank you.
07:06:20 <Heffalump> we may agree a lot, but we're different people really :-)
07:06:34 <dark> That's what they all say.
07:06:34 <Igloo> I agree
07:06:44 <dark> My clone detector is ringing madly here.
07:06:46 <Heffalump> I think there's about 30 feet between us.
07:07:13 * Heffalump watches Igloo looking to check
07:07:23 * Igloo watches Heff watching me
07:07:42 <ayrnieu> dark - if one of them were a clone, that would imply much disagreement and 'different people'.
07:07:53 * Heffalump watches for Igloo looking to see me watching him
07:07:56 <Heffalump> ahem.
07:08:01 <ayrnieu> (but I know what you mean)
07:18:22 <dark> ayrnieu: What did you mean about clones?
07:24:26 <Marvin--> hey shapr
07:24:33 <andersca> yo shapr, Marvin--
07:25:41 <ayrnieu> dark - I was intentionally misreading clones (same intelligence behind multiple clients) as 'biological clones'
07:25:56 <shapr> hi Marvin--, ltns
07:26:10 <dark> Oh, I meant neither of those.  I mean B-movie clones :)
07:26:25 <ayrnieu> Oh =)  OK.
07:30:55 * shapr bounces
07:31:01 <shapr> I'm back online! yay!!!
07:31:15 <Marvin--> shapr: with telia, poor guy :P
07:31:22 <shapr> yah, that part does suck
07:31:25 <Marvin--> we usually nickname telia with felia
07:31:27 <shapr> I had to setup one of my boxen as a NAT
07:31:53 <shapr> even though our DSL modem is an ethernet bridge, we still have to do DHCP, and we can only get one ip
07:31:55 <Marvin--> ("fel" = "error"/"wrong")
07:31:58 <shapr> very weird setup.
07:33:05 <shapr> debian has freedict-swe-eng makes my life much easier
07:33:23 <Igloo> :-)
07:33:43 <shapr> jag är amerikansa.
07:35:41 <Marvin--> eh
07:35:56 <Marvin--> parse error on 'amerikansa'
07:41:09 <ibid> shapr: amerikansk, kanske?
07:41:32 * Marvin-- hopes shapr didn't mean "amerikanska" :)
07:41:55 <ibid> you don't want multiple shaprs?
07:42:07 <Marvin--> one is enough ;)
09:53:21 * shapr laughs
10:06:01 <liiwi> dark: um, ever de-compiled shared object files?
10:06:35 * shapr sproings
10:06:57 <dark> liiwi: Not exactly.  Does a kernel module count?
10:10:08 <dark> liiwi: It should be easier than an executable, because it has more entry points and generally usually more symbol names.
11:17:46 * shapr bounces
11:17:53 <shapr> hi Kvaeser
11:18:49 <shapr> do you have Haskell questions?
11:19:17 * shapr blinks at a french bug report
11:20:56 <shapr> I think Dominic Steinitz was doing xmlrpc stuff in HaXml.. I wonder how far he got
11:29:40 <shapr> haskell wiki is way broken :-(
11:36:28 <shapr> hey Kvaeser, are you awake?
11:36:51 <shapr> hey, any swedish residents awake? I have a bankgiro/postgiro compatibility question...
11:37:47 * shapr asks on #debian.se
12:10:53 <shapr> mycket svensk talar Haskell
12:18:21 <andersca> shapr?
12:19:39 <shapr> ja?
12:19:48 <andersca> did you get help with the pg/bg stuff?
12:19:53 <shapr> ja, tack
12:52:57 <shapr> hi jemfinch, ltns
12:53:11 <jemfinch> yeah, I'm not on the best of internets :)
12:54:10 <jemfinch> how's your Haskelling goign?
12:55:25 <shapr> haven't done much with it in the last coupla weeks
12:55:29 <shapr> been busy moving to sweden
12:55:45 <shapr> now that I'm back online, I want to get back to figuring out how to use monads on a daily basis
12:55:49 <jemfinch> moving to sweden?  Craziness...
12:55:59 <shapr> well, I'm here now
12:56:03 <shapr> and mostly setup
12:56:06 <shapr> nice place
12:56:20 <jemfinch> you moved from...finland?
12:56:41 <shapr> yup
12:56:52 <jemfinch> hmm.
12:57:06 <jemfinch> so is moving countries in the EU like moving states in the US?
12:57:26 <Heffalump> not quite
12:57:38 <Heffalump> different languages, potentially
12:57:48 <jemfinch> shapr: do you know Finish?
12:57:53 <jemfinch> er, Finnish...
12:57:55 <jemfinch> :)
12:58:52 <shapr> I know just a bit of finnish
12:58:59 <shapr> I know nearly as much swedish already
12:59:09 <shapr> swedish is a lot like half dutch and half german
12:59:14 <jemfinch> yeah, but Swedish should be much easier, it's indo-european.
12:59:34 <jemfinch> Finnish is one of the like 3 eurasian languages that isn't in the indo-european family of languages.
12:59:51 <shapr> yah, it's *hard*
12:59:56 <shapr> it's agglutinative
13:00:06 <shapr> something like partial application in a language
13:00:13 <andersca> haha
13:01:08 * jemfinch doesn't know what agglutinative means.
13:01:25 <jemfinch> is it alright to talk about SML here?  There's no SML channel on OPN.
13:01:43 <shapr> I'm okay with it.
13:01:43 <Heffalump> I do occasionally, but usually only to complain :-)
13:01:48 <Heffalump> (fine with me)
13:01:56 <shapr> hi Heffalump!
13:02:09 <jemfinch> I've been wanting to implement an object-oriented language somewhat like Smalltalk in SML.
13:02:19 <shapr> have you looked at O'Haskell?
13:02:24 <jemfinch> (lazy evaluation boggles my mind a bit too much)
13:02:33 <shapr> oh, and check out Krishnaswami's Needle
13:02:35 <shapr> I gotta try Needle
13:02:44 <Heffalump> I doubt OO features in the host language would help implement them in the object language much
13:02:47 <lament> Is needle lazy?
13:02:55 <jemfinch> shapr: no, not really, but I also have been wanting to implement an interpreter for the pure enjoyment -- not really because I especially want a language like Smalltalk.
13:02:58 <shapr> lament: I'm pretty sure it is...
13:03:05 <shapr> lament: I don't know if it's pure FP though
13:03:06 <jemfinch> shapr: conceivably, it might be like Python, too, kinda a mix of the two.
13:04:08 <jemfinch> object representation in the host language seems pretty simple -- a (state, methods) pair, however state and methods are implemented.
13:04:10 <shapr> if it's pure, I'm in love...
13:04:15 <lament> heh
13:04:24 <lament> What makes it so good?
13:04:45 <jemfinch> (methods might be, for instance, a function of type "string * obj * obj list -> obj"
13:04:45 <Heffalump> jemfinch: right, yeah
13:05:28 <jemfinch> now, if extensibility wasn't a consideration, it'd be simple to implement: all the various states could be kept in a big data type.
13:05:45 <shapr> http://ll2.ai.mit.edu/talks/krishnaswami.pdf
13:05:46 <jemfinch> but that means that every time a new class is added to the interpreter, the core interpreter code has to be modified.
13:05:50 <shapr> that's his talk from LL2
13:06:34 <shapr> http://www.nongnu.org/needle/
13:06:56 <jemfinch> I thought about using combinator functors (making a signature TYPE, making a functor CombineFn that takes two TYPEs and returns a TYPE)
13:07:10 <jemfinch> but that still leaves the core problem: accessing the state from the SML side.
13:07:51 <jemfinch> e.g., how would one integer object access the internal state of another integer object in order to add it to itself?
13:08:26 <jemfinch> I'm thinking I finally came up with a solution, but it's not exactly the most elegant solution in the world -- it's based on the same idea that the PropList module is -- that exceptions are extensible data types.
13:09:20 <jemfinch> so the state can be an exception, and adding new types to the language is as easy as defining a new exception holding values of whatever the state needs to hold.
13:09:31 <jemfinch> the integer object could be implemented like this:
13:09:36 <jemfinch> exception INTEGER of int
13:09:39 <Heffalump> I don't understand why accessing the internal state of another object is a problem
13:09:57 <jemfinch> Heffalump: how would you append two strings, or add two integers?
13:10:58 <Heffalump> the function that does that just pattern matches on the internal state of the string, surely?
13:11:37 <jemfinch> Heffalump: in a simple interpreter, I could just define a datatype, and it would just match on the internal state of the string, for sure.
13:12:41 <jemfinch> Heffalump: but that's not extensible, since if I want to add a new class to the language, I have to modify that original datatype definition.
13:13:06 <jfincher_> Heffalump: what's the last message you got from me?
13:13:08 <Heffalump> ahh, right
13:13:16 <Heffalump> the bit about it not being extensible
13:13:23 <jemfinch> ah, ok, good.
13:13:32 <Heffalump> you could make your class names be strings rather than SML constructors
13:13:49 <jemfinch> but then there's the problem of allowing different forms of states.
13:14:23 <jemfinch> an integer object's state would be an int object, but a string object's state would be a string -- the constructors are really necessary to be able to have different states for each object that wants it.
13:16:12 <Heffalump> you could make a union type of all the primitive types
13:16:24 <Heffalump> data prim = int of int | string of string | ...
13:16:38 <Heffalump> and then keep a finite map from names to values for the object state
13:16:54 <jemfinch> yeah, I've thought of that, too.
13:17:24 <jemfinch> but that's an awkward programmatical interface, and it simply can't cover all primitive types (tuples and records, specifically) so it's not completely general.
13:17:44 <jemfinch> if SML had a Dynamic type, I could probably conceivably use that, too.
13:17:49 <jemfinch> but it doesn't :(
13:18:20 <jemfinch> the exception way is the way I've found most all-around pleasing thus far, I suppose.
13:20:55 <jemfinch> I wonder if matching on exceptions is just as efficient as matching on datatypes.
13:21:28 <lament> Is SML kinda like ocaml?
13:21:54 <jemfinch> in most ways.
13:22:09 <jemfinch> O'Caml is different from SML where O'Caml chose to be different from SML.
13:22:11 <jemfinch> and where it's grown to be different.
13:22:28 <jemfinch> SML's focus isn't research nearly as much as it is to be a good language for implementing large systems.
13:22:57 <jemfinch> so a lot of the research stuff in O'Caml (polymorphic recursion, polymorphic variants, classes, etc.) aren't in SML.
13:26:15 <Heffalump> the efficiency of exceptions depends on the implementation 
13:26:25 <Heffalump> some are pretty bad
13:26:33 <Heffalump> but I guess you won't actually be raising any
13:27:07 <jemfinch> yeah, just matching against them.
13:28:58 <Heffalump> you can deal with tuples etc by dealing with them in your prim type
13:29:09 <Heffalump> data prim = tuple of int * prim list
13:29:33 <Heffalump> and a | record of (string,prim) Splaymap.dict
13:29:42 <Heffalump> but I agree it's awkward
13:32:39 <jemfinch> oh, I don't mean tuples/records in the implemented language, I mean tuples/records in the host language.
13:34:03 <Heffalump> ah, ok
13:34:15 <Heffalump> which SML implementation are you using?
13:34:21 <jemfinch> sml/nj.
13:34:48 <Heffalump> and it doesn't have a Dynamic type or anything?
13:35:22 <jemfinch> no, unfortunately not.
13:35:31 <jemfinch> otherwise that'd be an excellent solution, I think.
13:35:49 <jemfinch> Dynamic type requires compiler cooperation, if I read correctly.
13:41:01 <Heffalump> fromDynamic would, I think
13:41:44 <jemfinch> I can't see why Dynamic types aren't implemented in every strictly typed language.
13:43:16 <ludde-> it's not as efficient as static typing, is it.
13:43:26 <Heffalump> cos they encourage people to break type safety to get round a problem?
14:57:29 <dark> Heffalump: Dynamic doesn't break type safety :)
14:57:37 <dark> At least in Haskell it doesn't.
14:57:46 <Heffalump> well, it does in the sense that you can now get runtime "type errors"
14:57:58 <Heffalump> basically it encourages people to start coding with dynamic types
14:58:13 <dark> Yeah, but that's not really any worse than a Maybe type turning out to be Nothing.  The moral is to not do fromJust unless you're really sure.
14:58:32 <dark> Yes.  This is a good thing if dynamic types describe their problem best :-)
14:58:39 <Heffalump> yeah
14:58:47 <Heffalump> it's just when they don't and people are tempted to use them anyway that it's bad
14:58:57 <Heffalump> we have strong types for a reason, you know :-)
14:59:02 <Heffalump> Dynamic is a weak type, in that sense.
14:59:14 <dark> True.
14:59:42 <dark> I'm using Dynamic in a bag-of-attributes type, where elements are implicitly keyed by type as well as by key string.
15:00:29 <dark> Can't have type errors that way, it just means the element isn't there :)  An all the code that accesses this bag needs to be able to deal with that anyway.
15:01:30 <dark> FiniteMap String Dynamic, with a special lookup function.
15:02:15 <dark> I did this because I was actively considering writing the program in perl so that I could use perl hashes.  Then I realized I wouldn't have to give up any of the other virtues of Haskell to get those :)
15:02:21 <Heffalump> heh
15:18:46 <lament> Hm, you could use Python instead :)
15:32:31 <dark> No, I can't use python :)
15:33:23 <lament> How come?
15:34:14 <dark> There's something about the language that I just can't stand.
15:34:25 <lament> heh.
15:34:26 <andersca> python is very cool
15:34:41 <dark> Its coolness shall forever be beyond my grasp.
15:34:44 <lament> dark: Well, I just had to say that since you mentoned perl :)
15:35:14 <dark> python was a step up from awk, I'll give it that :-)
15:35:28 <lament> No, it wasn't.
15:36:35 <lament> It was more or less a step sideways from smalltalk into lisp
15:36:44 <shapr> I like python.
15:36:46 <shapr> I like Haskell too
15:36:53 <andersca> so do I
15:37:00 <andersca> I also like the animated X cursors that I have now
15:37:00 <dark> Well, *everyone* likes Haskell.
15:37:04 <shapr> of course
15:37:08 <dark> Ask anyone on this channel :-)
15:37:11 * shapr laughs
15:37:28 <shapr> hey dark, I see you did subscribe to the haskell mailing lists ;-)
17:03:00 <Igloo> Chilli, are you around?
18:11:49 <Chilli> Igloo: Hi
18:11:58 <Chilli> Was away having lunch etc
18:12:41 <Igloo> I was being confused by Gtk+HS examples on the webpage not working, but now I've read the ChangeLog and am enlightened  :-)
18:13:01 <Igloo> Just to check I'm not missing something, though, you haven't implemented the GdkRGB stuff yet, right?
18:14:47 <Chilli> hmm, have to check myself
18:15:09 <Chilli> no, not implemented
18:15:16 <Chilli> what do you need it for?
18:15:46 <Chilli> (if you implement it, please send me a patch! :-)
18:17:16 <Igloo> I'm not 100% sure I want it yet - what I want is put_pixel :: Int -> Int -> RGB -> GC -> IO () (or a more sane argument ordering and return type). Currently reading GTK docs  :-)
18:17:53 <Igloo> My impression thus far is that GdkRGB would handle all the failures for me, though
18:17:57 <Chilli> to display your fractals?
18:18:02 <Igloo> Yup
18:18:57 <Igloo> Although I'm not quite sure how the interactivity will work out  :-)
18:20:29 <Chilli> Don't you rather want the gdk_draw_* primitives?
18:21:09 <Igloo> They don't take colours
18:21:41 <Igloo> put_pixel will call gdk_draw_point, yes
18:22:25 <Chilli> usually, you set colours using a graphics context
18:22:35 <Chilli> see gdk_gc_*
18:23:38 <Igloo> Hmmm, OK, gdk_colormap_alloc_color was the best non-RGB thing I'd found thus far
18:24:24 <Chilli> there is gdk_gc_set_forground()
18:24:55 <Chilli> or rather Gdk.gcSetForeground
18:25:00 <Igloo> Ah, yes, I wasn't sure whether it wanted an allocated or unallocated colour, though
18:25:06 <Chilli> sets the foreground colour
18:25:21 <Chilli> you need to allocate a colour first
18:25:35 <Igloo> Right, so I'd need to do gdk_colormap_alloc_color first and cope with it failing
18:25:39 <Chilli> otherwise, it's not portable to devices with low colour resolution
18:26:11 <Chilli> you can give it flags, so that it uses the colours closest to what you want
18:26:15 <Chilli> then, it never fails
18:26:41 <Chilli> but if you are on a 256 colour display and X doesn't allow you to use a privatre colour map
18:26:58 <Chilli> you need to deal with not being able to allocate all colours somehow
18:27:33 <Igloo> http://developer.gnome.org/doc/API/gdk/gdk-colormaps-and-colors.html#GDK-COLORMAP-ALLOC-COLOR doesn't say it doesn't fail
18:27:44 <Igloo> I think the GdkRGB stuff does that for you, though
18:28:16 <Chilli> true, doesn't say it
18:28:41 <Chilli> but I am pretty sure that it doesn't fail, if you specify False for the first Bool arg and True for the second
18:29:38 <Igloo> Hmmm, I shall play with this later. For now, bed.
18:30:35 <Chilli> 'night
18:30:41 <Igloo> Night  :-)
18:31:00 <Chilli> (to be honest, I haven't looked at GdkRGB much)
20:38:02 <creature> Morning, all.
20:38:19 <creature> A quick Q: How do I concatenate something into a list of strings? 
20:38:35 <creature> I'm trying to do "zipWith (++) "\n" strList" but it's not having any of it.
20:42:26 <Vulpyne> Trying to add [Char] to [[Char]]?
20:43:06 <creature> I have a list of strings. 
20:43:14 <creature> I want to get out one string.
20:43:25 <creature> But, I want to add a \n between each of them/
20:43:51 <Vulpyne> What error do you get?
20:43:57 <creature> a Type error.
20:44:05 <Vulpyne> Yes?
20:44:26 <Vulpyne> What's the error?
20:44:33 <creature> [Char] -> [Char] -> [Char] does not match Char -> [Char] -> [Char]
20:44:42 <Vulpyne> Hmm.
20:44:49 <Vulpyne> What happens if you make "\n" ["\n"] instead?
20:47:28 <creature> I get a different error. :)
20:47:33 <creature> Let me take a look at this one for a while.
20:47:36 <Vulpyne> Heh, okay.
20:47:48 <Vulpyne> I'm a clueless newbie, so I  doubt I can offer any more suggestions.
20:47:51 <Vulpyne> Never used zip.
20:48:09 <creature> I'm equally clueless, don't worry.
20:51:20 <creature> Got it sorted, using a completely different method.
20:51:39 <creature> formatStrings strList = concat([x ++ "\n" | x <- strList])
20:51:44 <creature> In case you're interested.
21:18:37 <tez> formatStrings = concat.map (\x->x++"\n")
21:18:55 <tez> (If you wanted a non-list comprehension version)
21:19:15 <creature> Could I have a hint about to move from [(String,String)] to [String], please/ 
21:19:16 <creature> ?
21:19:33 <creature> Ooh, I might be able to do this actually.
21:19:58 <tez> Give it a stab, I can try and help if you need.
21:22:43 <creature> glue :: [(String,String)] -> [String]
21:22:47 <creature> Why does this give me:
21:22:57 <creature> ERROR Library.hs:72 - Syntax error in declaration (unexpected `;', possibly due
21:22:57 <creature> to bad layout)
21:23:04 <creature> That is line 72.
21:23:19 <tez> Maybe the line before or after is incorrectly indented.
21:23:51 <tez> Or you've forgotten to close some parentheses the line before.
21:23:57 <creature> yep, that's what I like to call a "5AM error".
21:24:02 <tez> lol
21:24:12 <creature> Defined a function above, the commented out all except the declaration.
21:24:49 <tez> Ah
21:26:39 <creature> What's wrong with this:
21:26:47 <creature> glue [(n,p)] = [ a ++ b | (a,b) <- [(n,p)]]
21:26:54 <creature> It accepts that. 
21:26:59 <creature> Then I tried to do this:
21:27:17 <creature> glue [("Bob","Hoskins"),("Elmer","Fudd"),("James","Dean")]
21:27:23 <creature> And it gave me a program error.
21:27:30 <tez> Is that the only line you have for glue?
21:27:46 <creature> Yep.
21:27:48 <tez> That line will only match a list with one pair in it.
21:27:52 <creature> Well, I've got the above declaration.
21:28:24 <tez> You're trying to give it a list of size three, but your definition doesn't match.
21:28:45 <creature> My definition was for a list of (String,String) tuples, wasn't it?
21:29:26 <tez> Yes, yes, but look at the start of your line.  It says "glue [(n,p)] = ..."
21:29:49 <tez> [(n,p)] is a list with one pair in it.
21:30:10 <tez> So there's no way [("Bob","Hoskins"),("Elmer","Fudd"),("James","Dean")] can match it.
21:30:19 <creature> I feel some recursion coming on.
21:30:32 <tez> What I think you wanted to say was: glue xs = [ a ++ b | (a,b) <- xs]
21:32:51 <creature> That's very cunning, thanks. 
21:33:01 <tez> Well, you nearly had it.
21:35:00 <creature> I wasn't far off. :)
21:44:36 <creature> Hmm, I'm having some trouble with a different function.
21:44:42 <creature> I'd like hints, not answers. 
21:45:20 <creature> Anyway, I have to write a function maxBorrow :: Database -> [Person] that gives the answer to "Who has borrowed the most books in a given database?".
21:46:01 <creature> It's a list so that if 2 or more people have got an equal number, it returns them both.
21:46:35 <tez> Ah.  What's the type of Database?
21:46:48 <tez> Or are you given functions to access it?
21:47:06 <creature> It's [(Person,Book)]
21:47:13 <creature> Both Person and Book are strings.
21:47:55 <tez> Hmm
21:48:21 <creature> I've got useful stuff like maxLoan , to give the maximum number of books borrowed. 
21:48:31 <creature> Loans, to give how many boks an individual has borrowed. 
21:48:40 <tez> Ah, Loans.
21:48:50 <tez> Whatis the type of oans?
21:48:54 <tez> Whatis the type of loans?
21:49:25 <creature> loans is loans :: Database -> Person -> Int
21:49:55 <tez> and for that matter, what is the type of maxLoan?  Database -> Int?
21:50:18 <creature> Yep.
21:51:13 <creature> how easy is it to write a grep program in haskell?
21:51:19 <tez> I would be tempted to define a function personBorrow :: Database -> [(Person,Int)]
21:51:40 <creature> I've got a showLoanInfo that outputs a nice list of people, and how many books they've borrowed.
21:51:40 <tez> Uh, string-matching?  It's not straightforward.
21:51:46 <creature> Ah, ha, I hear a penny dropping.
21:51:49 <tez> lol
21:51:50 <creature> BRB.
21:51:58 <tez> *That* makes thins much easier.
21:53:49 <creature> Nope, need a hint.
21:53:59 <creature> Probably because I've been up for 22 hours on 3 hours sleep.
21:55:26 <tez> Well, you use showLoanInfo to get a list of (Person,Int)
21:55:36 <tez> Int, being the number of borrowed books, right?
21:55:49 <tez> That much we've discovered.
21:56:07 <creature> Ok, I can get that I think.
21:57:02 <tez> Now some how,, we've got to go through this loan info list and pick out the person(s) with the most loans.
21:57:45 <tez> It might me helpful to think about how a maximum :: [a] -> a would be written.
21:58:56 <creature> I've already got one of those. 
21:59:03 <creature> Hold on, jibbling with stuff.
22:04:55 <creature> I don't think my brain is working.
22:05:13 <creature> But I've got a nice little function loanPair to give me [(Person,Int)].
22:05:21 <creature> What to do with it still eludes me, though.
22:06:42 <tez> What does loanPair do?
22:07:06 <creature> you give it a Database and it returns a  [(Person,Int)]
22:07:10 <tez> How is it different to showLoanInfo?
22:07:14 <creature> showLoanInfo returns a string.
22:07:21 <tez> Oh
22:07:38 <creature> showLoanInfo dBase
22:07:39 <creature>         = formatStrings(glue(zip([show(loans dBase per) | per <- peopleIn dBase])(peopleIn dBase)))
22:07:47 <creature> I wouldn't ask.
22:07:59 <creature>  I wrote it, and I don't entirely see how it works 
22:08:03 <tez> lol
22:08:09 <creature> Well, I do.
22:08:13 <creature> But don't like to think too hard about it.
22:08:16 <tez> Well, you now have loadPair.
22:08:19 <tez> loanPair
22:08:21 <creature> "It just does" is good enough for me.
22:08:57 <creature> OK, so I've got a loanPair function.
22:09:26 <tez> now we want a function (what was it called?) maxBorrow, right?
22:09:32 <tez> Yes, ok.
22:09:33 <creature> yep, maxBorrow.
22:10:40 <tez> Well, first think about an auxilliary function, maxLoanPair.
22:11:36 <tez> that takes the result of loanPair, and returns a list of [Person] who have the most books borrowed.
22:11:57 <tez> what would loanPair [] be?
22:12:12 <creature> []?
22:12:23 <creature> As in, "is it []"?
22:12:38 <tez> Yeah, I think so.  I'm not sure a max is really well-defined over empty lists.  Anyway...
22:13:02 <tez> Actually, this should be your base case: what's loanPair [(p,n)]?
22:13:17 <creature> [p]
22:13:25 <tez> Hmm.
22:13:35 <tez> I've just thought of something, sorry.
22:13:47 <creature> No worries, I still haven't.
22:14:32 <tez> We;d better make maxLoanPair takes the result of loanPair, and return a list of (Person,Int).
22:14:46 <tez> We want to keep track of the number of books that person has.
22:15:29 <tez> So, loanPair [(p,n)] = [(p,n)] would be the base case.
22:15:49 <creature> Hold on a sec.
22:26:27 <creature> Argh, I'm close.
22:27:17 <creature> I can get it to output me a list of the maximum people in the form [(Person,Int)].
22:27:32 <tez> Oh good.
22:27:46 <creature> But I'm not sure how to turn that into a [Person] list.
22:27:51 <creature> Want to see what I've got so far? 
22:27:56 <tez> So now you just need all the first items in the pair (Person,Int)
22:27:58 <tez> (Hint, Hint)
22:28:08 <tez> Sure.
22:28:10 <creature> maxBorrow :: Database -> [Person]
22:28:10 <creature> maxBorrow dBase
22:28:10 <creature>         = ([people | people <- loanPair dBase, isMax people (maxLoan dBase)])
22:28:10 <creature> loanPair :: Database -> [(Person,Int)]
22:28:10 <creature> loanPair dBase
22:28:11 <creature>         = zip(peopleIn dBase)([loans dBase per | per <- peopleIn dBase])
22:28:13 <creature> isMax :: (Person,Int) -> Int -> Bool
22:28:15 <creature> isMax (a,b) max = if (b==max) then True else False
22:28:34 <tez> Whoa
22:28:41 <creature> What?
22:28:57 <tez> You like list comprehensions, don't you?
22:29:17 <tez> So are you saying maxBorrow gives you what you need?
22:29:35 <tez> Or are you still trying to get rid of the Int?
22:30:50 <creature> I want to get rid of the int.
22:30:54 <creature> Can't quite see. 
22:31:11 <creature> Although I think it's got something to do with [x] from the (x:xs) notation.
22:33:32 <tez> Well, if you had just a pair (a,b), and I needed just the first item, what function would I apply?
22:34:30 <creature> head ? 
22:35:16 <tez> fst
22:35:38 <creature> We've never been taught that - I claim ignorance all the way. :)
22:35:48 <creature> given that knowledge, let me try it. 
22:37:15 <creature> Woohoo!
22:37:34 <creature> maxBorrow :: Database -> [Person]
22:37:34 <creature> maxBorrow dBase
22:37:34 <creature>         = [fst p | p <- ([people | people <- loanPair dBase, isMax people (maxLoan dBase)])]
22:37:34 <creature> loanPair :: Database -> [(Person,Int)]
22:37:34 <creature> loanPair dBase
22:37:35 <creature>         = zip(peopleIn dBase)([loans dBase per | per <- peopleIn dBase])
22:37:37 <creature> isMax :: (Person,Int) -> Int -> Bool
22:37:39 <creature> isMax (a,b) max = if (b==max) then True else False
22:37:41 <creature> Isn't it beautiful?
22:38:08 <tez> yay!
22:38:31 <tez> I would have used  map fst  personally.
22:39:17 <creature> Never mind.
22:39:29 <creature> If it was difficult to write, it should be difficult to read. 
22:40:35 <tez> lol
22:40:46 <creature> There, done. 
22:40:51 <creature> Hmm.
22:40:57 <creature> I'm meant to be getting up in 20 minutes. 
22:40:59 <tez> Are you in the UK?
22:41:00 <creature> No sleep for me tonight.
22:41:01 <creature> Yep.
22:41:03 <creature> Thu Nov 28 06:41:03 GMT 2002
22:41:07 <tez> Yeah, me too.
22:41:11 <creature> Heh, whereabouts? 
22:41:19 <tez> But I'm up for absolutely no reason at all.
22:41:23 <tez> London.
22:41:33 <creature> Ooh, you're close-ish to me. 
22:41:36 <creature> I'm in Canterbury.
22:41:50 <tez> Yes, close-ish.
22:42:04 <tez> Was that stuff for today?
22:42:08 <creature> Yep.
22:42:13 <creature> I have 5 hours left to submit it.
22:42:24 <tez> Oh!  Easy going then ;)
22:42:24 <creature> Fortunately, I can submit it electronically, which I've done.
22:42:27 <creature> Yep.
22:42:36 <creature> Did a UML exercise for today as well earlier.
22:42:42 <creature> I'm very good at procrastinating.
22:43:06 <tez> Do you actually have classes/lectures/lab sessions today?  Or is it nap time now?
22:43:10 <creature> I've got to do a Spreadsheet thingy today as well - it's icky. 
22:43:31 <tez> Oh, I'm great at procrastinating.  People can vouch for my laziness.
22:43:42 <tez> Spreadsheet thingy?
22:43:44 <creature> In theory, I have a CO313 lecture at 9, a CO310 seminar at 11, a CO310 lecture at 12, a CO309 lecture at 1, and a maths lecture at 3. 
22:44:36 <creature> CO313 == Information Systems (databases at the moment, very dry, very boring), CO310 == foundations of programming, which is essentially Haskell today, CO309 is OOP, which means Java.
22:44:43 <tez> What's CO310?  It seems to deserve a lecture and seminar in one day.
22:44:48 <tez> Ah
22:44:52 <creature> That's just coincidence.
22:44:58 <tez> Oh, ok.
22:45:40 <creature> However, the plan is I shall turn up to the Haskell seminar, then go home, get pissed, and collapse in bed. 
22:45:49 <creature> As I'm feeling fairly down and could go for a bit of oblivion.
22:46:04 <tez> That sounds like fun.
22:46:04 <creature> I might just go for the caffienated challenge of "How long can I remain awake for".
22:46:10 <tez> lol
22:46:17 <creature> I had a pint of coffee earlier. 
22:46:28 <tez> I recall a day where I was relying on caffiene after an all-nighter.
22:46:29 <creature> I need to find a ceramic pint glass. 
22:46:43 <creature> I have a friend who goes through Pro-plus like M&M's.
22:47:05 <creature> I think food wouldn't be a bad idea at some point either, as all I've eaten in the past 24 hours was a little rice.
22:47:10 <tez> I had a morning lecture.  Pretty sleepy through that.  Then I had a huge coffee for lunch, and BAM, I was wide awake.
22:47:20 <creature> What are you studying? 
22:47:30 <tez> I went through the next lecture completely buzzed.
22:47:42 <tez> But then I fell asleep in the next class.
22:47:45 <creature> Heh.
22:47:56 <creature> The amount of people asleep in our lectures is actually quite impressive. 
22:48:05 <tez> I *was* studying Computation
22:48:23 <creature> Ah, beyond the student stage I take it. :)
22:48:32 <tez> Yes, and no.
22:48:45 <creature> The guy who takes us for EL307 (Digital Systems) is always wondering why half his audience is asleep.
22:48:53 <tez> I'm in non-student/non-employed limbo at the mo'.
22:49:03 <creature> Because it's a midweek lecture in a comfortable lecture theatre with dimmed lights.
22:49:04 <tez> lol
22:49:13 <creature> He turns the lights right down to get the best from the projector.
22:49:28 <creature> Some people just consistently sleep.
22:49:37 <creature> There's a Chinese guy who I keep seeing. 
22:49:43 <creature> I've *never* seen him awake in a lecture. 
22:49:57 <creature> I think he's going for some form of subconcious absorbtion.
22:50:15 <tez> Yeah, I remember one lecturer I had, I sat in the front row to try to make sure I didn't fall asleep.  I still did, only I was doing it right infront of him in the front row.
22:50:47 <creature> Heh, there's a lecturer here who whispers - I think he's had surgery on his throat - and I find it strangely soothing. 
22:50:53 <creature> It's like the snooker commentary.
22:51:13 <tez> Yes.  Good for radio.  Bad for lecturing.
22:51:30 <creature> Heh. 
22:51:50 <creature> Haskell and Java seminars are quite a laugh, actually, as I know the seminar leaders fairly well.
22:51:54 <creature> The joys of internal IRC. :)
22:52:37 <tez> lol
22:52:50 <creature> Take a look at mugshots.us-lot.org . 
22:53:19 <creature> quotes.us-lot.org is always fun too.
22:53:33 <creature> Worth looking at the CS ones, as they're all really shor.
22:54:14 <tez> shor?
22:54:24 <tez> Oh, short.
22:54:43 <creature> "When are you around for questions?"
22:54:43 <creature> "I'm around; I reserve the right to hide, though."
22:54:44 <creature>         -- Random student and Ian Utting
22:54:45 <tez> us-lot is a pretty good domain name to have.
22:54:51 <creature> It's a fallback.
22:55:02 <creature> It's normally hosted on fivegeeks.net, but I think that's still down.
22:55:38 <tez> Is the IRC server a university run thing?
22:56:01 <creature> It's a Computer Society run thing. 
22:56:04 <creature> It's semi-official.
22:56:15 <tez> Ah
22:56:24 <creature> Don't ask me what the Computer Society actually does, though, beyond provide IRC servers to the masses. :)
22:56:49 <tez> I bet they have linux install-fests.
22:57:29 <creature> There's a UUG on campus, I'm told. No lug, though.
23:00:14 <creature> We've got a fairly decent newsfeed here, too. It's nice. 
23:00:23 <creature> Oh, and www.mirror.ac.uk is inside the lan here :>
23:00:32 <creature> It's a Debian mirror! on campus! 
23:00:41 <creature> I was more excited about that than the nightclub on campus. 
23:00:44 <creature> Which I still haven't been to .
23:01:35 <tez> You host www.mirror.ac.uk?!
23:02:23 <tez> I'm a bit of a RedHat slut myself.
23:03:03 <creature> Well, not me personally. 
23:03:11 <creature> But yes, we host mirror.ac.uk. 
23:03:23 <creature> www.ukc.mirror.ac.uk forces it to use our local machine. 
23:03:32 <creature> I believe we load-balance with the Uni of Lancs too.
23:04:16 <tez> Oh.
23:05:48 <tez> And the assessment this week is... oh, bugger.
23:05:49 <tez> Simon Thompson, upon flipping a slide and noticing that he's just done the assessment as an example
23:05:51 <tez> lol
23:05:56 <tez> That's very good.
23:06:32 <creature> Heh. 
23:06:39 <creature> Ooh, sun coming up.
23:07:39 <creature> Well, it was dark and now it isn't so dark.
23:09:07 <tez> There are buildings blocking my view.
23:10:03 <creature> I'm not entirely sure which direction the sun comes up a.
23:10:06 <creature> I'm never normally up.
23:12:01 <creature> brb.
23:13:41 <creature> Back.
23:13:44 <creature> Switching to X.
23:17:08 <tez> You were on windows?
23:17:15 <creature> Nah, I was on the console.
23:17:24 <tez> Oh.
23:17:24 <creature> Fired up the X server.
23:18:00 <tez> First an assurrance that there will be only 5 Java lectures, 4 of which are in
23:18:00 <tez> Michaelmas term.  The reason the schedule lists currently 7 lectures is quite
23:18:00 <tez> simply that John found manipulating existing html tables rather complicated
23:18:02 <tez> Stefan Kahrs on CO508 web page
23:18:05 <tez> lol
23:19:24 <creature> Stephan Kahrs is a lovely guy. 
23:19:31 <creature> He's like a big cuddly Bavarian teddy bear. 
23:19:36 <creature> He's my personal tutor.
23:19:45 <tez> Your computing department give me the impression of a slightly stereotyped bunch of cynical, slightly clumsy profs who have a healthy dislike for students and practical things.
23:19:56 <creature> Heh. 
23:20:07 <tez> But that's probably all that makes it on to your quotes lists.
23:20:20 <creature> You should see a lecture by Janet Linington, the lecturer who does Spreadsheets.
23:20:22 <creature> She's appaling.
23:20:26 <tez> lol
23:20:30 <creature> She can't use the damn things. 
23:20:37 <tez> ha ha ha
23:20:46 <creature> She had to go and get someone to help her fix the computer the other day - turns out it wasn't plugged in.
23:21:01 <creature> The 4th years next door to me tell me that this has happened to her before. 
23:21:25 <creature> They also tell a good anecdote about how she had the mouse upside-down, and thought it was configured for someone left-handed when it wouldn't go where she wanted it.
23:21:37 <tez> lol
23:22:03 <creature> The spreadsheet thing is a joke, really.
23:22:19 <creature> We've been doing fairly mediocre stuff up to now - if statements, validation, autofiltering.
23:22:28 <creature> The most advanced we've covered is recording a macro.
23:22:37 <creature> Now we get an assignment where you really need to implement lots of it in VB.
23:22:48 <creature> Reading in external files, producing reports on-the-fly, etc. 
23:23:06 <tez> Well, that sounds reasonably challenging.
23:23:13 <creature> It's tricky, but I can handle it. I feel sorry for the people who have only had their first meeting with a spreadsheet in this lecture, though.
23:23:25 <creature> It's a ridiculous project, really.
23:23:34 <creature> It's far too complex, you wouldn't use a spreadsheet for it anyway. 
23:23:41 <creature> And it *has* to be done in Excel 2000 she says.
23:24:11 <creature> Apparently a few heads of staff are pissed off with her for setting such a tricky assignment. 
23:27:11 <creature> Thursdays are my worst days, really. 
23:27:14 <creature> Far too busy. 
23:27:22 <creature> Tuesdays are nice - one 12 O'clock lecture.
23:27:26 <creature> And wednesdays aren't too bad.
23:27:36 <creature> Lectures from 10 to 1, and then free.
23:27:42 <tez> I would have thought spreadsheet concepts are independent of VB...
23:27:57 <tez> Fridays?
23:28:23 <creature> Fridays are alright, ish. 
23:28:49 <creature> Got a lecture at 10, then sometimes a EL307 class from 11 to 1 (though I'm normally out by 12), then maths from 2 till 4.
23:29:11 <creature> As for the spreadsheets, there's not really that much spreadsheet in it. 
23:29:22 <creature> The challenge is in getting the data into Excel, and in producing the reports. 
23:29:33 <creature> The formulas themselves are fairly easy. 
23:30:00 <tez> Was Spreadsheets a compulsory module?
23:30:03 <creature> Yep.
23:30:08 <creature> It's really "Computing case studies".
23:30:14 <creature> It's spreadsheets to begin with. 
23:30:18 <creature> We've moved onto Haskell now. 
23:30:27 <creature> And I understand we're going onto Java later in the year 
23:31:13 <tez> Well "Computing case studies" sounds like an intersting course.
23:31:21 <creature> It's not, really. 
23:31:32 <tez> I would be very suspicious of a computer science course called Spreadsheets.
23:31:37 <creature> I've Christened it "The Joy Of Spreadsheets" thus far. 
23:31:45 <tez> But you get to experience Haskell!
23:31:46 <creature> We're just starting the Haskell stuff, and that doesn't seem too bad. 
23:31:56 <creature> Could be good fun.
23:31:59 <tez> lol
23:32:02 <creature> I like Java the most, I think.
23:33:10 <tez> I don't have much experience with it.
23:33:25 <creature> It seems to be fairly simple, with a nice C-like syntax.
23:33:50 <tez> Though when I was looking through some C++ books and Java books, Java seemed much friendlier.
23:34:10 <creature> Yep, it's got the syntax of C with the simplicity of something like VB, as far as I can see. 
23:34:14 <creature> It's quite a nice language. 
23:35:29 <tez> If you don't understand what PATH is for or how it works, you should BACK
23:35:29 <tez> AWAY FROM THAT KEYBOARD NOW SIR. KEEP YOUR HANDS AWAY FROM THE MOUSE.
23:35:29 <tez> Ian Utting in ukc.cs.cs3
23:35:44 <tez> Sorry, I sure you've read these already.
23:36:05 <creature> Yeah, but they're still good. I like to see what other people find amusing.
23:37:18 <tez> However, the skier featured in this picture unfortunately had an
23:37:19 <tez> affair with the editor's wife and therefore must be edited out.
23:37:19 <tez> Aliy Fowler, struggling to find a decent excuse for a Photoshop assessment
23:37:22 <tez> LOL
23:37:53 <creature> The latest UKCIRC ones are alright, and I'm in a couple of them.
23:38:04 <creature> The "real life" quotes are good, and nice and short too.
23:45:54 <creature> biab, going to shower. 
23:45:58 <creature> And make coffee.
23:46:03 <creature> But mostly shower.
23:46:39 <tez> Ok, later.
23:46:42 <dnm> shapr, you around?
23:46:52 <dnm> Oh. He's not even here.
