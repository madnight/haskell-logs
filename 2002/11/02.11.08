03:01:17 <Segora> re
03:22:42 <ibid> hm, is it possible to access a C structure from haskell using the standard ffi?
03:25:27 <ibid> seems not
03:27:42 <ibid> hm, no problem actually, it wasn't a struct :-)
04:07:50 <Segora> ibid: c2hs has support for generating struct accessors
04:14:53 <ibid> functions in the C side?
04:15:49 <ibid> anyway, overkill for this mission. and i don't need it, i'm just putting this in as a huge C string that i import to Haskell and then make it a data structure using read
04:16:07 <ibid> ugly but the only way i've been able to make the compilation fast
05:31:56 <ayrnieu> hello shapr!
05:32:10 <ayrnieu> How'd the move go?
05:32:18 <shapr> hi ayrnieu!
05:32:39 <shapr> it went well, our apt is setup nicely
05:32:53 <shapr> we don't have DSL yet, but we got desperate and bought a modem
05:33:47 <ayrnieu> oh, good.  When do you expect to get DSL?
05:42:27 <Marvin--> hey shapr
05:42:30 <Marvin--> heh
05:46:10 * Marvin-- grins
05:46:21 <Heffalump> shapr: good to know your Debian boxes are happy
05:46:23 <Heffalump> oh, he went
05:46:45 <Marvin--> Heffalump: I don't think it was by choice :)
05:49:54 <Heffalump> well, no :-)
06:03:22 * Heffalump looks at the Haskell 98 report in book form (from http://research.microsoft.com/Users/simonpj/haskell98-revised/)
06:28:16 <Marvin--> welcome back ;)
06:36:20 <shapr> hi marvin
06:36:28 <shapr> hej
06:36:32 <Marvin--> :)
06:36:34 <Marvin--> how're you doing?
06:36:46 <shapr> jåg heter shae
06:37:03 <shapr> jåg från USA
06:37:15 <Marvin--> jag, not jÃ¥g :)
06:37:16 <Marvin--> argh
06:37:18 <Marvin--> stupid utf-8
06:37:37 <shapr> well, I see an a with a ring on top
06:37:44 <Marvin--> hmm
06:37:55 <Marvin--> brb
06:37:59 <shapr> had my third swedish lesson today, yay!
06:38:29 <Marvin--> åäö
06:38:45 <Marvin--> anyway, 'jag är från', not 'jag från'
06:38:45 <shapr> åä
06:38:55 <shapr> ah, right.. tack
06:39:08 <Marvin--> and we don't actually say 'jag är Foo', we say 'jag heter Foo'
06:39:23 <shapr> jåg är från USA och jå bor i Boden.
06:39:37 * shapr considers starting #haskell.se
06:39:39 <Marvin--> jag, not jåg! :)
06:39:42 * shapr grins
06:39:52 <shapr> oh, yes..
06:40:05 <shapr> surplus rings hanging around in my head
06:40:08 * dark dances around shapr
06:40:11 <Marvin--> haha
06:40:17 <shapr> hey, did you announce HWS-WP on one of the mailing lists?
06:40:20 <shapr> hi dark! wassup?
06:40:42 <Marvin--> oh, no I forgot that
06:40:55 <dark> I made the first prerelease of my version control tool :-)  It's at http://www.xs4all.nl/~dark/harc-0.1pre10.tar.gz
06:41:01 <shapr> hey dark, I've been reading through Curses.hs, trying to figure out how it all works
06:41:18 <Igloo> Hey shapr!
06:41:20 * shapr downloads harc
06:41:27 <shapr> hi Igloo!
06:41:30 <dark> Marvin: ChanServ should have cooled down again, you could try putting it back in the topic.
06:41:34 <shapr> how's the sunny south?
06:41:53 <Igloo> Not bad  :-)
06:42:23 * dark can't type a's with rings on them.
06:42:42 --- topic: set to '["mo' nads than you", "We put the Funk in Funktion", "See logs @ http://tunes.org/~nef/logs/haskell/", "Gtk+HS 0.14.10: http://www.cse.unsw.edu.au/~chak/haskell/gtk/", "HWS-WP: http://www.dum.chalmers.se/~marvin/hws-wp/"]' by Marvin--
06:42:45 <shapr> it's easy with emacs, I donno how to do it any other irc client though
06:42:58 <Marvin--> dark: compose + * + a :P
06:43:15 <shapr> yah, exactly
06:43:21 <dark> Marvin: I figured it out, I can wait for someone else to use them and then cut and paste :)
06:43:38 <Marvin--> haha
06:43:43 * shapr grins
06:44:19 <shapr> dark: is there a more recent version of mage?
06:44:45 <Marvin--> well, I'd better go to the supermarket before it gets too crowded
06:44:49 <dark> Nope, at least none that actually compiles.
06:44:49 <shapr> I started writing a crack-attack clone, I'd like to try putting a Curses GUI on it.
06:44:59 <shapr> du lagar mat.
06:45:08 <dark> I have a strict "only commit what works" rule, which sometimes gets me into trouble :)
06:45:21 <shapr> I agree with that rule.
06:45:28 <shapr> never commit what doesn't pass the unit tests.
06:45:41 <shapr> er, "du köper mat"
06:45:47 <Marvin--> I don't follow that at all, that's what tags are for
06:46:09 <Marvin--> better commit it and have it in the backups
06:46:28 <Igloo> Oh, dark, are http://www.fifthvision.net/open/bin/view/Arch/ and http://superbeast.ucsd.edu/~landry/larch/ both forking arch?
06:47:05 <dark> Igloo: As far as I know everyone's impressed enough with Landry's version to use that one.
06:47:29 <dark> Igloo: If you go to Downloads on the fifthvision page, you'll see a prominent link to superbeast :)
06:47:55 * Igloo saw something about a GUI from him in a mailing list somewhere but nothing on that page about it
06:48:39 <dark> Marvin: Hmm, arch's system should make it easy to follow that strategy too, by making various small branches.
06:48:45 <dark> Marvin: But I never tried it :)
06:48:51 <Igloo> Oh, right  :-)
06:50:39 <dark> Marvin: It does also have revision tags if you want them, haven't tried those either :-)
06:50:51 * dark scribbles on his todo list.
06:51:20 <dark> shapr: Anyway, what's up with Curses?
06:51:53 <shapr> I know nothing about it... I started reading the ncurses tutorial but haven't gotten very far
06:52:17 <shapr> it looks pretty simple so far
06:52:26 <Heffalump> this channel really should sort out a curses module between it.
06:52:36 <shapr> hi Heffalump!
06:52:51 <Heffalump> hiya shapr
06:52:51 <Igloo> Can it use Template Haskell?  :-)
06:52:52 <shapr> how many Curses candidates are there?
06:53:02 <Heffalump> igloo: if you provide up-to-date packages to build it with :-)
06:53:10 <shapr> yah, that would be cool!
06:53:12 <Heffalump> actually, can TH be configured to spit out normal Haskell?
06:53:12 <Igloo> haskell.org does that now
06:53:13 <shapr> yay TH!
06:53:40 <dark> Heffalump: It's more likely to be a curses package, I think.
06:53:45 <Igloo> I thought about that, but I suspect only if you don't mind everything else being desugared and all the comments and whitespace disappearing
06:53:47 <shapr> TH does spit out normal haskell I think
06:53:52 <shapr> that's the point, right?
06:53:52 * shapr thinks
06:53:53 <Heffalump> igloo: haskell.org provides up-to-date packages of what?
06:54:00 <Heffalump> igloo: ah, pity
06:54:12 <Heffalump> but it'd be generated code anyway, so not too bad
06:54:14 <Igloo> CVS GHC nightly builds
06:54:27 <Heffalump> igloo: including debs and rpms?
06:54:28 * shapr is lagged
06:54:31 <Igloo> shapr: Yes, but you have to get it out of GHC
06:54:52 * Igloo hasn't looked as I'm using my own tree anyway
06:55:22 <shapr> algorithm question, I'm trying to find a good way of finding three contiguous blocks of the same color in an array of 6 x 12 colored blocks (it's a crack-attack clone)
06:55:23 <dark> I believe that things should only be librarized after they're used in at least three different programs :)
06:55:42 <dark> That way they don't get overspecialized.
06:56:18 <shapr> I wrote some code to pull out a list of columns and a list of rows and then replace three or more blocks in a row with blank blocks, but that's cheesy, and missed overlapping matches
06:56:27 <shapr> what's a better way to go about that?
06:56:55 <dark> shapr: Do diagonal blocks count too?
06:57:02 <Igloo> shapr: That's a bit vague, but I think elem True $ zipWith3 (\x y z -> x == y && y == z) xs (tail xs) (tail (tail xs)) and transsomething may be your friends
06:57:04 <dark> With "contiguous" do you mean in a line, or just touching?
06:57:08 <ibid> um, why is bounds taking so long? isn't it O(1)?
06:57:10 <shapr> dark: nah, only vertical or horizontal
06:57:42 <Igloo> IM findElem. I think.
06:58:01 <shapr> dark: three or more touching
06:58:25 <dark> shapr: So L shapes are ok?
06:58:40 <shapr> dark: oh sorry, must be a straight line
06:58:59 * shapr looks up findElem
06:59:08 <ibid> ahh, it was my array's building that takes the time
06:59:09 <ayrnieu> shapr - [[X]] ?
06:59:30 <Igloo> Oh, it's just find
07:00:00 <Igloo> transpose! Phew, that was annoying me
07:00:19 <dark> Ah, overlapping matches would be a column match crossing a row match?
07:00:24 <shapr> ayrnieu: huh? I have an array, I'd like some good way of matching stuff in that array, including overlapping matches.
07:00:30 <dark> Are all of those blocks part of the match in that case?
07:00:36 <ayrnieu> shapr - 1) write a function to scan a list for three contiguous elements; 2) write a function to use this on a list of lists; 3) write a function to 'rotate' a list of lists so that you can use the product of #2 on the columns. -- oh, nevermind.;
07:00:46 <shapr> dark: right, that would be overlapping matches, and yes, I think those are the same match then.
07:01:04 <dark> shapr: Do you need to identify or count matches in some way, or just make them disappear?
07:01:10 <Igloo> Ah, but what I *really* meant was elemIndex
07:01:34 <dark> Igloo: I use that for path munging :-)  elemindex '/' path
07:01:39 <Igloo> (or elemIndices depending on what you wanted)
07:01:52 <dark> Oh, I probably meant that one.
07:02:00 <shapr> dark: I need to count matches, yes... many matches happening in sequence (without user intervention)  give bonus score
07:02:16 <dark> shapr: Number of blocks matched, or number of separate matches?
07:02:34 <shapr> number of separate matches
07:02:44 <dark> Ew, that's more difficult :-)
07:03:07 <ayrnieu> shapr - is "XXXX" an overlap of two matches?
07:03:17 <shapr> I'm just trying to rewrite crack-attack (apt-get install crack-attack) in Haskell, for a cheesy fun project.
07:03:31 <dark> Oh, in sequence... so you remove only one match, then collapse the structure, then look for the next match?  You don't deal with multiple simultaneous matches?
07:03:32 <shapr> ayrnieu: nope, that's one match, four points
07:03:40 <shapr> oh, I guess I do need to count blocks in a match
07:03:59 <dark> I have no idea how crack-attack works, but it sounds similar to a Windows game "Alhemical Balls"
07:04:26 <ayrnieu> shapr - yes :-/ I thought you only wanted three-blocks.
07:04:35 <dark> Oh... after reading the description, no it's different :)
07:07:00 <shapr> hi jadrian
07:07:02 * jadrian steps in
07:07:07 <jadrian> hi shapr, what's up
07:07:40 <ibid> bah
07:07:40 <ayrnieu> a state machine: 'looking-for X (first cell) (0 points)'; 'looking-for X (second cell) (0 points)'; 'looking-for X (nth cell) (3 points)' 'looking-for X (nth cell) (4 points)' 'looking-for X (first cell) (4 points)' -- on "XXXY"
07:07:46 <ibid> BAH
07:08:04 <shapr> oh, another odd question, is there someway to get the length of a tuple?
07:08:08 <ayrnieu> (second->nth adds three points; nth->nth adds one point)
07:08:21 <ayrnieu> shapr - yikes, no.
07:08:24 <jadrian> shapr: hmmm 
07:08:25 <Heffalump> shapr: you know it statically
07:08:25 <ayrnieu> shapr - why do you want to do that?
07:08:37 <jadrian> shapr: well each tuple has a constant lenght
07:08:41 <jadrian> length
07:08:47 <shapr> I was trying to write a generic function that would give me the contents of an array along axisN, and wouldn't care how many axes the array has
07:08:49 <Heffalump> class TupleLength t where
07:08:52 <Heffalump>   length :: Int
07:09:02 <dark> shapr: It sounds a bit like xemeraldia, did you ever play that?
07:09:15 <dark> The nasty thing about xemeraldia is that its scoring rewards you for risky play :)
07:09:17 <Heffalump> instance TupleLength (a,b) where length = 2
07:09:21 <shapr> dark: nope, never heard of it... oss?
07:09:22 <Heffalump> oh, s/length/size/ or something
07:09:36 <dark> shapr: Yeah, debian main.
07:09:38 <shapr> Heffalump: yah, that makes sense
07:09:45 <jadrian> shapr: why not get those contents in a list?
07:09:58 <shapr> I wish I could get length of a tuple as well as a list with the same call
07:10:01 <Heffalump> shapr: you probably don't really need it, though
07:10:07 <shapr> also, is there a way to make a length one tuple?
07:10:14 <Heffalump> shapr: no, why would you want one?
07:10:26 <shapr> I don't know, just wondered...
07:10:48 <shapr> I can make a length one tuple in Python, thought it would work the same in Haskell :-)
07:11:21 <shapr> jadrian: yah, I'd like to get the array contents in a list of list of ...
07:11:26 <ayrnieu> In Haskell, you can think of a non-tuple (or even a tuple) as a length-one tuple, if you like.
07:11:52 <jadrian> not really ayrnieu
07:11:55 <ayrnieu> shapr - Python design is influenced by its unfortunate lack of pattern-matching =)
07:11:58 <Igloo> You can make them in TH </pred>
07:12:10 <jadrian> data LengthOneTouple a = LOT a
07:12:15 <Igloo> But you can't make length 2^33 tuples, a clear flaw
07:12:45 <jadrian> this is more like a length one tuple, since they are not strict 
07:12:48 <dark> shapr: Sounds like it'd be easier to just write it out for various tuple lengths :)  Will you ever need an 8-axis array?
07:13:00 <ibid> so damn slow this thing!
07:13:08 <shapr> speaking of which, is there some way to pattern match tuples? I think not, since pattern matches are spiffy ways of doing case statements, and case statements require the same type in and out, right?
07:13:10 <ayrnieu> ibid - what thing?
07:13:15 <Heffalump> igloo: what happens when it reifies a length 1 tuple?
07:13:17 <ibid> my code
07:13:36 <ayrnieu> shapr - erm?  add (n,m) = n + m
07:13:39 <Igloo> Don't see why it wouldn't work
07:13:44 <dark> shapr: You can pattern match tuples as long as you know their length :)
07:13:47 <ibid> i'm leaning to writing this in c and using it with ffi
07:13:48 <jadrian> shapr: multi parameter classes ?
07:13:55 <ibid> the speed difference is huge
07:13:59 <dark> shapr: If you find yourself wanting tuples of varying lengths, it's time to think of lists.
07:14:01 <shapr> dark: no, I probably won't need an 8-axis array, but otoh, I like to write code that uses recursive ways of doing something on an input of any size
07:14:08 <Igloo> Functions which have no arguments work and you can't create them by writing normal Haskell either
07:14:11 <jadrian> dark: exactly
07:14:42 <dark> shapr: Even ghc tricksies don't try to generalize on tuples.  See Data.Tuple for some lovecraftian horror :-)
07:14:44 <ayrnieu> Igloo - well, you can create a binding to an IO a which simulates a function =)
07:14:57 <shapr> ayrnieu: I wanted to write my tuple length function with (x,xs) and xs would match the rest of the tuple
07:15:15 <shapr> dark: yah, I looked at GHC.Tuple, and truly Cthulhu has visited that file.
07:15:18 <Igloo> That would still be represented as a value in teh AST, though
07:15:56 <ayrnieu> shapr - ah, OK.  This is precisely what tuples are not for =)  instance Listable (a,b) where toList (a,b) = [a,b] ?
07:16:35 <jadrian> Question. I'm going to use a STRefs as an implicit values to simulate global variabels. 'Record' of STRefs is more efficient than STRef to a record, right? 
07:16:49 <Heffalump> I don't see why
07:16:51 <shapr> ayrnieu: yah I thought about that approach, using Python-style list() to cast from a tuple to a list... but, tuples can have different types in each position, lists must be homogenous
07:16:58 <ibid> this is just a bad dream... this is just a bad dream...
07:16:59 <shapr> and I don't know of a way to unify types at runtime
07:17:11 <shapr> ibid: ffi?
07:17:31 <ibid> ghci is taking nearly 200 megs of memory to look up something in this table...
07:17:38 <jadrian> Heffalump: if I use a STRef to a Record and just update one of the fields won't it create another record?
07:17:44 <dark> ibid: Pah, what else were you going to use that memory for?
07:18:01 <dark> jadrian: Not necessarily, ghc might optimize it to an update-in-place.
07:18:09 <ayrnieu> instance Listable (Int,String) where toList (a,b) = [DynInt a, DynString b] :: [DynamicType]
07:18:24 <jadrian> dark: i see, that would be nice
07:18:32 <ibid> (table data is in the program as a C string which is accessed using FFI, then the string is read to form a list which is then used to feed a FiniteMap)
07:18:57 <ibid> the table has 13853 entries
07:19:21 <Heffalump> jadrian: oh right, possibly, yes
07:19:25 <ibid> represented as the C source, it's 3 megs
07:19:40 <ibid> how in Earth does GHCi turn that into 200 megs?
07:20:16 <ayrnieu> ibid - I don't know, but you should.  Doesn't GHC have tools to analyze memory use?
07:20:23 <shapr> I would guess you need to add some strictness somewhere when building the FiniteMap
07:20:25 <dark> ibid: Maybe by having lots of part-of-finitemap thunks around.
07:20:45 <ibid> shouldn't they be garbage?
07:20:47 <ayrnieu> *nod* or notice that you're dropping thunks all over the floor.
07:21:03 <ibid> okay, how can i make this stricter?
07:21:08 <dark> ibid: I'd try it with normal ghc first, see if the problem is with ghci specifically.
07:23:38 <ibid> it gets to 100 megs very fast with normal GHC and -O
07:23:46 <ibid> but it's better
07:24:28 <jadrian> Hmm... Question on style. I need something like  iterate f x0, but I need to maintain state. One state that is persistent during all iterations (like StdGens and such) another state that can be discard after each iteration. Should Would you use two monads? Or just make the local state persistent and reset it in each iteration?
07:25:04 <Heffalump> the one that you discard can be inside the function f
07:25:15 <Heffalump> the one that you don't needs to be threaded with a monad or similar
07:25:33 <ibid> ugh, it does get to 200 megs...
07:25:43 <jadrian> yeap problem is that I need to access the persistent one from within f too
07:25:54 <Heffalump> jadrian: right, so make something monadic
07:25:54 <jadrian> that would require monad transformers right?
07:25:56 <dark> ibid: But does it terminate?
07:26:07 <ibid> dark: it did with GHCi
07:26:09 <ibid> and does
07:26:18 <Heffalump> jadrian: shouldn't do, why do you think it might?
07:26:24 <ibid> it just takes time
07:26:26 <shapr> oh, Igloo... last night I was thinking about memoising fractal computations and I wondered whether some of the smaller calculations might be subsets of the larger calculations... I was thinking I could record the endpoint of each unique combination of Z and C and see if that sped things up
07:27:03 <dark> ibid: Sounds like heap profiling day to me :)
07:27:13 <jadrian> Heffalump: I'm thinking... :)
07:27:43 <ibid> "254 Mb total memory in use"
07:28:04 <jadrian> Heffalump: ok f would be something like  runSomeMonad( P )
07:28:10 <ibid> "57,273,628 bytes maximum residency (2 sample(s))"
07:28:25 <jadrian> Heffalump: P has type m a (it is a monadic function) right?
07:28:28 <Heffalump> jadrian: does your local state have/want to be kept in a monad too?
07:28:37 <dark> "maximum residency"?  No idea what that is.
07:29:14 <jadrian> Heffalump: I think I should, the persistent state is mainly because of Randomness
07:29:29 <Heffalump> right
07:29:33 <jadrian> Heffalump: the local state, I use it to count stuff that happens
07:29:43 <Heffalump> maybe a monad transformer would be best then
07:29:44 <jadrian> (in each iteration)
07:30:01 <shapr> hi dalroth, wassup?
07:30:07 <dark> Either that or do the Randomness with a lazy list.
07:30:44 <Heffalump> dark: still needs to be passed between iterations
07:31:14 <dark> Ah yeah, if you consume a variable number of elements.
07:31:21 <Marvin--> back
07:31:24 <dark> Hmm, this might be a job for RandT :-)
07:31:55 <Heffalump> make a state monad transformer
07:31:57 <Heffalump> that's fairly easy
07:32:05 <Heffalump> then stack that on the randomness monad
07:32:21 <Igloo> Mua ha ha ha ha - SPJ asks Jeff to empower me to break GHC more directly  :-)
07:32:31 <Heffalump> igloo: cool
07:32:44 <Heffalump> we'll be relying on you for hourly CVS builds, then, you realise?
07:32:44 <jadrian> this is kind of rticky because, on one hand I want to create a list of results lazily, something like iterate f x0, I need persistent state, so I got a monadic version of iterate. But then I also want to return statistics about how many times things happen in each iteration
07:33:04 <Igloo> Hmmm, I *think* that would be possible on urchin  :-)
07:33:09 <jadrian> I thought about building the list in the persistent monad, but it would become a mess...
07:33:17 <Heffalump> jadrian: you can't both count statistics of how many times things happen and have some of them not happen because of laziness
07:33:33 <Heffalump> because updating the count will always force evaluation of the things that didn't really need to happen
07:33:42 <Heffalump> the only way you can avoid that is unsafePerformIO, but that's asking for trouble
07:33:43 <jadrian> Heffalump: exactly! :)
07:33:52 <jadrian> Heffalump: so here is what I thought
07:34:29 <jadrian> Heffalump: I create the list lazily, and in each iteration my function will return both the result and the statistics
07:34:47 <Heffalump> wdym?
07:34:51 <jadrian> Heffalump: (the statistics of that iteration)
07:35:30 <jadrian> well in each iteration I will calculate what I want, plus the info about what happened in that iteration...
07:35:33 <shapr> Igloo: you're becoming a GHC wizard?
07:35:56 <jadrian> an example
07:36:15 <jadrian> this is kind of a genetic algorithm, in each iteration I return a new population, and number of crossovers, mutations etc
07:36:49 <jadrian> The persistent state as to do with randomness 
07:37:16 <jadrian> The local state is used to count stuff in each iteration (to avoid passing this variables around)
07:37:35 <jadrian> Am I making sense?
07:37:46 * Heffalump busy doing something else, biab
07:37:59 <jadrian> ok
07:38:41 <ibid> No instance for (IArray UArray UD)
07:38:42 <ibid> blah
07:38:45 <ibid> argh
07:38:49 * ayrnieu reads about Template Haskell.
07:38:57 <shapr> TH is spiffy
07:39:28 <ibid> gn, UArray does not have a generic IArray instance
07:39:31 <ibid> ARGGH
07:39:54 <dark> Isn't that on purpose?  Not everything can be unboxed.
07:40:04 <ibid> perhaps
07:40:27 <ayrnieu> (It's a little unnerving that it appears to be coming from C++ instead of Lisp)
07:40:31 <ibid> i'm just trying to go as strict as possible with this one
07:40:50 <ibid> but i don't know how
07:41:00 <Igloo> shapr: Slowly  :-)
07:41:04 <dark> Where do you need arrays anyway?  You said you were using FiniteMap.
07:41:08 <ibid> using a standard Array i get the same effect as with FiniteMap
07:41:23 <ibid> dark: either is good
07:41:25 <Igloo> I still haven't looked at the bug I really need fixed, though - don't even know where to start ATM  :-(
07:41:31 <dark> Igloo: Fortunately, wizards learn unholy rituals to extend their own life, so you have plenty of time.
07:42:21 <dark> ibid: What's the data?  If you're converting 3 MB of C strings to Haskell [Char], then that's probably where all your memory goes.
07:42:37 <Heffalump> jadrian: ah, so you don't want to use laziness to avoid doing particular things on each iteration, you just want to use it to avoid doing more iterations than you need?
07:42:47 <ibid> dark: yeah well, i don't have a choice there
07:42:51 <jadrian> Heffalump: exactly
07:43:11 <ibid> dark: GHC is dead slow when i try to feed these data structures to it directly
07:43:18 <ibid> slow in compilation i mean
07:43:19 <jadrian> Heffalump: that and to be able to use my iterations as they are calculated
07:43:47 <Igloo> dark  :-)
07:43:48 <dark> ibid: You could take a look at PackedString :)
07:44:00 <jadrian> Heffalump: well the results of my iterations
07:44:03 <dark> ibid: Or just leave the data as Ptr types until you need them.
07:44:04 <Heffalump> jadrian: ok, so as long as you never try to reuse the randomness monad after calling iterate with it, you should be fine
07:44:13 <ibid> dark: does not work
07:44:31 <ibid> dark: i need the data as a bunch of 14-field Haskell records
07:44:40 <ibid> dark: there are lots of those records
07:44:57 <dark> jadrian: hmm, you might be able to use the Random "split" function to give each iteration its own random seed, and avoid the persistent state.
07:45:12 <jadrian> Heffalump: iterate? I cannot really call iterate, I need to call a monadic version of iterate...
07:45:24 <Heffalump> jadrian: yeah, sorry, that
07:45:40 <jadrian> dark: I'm using split and keeping the stdGen inside of the monad, I don't want to pass it (well actually them) around
07:45:47 <dark> jadrian: Or make the randomgeneratorstate a part of the function's output :)  Then iterate wraps it up as state for you.
07:45:51 <ibid> dark: when i try to feed GHC with a file that has them in the usual style, it's SLOW... and MEMORY-HORNY... at compile time
07:45:57 <Heffalump> iterateM :: Monad m => (a -> m a) -> a -> m [a]
07:46:11 <Heffalump> MEMORY-HORNY??
07:46:14 <ibid> dark: actually, i have no problem getting those records
07:46:24 <shapr> ?
07:46:29 <ibid> Heffalump: taking lots of memory, more than i have physically available
07:46:31 <jadrian> Heffalump: exactly
07:46:43 <shapr> interesting way of putting it :-)
07:46:53 <ayrnieu> Heffalump - it's *almost* a nifty idiom similar to morphine-seeky (instead of morphine-addict)
07:46:56 <ibid> yes
07:47:04 <ibid> s/HORNY/HOG/, actually
07:47:32 <Heffalump> jadrian: have you written iterateM?
07:47:39 <ibid> dark: i've tried printing out the full list of these records after reading them from the strings... and i have no problems
07:47:40 <jadrian> Heffalump: yeap
07:47:43 <ayrnieu> I've never heard anyone claim that GHC was a fast compiler, no.
07:47:47 <Heffalump> iterateM f x = do fx <- f x    
07:47:47 <Heffalump>                   xs <- iterateM f fx
07:47:47 <Heffalump>                   return (x:xs)
07:47:54 <dark> ibid: It's probably trying to generate the FiniteMap or whatever at compile time, if you do it that way.
07:48:04 <Heffalump> is that roughly what it does?
07:48:18 <ibid> dark: probably
07:48:23 <jadrian> Heffalump: you just got some variable names different :)
07:48:28 <Heffalump> ok :-)
07:48:34 <dark> Heffalump: I use that pattern a lot :)  Except that it often needs to know when to stop, depending on fx.
07:48:42 <Heffalump> so now you just need to write f, which could probably use a monad transformer
07:48:52 <Heffalump> dark: well, you can just use takeWhile on the result
07:49:00 <Heffalump> as long as the underlying monad is lazy, it'll be fine
07:49:08 <ayrnieu> iterateM and functions of that pattern are still tail-recursive, right?
07:49:15 <jadrian> Heffalump: that's the part where I'm kind of confused
07:49:22 <Heffalump> ayrnieu: umm. not sure
07:49:30 <Heffalump> jadrian: ok, so f needs to be of type a -> Random a
07:49:33 <jadrian> Heffalump: f is going to acces the outer state so it needs to be ST
07:49:44 <dark> ayrnieu: Not in a strict monad, I think. 
07:49:52 <Heffalump> jadrian: hmm
07:50:03 <Heffalump> and is the randomness monad part of ST, or separate?
07:50:22 <dark> ibid: Judicious use of NOTINLINE might fix that :)
07:50:43 <jadrian> Heffalump: I was thinking about moedling my Randomness as a ST monad
07:51:10 <jadrian> Heffalump: I'd put the StdGens in STRefs as implicit parameters 
07:51:22 <Heffalump> jadrian: hmm
07:51:56 <Heffalump> can you make the randomness a monad transformer instead?
07:52:03 <jadrian> Heffalump: The environment might be more than just Randomness (even that is the main thing)
07:52:43 <ibid> okay, upon retry i get a problem with just listing the data after read... so it's there
07:52:53 <jadrian> Heffalump: Maybe a StateT
07:52:59 <ibid> i'll try the direct approach when i get home again
07:53:51 <ibid> dark: NOTINLINE for what?
07:53:51 <dark> ibid: I expect that the place where strictness may help is in the data records themselves.  If each record has 14 thunks associated with it it would eat a lot of memory.
07:53:54 <dark> ibid: For the table itself.
07:53:59 <ibid> hmm, true
07:54:05 <ibid> trying...
07:54:07 <dark> ibid: That way the functions that operate on it will have to do that at runtime.
07:54:19 <Heffalump> jadrian: yeah
07:55:12 <jadrian> Heffalump: now I'd also need another (local) state
07:56:34 <jadrian> f would be something like runState( P )
07:56:59 <Heffalump> jadrian: yep.
07:57:12 <Heffalump> so unravelling the outer bit of the monad transformer strack
07:57:14 <Heffalump> s/strack/stack/
07:57:23 <jadrian> and would I access the outer state from P using withStateT
07:57:31 <Heffalump> probably
07:57:44 <Heffalump> (I dunno what the precise function names are)
07:57:57 <Heffalump> but P should be of type StateT (...), and f will produce something of type ...
07:58:08 <ibid> now it's taking lots of stack space
07:58:34 <jadrian> I still don't know what's best though... ST or State...
07:58:52 <jadrian> ST could allow me to do some neat things later
07:59:06 <jadrian> can't I do that using ST
07:59:15 <ibid> ok, strictness for the records gets it down to 90 megs
07:59:17 <Heffalump> ST isn't a monad transformer
07:59:27 <Heffalump> but you can have ST as the "bottom" monad in the stack
07:59:41 <jadrian> the local right?
07:59:45 <ibid> but i'm off
08:00:30 <jadrian> so there is no way to use an ST from inside another ST right?
08:04:33 <Heffalump> nope.
08:04:37 <Heffalump> jadrian: no, the global
08:04:42 <Heffalump> the "top" monad will be the local
08:05:46 <jadrian> now I'm getting confused
08:05:48 <jadrian> :)
08:06:15 <jadrian> ah wait
08:06:25 * jadrian is not experienced with Monad Transformers
08:06:41 <jadrian> Heffalump: so the local one sould be the one with a monad transformer
08:06:43 <jadrian> ?
08:06:48 <Heffalump> jadrian: yeah
08:07:24 <jadrian> Heffalump: That explains *a lot* :)
08:07:55 <jadrian> So if I'm working inside a monad say say M and I want to use some monad H, H should be a monad transformer
08:08:11 <shapr> hi SyntaxPolice
08:08:16 * jadrian smacks is head
08:08:18 <SyntaxPolice> shapr: hello :)
08:08:22 <Heffalump> jadrian: yep
08:08:29 <shapr> SyntaxPolice: long time Haskeller? just starting?
08:10:09 <jadrian> Heffalump: now I just don't know what to choose, clean approach with monad transformers, or just use one ST monad, and use STRefs as implicit parameters
08:10:16 <Heffalump> heh
08:10:26 <SyntaxPolice> shapr: I've been using haskell pretty heavily for about a month now, had some exposure to ML before that.
08:10:50 * jadrian tries to figure out that "heh" :)
08:11:05 <shapr> SyntaxPolice: neat, have any questions or problems?
08:11:26 <liiwi> shapr!
08:11:30 <Heffalump> jadrian: not much to figure out :-)
08:11:31 <shapr> liiwi!
08:11:41 * liiwi squishes
08:11:44 <shapr> liiwi, väd gor du?
08:11:48 <Heffalump> could you get away with using lexical scoping for the STRefs instead of implicit parameters?
08:11:50 <SyntaxPolice> shapr: Thanks for asking :) I'm about to post to the haskell-cafe list, but perhaps I'll try this out on youall first, if I can explain it well enough on IRC>
08:11:53 <liiwi> idling at home atm
08:11:59 <jadrian> Heffalump: now way
08:12:04 <jadrian> Heffalump: no way
08:12:28 <shapr> liiwi: du talar svenska?
08:12:37 <liiwi> shapr: doligt
08:12:52 <shapr> SyntaxPolice: go for it, we get all kinds of questions
08:13:02 <jadrian> I got to think about it.
08:13:11 <jadrian> Thanks Heffalump!! :)
08:13:15 <jadrian> I'll bbl
08:13:24 <SyntaxPolice> I would like to create a type class that has some functions like toXML and some other stuff, but some of the types that I want to instantiate this typeclass are type synonyms, so thats against the rules.
08:13:42 <shapr> you could use newtype
08:14:02 <jadrian> hmm wait
08:14:13 <SyntaxPolice> But if I make it something else like a 'data =' type declaration, or a newtype, then I won't be able to use some functions I was using before.
08:14:30 <shapr> like what?
08:14:30 <SyntaxPolice> Like if I have "type Foo_Set = Foo_Set (FiniteMap String Foo)"
08:14:39 <SyntaxPolice> then I can use addToFM
08:14:45 <jadrian> Heffalump: just to make sure I gto everything straight... some function called by f that uses both monads, would have type ?
08:14:46 <ayrnieu> Strange.  You can't use 'String', for instance, but you can use [Char]?  What's the point of that?
08:15:25 <Heffalump> jadrian: both = the local and the global ones?
08:16:12 <SyntaxPolice> but I think if I use data or newtype, then I cannot use those functions anymore, and I'd have to create wrapper functions.
08:16:41 <Heffalump> syntaxpolice: sadly, yeah
08:18:39 <SyntaxPolice> so here's what I came up with: since I have several types like this Foo_Set that i want to use, all FiniteMap from String to something, I thought I could create a typeclass like StringMap to capture the similarities between these sets.
08:18:58 <Heffalump> that makes sense
08:19:37 <SyntaxPolice> but I'm having trouble with an implementation detail - Foo_set is something like "data Foo_Set = Foo_Set (FiniteMap String Foo)"
08:20:12 <SyntaxPolice> one sec...
08:20:29 <SyntaxPolice> (phone call :)
08:25:20 <SyntaxPolice> OK sorry.  So I have some functions in this typeclass to extract that map:
08:25:28 <SyntaxPolice> class StrMap a where
08:25:28 <SyntaxPolice>     obj'sMap   :: a -> FiniteMap String b
08:25:28 <SyntaxPolice>     addMap     :: FiniteMap String b -> a 
08:25:28 <SyntaxPolice>     emptyStrM  :: a
08:25:29 <SyntaxPolice> (etc)
08:25:47 <Heffalump> obj'sMap ? That surely can't be a valid name
08:25:49 <SyntaxPolice> maybe you see the problem already, but when I'd like to instantiate these functions
08:26:00 <SyntaxPolice> -- instance StrMap Foo_Set where
08:26:00 <SyntaxPolice> --    obj'sMap (Foo_Set m) = m
08:26:00 <SyntaxPolice> --    addMap   m = Foo_Set m
08:26:20 <SyntaxPolice> then it complains because 'm' is a FiniteMap of String Foo not String a
08:26:33 <SyntaxPolice> Heffalump: actually, Hugs has no problem with a ' in an identifier
08:26:41 <Heffalump> ok, fair enough
08:26:51 <Heffalump> I'm afraid you'll need a "multi parameter type class" here
08:27:04 <SyntaxPolice> that sounds nice, but does that exist in Haskell?
08:27:11 <Heffalump> yes, but it's an extension, not H98
08:27:12 <jadrian> Heffalump: I don't know what was your answer, but the type must have looked really bad, cause I had a power failure here in that axact moment :)
08:27:23 <Heffalump> [16:15] <Heffalump> jadrian: both = the local and the global ones?
08:27:32 <jadrian> Heffalump: yeap
08:27:51 <Heffalump> syntaxPolice: can you make Foo_Set the following:
08:27:52 <Heffalump> type Foo_Set = Foo_Set (FiniteMap String 
08:27:53 <SyntaxPolice> Heffalump: I see... so is this implemented in only ghc?
08:27:53 <Marvin--> you can have ' in an identifier?!
08:27:55 <Heffalump> oops, sorry
08:28:07 <Heffalump> newtype Foo_Set b = Foo_Set (FiniteMap String b)
08:28:17 <Marvin--> eeeeeeek
08:28:31 <Heffalump> or are there some of these types that really do have to have a particular target type for the finite map?
08:28:33 <SyntaxPolice> Marvin--: yeah, haven't you seen "fun = " and "fun' = " 
08:28:43 <ayrnieu> Marvin - yes; just not as the first character.
08:28:49 <Heffalump> SyntaxPolice: oh, of course
08:28:51 <Heffalump> duh :-)
08:28:53 <Heffalump> hi hdaume
08:29:08 <jadrian> hello hdaume
08:29:19 <Heffalump> jadrian: something -> MT (M a)
08:29:29 * ayrnieu uses this frequently as in the mathematics 'foo-prime' idiom, but not as SyntaxPolice just used it =)
08:29:30 <Heffalump> where MT is the local info monad transformer, and M is the global info monad
08:29:33 <SyntaxPolice> Heffalump: I'm not sure that I understand your question.
08:29:41 <Marvin--> SyntaxPolice: doh, true, but f'oo is just ugly
08:29:43 * SyntaxPolice is very special with his identifiers
08:29:49 <Heffalump> SyntaxPolice: is there a reason Foo_Set has to be tied to a target type of Foo?
08:29:50 <SyntaxPolice> Marvin--: sorry to offend ;)
08:29:59 <Marvin--> SyntaxPolice: go stand in the corner! :)
08:30:19 <SyntaxPolice> Heffalump: well... I'd like to make it a member of a typeclass later that implements a toXML function, among other things.
08:30:27 <SyntaxPolice> which is why I can't use a type synynom
08:30:36 * SyntaxPolice stands in corner w/ laptop
08:30:46 <jadrian> Heffalump: but if the *inner* monad is the Transformer one, shouldn't it be M(MT a)
08:31:06 <Heffalump> jadrian: but the outer one is the transformer one
08:31:09 <Heffalump> the inner one is the base one
08:31:18 <Heffalump> did I say that the wrong way round above?
08:31:28 <Heffalump> SyntaxPolice: what'll the type of toXML be?
08:31:53 <jadrian> Heffalump: Let me check the logs :)
08:31:56 <SyntaxPolice> Heffalump: not quite sure yet, but something like toXML :: Foo_Set -> XML_FOO_SET or something
08:32:13 <Heffalump> hmm
08:32:21 <SyntaxPolice> Foo_Set is a member of an abstract syntax tree which I want to be able to transform in a handful of ways
08:32:31 <SyntaxPolice> and to transform the other members of this tree in similar ways.
08:32:35 <Heffalump> and if you make it a typeclass member, what'll the type be?
08:32:49 <Heffalump> class XML a where toXML :: a -> XML_SOMETHING 
08:32:49 <Heffalump> ?
08:33:39 <SyntaxPolice> hrm... I haven't thought that far in advance, and I see that I may have a similar problem here.
08:33:44 <Heffalump> yeah
08:33:46 <hdaume> class XML typ xml | typ -> xml, xml -> typ where toXML :: typ -> xml?
08:33:59 <Heffalump> the thing is that at each stage you have two different types tied together
08:34:03 <Heffalump> hdaume: almost certainly :-)
08:34:10 <hdaume> perhaps an example of a bidirectional fundep that spj is looking for?
08:34:14 <jadrian> Heffalump: well you said the local one should be the monad transformer
08:34:22 <Heffalump> jadrian: yep, and the local one should be the outer one
08:34:25 <Marvin--> or class XML a b | a -> b where toXML :: a -> XML_SOMETHING b ?
08:34:28 <Heffalump> that way you can "unwrap" it easily
08:34:48 <jadrian> Heffalump: that I don't understand
08:35:14 <jadrian> Heffalump: I want to call the local one from inside the global one
08:36:06 <jadrian> isn't that so?
08:36:46 <SyntaxPolice> what hdaume said seems about right, I'm having trouble parsing Marvin--'s version
08:37:09 <dark> SyntaxPolice: You might be able to solve it the same way that Show does with Char vs. String: add a setToXML class function.
08:37:21 <jadrian> Heffalump: in each iteration f would run the local monad to get the values 
08:37:36 <SyntaxPolice> so this is doable with some haskell extentions that are implemented in ghc?
08:37:43 <Heffalump> jadrian: yes, but when you're inside the global one you're working with things of type M a
08:37:51 <dark> (Show
08:38:03 <jadrian> Heffalump: yes
08:38:05 <Heffalump> you then start working with things of type MT (M a) for a while, use the "run" operation of MT to get rid of the MT, and you're back to M a
08:38:12 <dark> (Show's problem is that show [Char] needs to behave differently from any other show [a])
08:38:35 <Heffalump> SyntaxPolice: I believe hugs implements them too, though I could be wrong
08:38:42 <Igloo> Why is that a rpoblem, dark?
08:38:53 <jadrian> Heffalump: you're right, I'm wrong, got it
08:38:55 <Heffalump> because that's not valid Haskell 98
08:39:00 <SyntaxPolice> dark: I'm not sure how to apply your suggestion.
08:39:00 <jadrian> :)
08:39:11 <Heffalump> you can't write instance Foo (List Char)
08:39:36 <Igloo> But the problem has been solved - am I missing the point?
08:40:21 <jadrian> Heffalump: That's why I was so confused about State monads... I would see MT(M a) and I would read it like, the outter monad (the gloabl one) is MT...
08:40:28 <SyntaxPolice> ahh, so show uses a function to convert [Char] to something?
08:40:30 <Heffalump> igloo: yes, but only by adding a separate member to the class
08:40:35 <jadrian> Heffalump: now I understand :))
08:40:56 * Igloo decides this probably requires having been following the conversation and stops  :-)
08:41:16 <jadrian> Heffalump: my algorithm would be doomed if I wanted to add IO to in each iteration wouldm't it?
08:41:33 <Heffalump> igloo: no, the relevant bit only starts from [16:37] <dark> ...
08:41:40 <Heffalump> jadrian: yes :-)
08:41:47 <dark> Igloo: It's been solved by creating a showList member, not by making a Show String instance :)
08:41:54 <Heffalump> sorry btw, I just realised I meant MT M a, not MT (M a)
08:42:09 <jadrian> Heffalump: can't you say that without a smiley :)
08:42:21 <Marvin--> haha
08:42:27 <SyntaxPolice> I haven't been using any Haskell extentions so I'll look into this.  Does anyone have the impression (if you can remember the higher-level problem) that I'm going about this the wrong way?
08:42:50 <Heffalump> jadrian: you can't do IO in each individual iteration and escape IO outside the iterations, just like you can never escape IO anywhere else
08:42:54 * Igloo knows how it's solved, I'm just confused. Just ignore me  :-)
08:43:04 <jadrian> Heffalump: I thought of ST because that way I could easily change to IO 
08:43:07 <dark> SyntaxPolice: I don't see how you're going to implement addMap :: FiniteMap String b -> a, without knowing something about b.
08:43:09 <Heffalump> SyntaxPolice: I suspect you're going about it reasonably, but I don't know enough about the general topic to be sure
08:43:17 <jadrian> Heffalump: but then iterateM wouldn't work because IO monad is strict anyway
08:43:19 <Heffalump> jadrian: oh, you can use IO as the inner (global) monad no problem
08:43:24 <Heffalump> ah, yes.
08:43:33 <Heffalump> you'd have to explicitly terminate rather than using laziness
08:43:40 <jadrian> yeap
08:44:08 <jadrian> not only that, I'd have to explicitly consume each value instead of just creating the list of values lazily
08:44:33 <jadrian> do I get in place updates in the State monad (in ghc) ?
08:44:33 <SyntaxPolice> dark: actually, b in this case is also a member of a typeclass like 'HasName', but even so, I'm not sure why I'd need to know anything about b to add it to a FiniteMap.
08:46:03 <SyntaxPolice> (except for the typechecking problem that we've been talking about, which can apparently be solved with a multi parameter type class)
08:46:41 <jadrian> bbl, thanks Heffalump! :))
08:48:26 <ayrnieu>  /msg #Emacs |
08:48:32 <ayrnieu> er, excuse me.
08:49:59 <SyntaxPolice> OK folks, thanks for the advice.  I'll look into your solutions.  I might get kicked off of here in a few minutes (router hardware upgrade), but I'll probably be back.
08:50:05 <SyntaxPolice> peace.
09:02:55 <shapr> so, have I missed anything in the Haskell world?
09:03:34 <dark> Not that I can think of :)
09:04:00 <shapr> we haven't taken over the world yet?
09:04:15 <shapr> hmm
09:04:20 <dark> shapr: We're going it lazily.
09:04:29 <dark> Only taking over the parts of the world that are needed.
09:04:31 <shapr> ah, of course.
09:04:40 * shapr laughs
09:17:40 <ayrnieu> How did you hear of Template Haskell?  "Future of Haskell" of www.haskell.org (which I'd think the place to look for such advancements) doesn't link to it.
09:17:41 * Marvin-- goes to make some fish soup
09:17:41 <Heffalump> how did who hear of it?
09:17:41 * Igloo talked to my supervisor about donig this sort of thing for my dPhil before I think it existed
09:17:41 <ayrnieu> anyone.
09:17:41 <Heffalump> I heard about it in the same way and through SPJ/Tim Sheard
09:17:41 <Igloo> And he then talked to SPJ at a conference
09:17:41 <ayrnieu> Igloo - ... Doctorate of Philosophy?
09:17:41 <Heffalump> Oxford's name for a PhD
09:17:52 <dark> I heard about it on #haskell :-)
09:18:05 <ayrnieu> hm, OK.
09:18:44 <Igloo> If you read cvs-ghs, cvs-all or glasgow-users you'd probably have seen talk about it
09:18:47 <hdaume> i peruse spj's web page periodically and there's where i heard it
09:19:32 <Igloo> How up to date is "On a rather longer time schedule a committee lead by John Launchbury may develop Haskell II."?
09:20:03 <Heffalump> I don't think John Launchbury is still in the frame
09:22:26 <hdaume> i would guess it's still a long ways off anyway
09:22:45 <hdaume> certainly spj has said that there isn't any haskell2 under consideration currently
09:22:54 <Heffalump> there's noone prepared to lead it
09:24:08 <Igloo> Hey, my offer still stands  :-)
09:24:52 <Heffalump> s/noone/& qualified/
09:25:57 <Igloo> :-)
09:26:54 <shapr> I think I found a paper about TH accidentally
09:28:46 <shapr> hey hal, is the latest version of hMPI on your homepage somewhere?
09:34:39 <Igloo> Is galconn in America?
09:34:40 <shapr> I think so... washington state maybe?
09:34:40 <Igloo> OK, ta
09:34:40 <Heffalump> Oregon
09:34:40 <Heffalump> (Portland)
09:34:40 <Heffalump> is "Jeff" Jeff Lewis?
09:34:40 <shapr> ah, northwest somewhere... I was close :-)
09:35:04 <ayrnieu`> shapr - yes; Oregen and Washington are neighbors.
09:35:06 <Igloo> Yes
09:35:22 <shapr> ayrnieu: I lived in Seattle for awhile, nice place.
09:36:05 <shapr> hm, I thought hal's updated hMPI sources were linked from his homepage.
09:37:56 <shapr> hdaume: could I get a copy of your updated hMPI sources?
09:45:13 <hdaume> yeah...lemme put them up...hold on
09:45:19 <shapr> yay :-)
09:45:45 <dark> matches = if null matches1 then matches2 else matches1
09:45:54 <dark> Is there a clearer way to express that?  I get confused just reading it.
09:46:08 <hdaume> get www.isi.edu/~hdaume/newhmpi.tar.gz
09:46:33 <dark> matches1 and matches2 are the results of different filters on the same list.
09:47:13 <shapr> thanks hal!
09:47:16 <Heffalump> dark: not really
09:47:30 <Heffalump> perhaps use not and switch the then/else around
09:47:34 <hdaume> shapr: you'll need to have the old hmpi...just overwrite /src with that tar
09:47:46 <mgoetze> dark: null :: match -> Boolean?
09:47:56 <Marvin--> mgoetze: null :: [a] -> Bool
09:48:00 <mgoetze> ah
09:48:12 * mgoetze doesn't know enough prelude functions.
09:48:19 <Heffalump> dark: that kind of pattern is very common in parser combinator libraries and the like
09:48:27 <Heffalump> and AFAICR it's usually written that way
09:48:58 <Marvin--> Heffalump: in a parser combinator library I'd just use mplus...
09:49:16 <Heffalump> Marvin--: only if you wanted it to be nondeterministic
09:49:35 <Heffalump> there's sometimes/often points where you want to cut the nondeterminism
09:49:42 <Marvin--> *shrug*
09:49:50 <Marvin--> take 1 :-P
09:49:57 <dark> I definitely want to prefer matches1 over matches2, if that's what you mean.
09:50:05 <Marvin--> dark: I'd use if xs /= [] then xs else ys instead
09:51:00 <dark> Hmm, using == [] or /= [] versus null and not_null, is that just a matter of style?
09:51:26 <Heffalump> dark: yes
09:51:27 <dark> (/=[]) sections look like weird smileys to me :-)
09:51:31 <Heffalump> oh, no
09:51:40 <Heffalump> == [] :: Eq a => [a] -> Bool
09:51:49 <mgoetze> 8=[]
09:51:50 <Heffalump> it imposes an unnecessary class constraint
09:51:50 <Marvin--> I think /= is more concise than not . null
09:52:00 <dark> Marvin: I defined not_null for that :-)
09:52:03 <Heffalump> it also has a different type :-)
09:52:12 <Marvin--> oh, I thought null used Eq too
09:52:18 <Heffalump> it should do, it can use pattern matching
09:52:23 <Heffalump> s/should/shouldn't/
09:52:30 <Heffalump> and you don't need Eq to do that, I hope :-)
09:52:34 <Marvin--> no
09:52:47 <Marvin--> case xs of { (_:_) -> xs; _ -> ys } ... ew ;)
09:53:03 <dark> Marvin: You could just write it in two lines :-)
09:53:24 <ayrnieu`> case xs of { [] -> ys; _ -> xs }
09:54:18 <Marvin--> ayrnieu`: the point was to make the relationship between non-empty list and xs more clear
09:54:44 <dark> matches = [ m | m@(_:_) <- [matches1, matches2] ]
09:55:07 <dark> No, that assumes matches2 is never empty :)
09:55:19 <dark> And it'd have to do "head" as well.
09:55:29 <ayrnieu`> Marvin - sorry, I don't see the obscurity.
09:56:12 <dark> I think I just want the conciseness of C here: x ? x : y
09:56:18 <ayrnieu`> data NonNilList a = NonNilList (a:[a])
09:56:32 * ibid is profiling the beast program
09:56:33 <Heffalump> dark: that's the wrong type
09:56:43 <dark> Heffalump: That was the wrong language :-)
09:56:48 <Heffalump> (the [ m | m...] thing)
09:56:57 <Heffalump> oh, sorry, no it isn't.
09:56:59 <ayrnieu`> (a ?: b) f = if f a then a else b
09:57:00 <dark> Heffalump: Yeah, it needs a "head" in front of the comprehension
09:57:07 <Heffalump> oh, yes it is
09:57:10 * Heffalump makes his mind up
09:57:16 <Heffalump> ah, but what if matches1 and matches2 are empty?
09:57:31 <dark> Heffalump: Then it fails horribly :)
09:58:04 <Igloo> concat . take 1 rather than head  :-)
09:58:34 <dark> ayrnieu: Is that a proposal or a prelude function?
09:58:42 <ayrnieu`> dark - proposal.
09:59:27 <dark> Igloo: matches is supposed to end up as the same type as matches1 and matches2
10:00:13 <dark> Igloo: What does concat . take 1 do that differs from head?
10:00:15 <Igloo> concat . take 1 has the same type as head
10:00:20 <Igloo> It works for the empty list
10:00:26 <dark> Oh :)
10:00:37 <dark> I hadn't thought of that.
10:01:03 <Heffalump> that would leave you with something horribly complicated
10:01:16 * Heffalump suggests you just go with what you had originally, the meaning is clear and it's not hugely inelegant
10:01:23 <Igloo> I thought it was more complicated than where we started anyway
10:02:50 <Heffalump> yes
10:02:55 <ayrnieu`> nullOr [] b = b; nullOr a _ = a
10:03:12 <Heffalump> hmm, that's nice
10:03:22 <Heffalump> not sure I like the name though
10:03:34 * Marvin-- returns to the kitchen and his fish soup :)
10:03:52 <Marvin--> almostmplus? ;)
10:04:11 <Heffalump> :-)
10:05:43 <ayrnieu`> You could call it '??', if you don't mind the C's ?: operator.
10:06:48 <Heffalump> perhaps orelse
10:07:12 <dark> matches = matches1 `orelse` matches2
10:07:19 <ayrnieu`> orelse sounds like it'd be involved with booleans.
10:07:24 <dark> Looks good, but the fact that []ness is the key is somewhat hidden :)
10:07:30 <Heffalump> `ifnull`
10:07:40 <Marvin--> heh
10:07:42 <Heffalump> `butifnull`
10:07:46 <Marvin--> "orelse: the threatening operator"
10:07:53 <ayrnieu`> butifnull might work =)
10:08:02 <Marvin--> beautiful?
10:08:04 <dark> Maybe a typeclass that decides interestingness :)
10:08:11 <Heffalump> `unlessnullinwhichcase`
10:08:20 <Marvin--> class Null a where isNull :: a -> Bool?
10:08:26 <dark> Yeah
10:08:34 <ayrnieu`> Marvin =)  It's a self-contradictory name!
10:08:37 <dark> instance Null [a] where isNull = null
10:08:43 <dark> instance Null Bool where isNull = False
10:08:44 <dark> etc
10:08:56 <dark> Er
10:09:04 <Heffalump> isNull = (==False)
10:09:05 <dark> the Bool one is wrong :-)
10:09:12 <Heffalump> or just "not"
10:09:47 <Marvin--> unlessnullinwhichcase, hahaha
10:10:54 <dark> With a HasNull class I would go with orelse :)
10:11:35 <dark> And also first :: (HasNull a) => [a] -> a
10:11:35 <Marvin--> bah, ?? would be more fun
10:11:47 <Marvin--> a ?? b
10:11:59 <dark> That should select randomly :)
10:12:25 <Heffalump> firstnonnull, I'd have thought
10:12:28 <Marvin--> all right, make it a ? b then
10:12:28 <ayrnieu`> It would be nice if '[]' could be part of operator-names.
10:13:13 <ayrnieu`> a `or, if the previous is []:' b
10:13:22 <ayrnieu`> ``, of course.
10:13:22 <dark> Hmm, should HasNull have a nullvalue :: a member?
10:14:16 <Heffalump> you're not seriously writing this entire class just to make your definition of matches look nicer, are you?
10:14:23 <ayrnieu`> data ChooseBy = FirstNotNull | ...
10:14:30 <Marvin--> dark: but then you'd need Eq to have a default definition of isNull
10:14:33 <ayrnieu`> a ?? b FirstNotNull
10:14:40 <andersca> hey Marvin--
10:14:44 <Marvin--> andersca: hullo
10:14:51 <dark> Heffalump: No, but I might if I encounter the pattern again :)
10:15:13 <hdaume> if you use pointfree, you get something like 'cond null (id, const matches2) matches1'
10:15:26 <hdaume> where cond is the ( , ->) operator
10:15:29 <hdaume> (i forgot it's real name)
10:15:42 <Marvin--> yay, let's all go back to using plain lambda calculus instead
10:15:46 <hdaume> oops, that should be 'cond null (const matches2, id) matches1'
10:15:57 <hdaume> :")
10:16:22 <Marvin--> I think my fish soup is just about ready *waves*
10:17:07 <ayrnieu`> in O'Caml: (function [] -> b | _ -> a) a b
10:17:20 <ayrnieu`> That's surely the most transparent!
10:17:54 <dark> Transparent as in, I can look at it and see nothing? ;-)
10:19:28 <ayrnieu`> dark - no, because it's not hiding nothing.
10:19:42 * ayrnieu` hums.
10:20:26 <Heffalump> ayrnieu`: it's also incorrect :-)
10:20:44 <Heffalump> (you don't take in b as a parameter to your function, yet you try to pass it as one)
10:20:44 <ayrnieu`> Yes, it is.
10:21:12 <ayrnieu`> Remove the 'b', I suppose, but I don't like that.
10:22:36 <ayrnieu`> (function [] -> (function _ -> b) | _ -> (function _ -> a)) a b
10:23:06 <ayrnieu`> dark - curiously, what have you decided to do with that confusing code of yours?
10:41:30 <ayrnieu`> Hm, the Haskell WishList is broken.
10:44:50 <dark> ayrnieu: Actually I, er, changed the behaviour so that I no longer have two matches lists to choose from :)
10:46:12 <dark> This code was part of the help command, and I noticed that matches2 was always a superset of matches1, and showing the longer one was more helpful.
10:46:52 <Heffalump> lol
10:47:11 <ayrnieu`> =)  I'm glad that the your problem was solved so handily.  Do you suppose that you would've noticed that if you weren't so disasstisfied with the beauty of your code?
10:48:39 <shapr> hi stepcut
10:52:14 <dark> ayrnieu: It's difficult to know :)
10:52:24 * shapr realizes he is in desperate need of a monad
10:52:33 <dark> ayrnieu: Certainly I looked longer and harder at it than I otherwise would have.
10:53:51 <ayrnieu`> shapr - what are you doing?
10:58:17 * Heffalump hands shapr a monad transformer and the identity monad, thus providing him with the means to make his own monads
11:01:01 <Igloo> Is Chilli or anyone else up on FFI history around?
11:14:22 <ibid>  3170 antkaij   17   0  472m 197m 5900 R 39.5 78.7   4:32.74 ghc-5.04          
11:14:27 <ibid> ugh
11:14:42 <ibid> it seems the read version was a lot better
11:30:12 <Vulpyne> ayrnieu`: Hey, I solved the problem the way I originally intended to (almost) by using your list function. Thanks.
11:30:58 <ayrnieu`> Vulpyne - congratulations, and which one?
11:31:49 <Vulpyne> Which list function? The one that generated a list of random numbers.
11:32:45 <ayrnieu`> oh, OK.
11:34:16 <Vulpyne> Want to see?
11:35:06 <ayrnieu`> Sure.
11:35:56 <Vulpyne> It's 6 lines. Should I paste?
11:36:57 <ayrnieu`> Sure.
11:37:06 <Vulpyne> makePassword :: Int -> IO ()
11:37:06 <Vulpyne> makePassword genlength = do
11:37:06 <Vulpyne>   randlist <- randomList genlength
11:37:06 <Vulpyne>   let result = ["0123456789abcdefghijklmnopqrstuvwxyz" !! thisrand | thisrand <- randlist]
11:37:06 <Vulpyne>   print result
11:37:07 <Vulpyne>   return ()
11:37:37 <hdaume> you don't need that 'return ()' at the end
11:37:51 <Vulpyne> Ah, okay.
11:38:37 <ayrnieu`> Vulpyne - so, you hardcode the range of randomList as (0,36) ?
11:39:06 <Marvin--> hmm, is there no randomElem function or something like that?
11:39:06 <ayrnieu`> or (0,35)
11:39:21 <Vulpyne> Heh, yeah.
11:40:04 <Vulpyne> It was just proof-of-concept, not production code.
11:40:58 <ayrnieu`> randomElem l = do n <- randomRIO (0, length l - 1); return (l !! n)
11:41:36 <shapr> QuickCheck has some cute random generators built in
11:41:48 <Marvin--> yeah, Arbitrary is cute
11:41:55 <shapr> and you can write a generator for any datatype with the QuickCheck stuff
11:42:08 <Vulpyne> I don't know enough to do that stuff yet. :)
11:42:53 <SyntaxPolice> greetings again.  Anyone have any advice: I'm now using the multi parameter type class extention, but now I have a new problem, I can't define a function which involves only one of the parameters
11:43:08 <SyntaxPolice> hugs complains that it is ambiguous.
11:43:20 <Marvin--> SyntaxPolice: well, it is :-)
11:43:42 <ayrnieu`> Syntax - foo a = mutate a :: Bar
11:43:55 <ayrnieu`> well, that's wrong.
11:44:03 <SyntaxPolice> Marvin--: I believe you :)
11:44:33 <SyntaxPolice> is it ambiguous in the sense that it doesn't know which type that variable represents?
11:44:58 * SyntaxPolice is trying to come up with an actual question instead of just floating my problems.
11:45:13 <ayrnieu`> Yes, actual questions are best.
11:46:23 <SyntaxPolice> I can immagine how it makes lots of sense to have a typeclass, of one parameter, where it disallows me to define a function which doesn't have that parameter in the type signiture
11:47:11 <SyntaxPolice> I guess my quick question is whether this is an actual problem with my code / design or if there is some way I can "disambiguate" it.
11:47:19 <SyntaxPolice> Also I don't understand in what sense the former case is ambiguous
11:48:19 <ayrnieu`> SyntaxPolice - could you show us how you define your typeclass?
11:48:54 <SyntaxPolice> sure.
11:49:05 <SyntaxPolice> class (HasName b) => StrMap a b where
11:49:05 <SyntaxPolice>     obj'sMap   :: a -> FiniteMap String b
11:49:05 <SyntaxPolice>     addMap     :: FiniteMap String b -> a 
11:49:05 <SyntaxPolice> --    emptyStrM  :: a
11:49:05 <SyntaxPolice>     addToStrM  :: (HasName b) => a -> b -> a
11:49:06 <SyntaxPolice>     lookupStrM :: (HasName b) => a -> String -> Maybe b
11:49:08 <SyntaxPolice> --    isEmptyStrM:: a -> Bool
11:49:15 <SyntaxPolice> The two commented functions are the ones that are causing problems (obviosly)
11:50:29 <SyntaxPolice> an implementation of emtyStrM should look like "emptyStrM f = isEmptyFM (obj'sMap f)
11:54:34 <SyntaxPolice> the point of this StrMap class is to make it so that a type can define "obj'sMap" and "addMap" and get all the other functions for free.
11:56:44 <ayrnieu`> do emptyStrM and isEmptyStrM really need to be differently defined for every StrMap a b ?
11:58:25 <SyntaxPolice> no, they will be the same I think.
11:58:40 <SyntaxPolice> I was intending to provide a default function
12:00:00 <ayrnieu`> (If this is a module, someone can override your function at the module-boundary-level.)  Could you just define those two functions seperately from the class-definition?
12:01:46 <SyntaxPolice> I see no problem with that idea, but I get the same error either way, since I'm using that "obj'sMap" function.
12:02:11 <Marvin--> can't you parameterize a over b?
12:03:27 <SyntaxPolice> sorry, Marvin-- I don't understand that.
12:03:31 <ayrnieu`> import Random hiding (randomRIO)
12:03:31 <ayrnieu`> import Random as R (randomRIO)
12:03:53 <ayrnieu`> this seems import randomRIO
12:03:59 <ayrnieu`> seems to.
12:04:12 <Heffalump> you want import qualified Random as R ...
12:04:14 <Marvin--> SyntaxPolice: I was under the impression that a "contains" b:s?
12:04:39 <ayrnieu`> Heffalump - yes, by which I mean that R.randomRIO should be accessible (but nothing else should be so accessible, because I only import randomRIO there)
12:05:17 <Heffalump> ayrnieu`: yes, I believe you need the "qualified" keyword
12:05:31 <ayrnieu`> err, yes, that's what I meant.  What does the above mean?
12:05:45 <Heffalump> syntaxpolice: I believe you need a functional dependency in your code above
12:06:03 <Heffalump> ayrnieu`: you're asking what it means without the qualified keyword?
12:06:36 <ayrnieu`> Heffalump - yes
12:06:54 <ayrnieu`> import qualified Random as R (randomRIO) -- with the other line, this seems to work =)
12:06:57 <Heffalump> SyntaxPolice: try making the definition into class (HasName b) => StrMap a b | a -> b 
12:07:16 <Heffalump> ayrnieu`: without "qualified", I believe it imports the function both qualified and unqualified
12:07:48 <ayrnieu`> hm, OK.
12:11:15 <SyntaxPolice> Heffalump: The compiler seems quite happy with that, and I'll work on my own to figure out what it means.  Thanks all again for the help.
12:12:58 <ibid> the compiler has been in the renamer for an hour, taking almost 500 megs of memory
12:13:01 <ibid> argh
12:15:33 <SyntaxPolice> btw, as above, I noticed that for instance having a ' in the middle of an identifier is non standard... is there any sort of standard style conventions for Haskell out there?
12:16:33 <ayrnieu`> hm?  non-standard in that it's illegal by Haskell98?
12:17:07 <Igloo> Uncommon I think
12:17:29 <Igloo> (foo_bar, foo_bar') and (fooBar, fooBar') are the 2 common style I've seen
12:17:51 <ayrnieu`> I haven't seen the former at all.
12:18:19 * ayrnieu` mostly follows the GHC libraries and emacs-mode.
12:18:41 <Igloo> You haven't read any of my code then  :-)
12:18:42 <ayrnieu`> that is, haskell-mode
12:18:45 <Igloo> Or Dark's IIRC
12:19:01 <ayrnieu`> ah, I may have seen some of that in mage.
12:19:24 <SyntaxPolice> Igloo: yeah, i meant uncommon.
12:19:43 <SyntaxPolice> Igloo: so you might write a identifier like "obj'sMap" ?
12:20:38 <Igloo> Not in either of the styles above, no - all the "'"s go at the end
12:20:47 * Marvin-- decides to go to the pub and have a few beers
12:21:05 <ayrnieu`> Marvin - bye; have fun.
12:23:47 <SyntaxPolice> Pardon the fawning, but I feel like saying that I've been very pleased and impressed w/ how helpful the Haskell community is, both here and on the Haskell-Cafe list.
12:23:55 <SyntaxPolice> I'll try not to abuse it :)
12:24:58 <ayrnieu`> I'm glad you're happy with it =)  I fear that I sometimes offend people (too many habits from EFnet:#Perl, lurking around).
12:25:10 * Heffalump reappears and realises that he just correctly told someone how to use a fundep without ever having used one himself before :-)
12:25:17 * Heffalump disappears again
12:25:37 <SyntaxPolice> heh
12:26:33 * ayrnieu` finds http://haskell.cs.yale.edu/pipermail/hugs-bugs/2001-April/000224.html, but is still in the dark on "fundep"
12:27:27 <Heffalump> fundep = functional dependency
12:27:34 <Heffalump> the | a -> b bit in that type class above
12:28:00 <Heffalump> basically it says that you'll never make two instances of the class with the same a but different b
12:28:20 <ayrnieu`> ah, OK.
12:28:45 <Heffalump> this means that the type checker can make some assumptions which avoid the ambiguity problems you get otherwise
12:29:35 * stepcut vomits on the XFree86 cvs repository
12:31:16 * ayrnieu` cringes every time he sees the name "Thaddeus L Olczyk" on usenet.
12:31:39 <Heffalump> who is that?
12:33:01 <ayrnieu`> Some incredible neen -- you can see his "Disappointed with caml. other implementations of ML" on comp.lang.ml to get an idea.  I think he also starred in a "What's the point of higher-order-functions?" cross-thread.
12:33:57 <stepcut> Apparently, for XFree86, they take 100 or so indepedant patches, and cvs commit them all at once with the same commit message. So if you want to get the patches for a specific bug, you are screwed.
12:34:28 <ayrnieu`> stepcut - yes, that's odd.
12:34:57 <stepcut> and they don't even have a webcvs interface.
12:35:20 <shapr> olczyk is an interesting guy
12:35:29 <ayrnieu`> shapr - oh?  How so?
12:36:16 <shapr> ayrnieu: I've seen him on the original WikiWiki, he's been here on #haskell, active on the [pragprog] list, and I think I've seen him on the XP yahoo list as well
12:36:22 <stepcut> All I know is I need the bug fix with the commit message '338. Fix for non monotic clocks' -- so I have to do a CVS log on the entire repository, then find all the files commit in that gigantic batch, and then try to guess which files are relevant to the specific fix I want :)
12:36:23 <Heffalump> shapr: what nick?
12:36:46 <shapr> olczyk I think
12:36:51 <shapr> or tolczyk
12:37:39 <shapr> he was unhappy with Haskell, but no one here wanted to proselytize him (not even me, I knew about him years ago)
12:38:39 <ayrnieu`> curiously, what was he unhappy about?
12:38:49 <Heffalump> shapr: do you remember roughly when?
12:38:57 <shapr> I think he's looking for the right thing for him, but I don't like the way he goes about it.
12:39:19 <shapr> hmm, I think it was between 1.5 to 2.5 months ago
12:40:33 <ayrnieu`> also, sorry; Olczyk seems more common to comp.lang.ml than comp.lang.functional
12:40:50 <shapr> I don't think he's purposefully difficult, but I think he does get frustrated and angry easily.
12:41:48 * Heffalump downloads logs for grepping purposes
12:42:32 <Vulpyne> Hey, shapr.
12:42:34 <shapr> I get frustrated easily also, I think I have been a lot of trouble to deal with in the past.
12:42:36 * Vulpyne used to be Myrdraal.
12:42:38 <shapr> hi Vulpyne
12:42:45 <shapr> wow! I thought that might be you...
12:42:49 <shapr> but it's been so many years :-)
12:42:51 <ayrnieu`> Vulpyne - oh!  Hello!
12:43:11 <Vulpyne> Oh, yeah... I remember you too. :)
12:43:11 <ayrnieu`> Vulpyne - I used to be ayrnieu =)
12:43:18 <shapr> last time you were on #python you were working at a 'web company'
12:43:27 <Vulpyne> I'm still at the same job.
12:43:32 <shapr> ah, I see.
12:43:37 <Vulpyne> How've you two been?
12:43:49 <shapr> I've been loving Haskell :-)
12:44:08 <shapr> moved to finland three years ago
12:44:09 <Vulpyne> It does seem interesting.
12:44:16 <shapr> moved to sweden one week ago
12:44:27 * shapr is hoping to homestead on mars next
12:44:28 * Vulpyne nods.
12:44:46 <Vulpyne> So you're going to be staying in Sweden for 30-60 years? :)
12:44:52 * shapr laughs
12:44:54 <ayrnieu`> Finland->Sweden->Mars.  I'd expect Sweden->Finland->Mars as a more natural progression, but OK =)
12:45:37 <shapr> Vulpyne: thirmite and I were talking about you a few months ago, wondering where you were
12:45:45 <shapr> he's changed nicks to sjj now
12:45:56 <Vulpyne> Ah.
12:45:59 <Vulpyne> I haven't done much Python stuff.
12:46:10 <shapr> I get paid to write Python
12:46:15 <shapr> Zope websites
12:46:20 <Vulpyne> Heh, nice.
12:46:24 <shapr> now I want to get paid to write Haskell =)
12:46:37 <Vulpyne> Are you sure you really want that? :)
12:46:47 <shapr> yup, I am.
12:46:49 <Vulpyne> I used to like coding a lot more before I had to do it as a job.
12:47:08 <shapr> I've been coding for a living for several years, I still love it.
12:47:12 <Vulpyne> I've heard the saying that you should pick your *second* favorite thing to do for a living.
12:47:21 <ayrnieu`> Vulpyne - I've not been up to much; a brief love-affair with Forth, and I'm now interested in Haskell/O'Caml/Erlang (which is a relief!).  I'll be going to US Airforce Basic Training in about three weeks, so I'll see you again in a year or two.
12:47:23 <Vulpyne> Guess it depends on t he individual. :)
12:47:47 <shapr> whoa, ayrnieu, you're going USAF
12:47:59 <Vulpyne> ayrnieu`: Make them give you net access. :)
12:48:02 <shapr> send us email!
12:48:31 <shapr> last I heard you can get standard net access pretty much anywhere, including aircraft carriers
12:49:05 <ayrnieu`> Wow, I hadn't heard the last.
12:49:46 * Heffalump has a friend who just finished basic training with the RAF, and he had to get net access using his mobile phone and laptop
12:49:49 <ayrnieu`> I'll still be here for about three weeks, so no worries.
12:59:10 <shapr> well, gotta get offline... modem is per-minute :-/
12:59:11 <shapr> bbl
13:06:11 <Vulpyne> ayrnieu`: Hmm, I don't really understand the way that you continued a set number of times for your randomList function.
13:06:25 <Vulpyne> [S+Z] Signoff: shapr ("be back tomorra")
13:06:26 <Vulpyne> Err.
13:06:40 <Vulpyne> makePassword2 0 = return []
13:06:40 <Vulpyne> makePassword2 (n+1) = do
13:06:44 <Vulpyne> And then calling itself...
13:06:51 <Vulpyne> I assume that eventually n somehow becomes 0.
13:09:13 <hdaume> presumably it's calling itself with 'n', not with 'n+1', in which case 'n' decreases at each call
13:09:23 * hdaume hasn't actually looked at the code though
13:09:31 <Vulpyne> Hmm.
13:09:35 <Vulpyne> That does make sense.
13:09:45 <andersca> what lexer should I use with parsec? alex?
13:09:50 <Vulpyne> Thanks.
13:10:01 <Vulpyne> Is that a common idiom in haskell?
13:10:05 <hdaume> it's the same as something like: "f 0 = 0; f (n+1) = (n+1) + f n"
13:10:23 <hdaume> though many people frown on the so-called "n+k patterns"
13:10:26 <ayrnieu`> Vulpyne - yes, this is an example of an "n+k" pattern
13:10:30 <hdaume> i think most people would rather write that:
13:10:34 <Heffalump> otherwise known as f n | n>0 = (n * (n+1)) `div` 2
13:10:36 <hdaume> "f 0 = 0; f n = n + f (n-1"
13:10:49 <ayrnieu`> Vulpyne - note that you don't need to put the case that matches 0 before the (n+1) case, because the (n+1) case breaks on zero.
13:10:55 <ayrnieu`> err, doesn't match zero.
13:10:58 <Vulpyne> "f 0 = 0; f n = n + f (n-1)", right?
13:11:04 <hdaume> right
13:11:18 <Vulpyne> I understand now... Thanks.
13:11:29 <Heffalump> s/>/>=/
13:11:32 <Vulpyne> So it's just shorthand to avoid having to subtract from the number each time.
13:11:41 <Vulpyne> Why don't people like n+k patterns?
13:11:55 <ayrnieu`> I don't usually use them (though I imagine that your example comes from my use of them); I'd read some mathematical text that defined functions in that way.
13:11:55 <hdaume> for one, they don't really fit in with the rest of the language
13:12:18 <hdaume> secondly, since (+) is user-definable, it's not always clear what is meant
13:12:32 <Heffalump> also, patterns are designed for inductive datatypes, and Int isn't one of those
13:12:34 <hdaume> for instance, if (+) and (-) aren't inverses
13:12:37 <hdaume> right
13:12:41 <ayrnieu`> Vulpyne - (n+k) patterns are a special-case
13:12:50 <Vulpyne> I see.
13:12:58 <Heffalump> s/Int isn't/most instances of Num aren't/
13:13:02 <hdaume> there's a web page devoted that this somewhere
13:13:25 <Vulpyne> makePassword2 0 = return []
13:13:25 <Vulpyne> makePassword2 n = do x <- randomRIO (0,35); l <- makePassword2 (n - 1); return $ ("0123456789abcdefghijklmnopqrstuvwxyz" !! x) : l
13:13:30 <Vulpyne> That would be the more usual way to do it?
13:13:38 <ayrnieu`> Yes, the "Haskell Humor" link off of www.haskell.org (have you seen the "Evolution of a Programmer" link, there?  I love it) links to a "ban n+k patterns" thread.
13:13:46 <ayrnieu`> Vulpyne - yes, that is more idiomatic.
13:14:06 <hdaume> ayrnieu`: yeah, i love that
13:14:23 <Vulpyne> Great, thanks.
13:14:51 <Vulpyne> Is: blah $ n - 1 weird?
13:15:06 <ayrnieu`> Vulpyne - probably you can devise a higher-order-function to hide the looping which is the sole purpose of that variable.
13:15:21 <Vulpyne> Higher-order function?
13:15:29 <ayrnieu`> Vulpyne - I don't think so.  It's equivalent to: blah (n - 1)
13:15:43 * Vulpyne nods.
13:15:45 <ayrnieu`> Vulpyne - or "function", if you prefer =)  Like map, foldl, mapM
13:15:59 <ayrnieu`> f $ x = f x -- where $ is a low-precedence operator
13:16:49 <ayrnieu`> 'blah n - 1' is '(blah n) - 1' since 'blah' takes one argument and function-application has more precedence than any operator.
13:18:30 * Vulpyne nods.
13:18:39 <Vulpyne> I proved to myself that it would work. :)
13:18:44 <Vulpyne> Just didn't know if it normal to do that or not.
13:18:54 <Vulpyne> I'd rather type a $ than some parenthesis.
13:19:12 <ayrnieu`> another common function-application operator is #
13:19:15 <ayrnieu`> x # f = f x
13:19:27 <ayrnieu`> Used in HaskellScript, for instance, to achieve OO-like syntax.
13:20:16 <Vulpyne> Funky.
13:20:37 <Vulpyne> I bet it would be fun to write obfuscated code in Haskell.
13:20:45 <ayrnieu`> 'a' # isLower
13:21:31 <Vulpyne> Like: #define rev(_x, _y) _y ## _x :)
13:21:51 <ayrnieu`> Vulpyne - have you read http://www.willamette.edu/~fruehr/haskell/evolution.html , yet?
13:22:52 <ayrnieu`> "combinatory haskell programmer" fairly approximates obfuscated Haskell.
13:23:44 <Heffalump> most programs written in continuation passing style do
13:25:38 <Vulpyne> Nope, I haven't read it yet, but I guess I'll have to. :)
13:26:12 <ayrnieu`> =)
13:30:11 <Vulpyne> Anyone written an IRC client in Haskell yet?
13:43:39 * stepcut uses erc
13:43:57 <stepcut> i have not seen a haskell IRC client yet
13:44:12 <Vulpyne> Maybe I'll have to write one.
13:54:01 <Heffalump> yes please
14:00:09 <Vulpyne> Don't hold your breath, though. :)
14:00:32 <Heffalump> :-)
14:00:35 <Heffalump> it's been mentioned on here before
14:00:52 <Heffalump> I think a more sensible goal would possibly be Haskell scripting for something like irssi (which already had perl scripting)
14:27:56 <Vulpyne> Hmm, I thought irssi was a C frontend to a Perl IRC client?
14:28:02 <Vulpyne> Am I thinkingf of something different?
14:28:12 <Heffalump> the core is all C, it has perl scripting
14:28:16 <Heffalump> (unless I'm really confused)
14:28:25 <Vulpyne> Ah... Where's the fun in that?
14:28:29 <Vulpyne> I'd rather write it all in Haskell.
14:28:47 <dark> Shouldn't be hard, if you have a proper Curses module :-)
14:28:48 <Vulpyne> Probably not something that other people would use, but server connections, protocol processing.
14:28:53 <Heffalump> dark: lol
14:29:09 <dark> The IRC client protocol is really simple.
14:29:16 <dark> You'll have to add features just to make it interesting :-)
14:29:17 <Heffalump> well, RFC 1459 or whatever is
14:29:28 <Vulpyne> dark: Keep in mind that I don't really know Haskell yet.
14:29:35 <Vulpyne> So writing anything in will be enough of a challenge for me. :)
14:29:37 <dark> Something 1459oid anyway.  I hear that following it exactly will get you nowhere.
14:29:45 <Vulpyne> I've written IRC clients and bots in C and Python.
14:30:30 <dark> What would Haskell scripting do, though?
14:30:39 <Heffalump> customisability
14:31:05 <dark> I guess I'm the wrong audience, I always find customization to be too much work :)
14:31:38 <dark> Setting my shell prompt is about the extent of it.
14:32:02 <Vulpyne> I hear you, dark.
14:32:18 <Vulpyne> I went through a period where I did a lot of IRC scripting and stuff.
14:32:26 <Vulpyne> But then I reached a point where I just didn't really care.
15:46:37 <dark> I achieved a new increment of geekhood today.
15:46:53 <dark> I started some pings so that the light from the network card would help me see better when plugging the audio cable.
16:01:00 <liiwi> dark: I did the same few weeks ago. Welcome to the ... um, family.
16:01:48 <liiwi> hmm, I really despice this dependency to light.
16:11:34 <stepcut> i just keep a flashlight behind my computer
16:18:23 <Igloo> Woohoo!
16:18:37 <Igloo> http://urchin.earth.li/~ian/Fraskell.txt (25% speedup with cunning THness)
16:32:00 <hdaume> what's the code being compared doing?
16:32:50 <Igloo> It's what I talk about in the future tense on http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/Mandelbrot/
16:32:57 <Igloo> (complete with pretty picture!)
16:40:44 <hdaume> cool
17:51:20 <Vulpyne> Is "or" lazy?
17:51:37 <Igloo> It is not strict in its second argument
17:51:40 <ChilliX> or?  You mean || ?
17:51:50 <Vulpyne> Hmm, yes.
17:51:54 <Igloo> Oh, I meant ||
17:51:54 <Vulpyne> Though, actually, nevermind.
17:51:57 <Vulpyne> Can't do what I wanted.
17:52:44 <Vulpyne> This is pretty sad. Can't even get if/then/else working. :)
17:52:56 <Igloo> Chilli: Is library names in square brackets an obsolete bit of FFI syntax?
17:53:10 <Igloo> C impent syntax in particular
17:54:00 <ChilliX> yes
17:54:11 <Igloo> Cool, ta
17:54:17 <ChilliX> it's been removed one or two RC ago
18:08:34 <Vulpyne> Hmm, is it normal for a 20 line program to compile to a 400 binary?
18:08:41 <Vulpyne> Er, 400k.
18:10:27 <Igloo> That sounds feasible - strip will probably help a bit
18:11:18 <Vulpyne> That's after strip.
18:11:50 <Igloo> Oh. That's a little higher than I'd remembered, but quite believable
18:12:02 <Vulpyne> I added a little bit more and the size went up a lot.
18:12:12 <Vulpyne> If I write a 40 line program, is the binary going to be 800k? :)
18:12:46 <Igloo> Oh, it should just be a large constant and fairly sane gradient - did the extra bit require importang a load more library stuff?
18:12:57 <Vulpyne> Yeah, it may have.
18:13:15 <Vulpyne> Well, I can deal with a large constant and a sane gradient.
19:24:54 <dark> Vulpyne: For what it's worth, I'm just over 5000 lines now, and the stripped binary is about 1.1 MB
19:25:25 <dark> ghc itself is almost 9 MB :)
