01:58:18 <bas> hello, i need to do a lot of 'date' calculations, like computing which day 5 december 2343 is...!? anyone have a clue where i can find such package/hs file!?
02:21:56 <dark> Is it okay to zap the last three topic entries?  We know that ICFP is over; the joke's getting old; and Ganesh doesn't have a URL anyway.
02:23:25 <Marvin--> I tried changing the topic to point to hws-wp, but chanserv zapped it, and I don't know how to make it cooperate :P
02:23:44 <dark> I think ChanServ has been misbehaving in general these last few days.
02:24:06 <dark> But some of its restarts were announced as bugfixes, so maybe it got fixed :)
02:25:29 <Marvin--> okay
02:51:30 * Heffalump thought his item should go away a while ago too :-)
02:51:35 <gdsx> hrm... I'm going through the gentle intro, and I'm trying some of the stuff that it says in hugs (with unused variable names) and it's not working... what's up?
02:51:38 <gdsx> for example...
02:51:47 <gdsx> Prelude> h :: [a] -> a
02:51:48 <gdsx> ERROR - Undefined variable "h"
02:52:06 <dark> Heffalump: Which one is yours?
02:52:06 <Heffalump> you have to define stuff in a file, you can't define it in the interactive system
02:52:14 <gdsx> aah
02:52:18 <Heffalump> dark: I'm Ganesh
02:52:40 <dark> Heffalump: Ah, that's confusing :)
02:52:53 <Heffalump> sorry :-) should have said Heffalump's ...
03:04:50 <dark> Hmm.  I'd heard of DAV before, but I didn't know it was the unholy offspring of HTTP and XML.
03:06:43 <dark> I'm tempted to parse autoindex output instead :)
03:46:45 * Igloo gets "Interesting!  I didn't expect to see qIO used quite so fast!" from SPJ  :-)
03:48:15 <Heffalump> heh
03:48:52 <ibid> qIO?
03:49:13 <Igloo> Used to do IO from Template Haskell code
03:49:35 <ibid> hm
04:05:11 <Heffalump> igloo's code uses it to write out a .h and .c file, then compile it with GHC
04:05:15 <Heffalump> all at compile-time
04:05:18 <Igloo> GCC
04:05:25 <Heffalump> yes, that :-)
04:10:38 <bas> how can i determine in hugs what the current date is?
04:12:00 <bas> and maybe put it in a nice datastructure...
04:12:06 <bas> anyone here?
04:12:22 <Igloo> I think that might be something the current hugs release doesn't support, but I think that about-to-be-released one has near total H'98 support
04:12:57 * Igloo can't remember what module provides it i H'98 OTTOMH but nothing in /usr/share/hugs98/lib/ looks right to me
04:13:15 <bas> hmm, that's to bad...
04:13:28 <Igloo> Oh, but another machine has a Time.hs there
04:13:35 <bas> isn't it possible to do it somehow io wise?
04:13:57 <Heffalump> looks like getClockTime is what you want
04:14:07 <Heffalump> (import Time first)
04:14:53 <bas> ok, i will try that.. where are the .hs modules installed by default? so i can look there for myself whenever i want something the next time...?
04:17:03 <bas> neverming that question...
04:17:13 <bas> s/g/d/
04:17:48 <bas> i tried a getClockTime in the hugs console, but it doesn't seem to return anything... howcome?
04:21:41 <bas> getClockTime seems to refer to getClockTimePrim which isn't implemented yet or so i think...
04:25:04 <Igloo> Time> do c <- getClockTime; print c
04:25:05 <Igloo> Tue Nov  5 12:24:06 GMT 2002
04:25:24 <Igloo> You'll need to read up o IO in Haskell if that doesn't make sense to you
04:26:29 <dark> Does anyone have a HTTP client module?
04:26:58 <dark> I'm about to make one but something tells me I wouldn't be the first :-)
04:28:06 * Igloo hasn't got down to networky stuff on my TODO list yet  :-/
04:28:57 <dark> Well I'll be publishing my stuff soon.
04:29:28 <dark> As soon as I have HTTP access, in fact :)  (It would be embarrassing to publish a version control tool in a way it can't access itself)
04:51:23 <bas> ok io it is, why doesn't this work? thisTime = year
04:51:24 <bas>   where
04:51:26 <bas>   io = do c <- getClockTime; CalendarTime yr _ _ _ _ _ _ _ _ _ _ = ToUTCTime c ?
04:52:12 <bas> i get syntax error in input ('=') kind of errors... ;-(
04:55:16 <Heffalump> you need a let before CalendarTime
04:56:36 <dark> Unless you intend the CalendarTime pattern to be part of the "where" list.  Currently it's part of the "do" block.
04:56:47 <dark> Or, wait.
04:57:01 <Heffalump> it can't be, it uses c
04:57:19 <Heffalump> but actually that can't work anyway
04:57:49 <Heffalump> are you trying to write a thisTime of type Int?
04:58:32 <Segora> thisYear = do { c <- getClockTime; let CalendarTime yr _ _ _ _ _ _ _ _ _ _ = ToUTCTime c; return yr }
04:58:56 <Segora> if i'm not mistaken
04:59:12 <Segora> thisYear :: IO Int
04:59:23 <bas> okay...
04:59:35 <Heffalump> yes, that's what you want
04:59:50 <Heffalump> if you need a value from the IO monad you have to do your entire computation under that monad
05:01:26 <bas> when i enter the 'thisYear =' line in my hugs i get a  Syntax error in declaration (unexpected `;', possibly due to bad layout) error... i am not really sure how this do systax works, don't have good references about it ;--(
05:01:50 <Segora> bas: look at the haskell report on www.haskell.org
05:03:07 <Segora> specifically http://www.haskell.org/onlinereport/lexemes.html section 2.7
05:07:18 <Segora> ah. types are different...
05:07:57 <Segora> thisYear = do { c <- getClockTime ; return $ ctYear $ toUTCTime c }
05:13:43 <Segora> to get some output in hugs:
05:13:47 <Segora> do { yr <- do { c <- getClockTime ; return $ ctYear $ toUTCTime c }; putStrLn $ show yr }
05:24:49 <dark> import qualified Network.URI as URI
05:24:49 <dark> import Network.URI(URI)
05:24:55 <dark> I hate it when modules make me do that.
05:31:07 <ibid> hmph
05:31:29 <ibid> ghc --make complains it cannot find module UnicodeData even though there are such .hi and .o files
05:32:38 <ibid> (and there is a .hcr for it)
05:39:19 <ibid> bah
05:39:25 <ibid> seems i need to make it a package
05:39:26 <ibid> blah
10:23:40 * dark discovers libcurl.
13:07:48 * |Fo|Ns is away: cenando
13:47:57 * |Fo|Ns is back (gone 00:40:08)
14:11:17 <dark> Yikes.  I wanted to use the curl library, but it's full of variadic functions.
14:11:42 <Heffalump> time for some dependent types :-)
14:35:34 <dark> Hmm... it might be cool to be able to generate a Haskell interface module from the debugging symbols in a C library.  There should be enough information for it.  Except of course with variadic functions.
14:36:54 <Igloo> Would that be easier than doing it from the source?
14:43:02 <dark> Probably easier, but less portable :)  The debugging symbols are in a regular format, much easier to parse than cpp and C.
14:43:58 <dark> Unfortunately there's several formats for them, and not all of them are useful.
14:44:33 <dark> Of course, I've already mentioned my opinion about supporting non-free systems :-)
14:45:00 <hdaume> hi all
14:45:18 <dark> Hello
14:45:41 <dark> I see that GHC's libraries use _ccall_ all over the place, but it's not documented in the users guide, not even as an extension.
14:46:15 <dark> And ``FOO'' to access C constants.
14:47:32 <Igloo> I think that's the old FFI syntax
14:49:55 * Igloo has vague plans to go through the deprecated syntax warnings fixing them, but if the old style isn't documented anywhere that will be harder
14:50:20 <Heffalump> in GHC?
14:52:16 <dark> Hmm.  I hoped it was the _new_ syntax, it looks a lot more convenient than fiddling with hsc2hs :)
14:53:31 <dark> I might have to make a wrapper function for each of curl's 102 options.
14:53:53 <Heffalump> you could imitate Igloo's TH hackery
14:55:09 <Igloo> Hmmm, I'm not familiar with the old style; perhaps some functionality was lost
14:55:12 <dark> Or I can decide I'd rather write all this in Haskell anyway :-)
14:55:59 <Igloo> Which is always the correct solution, in the long term at least  :-)
14:56:46 <dark> Question is, do I want a full-blown HTTP lib that I use from my program, or a minimal one that just does what I need?
14:56:55 <Heffalump> the former, then we can all use it too :-)
14:56:56 <dark> In Haskell, that is.  With curl it's going to be full-blown in any case :)
14:56:59 <dark> He.
14:57:16 <dark> I mean heh.  Will you be able to live with my identifier_names though?
14:58:33 <Igloo> I always get torn between the two styles. I naturally use foo_bar but fooBar fits better in 80 chars  :-)
14:59:05 <Pseudonym> We really need a formal Haskell coding standard.
14:59:18 <Heffalump> why?
14:59:51 <Pseudonym> Because the standard libraries alone are horribly inconsistent.
14:59:55 <dark> Hmm with Haskell I rarely hit the 80 char limit, it's so easy to rearrange lines.
15:00:04 <Heffalump> interface standards would be good
15:00:07 <Pseudonym> Of course it need not be mandatory.
15:00:26 <dark> Currently it's almost convenient, the way I can visually distinguish libraryCalls from my own_functions.
15:00:31 <Pseudonym> However, for candidates for standardisation, at least, we need one.
15:00:38 <Igloo> putChar vs hPutChar always annoys me
15:01:05 <Pseudonym> dark: Exactly.  In C++, standard libraries use underscored_spaces, so many coding standards mandate camelCase.
15:01:12 <Pseudonym> Or StudlyCaps for class names.
15:01:17 <dark> The GHC modules that seem most non-standard to me are FiniteMap and Set.
15:01:23 <Pseudonym> Yes.
15:01:33 * Pseudonym doesn't like the postfix namespaces in FiniteMap
15:01:45 <Heffalump> needs a typeclass really
15:01:59 <Heffalump> but module scoping should be just about enough
15:02:03 <dark> I think it's not even the names that bother me in FiniteMap, but the functions all seem to have their arguments in the wrong order :)
15:02:13 <Pseudonym> FM.insert is no less clear than addToFM.
15:02:46 <Pseudonym> Typeclasses aren't a bad idea either.  FiniteMap should probably be Edison-ised.
15:03:14 <dark> Hmm, my problem with using qualified imports that way is that I usually end up importing the module twice: once qualified for the functions, and unqualified to import just the types.
15:03:19 <Igloo> ISTR lookupFM is right but lookup is wrong
15:03:30 <Pseudonym> dark: Chris Okasaki spent a lot of time working out argument orders in Edison.  IMO, it's the most sane part of the Edison interface.
15:04:16 <Pseudonym> The least sane part, of course is tail [] == []
15:05:13 <dark> Oh, I don't know.  Unexpected empty list seems better than unexpected bottom.
15:05:32 <Pseudonym> I prefer catchable bottom.
15:05:50 <Pseudonym> rtail :: (Seq s, Monad rm) => s a -> rm (s a)
15:05:54 <dark> hmm, true, but does Haskell98 even guarantee that that can be caught?
15:06:10 <Pseudonym> Sure it does, if you choose the right return monad.
15:06:25 <Pseudonym> case (rtail xs) of { Just xs -> xs ; Nothing -> whatever }
15:06:45 <Pseudonym> Or you runIdentity (rtail xs) if you want it to call error.
15:06:57 <dark> I would go insane with even more Maybes around :)
15:07:13 <Pseudonym> More libraries should use return monads, IMO.
15:07:23 <dark> I feel guilty every time I use fromJust.
15:08:00 <Igloo> I don't suppose anyone happens to have a recent CVS hugs?
15:08:17 <Pseudonym> I do.
15:08:31 <Pseudonym> Doesn't work well, but it works.
15:08:57 <Pseudonym> (Entirely due to my misunderstanding of the hugs build process.)
15:12:44 <Igloo> Can you check whether 'foreign import ccall unsafe "errno.h & errno" errno :: Ptr CInt' works both with and without the space after the & please?
15:13:03 <Igloo> (you'll probably need to import Foreign and CForeign)
15:16:12 <Pseudonym> Er... doesn't work on my build for reasons completely unrelated to FFI syntax.
15:16:29 <Pseudonym> Told you it doesn't work properly. :-)
15:16:51 <Igloo> Heh
15:17:01 <Igloo> What's wrong with it OOI?
15:17:14 <Pseudonym> ERROR "/usr/local/lib/hugs/lib/exts/HugsStorable.hs" - Error while importing DLL "/usr/local/lib/hugs/lib/exts/HugsStorable.so":
15:17:30 <Pseudonym> Problem is I haven't gotten the hierarchical libraries build properly.
15:17:36 <Igloo> Ah
15:17:41 <Pseudonym> Doesn't work under my version of nhc98 either.
15:18:03 <Pseudonym> But I think this version only supports C functions.
15:18:28 <Pseudonym> Sorry about that.  Not very helpful.
15:19:06 <Igloo> np, I'll just say I haven't tested it
15:19:59 <Chilli> nch doesn't fully support the new FFI yet
15:20:03 <Chilli> nch = nhc
15:20:15 <Pseudonym> Right.
15:20:39 <Heffalump> how close is the FFI spec to being released, btw?
15:21:53 <Chilli> Heffalump: the only problem was the finaliser issue
15:21:57 <dark> That reminds me, will that usage of errno work correctly with the new glibc?  There's no longer an "errno" symbol, and errno is a macro.
15:22:04 * Igloo starts writing a lexical syntax and then realises that "static" is sometimes a keyword and sometimes not and this won't be particularly pretty
15:22:06 <Chilli> that seems to be setteled now, but I still have to summarise the result
15:22:19 <Chilli> otherwise it is finished, as far as I am concerned
15:22:30 <Chilli> dark: no
15:22:33 * Igloo points Chilli at ffi@haskell.org and jumps up and down
15:22:34 <Chilli> won't work
15:22:56 <Chilli> Ig: heh?
15:23:13 <Igloo> Thread "White space in ccall impents"
15:23:29 <Chilli> hmm, haven't read email in two days
15:23:32 <Chilli> to be honest
15:23:38 <Chilli> too much stuff going on
15:23:40 * Heffalump wonders if Igloo is hoping the jumping up and down will reverberate through the core of the earth
15:24:06 <dark> I thought reverbrations reflected off the mantle.
15:24:31 <Igloo> It's a very tiny thread
15:25:50 <Pseudonym> dark: Some is reflected, some is transmitted.
15:26:12 <Pseudonym> Just like what happens when any wave hits an interface between two regions of differing refractive index.
15:27:20 * Igloo disappears for a bit
15:27:58 <dark> Aha, and then again between the mantle and the core, I guess.
15:28:12 <Pseudonym> Yes.
15:28:28 <Pseudonym> And again when you hit the other side of the core (and the mantle when you hit it again).
15:28:57 <Pseudonym> It's a little more complicated than that because both the mantle and the core disperse shock waves slightly.
15:28:59 <dark> So the Igloo-jumping-up-and-down-detector is going to have to be pretty sensitive.
15:29:15 <Pseudonym> And they're moving already, too.
15:29:22 <Pseudonym> Yes, it is.
15:30:20 <Pseudonym> OK, exercise: Write a Haskell program to invert the echo signature caused by Igloo jumping up and down.  You can deal with the case of one jump only if you like.
15:31:11 <Pseudonym> And the corollary: Work out how much Igloo weighs, given the velocity of impact from when he landed.
15:32:51 <dark> I think that would need more than one detector, because the waves interfere.
15:32:59 <Pseudonym> Hmmm...
15:33:14 <dark> Well, unless you know the exact shape of the earth.
15:33:18 <Pseudonym> Right.
15:33:32 <Pseudonym> If you know the shape of the earth (and the structure of the mantle and core), you could do it.
15:33:51 <Pseudonym> I don't know if the interference is usually constructive or destructive.
15:34:11 <dark> Unless you happen to be at an interference minimum :)  You'd get a reading of zero.
15:34:20 <Pseudonym> True.  That'd be a problem.
15:34:36 <Pseudonym> I wonder where you'd have to be relative to Igloo for that to happen.
15:37:38 <Heffalump> it might be easier to take some bathroom scales into work if you want to know his weight :-)
15:39:21 <Igloo> If you are Heffalump, yes. Perhaps not if you are Pseudonym or dark
15:39:32 <dark> Pah.  We're not using Haskell because it's _easier_.
15:39:36 <dark> Oh wait, we are :-)
15:39:43 <Pseudonym> If I took bathroom scales to my work, how would I weigh Igloo?
15:39:49 <Heffalump> sorry, s/to/for me &/
15:40:43 <Pseudonym> OK, exercise: Write code for remote telescopy of bathroom scales in Haskell.
15:40:45 <Igloo> dark  :-)
15:46:18 <dark> Hmm, the System.Random trick for making a global variable, is that portable?
15:46:32 <dark> I'm trying to think of a way to make a connection cache in a HTTP module :)
15:47:32 <Pseudonym> How does it work?
15:48:31 <Igloo> Are IORefs Haskell'98?
15:48:42 <Pseudonym> Oh, I see.
15:48:53 <Pseudonym> I've used it elsewhere and it worked for me.
15:48:58 <dark> It has a top-level definition theStdGen, which takes no arguments uses unsafe IO to create an IORef.  Then there's other definitions getStdGen and setStdGen which wrap it, so that theStdGen is not directly visible.
15:49:30 <dark> I don't know about Haskell 98, I would mainly like to know if this construct is fragile :)
15:49:51 <dark> I don't think Haskell really guarantees that it's going to be the same IORef each time.
15:50:02 <Pseudonym> http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/hfl/hfl/ioext/IOGlobal.hs?rev=1.4&content-type=text/vnd.viewcvs-markup
15:50:39 <Pseudonym> I'm pretty sure that if you {-# NOTINLINE #-} it, it is a guaranteed CAF.
15:51:23 <dark> Interesting.
15:51:25 <Igloo> s/\./ in GHC./ (at least I'm fairly sure Haskell 98 gives no meaning to pragmas at all)
15:51:45 <dark> So, will anyone mind if I make a HTTP module that's GHC-specific? :)
15:51:59 <Pseudonym> Igloo: I thought NOTINLINE was H98?
15:52:08 <Heffalump> can't you pass the connection cache back to client code?
15:52:41 <Pseudonym> http://haskell.org/onlinereport/pragmas.html
15:52:50 <Igloo> Oh, I stand corrected
15:53:12 <Igloo> Oh, no, "An implementation is not required to respect any pragma"
15:53:15 <Pseudonym> Ah, I see.
15:53:18 <dark> Heffalump: Only if I make the client keep track of it.  For best results the connection cache should be shared between all request handles.
15:53:18 <Pseudonym> You're right.
15:53:37 <Pseudonym> Personally, I think that notInline should be respected.
15:53:40 <Pseudonym> inline may not be
15:53:58 <Pseudonym> In particular, an implementation which does no inlining (e.g. Hugs) will obviously not respect it.
15:54:08 <Heffalump> anyway, unsafePerformIO isn't H98
15:54:13 <Pseudonym> True.
15:54:27 <Igloo> Oh, interesting, I always assumed it was
15:54:43 <Heffalump> it'll have to be in the FFI appendix, though
15:54:46 <Pseudonym> unsafePerformIO breaks so many rules.
15:56:50 <dark> I guess I could provide an HTTPContext that also keeps track of cookies and such, and make the connection cache part of that.
15:56:56 <Igloo> So does seq  :-)
15:57:58 <dark> Hmm, can't (seq x y) be defined as: bottom if x is bottom, else y
15:58:43 <Pseudonym> dark: The problem is that it breaks other axioms.
15:58:54 <Pseudonym> Such as monad axioms.
15:59:06 <dark> The requirement to actually evaluate x is about as meaningful as the C standard's ranting about bits and bytes :)  Though, does Haskell have an "as if" rule?
15:59:44 <Igloo> "as if"?
16:00:17 <dark> Igloo: The C standard explicitly says that an implementation can do what it wants as long as no conforming C program can detect the difference.
16:00:38 <dark> This gives considerable freedom for optimizers, and it allows implementation on e.g. non-2s-complement machines.
16:00:49 <Pseudonym> Which made sense once.
16:01:37 <dark> I think that since then, it's been adopted as such a generally good idea that many languages use the rule implicitly.  Except for Java.
16:02:12 <Pseudonym> Haskell 98 doesn't have or need an "as if" rule.
16:02:27 <Pseudonym> With a few exceptions.
16:04:22 <Pseudonym> I believe that H98 uses the same div/mod rule as C, for example.
16:04:59 <Igloo> I think the report says somewhere that the prelude functions must behave identically, including WRT laziness, but can be implemented differently
16:05:12 <Igloo> I don't know if it explicitly says something similar about the core language too
16:05:54 <Pseudonym> Actually, now that I think of it, I'm not sure that full laziness is a language requirement.
16:06:28 <hdaume> i'm sure it's not
16:06:45 <hdaume> if it were a requirement, no one would do strictness analysis
16:07:40 <Pseudonym> Full laziness involves two properties.
16:08:09 <Pseudonym> One is that an expression is evaluated at most once, the other is that an expression is evaluated only if needed (without saying _when_).
16:08:20 <Pseudonym> Only if needed is not the same as only _when_ needed.
16:08:40 <Pseudonym> I believe it's the former requirement which is not in H98.
16:08:53 <Pseudonym> In particular, I think you can re-evaluated internal MFEs.
16:09:40 <Igloo> Oh, I think I mean strictness
16:09:49 <hdaume> ah okay
16:10:03 <Pseudonym> Don't quote me on this, though.
16:10:11 <Pseudonym> It's from a half-remembered section in the STG paper.
16:13:11 <hdaume> :)
16:28:35 <dark> Hmpf, GHC's libraries have a bad habit of saying String when they mean a sequence of bytes.  I'm not sure if I should follow that "convention" with HTTP, or return message bodies as [Word8] or something.
16:29:12 <dark> Either that or I could actually do character set conversion inside the HTTP module.
16:29:39 <Heffalump> that would be ideal
16:31:45 <dark> Not all entities have a character set, though :)  It wouldn't make much sense for image/jpeg.  Hmm, that would be fixed with a separate constructor for text data. 
16:31:53 <dark> Is there a Haskell lib for MIME types already?
16:38:10 <dark> Ooh, http://homepages.paradise.net.nz/warrickg/haskell/http/
17:02:03 <dark> Hmm, this smells of Other People's Code, so it is obviously inferior :-)
17:02:19 <Heffalump> :-)
17:06:17 <Pseudonym> My solution to an OPC problem is to fork the code until it's unrecognisable as other people's.
17:06:49 <Pseudonym> It also makes me feel superior by virtue of the fact that I can spot all the flaws.
17:07:03 <Pseudonym> Where "flaw" is defined as "not the way I'd do it".
17:07:19 <dark> That sounds like a good approach.
17:08:02 <dark> Obviously whoever wrote this OPC had all the wrong priorities :-)
17:08:07 <hdaume> *grin*
17:08:21 <dark> For example, it's mysteriously inadequate at solving *my* problem.
17:08:34 <dark> You'd think the author would have used better foresight.
17:22:37 <clausen> some pieces of code are really nice though
17:22:43 <clausen> like, they do actually solve your problem
17:22:50 <clausen> or, if they don't, they don't solve it in an elegant way :)
17:23:57 <Pseudonym> That's no use if they're not optimised for your problem.
17:25:19 <dark> Well, I like most of the modules that come with GHC (except that Network.URI annoys me).  FiniteMap is always handy even though it seems a bit crufty.
17:26:04 <dark> I guess those modules don't seem so much like OPC because I don't have to bundle them with my own code :)
17:26:45 <Pseudonym> Oh, if they come with the implementation they're not OPC.
17:26:53 <Pseudonym> They're just poorly designed in that case.
17:36:01 <jadrian> hello
17:36:26 <Pseudonym> G'day.,
17:36:31 <jadrian> hi Pseudonym
17:41:43 <jadrian> funny, the room now has much more people than sometime ago, but it's even more silent than it used to be :)
17:42:05 <dark> Well it's late :)
17:42:17 <dark> Strange to see it called a "room" though.
17:42:17 <jadrian> dark: depends on where you are ;)
17:42:25 <jadrian> channell?
17:42:29 <jadrian> channel
17:42:32 <dark> Yep.
17:42:35 <jadrian> ah
17:42:37 <Pseudonym> Indeed.  It's not late here, but nobody else wants to talk.
17:42:42 <jadrian> dumb literall translation
17:42:46 <Pseudonym> Unless it's about how much Igloo weighs, of course.
17:43:02 <jadrian> well here and it's quite late.
17:43:18 <jadrian> and it's even more late for dark ;)
17:43:24 <Igloo> I'll talk - just start a conversation about template Haskell or how inflate works  :-)
17:43:40 <Pseudonym> Perfect timing.
17:44:06 <jadrian> Igloo: template haskell... I've heard Simon talk about it, but haven't seen anything about it yet
17:44:33 <Igloo> jadrian: I've been having fun doing evil things with it  :-)
17:44:51 <jadrian> Igloo: so how does it compares to generic programming?
17:44:58 <Igloo> (Haskell code that, when compiled, writes C interface stuff and invokes GCC)
17:45:00 <jadrian> generic haskell and the like
17:45:07 <Igloo> Never used generic Haskell
17:45:15 <Igloo> I probably should look at it, actually
17:45:33 <jadrian> is there a url for template haskell?
17:45:43 <Igloo> For what, exactly?
17:45:49 <jadrian> info 
17:46:01 <Igloo> Simon Peyton-Jones and Tim Sheard have written a paper on it
17:46:36 <jadrian> ok I'll look for it then
17:46:53 <Igloo> Hmmm, can't see it on his webpage now
17:47:12 <Igloo> Ah, http://research.microsoft.com/Users/simonpj/papers/meta-haskell/
17:47:20 <Igloo> Not on his papers page for some reason
17:47:26 <jadrian> I got it
17:47:39 <jadrian> oh you got it too :)
17:48:00 <Igloo> :-)
17:48:05 <jadrian> you said you were working with it, is there support in ghc already?
17:48:51 <Igloo> Yes, but not complete and sometimes things change
17:49:05 <jadrian> I see
17:52:30 <jadrian> hmm seems nice, got to try it out later
17:53:54 <jadrian> hmmm hdaume? Hal Daume III?
17:56:02 <jadrian> (in case you are, I just answered your mail...)
17:56:17 <Heffalump> he is, yes
17:56:31 <jadrian> Hey Heffalump
17:56:41 <Heffalump> hiya
17:56:50 * Heffalump is just off to bed, having figured out what his bug is but not how to fix it
17:56:59 <jadrian> I thought so, it would be quite a coincidence :)
17:57:05 <jadrian> lol :)
18:01:02 <jadrian> Igloo: is there anything like template haskell, but to create algorithmic construction of programs in *run time* (the answer is most probably no, but I thought I'd ask anyway...)
18:01:58 <jadrian> Igloo: I was thinking about how nice that would be for evolutive programming kind of stuff
18:02:21 <Igloo> No (well, I suspect you could cobble something together with the plugin stuff using GHCi's internals)
18:02:57 <Heffalump> well, you just need to redefine your notion of run-time to include what happens when you run GHC over your program
18:03:54 <jadrian> Heffalump: you mean, generate the code, compile it and run it, right?
18:04:17 <Heffalump> yeah
18:04:41 <Heffalump> I guess you need a bit more work to be able to go back to the compile stage after running some of it
18:04:42 <jadrian> Heffalump: I've thought about it, but that way you have to create the haskell actuall code
18:05:01 <jadrian> "actuall haskell code"
18:06:06 <jadrian> I know there is a "typing haskell in haskell" project, that could probably help...
18:07:32 * jadrian is getting way to sleepy, and he's still not sure about the best way to code is project
18:07:55 <jadrian> bbl
18:08:04 <jadrian> have fun
19:11:13 <graylensman> Template Haskell looks complex when compared to the elegance of hygenic scheme macros.  interesting non-the-less
19:12:29 <Pseudonym> Unfortunately, lisp macros aren't strongly typed, which is where a lot of TH's complexity comes from.
19:13:53 <Pseudonym> Without that, you'd have something like C++ templates, which aren't too bad except the error messages are awful.
21:07:05 * bronaugh is back, unfortunately :(
21:14:02 <bronaugh> ERROR "/home/bronaugh/csc330/proj_2/Skates/Skates.hs":127 - Recursive type synonym "Vertex"
21:16:56 <bronaugh> nm
21:20:20 <bronaugh> how do you define a constant?
21:20:29 <bronaugh> something that will just be replaced.
21:21:50 <clausen> huh?  everything in haskell is a constant :)
21:21:58 <clausen> someConstant = 35
21:42:58 <bronaugh> hmm.
21:42:59 <bronaugh> nother q
21:43:09 <bronaugh> any easy way to access the members of a tuple?
21:44:32 <clausen> fst, snd ?
21:44:39 <bronaugh> what about third?
21:44:42 <bronaugh> and fourth?
21:44:44 <clausen> sorry
21:44:49 <clausen> write your own function
21:44:49 <bronaugh> and eighth?
21:44:50 <clausen> eg:
21:44:59 <clausen> \(_, _, _, x) -> x
21:45:10 <bronaugh> ok.
21:45:49 <clausen> why do you have big tuples?
21:46:04 <clausen> (it's considered dirty!)
21:46:08 <bronaugh> I don't in this case; I was just curious.
21:46:22 <bronaugh> I have one with 4 elements in it.
21:46:26 <bronaugh> that's as big as it gets.
21:46:27 <clausen> aha
21:46:45 * clausen off
21:46:45 <clausen> cya
21:46:59 <Pseudonym> When you get his big, it's usually easuer to use records.
21:47:23 <dufflebunk> Everyone knows tuples are for two things!  ;)
21:47:31 <Pseudonym> Even for single-element tuples (usually newtypes) I use records often.
21:48:20 <bronaugh> ok, how would I define a record?
21:48:28 <Pseudonym> dufflebunk: What two things?
21:48:40 <dufflebunk> Pseudonym: (x, y)
21:49:00 <Pseudonym> bronaugh: newtype Foo = Foo { field1 :: Type1, field2 :: Type2 }
21:49:16 <Pseudonym> makeAFoo f1 f2 = Foo { field1 = f1, field2 = f2 }
21:49:21 <bronaugh> Pseudonym: ooh nice.
21:49:28 <Pseudonym> Then if you need to extract a member:
21:49:31 <Pseudonym> field1 foo
21:49:40 <bronaugh> interesting...
21:49:44 <Pseudonym> Also:
21:49:48 <Pseudonym> foo { field2 = f2 }
21:49:53 <Pseudonym> If you need to set only one element.
21:50:23 <bronaugh> why did you name the func makeAFoo?
21:50:27 <bronaugh> any particular reason?
21:50:58 <Pseudonym> Nope.
21:51:20 <bronaugh> hmmm..
21:51:29 <bronaugh> so what does newtype do?
21:51:33 <bronaugh> pardon my ignorance.
21:51:40 <bronaugh> and how does it differ from type?
21:52:26 <Pseudonym> Good question.
21:52:36 <Pseudonym> newtype is like type except it introduces a type constructor.
21:52:59 <bronaugh> and what's a type constructor in this case?
21:53:00 <Pseudonym> newtype Foo a = Foo (a -> Int)
21:53:08 <Pseudonym> newtype is like data
21:53:18 <Pseudonym> Except it allows only one constructor with one argument.
21:53:20 <bronaugh> argh.
21:53:36 <bronaugh> wish the frickin prof had gone _over_ this stuff, instead of leaving us with only half of what we need to work with...
21:53:42 <Pseudonym> Ah. :-)
21:53:53 <Pseudonym> For most situations, you can use data instead of newtype.
21:54:03 <Pseudonym> In fact, forget newtype.  Read it as "data".
21:54:07 <bronaugh> ok.
21:54:11 <bronaugh> what's the diff?
21:54:18 <Pseudonym> newtype is as efficient as type.
21:54:40 <bronaugh> and data is?
21:54:41 <Pseudonym> But like data, it allows recursion (see your type error mentioned earlier).
21:54:41 <bronaugh> slow?
21:55:05 <Pseudonym> If what you want is type, data is slow by comparison.
21:55:19 <Pseudonym> It's like using a struct instead of typedef in C.
21:55:31 <Pseudonym> It's unnecessary in most situations.
21:56:05 <bronaugh> newtype Vertex = Vertex {adj_list :: [CoordTuple], elev :: Int, dist :: Int, path :: CoordTuple)
21:56:34 <bronaugh> now, what would be insane/wrong there?
21:56:36 <bronaugh> and what's it missing?
21:56:52 <bronaugh> other than having a wrong term char.
21:56:52 <Pseudonym> Looks fine to me.
21:56:54 <Pseudonym> Oh.
21:56:58 <Pseudonym> Yes. :-)
21:57:01 <Pseudonym> Apart from that it's okay.
21:57:02 <bronaugh> now.
21:57:06 <bronaugh> should I have a type constructor or such?
21:57:14 <Pseudonym> You have one.  It's Vertex.
21:57:21 <bronaugh> ahh.
21:57:24 <bronaugh> I get it by default then.
21:57:28 <Pseudonym> Right.
21:57:36 <Pseudonym> That's why "Vertex" is repeated after the = sign.
21:57:40 <bronaugh> ahh!
21:57:42 <bronaugh> understood.
21:58:56 <Pseudonym> Can I ask what's the problem you're solving here?
21:58:59 <bronaugh> ERROR "/home/bronaugh/csc330/proj_2/Skates/Skates.hs":124 - A newtype constructor must have exactly one argument
21:59:06 <bronaugh> newtype Vertex = Vertex {adj_list :: [CoordTuple], elev :: Int, dist :: Int, path :: CoordTuple}
21:59:13 <bronaugh> Pseudonym: a rather annoying one.
21:59:45 <bronaugh> Pseudonym: basically, given a list of elevations, find the path through them which doesn't involve going up more than 10 units from point a to point b, and only use the paths provided to do it.
22:00:02 <bronaugh> Pseudonym: given a list of elevations, paths, and the size of the graph..
22:00:14 <bronaugh> Pseudonym: and a problem to solve.
22:00:27 <Pseudonym> OK, whatever.  I have to context to understand what you said and no time to try to understand. :-)
22:00:30 <bronaugh> Pseudonym: ie, find best possible route from (x1, y1) to (x2, y2)
22:00:41 <Pseudonym> Sorry, I have _no_ context is what I meant to say.
22:00:43 <bronaugh> shortest-path.
22:00:53 <Pseudonym> OK, shortest-path problem I can understand. :-)
22:00:57 <bronaugh> djikstra's algorithm.
22:00:58 <bronaugh> basically.
22:01:00 <Pseudonym> Right.
22:01:14 <bronaugh> of course, it doesn't exactly translate neatly into a functional language....
22:01:24 <Pseudonym> It depends on the graph representation.
22:01:30 <bronaugh> hmm.
22:01:35 <Pseudonym> If you use a functional graph representation, it maps quite nicely.
22:01:52 <bronaugh> functional graph representation...?
22:01:54 <bronaugh> hmm..
22:01:57 * bronaugh listens.
22:02:11 <Pseudonym> Are you sure you want your head to be filled with trivia right now?
22:02:36 <bronaugh> trivia tends to come in handy.
22:03:06 <Pseudonym> http://cs.oregonstate.edu/~erwig/fgl/haskell/
22:04:07 <bronaugh> hm.
22:04:09 <bronaugh> how crazy is the code?
22:04:27 <Pseudonym> Too crazy to bundle with an assignment solution, if that's what you meant.
22:04:33 <bronaugh> pretty much.
22:04:45 <bronaugh> I don't want to rip other people's code off here, if at all possible.
22:04:46 <Pseudonym> It'd help if it came standard with fptools/libraries.
22:05:15 <bronaugh> so anyhow.
22:05:21 <bronaugh> before this sidetracking, I was having an error.
22:05:25 <Pseudonym> Yes.
22:05:29 <bronaugh> ERROR "/home/bronaugh/csc330/proj_2/Skates/Skates.hs":124 - A newtype constructor must have exactly one argument
22:05:36 <bronaugh> newtype Vertex = Vertex {adj_list :: [CoordTuple], elev :: Int, dist :: Int, path :: CoordTuple}
22:05:48 <Pseudonym> That's the line?
22:05:53 <bronaugh> yep.
22:05:57 <Pseudonym> Er... oh, use data.
22:06:00 <Pseudonym> Duh.
22:06:06 <bronaugh> erm, why?
22:06:31 <Pseudonym> I need caffeine, that's why. :-)  newtype only works if you have only one element in the record.
22:06:47 <bronaugh> only one element in the record, hmm...
22:06:47 <bronaugh> ok.
22:06:51 * bronaugh uses data
22:06:55 <Pseudonym> Which is sometimes very useful.
22:07:06 <bronaugh> yes, I'm not discounting it.
22:07:49 <Pseudonym> I know, I was just commenting,
22:08:07 <bronaugh> yeah.
22:08:32 <bronaugh> so my next demon-hell-ride on the highway to haskell here is trying to get it to add street definitions...
22:16:19 <bronaugh> speaking of which.. /me turns on AC-DC -- Highway to Hell
22:19:33 <Pseudonym> Where am I going and what am I doing in this handbasket?
22:19:56 <bronaugh> lol
22:22:14 <bronaugh> and my devil-worshipping prof has to use column major order.
22:22:15 <bronaugh> grr.
22:22:53 <Pseudonym> transpose :: [[a]] -> [[a]]
22:23:06 <bronaugh> hmm..
22:23:11 <bronaugh> I could do that.
22:23:21 <Pseudonym> transpose [] = []
22:23:22 <bronaugh> but I could also just work with it, which would probably introduce fewer bugs.
22:23:29 <Pseudonym> transpose [xs] = map (:[]) xs
22:23:52 <Pseudonym> transpose xss = map head xss : transpose (map tail xss)
22:23:59 <Pseudonym> There you go.  Problem solved. :-)
22:24:23 <Pseudonym> Yes, or you could just work with it.
22:24:26 <bronaugh> btw, is && the logical and operator?
22:24:31 <Pseudonym> Yes.
22:24:40 <bronaugh> ok.
22:24:55 <bronaugh> what's its precedence versus =
22:25:38 <Pseudonym> You mean ==?
22:25:43 <bronaugh> no.
22:25:44 <bronaugh> I mean =
22:25:58 <Pseudonym> = isn't an operator
22:26:16 <Pseudonym> You can't use it in the middle of an expression.
22:26:20 <bronaugh> ok.
22:26:28 <bronaugh> it's something very different then.
22:26:34 <Pseudonym> Right.
22:26:57 <bronaugh> ok.
22:26:57 <Pseudonym> Haskell does not have assignment.
22:27:03 <bronaugh> this is turning into a mess.
22:27:10 <Sydx> hi all!
22:27:24 <Sydx> are there any gurus of permutations here?
22:27:28 <bronaugh> question: if you had an array of the data structure described above, and you wanted to add stuff to adjacency lists, how would you?
22:27:35 <Sydx> can someone answer a simple probability question?
22:27:40 <bronaugh> Sydx: possibly.
22:27:44 <Pseudonym> Sydx: What's a guru of permutations?  Is that like a cult?
22:28:02 <Pseudonym> bronaugh: You could use something like this:
22:28:16 <Sydx> no -- not really. a guru of persmutations is someone who understands what the damn things are...
22:28:25 <Pseudonym> stuff_adj_list :: CoordTuple -> Vertex -> Vertex
22:28:27 <Sydx> bronaugh: may i pvt msg u?
22:28:27 <bronaugh> Sydx: yeah, I'm familiar with them.
22:28:41 <bronaugh> Sydx: preferably not.
22:28:42 <Sydx> excellent
22:28:50 <Sydx> shall i ask here?
22:28:51 <Pseudonym> stuff_adj_list coord vertex = vertex { adj_list = coord : adj_list vertex }
22:28:54 <bronaugh> Sydx: do so
22:28:59 <Sydx> it's not really that relevant to haskell
22:29:13 <Sydx> the question is easy
22:29:13 <bronaugh> Sydx: do you see a busy channel?
22:29:52 <bronaugh> Pseudonym: now, here's the complication.
22:29:59 <bronaugh> Pseudonym: they're given as ranges.
22:30:01 <Sydx> u've got 20 socks made up of 10 different pairs, randomly distributed throughout a drawer
22:30:10 <bronaugh> Pseudonym: and to_x may be less than from_x.
22:30:23 <Sydx> if 8 socks are selected at random, what is the probability that there's at least one pair?
22:30:28 <Sydx> that's it
22:30:29 <bronaugh> Pseudonym: and to_y may be less than from_y
22:30:39 <Sydx> now i'm confused as to what choose what, etc. :(
22:30:40 <bronaugh> Sydx: combs with reps.
22:31:10 <Pseudonym> bronaugh: And this is a complication because...?
22:31:13 <Sydx> ?
22:31:18 <bronaugh> Sydx: p=0.1
22:31:29 <bronaugh> Sydx: ohh.
22:31:34 <bronaugh> Sydx: I betcha money that's normally distributed.
22:31:55 <Pseudonym> bronaugh: I bet you money it's not.
22:31:55 <bronaugh> Pseudonym: it makes things a mess.
22:32:17 <bronaugh> actually yeah.
22:32:22 <bronaugh> it probably is too small a sample.
22:32:43 <bronaugh> C(8, 20)
22:32:44 <bronaugh> hmm.
22:33:06 <bronaugh> so 1 - P(there are no pairs)
22:33:13 <Pseudonym> The denominator will be 20 choose 8.
22:33:35 <Pseudonym> The numerator will be the number of combinations which contain a pair.
22:33:49 <Pseudonym> Which is 20 choose 8 - the number of combinations which _don't_ contain a pair.
22:34:00 <Pseudonym> - is minus
22:34:05 <Pseudonym> not a hyphen
22:34:28 <bronaugh> that sounds right.
22:34:29 <Sydx> hmm
22:34:46 <Sydx> but we can swap 2 socks within a pair
22:34:55 <Sydx> without making any difference
22:34:58 <Sydx> how does that affect our life?
22:35:07 <Pseudonym> I'm 90% certain that will fall out as a common factor.
22:35:18 <bronaugh> Pseudonym: not quite.
22:35:55 <bronaugh> Pseudonym: I'm not certain yet, though you seem to be correct when I'm thinking about it.
22:36:55 <Sydx> it's so confusing
22:37:10 <Sydx> i dunno where to put 20 (number of socks) and 10 (number of pairs)
22:37:37 <Sydx> first of all, how many combinations are there that do not contain a pair?
22:38:11 <Sydx> isn't it 10*9*8*7*6*5*4*3?
22:38:44 <bronaugh> (n + r - 1)!/r!(n - 1)! = r choose (n + r - 1)
22:38:48 <Sydx> which is 1814400
22:38:50 <bronaugh> that's straight from my discrete math book.
22:38:59 <bronaugh> that's number of combs total.
22:39:26 <bronaugh> combs with repetition.
22:39:37 <bronaugh> n = 20, r = 10
22:40:01 <Pseudonym> The number of nonpair combinations is 11520 out of a possible 125970.
22:40:26 <Pseudonym> That should give you a way to verify your answer.
22:40:48 <Pseudonym> The Haskell code to compute this took all of 2 minutes to write, incidentally.
22:42:23 <Sydx> hmmm...
22:42:40 <Sydx> So p = 0.9085?
22:42:47 <Sydx> isn't that a bit high?
22:43:18 <bronaugh> no, you're wrong.
22:43:24 <Pseudonym> No, it's 1 - that
22:43:38 <bronaugh> 11520/125970 would be correct.
22:43:47 <Sydx> well that's too low
22:44:01 <Sydx> surely, it's more likely that there WILL be at least one pair?
22:44:03 <bronaugh> what are you checking it against?
22:44:22 <Sydx> intuition
22:44:22 <bronaugh> and why are you saying it's too low, etc.
22:44:23 <Pseudonym> This is the probability that there are no pairs.
22:44:35 <Sydx> Oh! i c
22:44:35 <Pseudonym> You actually want pairs, do you?
22:44:45 <Sydx> yeah, at least 1.
22:44:57 <bronaugh> 1 - 
22:45:05 <bronaugh> then your original result was correct.
22:45:16 <Pseudonym> Guess so.
22:45:38 <bronaugh> hmm...
22:45:42 <Pseudonym> choose 0 xs = [[]]
22:45:42 <Pseudonym> choose k [] = []
22:45:42 <Pseudonym> choose k (x:xs) = map (x:) (choose (k-1) xs) ++ choose k xs
22:45:47 <Pseudonym> sockdrawer = concat [ [i,i] | i <- [0..9] ]
22:45:52 <bronaugh> you know, I wonder if n choose r would map to a normal distribution curve.. I think it would.
22:45:52 <Pseudonym> haspair [] = False
22:45:52 <Pseudonym> haspair (x:xs) = x `elem` xs || haspair xs
22:45:56 <Pseudonym> solve = (length (filter (not . haspair) (choose 8 sockdrawer)),
22:46:03 <Pseudonym> solve = (length (filter (not . haspair) (choose 8 sockdrawer)),
22:46:09 <Pseudonym>   length (choose 8 sockdrawer))
22:46:11 <Pseudonym> There you go.
22:46:27 <Sydx> ok, guys, what's wrong with this:
22:46:34 <Pseudonym> Remove the "not ." if you want the figure you actually need. :-)
22:46:37 <Sydx> the number of combinations with no pairs =
22:46:48 <Sydx> 10 * 9 * 8 * ... * 3?
22:46:58 <Sydx> this is much greater than 11520...
22:47:11 <bronaugh> well let's see.
22:47:22 <Sydx> i thought it goes like this:
22:47:23 <bronaugh> I can't see how that would be right.
22:47:30 <Sydx> 10 pairs in total
22:47:35 <bronaugh> you could do this with a summation series.
22:47:45 <Sydx> so we have 10 choices for the 1st one
22:47:53 <Sydx> 9 choices for 2nd one
22:47:55 <Sydx> 8...
22:48:07 <Sydx> etc. so 3 choices for 8th one!
22:48:10 <bronaugh> choosing 8 from 20 chosen from 10 different sets.
22:48:18 <bronaugh> wierd.
22:48:35 <bronaugh> think letter ordering.
22:48:46 <bronaugh> but without the order.
22:49:01 <bronaugh> 01234567890123456789
22:49:33 <bronaugh> now p(0) is 0.1
22:49:57 <bronaugh> p(0)*p(0|p(0)) = 0.019
22:50:28 <bronaugh> less than that.
22:50:39 <bronaugh> no. different than that.
22:50:58 <bronaugh> 0.152
22:51:08 <Pseudonym> Ah!
22:51:10 <Pseudonym> I've got it.
22:51:20 <bronaugh> no wrong again.
22:51:32 <Pseudonym> 11520 = 2^8 * (10 choose 8)
22:51:34 <bronaugh> 0.00526
22:52:00 <Pseudonym> THink about it.
22:52:18 <bronaugh> hmm
22:52:23 <bronaugh> 0.958662249143298
22:52:25 <bronaugh> that's my answer.
22:52:32 <bronaugh> reasoning:
22:52:53 <Pseudonym> Here's my reasoning:
22:53:01 <bronaugh> probability of p(<some number> given we've already taken out that number once is 0.00526.
22:53:22 <bronaugh> now, probability of the opposite is 0.994
22:53:31 <bronaugh> so 0.994^8 = 0.95866
22:53:50 <Pseudonym> There are 2^8 ways to get a set of 10 distinct socks from the drawer.
22:54:02 <bronaugh> yep.
22:54:05 <Pseudonym> Then there are 10 choose 8 ways to choose 8 socks from that set of 10.
22:54:30 <bronaugh> but it's not a set of 10
22:54:36 <Pseudonym> Yes it is.
22:54:38 <bronaugh> it's a set of 20.
22:54:45 <Pseudonym> What you do is you pick a set of 10 distinct socks first.
22:54:46 <bronaugh> 20 socks. two of each kind.
22:54:55 <Pseudonym> Then you choose 8 of them.
22:55:08 <Pseudonym> 2^8 * (10 choose 8)
22:55:18 <bronaugh> Pseudonym: you grok what I'm doing with probability there?
22:55:29 <Pseudonym> I think so.
22:55:35 * Pseudonym wasn't following it
22:55:43 <Pseudonym> I was using my own derivation. :-)
22:55:57 <bronaugh> hehe
22:56:00 <bronaugh> I think it's wrong anyhow.
22:56:06 <bronaugh> there's something really messed up about the logic.
22:56:24 <bronaugh> the 0.0526 prob is correct.
22:56:29 <Pseudonym> Logic says I overestimated.
22:56:33 <bronaugh> that is the prob that you'll have one match.
22:56:38 <Pseudonym> But in fact it matches the value I got by brute force.
22:57:01 <bronaugh> 0.00526
22:57:16 <bronaugh> ohh.
22:57:18 <bronaugh> I see the error.
22:57:35 <bronaugh> that's for the first two.
22:57:40 <bronaugh> eww.
22:57:43 <bronaugh> that could get ugly.
22:58:00 <Pseudonym> Gotta go home.
22:58:04 <bronaugh> alrighty.
22:58:04 <Pseudonym> Night everyone.
22:59:41 <bronaugh> oh great.
22:59:48 * bronaugh needs to write a lambda function.
23:02:36 <bronaugh> or I could use a Haskell array.
23:07:53 <bronaugh> oh god.
23:07:55 <bronaugh> arrays in haskell.
23:08:03 <bronaugh> any notes on these?
23:08:09 <bronaugh> can you create a 2D array?
23:08:28 <^Sydx^> i am BACK!
23:08:30 <^Sydx^> :)
23:08:34 <^Sydx^> u guys are correct
23:08:46 <bronaugh> ^Sydx^: haskell q
23:08:50 <bronaugh> arrays in haskell.
23:08:55 <bronaugh> can you create a 2D array?
23:09:21 <^Sydx^> i suppose u need to use something like ([...], [...])
23:09:27 <^Sydx^> a tuple of lists
23:09:29 <bronaugh> that's a list.
23:10:01 <^Sydx^> or, a list of tuples!
23:10:12 <^Sydx^> [(a, b), (c, d), (e, f), ...]
23:10:22 <bronaugh> note.
23:10:27 <bronaugh> I'm talking about _arrays_
23:10:40 <^Sydx^> yeah
23:11:06 <^Sydx^> but there is no built-in support for 2D arrays
23:11:26 <bronaugh> I think you can have an array of arrays.
23:11:41 <bronaugh> which is by definition a 2D array.
23:11:46 <^Sydx^> u have to implement it yourself...
23:11:48 <^Sydx^> what's an array? a list?
23:11:59 <^Sydx^> is there any difference?
23:12:18 <bronaugh> there's an enormous difference.
23:12:23 <bronaugh> http://www.haskell.org/tutorial/arrays.html
23:13:04 <^Sydx^> what is it?
23:13:22 <^Sydx^> oh, u mean that u can't really get an element at a given index within a list?
23:14:29 <bronaugh> you can -- it's just really inefficient.
23:14:34 <bronaugh> array == constant time
23:15:15 <^Sydx^> constant time? that's very interesting
23:15:17 <^Sydx^> what do u mean by that?
23:15:23 <^Sydx^> i never understood the difference
23:15:28 <bronaugh> done any comp sci training?
23:15:38 <^Sydx^> u mean same access time to each element?
23:15:49 <^Sydx^> yes
23:15:50 <bronaugh> yeah.
23:15:55 <bronaugh> lists, it varies.
23:16:02 <^Sydx^> never heard of this
23:16:07 <bronaugh> if it's at the end of the list, it'll take a long time to get there.
23:16:24 <bronaugh> in Haskell, you get there by recursing like crazy.
23:16:32 <bronaugh> other languages, you do other things.
23:16:33 <^Sydx^> u r certainly right
23:16:41 <bronaugh> now, all that recursion costs.
23:16:45 <^Sydx^> we've never looked at them from this perspective
23:16:46 <bronaugh> it has a constant cost.
23:16:49 <bronaugh> but you do it n times.
23:16:59 <bronaugh> so it is within O(n)
23:17:09 <bronaugh> whereas array lookups are O(1)
23:17:21 <^Sydx^> (perhaps in us they teach differently, or my 1st year knowledge is not enough)
23:17:29 <bronaugh> 1st year knowledge isn't enough.
23:17:33 <^Sydx^> aha, i got it now, thanks
23:17:55 <^Sydx^> i mean i did programming for a long time, but a-scientifically :)
23:17:56 <bronaugh> all big-O notation is about is the worst-case running time.
23:18:00 <bronaugh> big-theta notation is about average
23:18:06 <bronaugh> there's also little-o
23:18:13 <bronaugh> and something else, but I can't remember that.
23:18:14 <^Sydx^> now i'm 1st year university student...
23:18:35 <^Sydx^> in fact in this case i never knew u could have arrays in haskell!
23:18:37 <^Sydx^> even 1D!
23:18:59 <bronaugh> yeah, well, I RTFM'd
23:19:26 <^Sydx^> interesting tutorial
23:19:36 <bronaugh> it's good.
23:19:41 <bronaugh> why're you in #haskell anyhow?
23:20:17 <^Sydx^> 'cause that's the main functional prog lang we use at my uni
23:20:39 <bronaugh> you do functional programming in 1st year?
23:20:39 <^Sydx^> :)
23:20:41 <bronaugh> wtf
23:20:47 <^Sydx^> yeah
23:20:59 <bronaugh> well, they might as well throw you in the deep end I guess.
23:21:16 <^Sydx^> i'm in uk
23:21:29 <^Sydx^> they teach differently here
23:21:36 <bronaugh> it's more theoretical I know.
23:21:42 <^Sydx^> in fact haskell is used for pretty much everything here
23:21:59 <^Sydx^> prolly because it's good for theoretical stuff indeed
23:22:15 <^Sydx^> it's haskell, prolog, java and c
23:22:16 <bronaugh> well, it's sorta neat.
23:22:19 <bronaugh> wow.
23:22:20 <bronaugh> not bad.
23:22:29 <bronaugh> let's see, first year here (Canada) they taught Java.
23:22:32 <^Sydx^> yeah, i guess it's easy to reason about...
23:22:34 <^Sydx^> oh, also maple
23:22:36 <bronaugh> second year, dabbled in C, Perl, ASM
23:22:51 <bronaugh> this is third year, and now they're dumping in the Haskell and Prolog.
23:22:59 <bronaugh> oh, and C++ -- but only a tiny bit of that.
23:22:59 <^Sydx^> because i'm actually doing a maths degree (maths applied to comp)
23:23:08 <bronaugh> ^Sydx^: sick bastard :P
23:23:09 <^Sydx^> we do asm, but it's 68000, not Intel
23:23:14 <^Sydx^> which is strange :)
23:23:17 <bronaugh> yeah, well, this was 6811
23:23:25 <^Sydx^> yeah :)
23:23:35 <^Sydx^> comp people do the same, but they use Intel
23:23:37 <bronaugh> you can do a _lot_ with 6 bytes of memory :P
23:23:44 <^Sydx^> we do it next year :)
23:23:53 <^Sydx^> yeah -- we also do turing machines
23:24:10 <^Sydx^> it's amazing that everything u can imagine can be done by one of them
23:24:31 <^Sydx^> 6 bytes?! is that how much mem 6811 has?
23:24:50 <bronaugh> ^Sydx^: yep ;P
23:24:57 <bronaugh> ^Sydx^: that's registers.
23:25:10 <bronaugh> ^Sydx^: board we were supposedly working with had about 4k of RAM
23:25:13 <^Sydx^> Wicked :)
23:25:37 <bronaugh> bwahaha I found a GCC port to it, and wrote what I was allowed to in C
23:25:45 <^Sydx^> Well, when I got interested in progging, I started with Commodorre 64
23:25:47 <bronaugh> and didn't use their piece of crap C compiler for it.
23:25:52 <^Sydx^> (if i spell it correctly)
23:26:03 <bronaugh> Commodore
23:26:04 <^Sydx^> that was 64 kb, and a very powerful machine
23:26:31 <^Sydx^> they used it for special effects! lol
23:28:14 * bronaugh is starting to think education here sucks.
23:28:20 <^Sydx^> brb
23:28:21 <bronaugh> education system rather.
23:30:18 <^Sydx^> us is better for postgrad though
23:30:30 <^Sydx^> more funding, more interesting projects
23:30:34 <bronaugh> hmm.
23:30:45 <^Sydx^> my uni is sposed to be the best here for maths + comp
23:30:51 * bronaugh still trying to figure out how the F to do this.
23:30:56 <^Sydx^> but it's like a fraction of harvard
23:31:03 <^Sydx^> or mit...
23:34:01 <bronaugh> they don't seem to teach much here until 2nd year.
23:34:04 <bronaugh> 1st year was monkey crap.
23:34:12 <bronaugh> woo, they showed us binary search trees.
23:34:14 <bronaugh> and heaps
23:34:17 <bronaugh> and stuff like that.
23:34:31 <bronaugh> and asked us to take way too much math.
23:34:31 <^Sydx^> i spose undergrad is like that...
23:34:40 <^Sydx^> exam questions are confusing though
23:34:45 <^Sydx^> they are quite tough here
23:34:58 <bronaugh> I haven't got less than a B in a comp sci course yet.
23:35:21 <bronaugh> so far I'm running a grade of an A+ in the course which I'm supposedly working on this project for.
23:35:35 <bronaugh> reason I have that grade: because I actually put some time/effort in this time.
23:35:52 <^Sydx^> we don't have that thing here
23:36:08 <bronaugh> you have some logical system instead?
23:36:12 <^Sydx^> we have 1st, 2nd (2.1 and 2.2) and 3rd degree...
23:36:26 <^Sydx^> i am getting a 1st so far
23:36:26 <bronaugh> oh.
23:36:34 <bronaugh> 1st class average?
23:36:36 <^Sydx^> that's equivalent to A i spose
23:36:45 <bronaugh> is that marked on a histogram or something?
23:36:53 <^Sydx^> yeah
23:36:56 <bronaugh> ahh.
23:37:01 <^Sydx^> it's normal distrib usually
23:37:21 <bronaugh> so 1st would be 90th percentile?
23:37:28 <bronaugh> or what?
23:37:52 <^Sydx^> no, it doesn't normally work like that
23:37:59 <^Sydx^> it's 70% in exams
23:38:10 <^Sydx^> but exams are scaled up or down, depending on performance
23:38:19 <bronaugh> oh.
23:38:22 <^Sydx^> this is where normal distrib comes into play
23:38:24 <bronaugh> so you actually have a crazier system then.
23:38:40 <^Sydx^> 1/4 at my uni get 1sts.
23:38:53 <bronaugh> hm..
23:38:55 <^Sydx^> (in order to do a PhD u need a 1 or 2.1)
23:38:58 <bronaugh> that wouldn't be too hard to pull off most of the time.
23:39:18 <^Sydx^> it varies from uni to uni tho
23:39:26 <^Sydx^> also from course to course
23:39:54 <^Sydx^> it's crazier than us in that sense
23:40:07 <^Sydx^> and less flexible
23:42:50 <dennisb> you can use (x,y) as index in an array
23:43:17 <dennisb> thus, you don't have to have array of arrays to get 2d
23:43:34 <^Sydx^> good idea...
23:43:36 <bronaugh> but then, how do you declare the range?
23:43:51 <bronaugh> oh as another tuple of tuples?
23:43:57 <dennisb> here is one definition of an array: array ( (0,0), (2,2) ) [ ((1,2),"foo"), ((0,0),"bar") ]
23:43:58 <dennisb> yes
23:44:51 <dennisb> also try "range ((0,0), (2,2))"
23:47:01 <bronaugh> btw, where's Haskell used in "real life"?
23:47:33 <^Sydx^> nat language processing
23:47:38 <bronaugh> hmm.
23:47:39 <bronaugh> that all?
23:47:46 <^Sydx^> (see http://www.haskell.org/)
23:47:55 <bronaugh> already read that stuf.
23:47:59 <bronaugh> it's used in telecom stuff.
23:48:01 <^Sydx^> there are some projects
23:48:10 <dennisb> There are a couple of companies that use it for theorem provers, I also know it's often used as a prototype language
23:48:17 <^Sydx^> but i think it's more of an acad
23:48:37 <^Sydx^> that's what we use it for
23:48:46 <^Sydx^> prototype lang for projects
23:48:57 <^Sydx^> Oh! also for specification
23:49:47 <bronaugh> hmm
23:50:02 <dennisb> I know of a company doing airline scheduling programs that made the first version in haskell and then rewrite it when they knew how it was supposed to work. Haskell is great to make high level program.
23:50:04 <bronaugh> how do I create a new show function?
23:50:11 <bronaugh> for a user-defined data type
23:50:13 <bronaugh> ie...
23:50:15 <dennisb> make in instance of the Show class
23:50:23 <bronaugh> oh god.
23:50:25 <bronaugh> ok explain.
23:50:52 <dennisb> you have your type and you say that from now on this type is an instance of Show and here is how show is defined
23:51:00 <dennisb> the syntax is easier to look up
23:51:11 <dennisb> find an example, that's the easiest
23:51:41 <dennisb> a declaration like: instance Show Foo where ....
23:51:55 <bronaugh> ERROR "/home/bronaugh/csc330/proj_2/Skates/Skates.hs":126 - Illegal Haskell 98 class constraint in type declaration
23:52:06 <bronaugh> showVertex :: (Show Vertex) => Vertex -> String
23:52:25 <dennisb> you don't need Show there
23:52:31 <bronaugh> ok.
23:52:37 <dennisb> just: showVertex :: Vertex -> String
23:52:41 <bronaugh> ok.
23:52:48 <bronaugh> and what else?
23:52:57 <dennisb> if you want to overload the name "show" you have to make it into an instance of Show
23:53:10 <bronaugh> that's what I want.
23:54:08 <dennisb> something like: instance Show Vertex where show x = "Here it is"
23:56:43 <bronaugh> ok.
23:56:47 <bronaugh> I'm too damned confused.
23:56:56 <bronaugh> data Vertex = Vertex {adj_list :: [CoordTuple], elev :: Int, dist :: Int, path :: CoordTuple}
23:56:57 <bronaugh> instance Show Vertex where show v = "adj_list, " ++ " elev=" ++ show (elev v) ++ " dist=" ++ show (dist v) ++ " path=" ++ show (fst (path v)) ++ show (snd (path v))
23:57:11 <bronaugh> ERROR "/home/bronaugh/csc330/proj_2/Skates/Skates.hs":127 - Syntax error in expression (unexpected `}', possibly due to bad layout)
23:58:12 <bronaugh> ideas?
