00:53:38 <Fractal> Anyone awake?
00:54:47 <Fractal> I want to pass the output of a function (hGetContents) of type Handle -> IO String   to a function of type  String -> String  I can't figure out how.
00:55:51 <Heffalump> do foo <- hGetContents handle
00:55:58 <Heffalump>    let res = f foo
00:56:01 <Heffalump>    ...
00:56:18 <Fractal> Hrm. Won't res foo have type IO String?
00:56:34 <Heffalump> well, you'll be stuck inside the IO monad
00:56:43 <Heffalump> but res itself will have type String
00:56:54 <Fractal> Er, sorry. Won't foo have type IO String?
00:57:04 <Heffalump> no, foo will have type String
00:57:45 <Fractal> Could you explain why not? I don't quite understand that...
00:58:02 <Heffalump> "do ... ; var <- iovar ; ..." sort of removes the IO from the type of iovar
00:58:13 <Heffalump> do you know about the >>= operator?
00:58:26 <Fractal> Vaguely. I don't completely understand it though.
00:58:39 <Heffalump> well, it's part of the Monad class, which IO is an instance of
00:58:46 <Fractal> Right.
00:58:50 <Heffalump> in the case of IO, it has type IO a -> (a -> IO b) -> IO b
00:59:17 <Heffalump> and return has type c -> IO c
00:59:27 <Fractal> Oh... So all it really does is strip off the IO?
00:59:39 <Heffalump> not exactly, because it puts it back on again for the result type
01:00:03 <Heffalump> but if you're willing to accept that the result type will be in IO, then yes
01:00:11 <Fractal> Er, right. But it strips it off so (a -> IO b) can be applied...
01:00:18 <Heffalump> (and you really have no other choice, since there is no function that will strip off the IO permanently)
01:00:21 <Heffalump> yep.
01:00:47 <Heffalump> and if f :: String -> String, then return . f :: String -> IO String
01:00:49 <Fractal> Oh... I don't know why I didn't get that...
01:01:11 <Fractal> OK
01:01:37 <Fractal> So a do statement is really just one expression.
01:01:38 <Fractal> ?
01:01:50 <Heffalump> a do statement is just syntactic sugar for repeated uses of >>=
01:02:22 <Fractal> OK, I understand. I think.
01:02:33 <Fractal> Somebody really ought to write a gentler introduction. :)
02:09:42 <dark> "A soothing introduction to Haskell"
02:10:06 <Fractal> I was thinking more like "A complete, utter idiot's guide to Haskell" :)
02:29:05 <norpan> Idiots are better off not using Haskell
02:29:48 <norpan> labelling something as "for idiots" is silly
02:51:07 <Heffalump> yes, idiots wouldn't have understood the explanation I gave above
02:54:25 <Fractal> Woohoo!
03:07:09 <bas_> whois norpan
03:07:50 <dark> pingofdeath bas_
03:08:21 <Heffalump> :-)
03:09:49 <dark> Are there any studly math/statistics people here who can tell me more about Hidden Markov Models?
03:09:57 <dark> Or provide online references... I haven't found any.
03:11:56 <dark> My interest in them is in the area of spam filtering :-)
03:12:16 <Heffalump> I know what they are, but...
03:12:51 <Heffalump> (a) not in much detail and (b) I have to go now
03:13:00 <dark> Okay, I'll continue searching :)
03:13:24 <dark> I found a C library that implements some HMM algorithms, but its documentation assumes I know what to do with it :-)
03:56:37 <bas_> i made a parser with the general parser functions in Bird's 'craft of functional programming', now i need to implement a few 'contraction' rules to transform the parsed structure... does anyone have experience in doing this?
05:11:32 <bas_> i want to define a function which pattern matches it's arguments (which can be composed of several constructors), but i also want to determine if some variable is >= 0... how should i do something like that?
05:12:04 <ayrnieu> guards.
05:12:27 <ayrnieu> fact n | n >= 1 = n * fact (n-1)
05:13:00 <bas_> but it gets so ugly that way!
05:13:06 <bas_> i have for example normsem (Terms (Constant S) (Constant (Value (Number n)))) = Constant (Value (Number (n+1)))
05:13:23 <bas_> but i only want to do it when n >= 0
05:13:37 <dark> What's ugly about adding | n >= 0 to that?
05:14:03 <bas_> isn't it so that i need to add a 'otherwise' clause to it?
05:14:15 <ayrnieu> "Put a hat on that girl."  "But it gets so ugly that way!"  "Son, that girl's plenty ugly without the hat."
05:14:23 <dark> Nope, if none of the guards is true then it falls through to the next pattern.
05:14:56 <bas_> is that so... ok... than it's quite easy... thanks for your help...
05:15:20 <ayrnieu> You can also use n+k patterns =)
05:15:27 <ayrnieu> (Which fail on negative numbers)
05:15:34 <dark> They do?  I didn't know that.
05:15:42 <bas_> n+k patterns ?!?
05:15:45 <bas_> what are those?
05:15:47 <dark> Now I'm really sure they're an ugly blemish on the language :-)
05:15:51 <ayrnieu> normsem (Terms (Constant S) (Constant (Value (Number (n+1))))) = Constant (Value (Number (n+2)))
05:16:19 <dark> ayrnieu: Will 0 match n+1?
05:16:22 <bas_> why does that fail on negative numbers?
05:16:27 <ayrnieu> dark - I was fairly surprised; they're from a common mathematical notation, I think.
05:16:28 <dark> Remember, this is supposed to be a >= 0 guard.
05:16:33 <ayrnieu> bas - because (n+1) doesn't match negative numbers.
05:16:43 <ayrnieu> dark - yes.
05:17:08 <dark> bas: n+k patterns are discouraged by the Haskell98 Report :)
05:17:23 <bas_> dark: that's cool...
05:17:36 <ayrnieu> They're only discouraged because they are a totally unique feature of pattern-matching.
05:17:37 <bas_> i don't see why n+1 matches natural number only :(
05:17:53 <dark> ayrnieu: I think it's because they might be removed in a future version of Haskell :)
05:17:59 <dark> At least, that's the reasoning the Report gives.
05:18:02 <ayrnieu> bas - something to do with their common use in mathematics.
05:18:26 <bas_> is it because a number is defined inductively as 1+1+1+1+1...etc.. !?!?
05:18:34 <ayrnieu> Oops, no: n+k patterns don't match 0.
05:18:42 <dark> ayrnieu: told you.
05:19:01 <ayrnieu> dark - somehow I'd forgotten this from my experiments =(
05:19:26 <ayrnieu> bas - ah, possibly =)
05:19:36 <dark> bas: Yeah, it's intended for inductive definitions, where you only define foo 0 and foo (n+1).
05:19:55 <dark> However, the language has plenty of other ways to write that.
05:20:12 <ayrnieu> fact 0 = 1; fact (n+1) = (n+1) * fact n
05:21:18 <dark> I don't think I've ever actually used that kind of recursion on natural numbers :)
05:21:28 <bas_> i DO get program error when i define normsem (Terms (Constant S) (Constant (Value (Number (n+1))))) = Constant (Value (Number (n+2)))
05:21:31 <bas_> :(
05:21:32 <dark> It's always on some data structure.
05:21:43 <bas_> it doesn't automagically match the next pattern...
05:21:46 <ayrnieu> bas - what program error?
05:21:53 <bas_> Program error: {parseNorm_v1315 []}
05:22:10 * Igloo_ will be upset if it gets removed
05:22:16 <Igloo_> I use it a reasonable amount
05:22:27 <bas_> and parseNorm is parseNorm a = normsem t \n where ((t,_):_) = semParse a 
05:22:32 <dark> Igloo:  Well... you could always keep it in your Free People's Haskell Report :-)
05:22:54 <Igloo_> bas: The problem is probably semParse a == []
05:23:15 <Igloo_> Well, I'd have to convince Ross to keep it in his or maintain YA fork  :-)
05:23:35 <bas_> Igloo_: oops yeah it is... stupid grammar...
05:23:39 <ayrnieu> You could just maintain a patch against GHC =)
05:23:46 <dark> "Haskell 98.3 -- The Revenge"
05:23:48 <ayrnieu> bas - stupid grammar?
05:25:03 <bas_> ayrnieu: yeah need to make a parser/interpreter for this SEM/SEMDEC/PCF language... literals can't be negative numbers
05:25:36 <ayrnieu> bas - are you using Parsec?
05:26:20 <bas_> Parsec!?!? never heard of it... just using a couple of general parsing functions from 'craft of functional programming' book...
05:26:28 <bas_> what's parsec?
05:27:29 <ayrnieu> bas - one sec.
05:27:51 <bas_> sure..
05:27:52 <dark> http://www.cs.uu.nl/~daan/parsec.html
05:28:33 <ayrnieu> bas - it's a combinatorial parser library.  There are other parsers in Haskell (shapr seems to like Arrow-based parsers), but Parsec is nice.
05:28:48 <dark> shapr likes Arrow-based anything :-)
05:29:18 <dark> Hmm, would I offend too many people by having "Brainfuck interpreter" in the subject of a mail to the haskell list?
05:29:28 <dark> I don't approve of random *'s in words.
05:29:34 <ayrnieu> dark - I don't think so, and neither do I.
05:29:42 <ayrnieu> (We're all adults, here)
05:30:00 <ayrnieu> (So hopefully nobody will act like a censor)
05:30:55 <dark> The first Haskell function I taught to my girlfriend was four_letter_word :-)  (to demonstrate pattern-matching on strings and lists)
05:31:29 <ayrnieu> What did that do?
05:31:59 <dark> Essentially it did (== 4) . length in various ways.
05:32:26 <ayrnieu> oh.  Did it check that the list was of letters?
05:32:36 <dark> Hmm, no :)
05:33:27 <dark> I used it to show how a function of String was really a function of [Char] that could be generalized to [a], etc.  I never thought of Chars that weren't letters.
05:33:57 <ayrnieu> Oh, OK.
05:34:13 <dark> It could have been educational to show how adding an isAlpha check would force it to be a function of [Char] specifically.
06:25:18 <bas_> i want to define a function, but somehow it doesn't allow me to do the following over a this type: data Ter = Variable Var | Constant Con | Terms Ter Ter | Lambda Var Ter deriving Show
06:25:24 <bas_> sub :: Ter -> Var -> Ter -> Ter
06:25:24 <bas_> sub (Variable x) x b = b
06:25:44 <bas_> but i can't seem to repeat the variable 'x' in the pattern... why not!?!?
06:26:08 <Heffalump> it's just not allowed
06:26:17 <Heffalump> you have to say sub (Variable x) y b | x == y = b
06:26:32 <bas_> allright...
06:31:01 <ayrnieu> Like pattern-matching in ML, unlike pattern-matching in Prolog-and-like.
06:32:13 <Heffalump> yeah
06:40:17 <mgoetze> how do i define a type 'Matrix a', which should be a [[a]] with the context (Num a)?
06:40:56 <Igloo_> newtype Num a => Matrix a = Matrix [[a]]
06:41:18 <ayrnieu> or 'type Num a => Matrix a = [[a]]', but you probably want Igloo's.
06:41:41 <bas_> what's the difference between them?
06:42:33 <ayrnieu> bas - one says "I'm going to call this type 'Matrix a', even though it's [[a]]"; the other says "I'm going to call this type 'Matrix a' sometimes, even though it's [[a]] -- you don't worry about that."
06:43:16 <Igloo_> Does the first actually work?
06:43:19 <mgoetze> Igloo_: can you tell me why there must also be 'Matrix' on the right-hand side?
06:43:21 <Igloo_> IM the second
06:43:31 <bas_> isn't that a constructor?
06:43:46 <ayrnieu> mgoetze - newtypes need constructors.
06:44:05 <bas_> isn't it a bad manner to name the constructor the same as the type itself?
06:44:05 <mgoetze> ah, right
06:44:07 <ayrnieu> Igloo - I don't know what you're talking about.
06:44:10 <mgoetze> ok
06:44:20 <ayrnieu> bas - not SFAIK.  Why do you think that it would be?
06:44:25 <Igloo_> ayrnieu: You can't do it with type
06:44:28 <ayrnieu> bas - Haskell has several distinct name spaces.
06:44:42 * mgoetze now tries to implement 'Matrix a' as an instance of 'Eq a'
06:44:44 <ayrnieu> Igloo - ... oh, of course.
06:45:19 <bas_> i heard there is some error in hugs which puts contructor names globally when you try to hide them in a module and the contructor has the same name as the type..
06:45:47 <ayrnieu> bas - seeing as that's a bug, I wouldn't worry about it unless it has yet to be fixed.
06:47:09 <ayrnieu> newtype Num a => Matrix a = Matrix [[a]] deriving (Eq)
06:47:48 <mgoetze> ayrnieu: oh, i have to include that in the newtype definition already? good to know :)
06:52:58 <bas_> i have this pattern matching in a 'where' clause, but i want my program to do a error when it doesn't match there... do i really need to make it a seperate function for this purpose?
06:54:02 <ayrnieu> foo a = b a
06:54:05 <ayrnieu>   where b 0 = 1
06:54:08 <ayrnieu>        b 1 = 2
06:54:17 <ayrnieu> (only indented correctly)
06:54:29 <ayrnieu> Does that answer your question?
06:54:48 <ibid> bas_: i don't understand the problem
06:55:31 <bas_> i want it to give a error when it doesn't pattern match in the where clause... like this...
06:55:37 <bas_>     where Constant (Value (Number b)) = normsem t
06:55:49 <ayrnieu>      b _ = error "b given other-than [1,2]"
06:55:52 <bas_> when normsem t doesn't match the constructor Constant
06:56:25 <Igloo_> b = case normsem t of
06:56:33 <Igloo_>  Constant (Value (Number x)) -> x
06:56:41 <Igloo_>  _ -> error "b given other-than [1,2]"
06:57:12 <bas_> case... right... i am in a semantical confusion ;~(
06:57:17 <bas_> but thanks
06:57:19 <ayrnieu> bas - your 'where x' seems wrong, anyway.  Are you supposed to have a function there, somewhere?
06:58:06 <bas_> i can paste the whole thing i guess so you can see what i'm talking about...
06:58:07 <bas_> evalSem a = b
06:58:07 <bas_>     where Constant (Value (Number b)) = normsem t
06:58:11 <bas_>   ((t,_):_) = semParse a
06:58:34 <ayrnieu> bas - that doesn't make any sense at all.
06:58:46 <bas_> ok...
06:58:51 <bas_> why not!?
06:59:07 <bas_> you don't know the types etc..
06:59:27 <ayrnieu> bas - you're defining bindings to data structures and not using them in your definition.
06:59:31 <ayrnieu> ITYM
06:59:34 <ayrnieu> evalSem a = f b
06:59:43 <ayrnieu>   where f (Constant (Value (Number b))) = normsem t
06:59:54 <ayrnieu>        f ((t,_):_) = semParse a
06:59:58 <ayrnieu> (only indented correctly)
07:00:36 * ayrnieu isn't at all sure what that other thing (in the second match) is supposed to be.
07:00:41 <Igloo_> It does makes sense
07:00:48 <Igloo_> Patterns are valid left hand sides
07:01:05 <ayrnieu> Igloo - do his bind b and t, then?
07:01:09 <Igloo_> Yes
07:01:14 <bas_> hmmm, i don't really follow the discussion myself... i only know i works :)
07:01:17 <ayrnieu> Oh, OK.
07:01:20 * ayrnieu gets it now.
07:01:41 <ayrnieu> bas - sorry.
07:02:36 <Igloo> So what is the current problem, bas?
07:02:41 <bas> ayrnieu: doesn't matter...
07:03:12 <bas> Igloo: the problem is normsem t doesn't match the constructor 'Constant' every time..
07:03:21 <bas> but i fix that with a 'case' clause
07:03:26 <Igloo> Right
07:03:42 <Igloo> But then you said you had semantical confusion?
07:05:20 <mgoetze> so, what's wrong about this?: instance Eq Matrix a where
07:05:28 <Heffalump> you need some brackets
07:05:30 <bas> well, I do loose the functional programming style after programming nonstop for 2 days in haskell... don't know when to use pattern matching, when to use case's, etc... but i am getting better at it... probably all just a matter of experience... right?
07:05:32 <Heffalump> instance Eq (Matrix a) where
07:05:41 <mgoetze> yay, brackets :)
07:06:00 <ibid> those are parentheses, not brackets :-)
07:06:04 <ibid> brackets are [] :-)
07:06:23 <ayrnieu> bas - experience and asthetic.
07:06:39 <bas> aesthetic!?
07:06:50 <ayrnieu> ibid - this is a cultural thing.  Some people call {} 'curly brackets' instead of 'braces', as God intended.
07:06:50 <mgoetze> ok, so when i do the newtype declaration with deriving, and then an instance declaration, ghc says "Duplicate instance declarations"
07:07:01 <mgoetze> so, should i leave out the "deriving" after all?
07:07:12 <Igloo> bas: Ah, cool, yes  :-)
07:07:24 <ayrnieu> mgoetze - yes.  The deriving creates an automatic 'instance of'.
07:07:34 <ibid> ayrnieu: sure. and they also call ()'s parentheses, as god intended :-)
07:07:57 <ayrnieu> bas - yes.  If all else is equal, choose the prettiest option.
07:08:15 <ayrnieu> 'opt for the prettiest'
07:08:38 <mgoetze> ()'s must be called "parentheses" so that some popular expansions of the acronym LISP work...
07:09:13 <ayrnieu> Lots of Irritating Silly Rounded Brackets.
07:09:59 * ayrnieu realizes that he is not properly parenthesizing himself.
07:10:20 <ibid> (in finnish, we call them "kaarisulkeet", literally arc closures:-)
07:12:09 <mgoetze> can i mix deriving and instance, e.g. "newtype [...] deriving (Eq) [...] instance Num (Matrix a) [...]"?
07:12:13 <ayrnieu> That's a nice description =)
07:12:25 <ayrnieu> mgoetze - you ought to be able to.
07:12:30 * mgoetze tries.
07:13:23 <ibid> sure you can
07:13:33 <ibid> just not for the same class :-)
07:14:06 <bas> darn, i can't get this 'normsem t' thingy to work with case after all... i want to assign 'b' as follows: Constant (Value (Number b)) = normsem t ... and do a 'error' when it does not match... but when i use a 'case normsem t of' i can't do the assigntment to b... :( any ideas?
07:14:15 <ayrnieu> ibid - Why can't you mix them?
07:15:06 <ayrnieu> where b = case normsem t of Constant (Value (Number b')) -> b; _ -> error "foo"
07:15:36 <mgoetze> how do i derive Eq and Show?
07:15:43 <ayrnieu> deriving (Eq, Show)
07:15:44 <ibid> ayrnieu: ?
07:16:08 <ayrnieu> ibid - Why can't you mix 'deriving' and instance declarations?
07:16:13 <ibid> ayrnieu: i mean, you can't both derive and instance the same type to the same class
07:16:15 <mgoetze> ok, following code:
07:16:20 <ibid> ayrnieu: i never said that
07:16:21 <mgoetze> newtype Num a => Matrix a = Matrix [[a]] deriving (Eq, Show)
07:16:25 <ayrnieu> ibid - yes, sorry, I read 'class' as 'type'.
07:16:28 <mgoetze> instance Num (Matrix a) where
07:16:33 <mgoetze> ghc says:
07:16:43 <mgoetze>     Could not deduce (Show a, Eq a) from the context ()
07:17:17 <mgoetze> is ghc just telling me about it's own stupidity or have i made a mistake?
07:17:27 <bas> ayrnieu: thanks! it works... it works!
07:18:07 <Heffalump> hmm
07:18:21 <ibid> mgoetze: you are missing context as it says
07:18:31 <Heffalump> does that error happen without the instance Num (Matrix a) ?
07:18:55 <mgoetze> ibid: the context is in my newtype declaration!
07:19:09 <mgoetze> Heffalump: no, that's the line it's refering to
07:19:57 <ibid> mgoetze: there is no context (Show a, Eq a)
07:20:00 <Heffalump> class (Eq a, Show a) => Num a where
07:20:13 <Heffalump> so you need Eq and Show instances first, before you can make a Num instance
07:20:21 <ayrnieu> ooh, nifty (http://www.cs.mu.oz.au/~keving/fpu_snip/0194.html)
07:20:26 * Heffalump wonders why on earth Show is a precondition, but anyway...
07:20:36 <mgoetze> ibid: well, it's explicitly implied in my newtype declaration
07:20:58 <ibid> mgoetze: no idea :-)
07:21:29 <Heffalump> deriving Eq, Show will create
07:21:30 <mgoetze> Heffalump: yeah, but i derived those from [[a]] for Matrix a, and they must exist for a due to the constraint in my newtype declaration.
07:21:33 <Heffalump> instance Eq a => Eq (Matrix a)
07:21:40 <Heffalump> and instance Show a => Eq (Show a)
07:21:49 <Heffalump> you haven't demonstrated that Eq a and Show a hold in your instance Num
07:22:24 <Heffalump> oh.
07:22:25 <mgoetze> Heffalump: i don't want to demonstrate that, i demand that anyone creating Matrix a demonstrate that for me! lol
07:22:28 <Heffalump> hmm.
07:22:43 <Heffalump> mgoetze: well, then you need instance (Eq a, Show a) => Num (Matrix a) where
07:22:46 <Heffalump> but that doesn't work for me either
07:24:25 <Heffalump> and anyway, Num a => ... in the newtype should imply Eq a and Show a too
07:24:28 <Heffalump> so I'm a bit confused
07:24:50 <mgoetze> so, i guess i need to keep saying (Num a) all the time, everywhere then... :)
07:25:12 <Heffalump> ah, instance Num a => Num (Matrix a) 
07:25:13 <Heffalump> works
07:25:53 <dark> You'll still have to keep saying (Num a) all the time, I think.  You can have functions on Matrix a which expect Num a, and functions that don't.
07:26:14 <mgoetze> dark: but i said (Num a) in my newtype! waaaaaaaaaah!
07:26:18 <Heffalump> but why is the Num a => in the newtype if you can have functions which don't?
07:26:25 <dark> I don't know :)
07:26:41 <ayrnieu> Current version: newtype Num a => Matrix a = Matrix [[a]] deriving (Eq, Show)
07:27:47 <mgoetze> ayrnieu: yep, that's right. it just seems that the "Num a" in there doesn't do anything useful
07:29:07 <ayrnieu> data Num a => Matrix a = Matrix [[a]] deriving (Eq, Show) -- ?
07:29:19 * Igloo hasn't been following, but is the problem that you aren't dreiving Num for Matrix?
07:29:57 <mgoetze> Igloo: i want to define my own instance Num (Matrix a), but it seems i have to keep restating the context (Num a)
07:30:06 <Igloo> Ah, hmmm
07:30:40 <mgoetze> ayrnieu: nope, doesn't help
07:31:23 <Igloo> I don't see why - foo (Matrix [[x]]) (Matrix [[y]]) = (Matrix [[x + y]])   is accepted by hugs for me
07:31:46 <Igloo> Oh, but type inference would do that for me
07:32:01 * mgoetze smokes ghci.
07:32:29 <mgoetze> Igloo: that's easy enough, but how would you do matrix multiplication? :)
07:34:08 * Igloo doesn't understand mgoetze
07:34:18 <Igloo> Hmmm, looks like it doesn't deduce it for you. How odd.
07:34:44 <mgoetze> Igloo: uhm, you do know how to multiply two matrices, right?
07:34:55 <Igloo> Yes
07:35:22 <Igloo> I was testing inference, not writing useful code...
07:35:39 <Igloo> A function that adds singleton matrices isn't hugely useful either
07:36:11 <mgoetze> Igloo: yeah, well, my only problem there is that i have to keep specifying (Num a) over and over again
07:37:14 <mgoetze> also, i don't suppose i can add some checks to a type constructor? such as that all the sublists must be the same length? :)
07:37:46 <dark> In that case you're probably better off with an Array.
07:38:25 <dark> Otherwise, you'll have to make a function that does the construction, and hide the constructor itself.
07:38:46 <mgoetze> dark: i'm afraid of Arrays. :)
07:39:05 <dark> They can't be any scarier than matrices )
07:40:00 <mgoetze> dark: they have too many variables ('Array a b c d e f g etc' as opposed to 'Matrix a')
07:50:41 <ayrnieu> Is there some way to *actually download* a real audio file?  There are presentations at http://ll2.ai.mit.edu/ I'd like to see, but I keep losing the connection (and getting horrible 'reception' besides).
07:51:41 <mgoetze> ayrnieu: tried wget or the like?
07:52:25 <bas> there are some problems with real media...
07:53:06 <bas> many of them are broadcasted on a rtsp protocol which is partly open source, except for the part real's servers use!
07:53:37 <bas> you can use unix 'mplayer' to connect to a rtsp server and download the real file...
07:53:50 <ayrnieu> mgoetze - no, that just gets the 'link', or whatever the .ram file is.
07:53:53 <ayrnieu> bas - hm, OK.
07:54:13 <dark> realnetworks are spammers, too.
07:54:48 <ayrnieu> Well, I can't use unix 'mplayer'.  /me looks for a windows rtsp client.
07:55:16 <dark> I'm having fun with newtype Sack = Sack (FiniteMap String Dynamic)
07:56:41 <bas> ayrnieu: you should look at live.com where they have livemedia for download when you need to save a rtsp stream
08:01:16 * ayrnieu decides that this isn't worth the stress.
08:08:44 <dark> Hmm I fairly often need a maximumAccordingTo :-)
08:08:54 <ayrnieu> What does that do?
08:09:11 <Igloo> maximumBy probably exists
08:09:14 <dark> Something that's (Ord b) => (a -> b) -> [a] -> a, and returns the a with the highest b.
08:09:23 <dark> maximumBy doesn't do what I need.
08:10:03 <dark> For example, maximumAccordingTo length strs
08:10:39 <dark> Oh, right, maximumBy would do it with the right comparison function.
08:11:42 <dark> It would probably end up calculating the length twice for every string, though.
08:11:48 <Igloo> It would be quite messy
08:11:53 <Igloo> Have you got an instance of Ord a?
08:12:22 <Igloo> If so tupling toget [(b, a)] and using snd . maximum is probably easiest
08:12:47 <dark> No, the ordering is quite complicated in the current case.  I have a list of lists, and a list of preference functions ([a] -> Bool), and I need to find the list for which the largest number of preference functions are true.
08:14:28 <ayrnieu> dark - GHC deforestation might keep you from doing that.
08:14:37 <dark> Hmm, if there's more than one maximum in the list, which does it return?  Is that defined?
08:14:38 <ayrnieu> (calculating the length twice for every string)
08:14:55 <Igloo> It returns whatever the prelude maximum in the report returns
08:16:17 <dark> The one in the report uses foldl1 max xs
08:16:53 <ayrnieu> what module is maximumBy in?
08:16:56 <Igloo> List
08:17:19 <Igloo> So it'll return the first or last depending on what max does then
08:17:22 <dark> Interesting, the report gives the wrong type signature for maximumBy.
08:17:39 <Igloo> The revised report?
08:17:49 <dark> Not sure... whichever one is up at haskell.org :)
08:18:04 <dark> At the top it says maximumBy :: (a -> a -> Ordering) -> [a] -> a
08:18:24 <dark> But lower down it's maximumBy :: (a -> a -> a) -> [a] -> a
08:18:27 * ayrnieu decides that GHCi isn't all that useful for quick questions like "What is the type of maximumBy?"; by the time documentation was found to get the module for maximumBy, the type signature would be found.
08:18:55 <ayrnieu> dark - haskell.org has both.
08:19:30 <ayrnieu> (or links to both) http://research.microsoft.com/Users/simonpj/haskell98-revised/haskell98-report-html/
08:20:00 <dark> Right, the revised one has (a -> a -> Ordering) in both places, and a different implementation of maximumBy.
08:20:05 <Igloo> It's fixed in the revised report
08:20:17 <dark> Hmm, this actually seems less useful :)
08:20:32 <Igloo> You can use compare to do the actual comparison for you
08:20:58 <Igloo> a `max` b => a `compare` b should work
08:21:19 <dark> According to the revised definition, it should return the last maximum.
08:21:36 <Igloo> Oh, except you want to do something a bit stranger. Maybe it will be slightly uglier then
08:21:53 <ayrnieu> dark - which would be the most maximum, no?
08:26:37 <dark> Hmm, it seems to take only three lines of code :)
08:28:12 <dark> Using maximumBy and a custom comparison function.
08:32:07 <dark> It might turn out to be hideously slow, but that's a later worry :-)
08:36:34 <Igloo> I see what you mean about arch's speed, BTW...
08:39:17 <dark> I got a 1.5 orders of magnitude speed improvement with harc :-)
08:39:46 <Igloo> But with 1.5 orders of magnitude fewer features?  :-)
08:39:53 <dark> Umm... yeah :-)
08:40:14 <dark> Except that I added http access, which arch doesn't have.
08:41:14 <dark> (Landry's arch also has http access but it requires DAV, which my ISP doesn't have)
09:57:22 <dark> I recently discovered the power of Functor monads :-)
09:57:51 <dark> Gets rid of a lot of excess lifting.
09:57:57 <bas> what are they?
09:58:07 <dark> Well, simply a monad that's an instance of Functor.
09:58:15 <dark> The State monad has this, for example.
09:58:50 <dark> For example, this definition:
09:58:57 <dark> roll_3d6 :: Rand Int
09:58:58 <dark> roll_3d6 = fmap sum $ sequence $ repeat 3 $ rnd (1, 6)
09:59:09 <dark> (Rand is a variant of State)
10:00:10 * ayrnieu hums at http://www.cs.mu.oz.au/research/mercury/mailing-lists/mercury-users/mercury-users.0105/0033.html
10:04:59 <dark> Aha!  There's also a Functor IO instance :)
10:07:23 <dark>   input <- if null args
10:07:23 <dark>             then getContents
10:07:23 <dark>             else fmap concat $ sequence $ map readFile args
10:10:18 * ayrnieu wonders where in the execution of that program readFile will realize that it can't open one of its arguments.
10:23:47 <dark> I don't know :-)  But in this program it doesn't matter, it won't go any more IO until it's eaten all of the input./
10:24:13 <dark> The bigger problem is that at least in GHC, lazy input will discard I/O errors.
10:34:39 <ayrnieu> hm, OK.
10:35:35 <ayrnieu> Is this a problem in any use of unsafeInterleaveIO?
10:36:11 <dark> No, it's done explicitly by the implementation of hGetContents, which is used by readFile.
10:37:28 <ayrnieu> ... This may explain some of my (totally mysterious) problems with hGetContents.
10:43:08 <dark> It's more likely to show up with sockets than with files.
10:43:52 <ayrnieu> Which was what I was dealing with.
10:44:26 <ayrnieu> were what.  Better:  The problems occurred in the setting of sockets.
10:44:32 <dark> I made a hGetStr for my http client.  It's not difficult if you use hGetBuf.
10:45:04 <ayrnieu> I'll do that, then.
10:45:35 <dark> Don't mix it with hGetChar, though, because I found that makes it insist on waiting for 8192 bytes of data :-)
10:45:52 <ayrnieu> hm, OK.
10:45:54 <dark> hGetLine doesn't seem to have that problem.
10:46:45 <ayrnieu> This sounds like the kind of stuff that documentation ought to, like, document.
10:46:53 <ayrnieu> but thanks =)
10:47:39 <dark> I think these are unexpected features :)
10:47:54 <ayrnieu> I was so frustrated and disgusted that I started over in Erlang, but I'll think about Haskell soon.
10:48:01 <ayrnieu> Good documentation documents the unexpected!
10:48:41 <dark> If you want some sample code, look at Util.IO in http://www.xs4all.nl/~dark/harc-0.1pre10.tar.gz
10:49:37 * ayrnieu fetches.
10:51:30 <dark> hGetStr might not be tail-recursive, but I didn't mind because it needs to allocate an arbitrary amount of data anyway :)  (Because of being strict)
10:56:49 <ayrnieu> Where is Util.IO defined in that tarball?
10:58:46 <ayrnieu> nevermind; stupid windows extractor problems.
11:09:18 <dark> Heh.  I started writing a small utility for generating random NPCs for a D&D campaign.
11:09:45 <dark> Now I find myself writing a parser for the datafile format.
11:09:49 <dark> This may be overkill :-)
11:10:26 <dark> But I had sudden visions on how I could make the system generic enough to also generate whole villages, or wandering monsters, or even the weather.
11:11:18 <ayrnieu> The parser alone would constitute 'overkill' for your purpose if you weren't writing it in Haskell =)
11:11:21 <ayrnieu> How would you generate villages?
11:13:05 <bas> i get a syntax error i a expression while trying to compute some long input, how can i 'trace' or see where it is going wrong? i am trying to do this:
11:13:08 <bas> (Terms (Terms (Lambda (Name (Number 2)) (Terms (Lambda (Name (Number 1)) (Lambda (Name (Number 0)) (Terms (Terms (Terms (Constant T) (Variable (Name (Number 0)))) (Constant (Value (Number 0)))) (Terms (Constant S) (Terms (Constant S) (Terms (Variable (Name (Number 1))) (Terms (Constant P) (Variable (Name (Number 0)))))))))) (Terms (Variable (Name (Number 2))) (Variable (Name (Number 2)))))) (Lambda (Name (Number 2)) (Terms (Lambda (Name (Number 1)) (
11:13:26 <bas> oops...
11:13:39 <bas> that's the parameters to this function...
11:14:46 <dark> ayrnieu: Not village maps or anything, but its size and inhabitants, maybe even guilds and other organizations.
11:15:05 <ayrnieu> dark - doesn't sound terribly useful, but OK.
11:16:03 <dark> ayrnieu: I tried generating NPCs by hand, but it's actually a lot of work in 3rd edition D&D :)  You can't just say "6th level fighter", you have to construct it from level 1 up.
11:16:48 <ayrnieu> bas - your question is cut off.
11:17:02 <ayrnieu> truncated.
11:17:09 <Heffalump> thank god :-)
11:17:37 <Heffalump> dark: I thought the rulebooks say how to roll higher-level characters
11:18:21 <ayrnieu> dark - ever read the Crpytonomicon (fiction; by Neal Stephenson)?
11:18:27 <dark> Heffalump: as far as I can tell, they say you need to generate them from level 1 up :)  Unless you use their cheesy tables of pregenerated characters, which would make all (e.g.) 6th level fighters identical.
11:18:33 <bas> ayrnieu: oh... i just wanted to know if there is any way to see where the evaluation of a expression goed wrong when i only get the error: Syntax error in expression in hugs...
11:18:37 <dark> ayrnieu: Yep.
11:19:03 <ayrnieu> dark =)
11:19:22 <Heffalump> dark: ah, ok, I thought there were some rules about how to make reasonable assumptions
11:19:32 <dark> ayrnieu: I don't know why you asked though :)
11:19:47 <dark> Heffalump: I suppose you can wing it if you have experience with the system, but I don't :)
11:19:51 <ayrnieu> bas - You might break that up onto multiple lines and use Emacs or Vim to get the parentheses right.  You might also see if GHC gives a more precise error.
11:20:59 <dark> bas: If that huge expression is part of your source, then I suggest giving names to its parts.
11:21:06 <ayrnieu> dark - the main character gets involved with a person of a 'fractally wierd' childhood, relating to the use of applied thermodynamics in D&D?
11:21:18 <bas> never used ghc before... do have it installed.. what's the big difference between hugs and hgc!?
11:21:34 <dark> ayrnieu: I don't remember that :)
11:21:47 <dark> bas: hugs is mainly an interpreter, ghc is mainly a compiler.
11:22:14 <Heffalump> hugs is entirely an interpreter
11:22:47 <ayrnieu> bas - hugs offers an interpreter, is faster as such, and starts up quicker.  GHC's GHCi starts a little slower, but offers more of Haskell (bindings).  GHC also has (terminology failure) concurrency (Hugs only has cooperative).
11:23:19 <bas> right... 
11:23:30 <bas> ghc supports SMP?
11:23:33 <ayrnieu> preemptive.
11:24:31 <ayrnieu> bas - I don't know if it does.
11:24:38 <bas> i want to check out the generic haskell compiler as well..
11:25:47 <ayrnieu> I think that GHC tends to have innovations sooner and better than Hugs.  Concurrent Haskell, for instance.  /me waits for Template Haskell.
11:26:32 <Heffalump> Tim Sheard has implemented Template Haskell for Hugs, I believe
11:26:46 <Heffalump> (before the GHC implementation was written)
11:27:04 <ayrnieu> The GHC implementation has been written?
11:27:23 <Heffalump> well, sort of
11:27:29 <Heffalump> it's in CVS, but lots doesn't work
11:27:46 <Heffalump> ask Igloo about it, he's the local expert
11:28:21 <ayrnieu> OK, thanks.
11:31:27 * ayrnieu wants for Dynamic Haskell, then, with 'hot' code loading.
11:31:32 <ayrnieu> waits for.
11:32:08 <Heffalump> you've seen Marvin's web server?
11:33:35 <ayrnieu> I haven't looked at it.  It has plugins, yes?
11:34:01 <Heffalump> yep.
11:34:08 <Heffalump> uses o3's dynamic loader
12:18:47 <dark> Cool, defining the layout rule is surprisingly easy using Parsec :)
12:23:06 <Igloo> I thought Tim Sheard wrote something hugs-like from scratch to demonstrate what TH would be able to do
12:40:07 <Heffalump> yes
12:41:05 <Igloo> Has he also implemented TH for hugs then? I don't recall seeing any CVS messages about that either
12:49:37 <Heffalump> oh, sorry, you said from scratch
12:49:41 <Heffalump> I thought he patched hugs
12:50:59 <Igloo> ISTR what he had didn't have support for the whole class system, real Integers etc, BICBW
12:51:53 <Heffalump> ah
13:56:08 * dark builds not one, but TWO Parsec layers for his datafiles.
14:00:36 <Igloo> As in a lexer and a parser?
14:09:50 <dark> Yep.
15:19:30 * Stewart002 greets all
15:21:24 <Vulpyne> Hello.
15:22:40 <Stewart002> could you take a quick look at some code I worked up in here last night, there's a feature I want to add and I'm not sure how.
15:23:17 <Vulpyne> Unless it's extremely simple, I doubt I'll be able to help you.
15:23:23 <Vulpyne> I'm a newbie to Haskell. :)
15:23:30 <Stewart002> it's about instances of show.
15:24:20 <Stewart002> I have a custom instance of show linked to a record structure, it returns the whole record with nice formatting. I want to return just a single element formatted.
15:24:46 <Vulpyne> Ah... I have no idea.
15:24:51 <Vulpyne> Sorry.
15:25:00 <Stewart002> unless dennisb or Marvin are awake? they were helping me last night. (and dark isn't here I see)
15:25:07 * Stewart002 pokes dennisb
15:26:00 <Vulpyne> Is it short enough to paste?
15:26:11 <Stewart002> not really, it's on the web
15:26:12 <Vulpyne> Maybe if you do that and wait a while, someone will wake up and give you an answer.
15:26:18 <Marvin--> I'm about to head off to bed, but I have time for a short question...
15:26:27 <Vulpyne> If it were me, I'd post the link and describe my problem.
15:26:31 <Stewart002> marvin :) see above question
15:26:36 <Vulpyne> And then people would see it when they look at their session and possibly help you.
15:26:40 <Stewart002> http://www.starwars-csa.com/haskell.hs
15:27:13 <Stewart002> the 'instance Show Record' is associated with record, can I create one associated to a single element?
15:27:31 <Marvin--> Stewart002: Err, single element being just the origin, or the destination et.c.?
15:27:37 <Stewart002> yes
15:27:42 <Stewart002> instance Show origin ?
15:28:10 <Marvin--> no... In that case you probably want to write your own functions, unrelated to show
15:28:22 <Marvin--> e.g. showOrigin :: Record -> String
15:29:22 <Marvin--> since show is just meant to give a textual representation of a value of a data type
15:29:34 <Stewart002> showOrigin r = putStr origin r   ?
15:29:54 <Marvin--> putStr prints the string to the screen
15:30:08 <Marvin--> show just returns a string, so I think that showOrigin r = origin r is what you really want :)
15:30:15 <Stewart002> sorry, you know I'm dumb :)
15:30:28 <Marvin--> I'm still not sure what you're trying to do
15:30:42 <Stewart002> return a single element rather than the entire record.
15:31:03 <Marvin--> well, that's what the selector functions fno, origin, ... are for...
15:31:15 <Stewart002> if you say 'filterTo "London" flightnumber'
15:31:31 <Stewart002> it should show the fno of all flights going to london
15:31:58 <Marvin--> well, you can use map with fno...
15:32:07 <Marvin--> map fno (filterTo "London")
15:32:26 <Marvin--> since fno :: Record -> String, this expression will have type [String]
15:32:47 <Stewart002> okay, I'm just about following
15:33:17 <Marvin--> I think I left around when you started using records instead, so I'm not sure how much you know of them...
15:33:25 <Stewart002> :) yea
15:33:35 <Marvin--> you get the part about 'fno r' being the fno of a record r?
15:33:42 <Stewart002> I'm recognising patterns in haskell but not a great deal of theory sank in
15:33:50 <Stewart002> yes
15:34:02 <Marvin--> Since r :: Record and a flight number is :: String, then fno, regarded as a function, must have type Record -> String
15:34:14 <Stewart002> yes
15:34:23 <Marvin--> and since it's a function, we can use map :-)
15:34:26 <Stewart002> is map a predefined function or one I make?
15:34:34 <Marvin--> oh, you haven't seen map
15:34:40 * Stewart002 shakes head
15:34:48 <Marvin--> map takes a function and a list, and applies the function to every element of the list, thus creating a new list
15:34:58 <Marvin--> (map :: (a -> b) -> [a] -> [b])
15:35:21 <Stewart002> yes!
15:35:31 <Stewart002> and filterTo "London" returns a list
15:35:35 <Stewart002> of those that match
15:35:36 <Marvin--> exactly, a list of records
15:35:52 <Marvin--> so  map fno :: [Record] -> [String]  (remember partial application)
15:35:53 * Stewart002 watches his last student style penny drop!
15:36:24 <Stewart002> partial appilcation? (uh-oh?)
15:36:36 <Marvin--> oh, I thought we talked about it yesterday...
15:36:50 <Stewart002> maybe, it can't have stuck, I'm sorry
15:37:02 <Marvin--> In Haskell, all functions take only one argument, when we say f :: a -> b -> c, f doesn't take two arguments, f takes one argument, and returns a function :: b -> c
15:37:17 <Stewart002> Ah-ha!
15:37:20 * Stewart002 remembers
15:37:31 <Stewart002> functions calling functions, calling fucntions...
15:37:42 <Marvin--> well, not calling, in this case it's more like returning
15:38:13 <Marvin--> but it's more of a mathematical style of functions, they aren't "called", they just "are"
15:38:24 <Stewart002> so if x has [record] -> string -> bool then it takes a record and returns a string which it passes to a function which has String -> Bool
15:38:48 <Stewart002> the end result is a bool.
15:39:05 <Stewart002> [record] -> (string -> bool) ?
15:39:10 <Marvin--> well, if x :: [Record] -> String -> Bool, then  x applied to a record is a function String -> Bool
15:39:28 <Marvin--> Stewart002: remember that type names start with capital letters
15:39:43 * Stewart002 was typing fast :)
15:39:49 <Marvin--> and yes, there's no difference between   a -> b ->c   and   a -> (b -> c)   in Haskell
15:39:59 <Stewart002> I'm getting there
15:40:11 <Stewart002> I'm still more fond of C++ but I see the attraction of Haskell.
15:40:20 <Marvin--> but now I really should head off to bed, good luck :)
15:40:25 <Stewart002> I'll definately keep learning :)
15:40:33 * Stewart002 thanks you greatly
15:40:38 <Stewart002> good night
15:43:23 <Stewart002> Vulpyne: did you follow all of that?
16:16:18 <bas_> tetryl: what time is in japan right now?
16:16:51 <tetryl> 9:17 am
16:17:13 <bas_> ok, just wondering...
16:17:27 <bas_> want to go there next year actually...
16:17:52 <tetryl> that's good
16:18:02 <bas_> i hope so!
16:18:49 <bas_> is there a lot of haskell'ing in japan?
16:20:20 <tetryl> hmm..No
16:20:33 <Heffalump> Jens Petersen is there
16:20:50 <Stewart002> heya heffalump
16:20:54 <Heffalump> and there's a group at Tokyo uni who do some Haskell
16:20:57 <Heffalump> hi Stewart
16:21:10 <Stewart002> :)
16:22:24 * Stewart002 hates his complicated and busy life... sdl, opengl, haskell, c++, prolog, java, pascal, rpgs, muds, university, money, grumpy girlfriend... sigh
16:23:29 <Heffalump> SDL?
16:23:31 <bas_> Heffalump: is that at todai university?
16:23:46 <bas_> stl?
16:24:12 <Stewart002> Simple Direct Layer
16:24:25 <Heffalump> bas_: http://www.ipl.t.u-tokyo.ac.jp/
16:24:30 <Heffalump> Stewart002: what uni?
16:24:30 <bas_> Stewart002: games programmer?
16:24:41 <Stewart002> Simple DirectMedia Layer rather
16:24:51 <Stewart002> I'm at Lincoln Uni, Hull Campus (UK)
16:25:09 <Stewart002> I'm an aspiring computing lecturer with my finger in many pies
16:25:24 <Heffalump> heh :-)
16:25:27 <Stewart002> well, when I say aspiring.. I mean I'm a 3rd year student hoping :P
16:25:37 <Heffalump> you want to go on to a PhD then?
16:26:06 <Stewart002> yep
16:26:17 <Stewart002> though in theory I could lecture next year
16:27:06 <Heffalump> where are you planning on applying?
16:27:30 <Stewart002> whereever I find a job :) Sheffield has some going I think and so does Lincoln (lincoln campus)
16:27:58 <Heffalump> heh :-)
16:28:38 <Stewart002> I've started dropping hits with my lecturers to mention my name. I'm predicted a 1st so I'm most people's favourite :)
16:31:48 <Stewart002> how about everyone else? what do you guys do when your not here :P
16:31:51 <bas_> now why doesn't this work? new ((Name (Number x)):xs) = Name (Number (max (x+1) y)) where Name (Number y) = new xs ... it seems to add the elements from the array rather than return the hightest entry...!?
16:32:53 <Heffalump> bas_: wdym add the elements?
16:33:07 <Heffalump> Stewart002: I do programming languages research
16:33:49 <Stewart002> heffalump: that would explain your sadistic love of haskell? :P j/k
16:33:57 <Heffalump> Stewart002: absolutely :-)
16:34:06 <bas_> it just sums all the 'x' elements from the array... e.g. new [Name (Number 2),Name (Number 1),Name (Number 0),Name (Number 0),Name (Number 1),Name (Number 0),Name (Number 2),Name (Number 2),Name (Number 2),Name (Number 1),Name (Number 0),Name (Number 0),Name (Number 1),Name (Number 0),Name (Number 2),Name (Number 2)] ... returns: Name (Number 17)
16:34:26 <Pseudonym> Stewart002: Having researched other languages, Haskell is one of the least sadistic.
16:34:26 <bas_> instead of returning Name (Number 3)
16:34:38 <Pseudonym> Unless you're into type theory, of course.  That's pretty bad no matter what language it is.
16:34:55 <Igloo> bas: So what does/doesn't work?
16:35:25 * Heffalump doesn't see why that would break
16:35:30 <Igloo> I guess what I do when I'm not here is about the same as when I am. That probably says something about me  :-)
16:35:39 <bas_> the answer isn't correct... Name (Number 17) is the sum of all the Int's in the array, not the 'max' element!
16:38:03 <bas_> for example new [Name (Number 2),Name(Number 2)] return Name (Number 5) instead of Name(Number 3)
16:38:16 <Igloo> What's the base case?
16:38:22 <bas_> new [] = Name (Number 0)
16:38:57 <bas_> i am staring at this function for a straigh hour now...
16:39:03 <Heffalump> you are using the standard "max" function?
16:39:25 <bas_> standard prelude... just running 'hugs' from the command...
16:39:33 <Igloo> Can you put the code on the web?
16:40:27 <Heffalump> Main> new [Name (Number 2),Name(Number 2)]
16:40:27 <Heffalump> Name (Number 3)
16:40:36 <Heffalump> newtype Number = Number Int deriving Show
16:40:36 <Heffalump> newtype Name = Name Number deriving Show
16:40:39 <Heffalump> new [] = Name (Number 0)
16:40:42 <Heffalump> new ((Name (Number x)):xs) = Name (Number (max (x+1) y))
16:40:42 <Heffalump>     where Name (Number y) = new xs
16:41:51 <Heffalump> you're sure you didn't mix up (x+1) and y and get (x+y) and 1 or something?
16:41:54 <bas_> Heffalump: that's exactly what i have... i don't understand, i do have a different definition of my types...
16:42:09 <Heffalump> that really shouldn't matter, best put your code online somewhere
16:43:12 <bas_> ok, i have it online.. 217.121.242.112/~bas/SEMParser.hs
16:43:46 <bas_> i have problems with the function 'new' in this file...
16:44:22 <Heffalump> I need Parser.hs
16:44:51 <bas_> o yeah... i put it on 217.121.242.112/~bas/Parser.hs
16:45:18 <Heffalump> SEMParser> new [Name (Number 2),Name(Number 2)]
16:45:18 <Heffalump> Name (Number 3)
16:45:55 <bas_> wtf!?
16:46:58 <bas_> ok... maybe it is this buggy module i have hanging in my kernel which does the virtual memory management...
16:47:40 <bas_> so it doesn't reload the file well...
16:47:54 <Heffalump> errm, ok.. :-0
16:48:10 <bas_> anyway thanks for your time, sorry bothering you...
16:48:14 <Heffalump> np
16:48:21 <Heffalump> good luck fixing your kernel...
16:48:35 <bas_> and it's always nice to conclude that it's not me driving crazy...
16:49:08 <bas_> i got it loaded as a module this particular part, so it's already fixed... 
17:35:10 <bas_> i get a 'ERROR - Control stack overflow'... what can that be? too less memory?
17:35:25 <Igloo> Too deep recursion
17:35:56 <bas_> Igloo: too deep recursion... is that like 100 levels, or much more?
17:36:18 <Igloo> No idea
17:36:29 <bas_> ok
17:37:08 <Pseudonym> It usually means unbounded recursion.
17:38:14 <bas_> that's probably the case... but i am using a recursive function with lots of different pattern matched entries... i there a way to display the pattern it stops at (returns the error)!?
17:38:30 <bas_> so i can locate the problem more easily?
17:38:31 <Igloo> The good thing about long compiles is they give you lots of time to stare at Dip maps
17:38:49 <bas_> Dip maps???
17:39:09 <Igloo> Dip(lomacy) is a game
17:39:26 <Igloo> It's not possible as far as I know, no
17:43:05 <gene9> quote: Sorry, no results were found on getting http://www.dum.chalmers.se/~marvin/hws-wp/ 
17:43:19 <gene9> looking at topic
