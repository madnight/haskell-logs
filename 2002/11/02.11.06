00:07:10 <dennisb> bronaugh: not really, that should work
00:08:08 <dennisb> you have some other bug in the program
00:09:51 <bronaugh> there's about 8 LOC other than that.
00:10:09 <dennisb> loc?
00:10:17 <bronaugh> lines of code.
00:10:24 <dennisb> well, this works!
00:11:11 <bronaugh> what the hell.
00:11:14 <bronaugh> I retyped it and it worked.
00:11:57 <dennisb> maybe you hade some strange space, some editors give you ascii 160 (or what it is) instead of 32 when you type shift-space
00:12:16 <dennisb> i've been bitten by that sometimes
00:17:11 <bronaugh> some wierd space issue yeah.
00:17:13 <bronaugh> yuck.
00:17:30 <bronaugh> try to make your code prettier and F it up. great eh
00:35:33 <bronaugh> oh hey clausen 
00:36:45 <bronaugh> how would I cook up a lambda function?
00:39:33 <clausen> I already gave you an example :)
00:39:39 <clausen> (just I didn't tell you it was a lambda function)
00:39:44 <bronaugh> heh
00:39:56 <bronaugh> probem is that I have a list of lists.
00:39:56 * clausen just checks notation
00:40:00 <bronaugh> if it were just a list it'd be easier.
00:40:18 <clausen> \x -> x + 1
00:40:27 <bronaugh> hmm.
00:40:35 <clausen> why?
00:40:51 <clausen> map, filter, and list comprehensions are your friends
00:40:53 <bronaugh> clausen: might be convenient for creating more generally-applicable functions.
00:41:16 <clausen> so, what difference do lambda functions make?
00:41:21 <clausen> (lambda == anonymous, basically)
00:41:42 <bronaugh> pass the function along.
00:41:53 <clausen> oh, you mean high order functions
00:42:15 <clausen> you using hugs?
00:42:38 <clausen> if not, start using it :)
00:42:43 <clausen> then, read Prelude.hs
00:42:57 <clausen> read the source for "map" and "filter"
00:43:12 <bronaugh> using hugs.
00:43:17 <bronaugh> yea, I dug it up.
00:43:49 <clausen> you know how to use map and filter?
00:43:55 <clausen> (google!)
00:44:22 <bronaugh> not entirely, and I will learn.
00:44:35 <bronaugh> I really shouldn't have left this project til the last minute.
00:44:43 <bronaugh> but sickness and statistics intervened.
00:46:29 <clausen> map (+1) [1..5]
00:46:34 <clausen> gets you [2..6]
00:46:44 <clausen> filter (>3) [1..5]
00:46:47 <clausen> gets you [4, 5]
00:47:15 <bronaugh> yeah.
00:47:41 <bronaugh> but what if I want to check if, say, the next element is greater than 20?
00:47:51 <bronaugh> or the next element is less than this element?
00:47:54 <bronaugh> or something like that?
00:49:09 <bronaugh> another q
00:49:13 <bronaugh> why use tuples?
00:50:01 <clausen> what do you mean by "next element" ?
00:50:13 <bronaugh> next element in the list.
00:50:31 <clausen> I don't understand what you mean by that
00:50:38 <clausen> what is "this element" ?
00:50:39 <bronaugh> I mean, I'm walking through a list, right?
00:50:41 <clausen> what is "next element" ?
00:50:43 <clausen> no
00:50:44 <clausen> you're not
00:50:57 <clausen> well, convince me you are
00:50:59 <bronaugh> fine. I'm _recursing_ up a list.
00:51:09 <clausen> so, does "next" just mean "second" ?
00:51:17 <bronaugh> now, I have element x and tail xs
00:51:22 <clausen> yep
00:51:26 <bronaugh> so head xs would be what I'm looking at.
00:51:33 <clausen> ok, now you're making sense :)
00:51:42 <clausen> so, you really mean "second element in a list"
00:51:49 <clausen> thats: (head . tail) list
00:51:59 <bronaugh> explain syntax?
00:52:09 <clausen> head . tail
00:52:12 <clausen> is function composition
00:52:18 <bronaugh> oh right.
00:52:24 <bronaugh> one of those things I don't understand. great.
00:52:33 <clausen> it's pretty easy :)
00:52:34 <clausen> eg:
00:52:39 <clausen> f (g x)
00:52:42 <clausen> can also be written
00:52:44 <clausen> (f . g) x
00:52:49 <bronaugh> yeah.
00:53:06 <bronaugh> alright, now it comes back.
00:53:45 <bronaugh> btw, can you test for equality of tuples?
00:54:12 * clausen playing chess
00:54:14 <clausen> bronaugh: yes, you can
00:54:35 <bronaugh> ok.
00:54:42 <bronaugh> can you do like tuple1 == tuple2?
00:54:46 <bronaugh> if they're the same type?
00:55:11 <mgoetze> bronaugh: get yourself a haskell interpreter and just try things :)
00:55:29 <bronaugh> mgoetze: I've got one.
00:55:34 <mgoetze> (learning by coding is the only good way to learn a programming language)
00:55:54 <bronaugh> mgoetze: I wouldn't disagree with tha.
00:56:01 <bronaugh> (having learned many languages that way)
00:56:14 <bronaugh> but I haven't learned a functional language before.
00:56:32 <bronaugh> and btw, I'm finding it a serious pain in the ass.
00:57:09 <bronaugh> no comment on functional languages. I actually kind of like them.
00:57:14 <mgoetze> bronaugh: oh, functional programming is easy once you manage to stop thinking imperatively :)
00:57:30 <bronaugh> mgoetze: yeah, but that takes more than two or three days.
00:57:48 <mgoetze> anyway, doing the following is easier and quicker than asking on irc:
00:57:49 <mgoetze> Prelude> (1,"a")==(1,"a")
00:57:49 <mgoetze> True
00:58:34 <bronaugh> my problem is that I haven't the faintest clue how to do this problem in a functional language.
00:58:58 <bronaugh> so I'm sitting here, and I ask things, but I'm not getting _ANYWHERE_ because I still can't figure out how to approach it.
00:59:08 <bronaugh> and everything seems to get ugly really fast.
00:59:57 <mgoetze> bronaugh: wassa problem?
01:00:09 <bronaugh> mgoetze: shortest-path.
01:00:26 <mgoetze> :)
01:00:44 <bronaugh> mgoetze: given list of lists basically representing a 2D array containing elevations.
01:00:55 <bronaugh> diff from one to other is cost.
01:01:15 <bronaugh> with the twist that if the cost is greater than 10 it is prohibitive.
01:01:37 <bronaugh> and that if the cost is less than or equal to 0 it is considered to be 1
01:01:53 <bronaugh> then given a list of "streets"
01:01:59 <bronaugh> one way streets.
01:02:04 <bronaugh> so it's a directed graph.
01:02:30 <bronaugh> follow the streets through the map and try not to go up too many hills.
01:02:40 <bronaugh> that's pretty much it.
01:03:02 <bronaugh> it's just _not_ clean.
01:03:10 <bronaugh> in an imperative language it's reasonable.
01:03:15 <mgoetze> you mean, it's nontrivial
01:03:51 <mgoetze> it's certainly easier in a functional language than in an imperative language, *if* you understand functional programming :)
01:04:00 <bronaugh> no, I mean it's going to involve construction and destruction of thousands of lists.
01:04:09 <bronaugh> I can see it.
01:04:13 <bronaugh> way I'm thinking.
01:04:20 <bronaugh> and that's going to be SLOW
01:04:23 <bronaugh> _very_ slow.
01:04:36 <mgoetze> yeah, you're thinking wrong. don't bother constructing or destructing anything. lists just *are*.
01:05:04 <mgoetze> as for speed, let the compiler worry about that. it's probably better at it than you are :)
01:05:10 <bronaugh> no compiler.
01:05:12 <bronaugh> hugs. :P
01:06:03 <bronaugh> but anyhow
01:06:32 <mgoetze> bronaugh: apt-get install ghc, unless you are not using the best linux distro around... lol
01:06:34 <bronaugh> what I'm currently doing is creating a new grid from the old one which contains vertexes
01:06:56 <bronaugh> mgoetze: I'm using Debian; how do you think I installed hugs and ghc?
01:07:04 <bronaugh> mgoetze: prof says 'no ghc' so ... I'm stuck with hugs.
01:07:22 <mgoetze> bronaugh: lol... how, uhm, nice of him. so anyway, it's the prof's problem if it's slow.
01:07:36 <bronaugh> I wrote a solution to another problem.
01:07:59 <bronaugh> my Java solution takes a bit over 10s. My C++ solution is something like 2.5. My Haskell solution is 7.5 minutes.
01:08:02 <bronaugh> under HUGS but still.
01:08:08 <bronaugh> it's awful.
01:09:12 <mgoetze> well, you probably wrote it in an unhaskellish way :)
01:09:21 <bronaugh> most likely.
01:10:39 <mgoetze> and of course you can optimize haskell just as you can any other programming language. i wrote a sieve of erastothenes in haskell the way it was 'intuitive' to me, then proceeded to optimize it and got it faster by two orders of magnitude at least :)
01:11:10 <bronaugh> http://bronaugh.linuxboxen.org/Stamps.hs
01:11:43 <bronaugh> I couldn't even figure out how to do it the way I did it in C++/Java in Haskell.
01:11:50 <bronaugh> so I did it differently. Very differently.
01:15:47 <bronaugh> mgoetze: you interested in that code?
01:16:34 <mgoetze> bronaugh: you mean the C++/Java?
01:17:53 <bronaugh> mgoetze: nah, the link to the Haskell I wrote.
01:18:05 <bronaugh> C++/Java is pretty easy for me; I don't worry much.
01:18:42 <mgoetze> bronaugh: i'm having a look at it parallel to a bunch of other stuff :)
01:19:56 <clausen> bronaugh: you don't know enough about haskell to judge it fairly yet, IMHO
01:20:12 <clausen> bronaugh: even if you don't end up liking it, it's still a useful set of concepts for you to know
01:20:17 <bronaugh> clausen: that's about it.
01:20:22 <bronaugh> clausen: regarding judging fairly.
01:21:10 <bronaugh> clausen: and btw: I actually like haskell.
01:21:18 <bronaugh> clausen: I just find it very frustrating at times.
01:21:47 <bronaugh> and btw, how do I create an instance of a data type?
01:21:49 <clausen> ok :)
01:22:08 <clausen> via type constructors
01:22:16 <bronaugh> yes.
01:22:21 <clausen> eg:
01:22:21 <bronaugh> now how do I create one?
01:22:26 <bronaugh> thanks.
01:22:40 <clausen> type Maybe a = Nothing | Just a
01:22:44 <clausen> instance:
01:22:45 <clausen> Nothing
01:22:52 <clausen> Just [1, 2]
01:22:54 <clausen> etc.
01:23:04 <clausen> (think of Nothing and Just as functions that return the instances)
01:23:05 <mgoetze> bronaugh: first of all, align your =s and ::s.
01:23:24 <bronaugh> no.
01:23:31 <bronaugh> first of all, what should it look like in the end?
01:23:42 <bronaugh> syntax first, please.. then we can talk about semantics.
01:24:15 <mgoetze> syntax includes whitespace :)
01:24:29 <bronaugh> maybe I should go to sleep.
01:24:41 <bronaugh> probably this will make more sense when not put forth at 1:30 in the morning.
01:25:15 <bronaugh> the only problem being it's due way too frickin soon.
01:25:16 <bronaugh> anyhow.
03:45:24 <ibid> hm, how hard would it be for someone like me to try and implement unicode support in ghc? (i have never looked at ghc internals, but i have some experience in implementing unicode in some programs i've written)
03:49:41 <Heffalump> there's been a lot of discussion on various lists about Unicode support, IIRC
03:50:35 <dark> I expect the biggest problem will actually be in the System.IO interface.  None of the Handle functions are set up for a charset specification.
03:51:04 * dark wonders if it would be evil to represent and MD5 sum as Integer.
03:51:28 <Heffalump> why not represent it as a [Word8] or something?
03:52:45 <Igloo> It *is* an integer
03:53:11 <dark> Heffalump: I looked in vain for a Word128 :)
03:53:28 <Heffalump> it doesn't need to be able to grow arbitrarily, though
03:53:40 <Heffalump> I suppose a [ ] has the same problem
03:53:48 <Igloo> I have some code to do md5sums somewhere if you want it
03:54:02 <Igloo> Nothing particularly pretty, but it works
03:54:05 <dark> Igloo: That would be nice.
03:54:08 <Heffalump> ideally it should be a tuple of 16 Word8s, but that'd be annoying without TH to help manipulate said tuple :-)
03:54:16 <dark> Igloo: It's for the HTTP module :)
03:54:38 <Igloo> I think a tuple of 4 Word32s is the obvious representation given the algorithm
03:54:39 <dark> Heffalump: I don't think the individual bytes of it are ever used separately, except as workarounds in languages that don't have Integer :-)
03:54:42 <Heffalump> does HTTP require being able to do MD5sums then?
03:54:47 <Heffalump> ah, ok
03:54:58 <dark> HTTP doesn't require it, but it does allow the recipient to verify a Content-MD5 header if one is present.
03:55:05 <dark> I'm not sure what it should do if the sum doesn't match, though.
03:55:42 <dark> Supplying a function that does the verifying would be nice.
03:56:46 <dark> Actually, in my application I would definitely want to check the sum before applying a downloaded patch.
03:57:13 <Igloo> http://chaos.earth.li/~ian/MD5.lhs
03:57:15 <Heffalump> you want to check a PGP signature in that situation :-)
03:57:19 <dark> Maybe with a --force-badsum flag if people are desperate :)
03:58:14 <Igloo> md5, md5i, md5s give you (Word32, Word32, Word32, Word32), Integer, String respectively
03:58:22 <dark> Igloo: Thanks.  What's the license?
03:59:22 <Igloo> GPL or BSD
03:59:25 <dark> Heffalump: Well it'll be downloaded from a repository.  If it was done with https access then it should be fine.
03:59:32 <Igloo> GPL encouraged  :-)
03:59:41 <dark> Currently I'm using this one on my code:
03:59:45 <dark> -- You may freely use, modify, and distribute this software, as well as
03:59:45 <dark> -- modified versions and derived works of this software, but at your own
03:59:45 <dark> -- risk.  NO WARRANTY is given; not even the implied warranty of
03:59:45 <dark> -- merchantability or fitness for a particular purpose.
04:00:11 <Igloo> That's pretty much BSD isn't it?
04:00:21 <dark> Yeah, but short enough to include in every file without being annoying :)
04:00:34 <dark> With 50-line modules I didn't want a 25-line license.
04:00:40 <Igloo> :-)
04:02:02 <dark> Can I put it under that license?  I'd like to have all files under the same license if possible.  Less complicated that way.
04:02:18 <Igloo> Yeah, sure
04:02:21 <dark> Thanks :)
04:02:42 <dark> (I once considered proposing a DFSG amenmdent, "License Must Not Be More Than 200 Lines Long)
04:02:52 <Igloo> :-)
04:06:47 <ibid> Heffalump: can't find such discussion with google
04:08:07 <Igloo> http://www.google.com/search?hl=en&ie=UTF-8&oe=UTF-8&q=unicode+%2Bsite%3Ahaskell.org
04:09:23 <Heffalump> it was on haskell or haskell-cafe for a while, then wandered off to an i18n list, I think
04:12:15 <ibid> ahh, that
04:12:50 <ibid> but that was general haskell talk, but i'm interested in making it happen...
04:12:59 <Heffalump> ah :-)
04:13:04 <ibid> i need it (and i rather not code my own Char modules)
04:13:13 <Heffalump> check progress on the i18n list and go ahead, then :-)
04:13:19 <ibid> (for my own programs, that is)
04:13:26 <Igloo> I think Marcin might have code to do that sort of thing, but I'm not sure
04:13:53 <Igloo> I haven't found GHC code that hard to get into if you have a bit of time to invest, FWIW
04:14:44 <ibid> to do what sort of thing?
04:15:02 <Igloo> unicode stuff
04:15:41 <ibid> specifically?
04:15:50 <ibid> "unicode stuff" is vague
04:16:06 <Igloo> I don't know
04:16:26 <Igloo> I never got around to looking at it
04:17:39 <ibid> \uhhhh - hehehe (never thought of it that way)
04:22:32 <dark> ibid: What kind of unicode support are you thinking of?
04:22:49 <ibid> fairly basic
04:23:21 <ibid> reading/writing UTF-8 is not important (it's easy to do that manually), but making the Char module work is harder
04:25:04 <ibid> looks like the -i18n folks have good ideas
04:26:00 <dark> Suddenly == on Strings becomes hard :-)
04:26:29 <dark> Hmpf, because just about all HTTP headers are optional, I have Maybe types all over the place.
04:27:20 <ibid> dark: well, yes, you need to define which normalization form to use :-)
04:28:30 <dark> Note that Haskell98 defines a 16-bit Char, while GHC extends it to 20 bits.
04:29:27 <Igloo> Does H98 really? I thought it just said something like "Implementations must conform withthe latest unicode spec"?
04:29:43 <Igloo> And 20 bits seems unlikely seeing as unicode needs about 20.8 IIRC  :-)
04:29:55 <ibid> "The character type Char is an enumeration and consists of 16 bit values, conforming to the Unicode standard [10]. "
04:30:30 <ibid> this was written back when Unicode still talked about 16 bits
04:30:41 <Igloo> Where is that?
04:31:02 <ibid> the revised report says: "The character type Char is an enumeration whose values represent Unicode characters [11]."
04:31:09 <ibid> 6.1.2
04:31:34 <Igloo> Right
04:31:47 <dark> The GHC users guide says maxBound :: Char is 0x10FFFF
04:32:40 <dark> That's not a round number of bits, ick :-)
04:33:09 <ibid> it's what unicode currently specifies
04:34:39 <dark> I guess it's a result of the UTF-16 dance.
04:34:57 <ibid> ?
04:35:40 <dark> ibid: The technique they used to make UTF-16 allows precisely that many additional characters.
04:36:07 <dark> This pairing of codes in the 0xD8xx range, or wherever it was.
04:36:41 <ibid> surrogate pairs
04:38:05 <dark> Current documentation describes UTF-16 as a convenient way to pack UCS-4, but I suspect the real development was the other way around :)
04:40:14 <dark> Hmm, would anyone be upset if I use :/ as a constructor?
04:41:15 <dark> No, I guess that would suck.  I was thinking of Text :/ Plain
04:41:37 <dark> But it's probably easy enough for clients to do their own parsing of simple strings :)
04:46:32 <dark> Hmm, I wonder if I should make the module anal about not sending invalid headers, or if that would just be annoying.
04:46:56 <dark> There's always the escape hatch of adding headers to the "custom headers" list.
05:12:41 * Marvin-- finally got his hands on The Implementation of Functional Programming Languages :)
05:31:23 <BlitzNL> I was wondering; why is #haskell on freenode and not on one of the more default networks like IRCnet, EFNet, DalNet?
05:33:12 * ayrnieu shrugs.
05:34:08 <ayrnieu> Programmers and ilk seem to like OPN.
05:34:53 * BlitzNL is looking up 'to shrug' on dictionary.com .. ahh cool : raise and lower the shoulders to express indifference ;)
05:35:28 <Marvin--> heh
05:38:19 <ayrnieu> Well, that's a rather narrow definition =)
05:38:54 <BlitzNL> ayrnieu: I admit there was more to it, but I am lazy ;)
05:56:19 <mgoetze> BlitzNL: what's so "default" about IRCnet, EFNet or DalNet?
05:59:42 <dark> I think #haskell here is popular because of inflow from #debian-devel.
06:00:10 <dark> It stands to reason that people who use the coolest programming language would also use the coolest operating system.
06:00:22 <mgoetze> so, when will dpkg be rewritten in haskell? :)
06:01:25 <dark> When we kill and exterminate all Python subversives :-)
06:01:35 <mgoetze> module apt-get where install package = dpkg-install (download package)
06:01:48 <mgoetze> dark: as soon as we're done with the php-witchhunt?
06:01:59 <dark> PHP is beneath notice.
06:03:05 <dark> The large binary size of ghc-built executables might be a problem, though :)
06:03:35 <dark> And there's the little detail of providing ghc for architectures other than i386.
06:03:51 <mgoetze> hm... i wonder how much of that is common and could be put into some library.
06:04:07 <dark> Obviously we must first enforce adoption of Haskell everywhere, and worry about these problems later.
06:04:14 <mgoetze> yeah
06:04:34 <dark> mgoetze: Compiled Haskell code is fairly difficult to share, because of all the inlining and specialization going on.
06:04:36 <Igloo> I'm sur eHaskell porting would go faster if AJ announced that sarge wouldn't release until it was ported to at least the 11 released arches  :-)
06:04:47 <dark> mgoetze: But it would be a nice research project, to figure out how much can still be shared.
06:05:16 <mgoetze> like, hey! i just rewrote dpkg in haskell and deleted all the old versions on all the mirrors! oh, uhm, it only works on i386? well, i guess you people will just have to help port ghc! :)
06:05:28 <dark> Igloo: I'm having too much fun programming in Haskell to worry about porting the compiler :)  But that might change once I have a version released, and people start wanting to use it.
06:05:52 <dark> mgoetze: That might be counterproductive, since the autobuilders rely on having dpkg installed :-)
06:06:50 <mgoetze> bah... details
06:07:01 * mgoetze leaves the details to the c-programmers. :)
06:08:42 <Igloo> I have a feeling there are issues with changing "foo x y x = " to "foo = \x y z ->"; does anyone know if this is the case when there is only one such line, and if so does anyone happen to know of a good place to read about it?
06:12:57 <BlitzNL> mgoetze: That's not a statement I can prove mathematically of course, but those 3 networks are the most loaded and popular ones
06:13:39 <dark> Hmm, Haskell98 section 4.4.3, heading "Translation"
06:13:47 <Igloo> Computery things often have big channels here
06:13:56 <Igloo> Well, OS things really
06:14:32 <dark> It says that "foo x y z" is equivalent to "foo = \x y z -> case x y z of x y z -> "
06:14:41 <mgoetze> BlitzNL: that doesn't make them in any way "default". this is a special-purpose network, so it should be considered more "default" for things relating to that purpose than a general-purpose chat netword such as the ones you mentioned
06:14:42 <dark> Oh, mistyped.
06:14:47 <dark> case (x, y, z) of (x, y, z) ->
06:14:56 <mgoetze> (and note that "loaded" is not exactly a compliment when it comes to irc networks...)
06:16:44 <Igloo> I have a feeling the difference is in memoisation or laziness or something, causing potential time or space leaks, but I can't really remember  :-/
06:16:45 <ayrnieu> OPN seems to be less concerned with controlling channels, for instance (look at this one -- we don't even have +t!), than EFnet.
06:17:39 <dark> I don't think it can be a difference in laziness if they have to be semantically equivalent.  The Report is quite careful about that.
06:17:55 <mgoetze> it's our policy not to interfere in channel operations at all if we can avoid it :)
06:18:10 <mgoetze> (btw, the network's called "freenode" nowadays)
06:18:15 * ayrnieu remembers that EFnet:#Perl's strategy was to auto-voice everyone and then devoice annoyances; also to have many ops with channel-protection -- and it *still* got 'taken over'.  The #Perl people've mostly moved to their own network and here, I understand.
06:18:22 <ayrnieu> mgoetze - when did that happen?
06:19:02 <mgoetze> ayrnieu: uhm... coupla months?
06:19:15 * ayrnieu shrugs.
06:19:18 * Heffalump thinks OPN is a much better name :-)
06:19:29 <Heffalump> freenode is too much typing
06:19:30 <ayrnieu> OPN is, by far, a shorter name =)
06:19:31 <mgoetze> hey, i didn't choose the new name :)
06:19:43 <mgoetze> go ahead and call it FN, then :P
06:19:52 <Heffalump> too confusing
06:19:54 <Heffalump> OPN is just right
06:20:24 <Igloo> "FN" "Huh?" "OPN" "Oh" is longer than "OPN"  :-)
06:20:28 --- topic: set to '["mo' nads than you", "We put the Funk in Funktion", "See logs @ http://tunes.org/~nef/logs/haskell/", "Gtk+HS 0.14.10: http://www.cse.unsw.edu.au/~chak/haskell/gtk/"]' by dark
06:20:57 <mgoetze> hehe
06:20:59 <dark> ... speaking of topic :-)
06:21:12 * Heffalump also thinks OPN/FN/whatever has interfered with channels unjustifiably in the past, but that's a political argument best not gone into too much :-)
06:21:39 <mgoetze> Heffalump: feel free to inform me privately of particular incidents which came to your attention :)
06:21:57 <Heffalump> I think all the incidents I'm thinking of were well documented at the time
06:22:12 <dark> I wonder if we should add "welcome back shapr" to the topic, for when he comes back.
06:22:17 <Heffalump> heh :-)
06:22:30 <dark> It would be confusing until that time, though :)
06:22:39 <ayrnieu> "Hello shapr!  How'd the move go?"
06:23:53 <ayrnieu> Yes, too wordy for a topic.
06:23:54 <dark> Does anyone know when he's expected to come back?  I figure he's moved by now but is waiting for a net connection or something.
06:24:11 <dark> More wordy than half-a-page urls?
06:24:52 <ayrnieu> dark - yes.
06:27:02 <ayrnieu> dark - more wordy in the same way that a bit of text is more attention-drawing than a huge colorful pictoral sign.
06:28:24 <dark> That dependson whether the huge sign shows anything naked.
06:29:11 * mgoetze doesn't want to see naked hairy middle-aged men.
06:32:31 * dark wonders where an MD5 module should go in the hierarchy.
06:33:24 <Igloo> It's been allocated a place in the heirarchial modules if that's what you mean?
06:34:29 <dark> Has it?
06:34:53 * ayrnieu wonders if MD5 should be considered 'Cryptographic' (Cryptologic), since it fulfills one of the requirements for information security.
06:35:03 <Igloo> I think so. Somewhere under Data IIRC
06:35:18 <ayrnieu> Igloo - Data?  Not Text?
06:35:38 <dark> ayrnieu: You can take an MD5 of any octet stream.
06:36:32 <Igloo> http://www.haskell.org/~simonmar/lib-hierarchy.html
06:36:38 <Igloo> Data.Digest.MD5
06:36:56 <ayrnieu> http://www.cs.york.ac.uk/fp/libraries/layout.html
06:37:02 <ayrnieu> Data.Encoding.MD5 =)
06:38:05 <Igloo> Ah, OK, I have no idea which is more up-to-date, Simon's was the first google found for me  :-)
06:38:13 <Segora> maybe Algorithms.MD5? :)
06:39:12 <ayrnieu> Algorithms.isAscii ? =)
06:39:37 <dark> Well I like Simon's better :)
06:40:27 <ayrnieu> the other-person's seems more complete, and it says "Death to Misc and Utils" at the top.
06:41:28 <dark> Yeah but there isn't any Misc and Utils in Simon's :)
07:04:57 <dark> This HTTP module seems more and more like work.
07:05:37 <dark> Maybe I should cut the fluff and make one that does only what my program needs :-)
07:07:54 <dark> On the other hand, my program will eventually use DAV, which exposes corners of HTTP that were not meant to see the light of day.
07:13:12 <ayrnieu> What is your program?
07:16:23 <dark> ayrnieu: A version control tool.  I'm implementing something similar to "arch" in Haskell.
07:17:11 <ayrnieu> hm, OK.
07:20:45 <Heffalump> dark: ooh, /me needs a good version control tool
07:20:56 <Heffalump> what features will it have?
07:23:06 <dark> Heffalump: Do you know "arch"?
07:24:01 <Heffalump> not really, no
07:24:38 <Heffalump> where is it atm?
07:24:45 <Heffalump> (I know its homepage seems to keep going walkies)
07:26:39 <dark> The new homepage seems to be at http://www.fifthvision.net/open/bin/view/Arch/WebHome
07:27:26 <dark> My tools features compared to arch will be:
07:27:40 <ayrnieu> It used to be www.regexps.net or somesuch.  The author also had an unexec library and a fork of Guile.
07:27:41 <dark> - Simpler, more regular interface
07:27:45 <dark> - Way faster
07:28:25 <dark> - Anonymous read-only repository access over straight HTTP
07:28:43 <dark> I'll think of more as I go along :-)
07:29:39 <dark> I've tried to quantify "way faster", currently it's 1.5 orders of magnitude for the "get" operation.
07:30:06 <Heffalump> there seems to be lots of things there about how individual patch sets work, but not about how many patch sets are managed
07:30:30 <dark> Each patchset is marked with an archive name, branch, version, and revision number.
07:30:54 <dark> Each patchset has an ancestor, not necessarily in the same archive.
07:31:22 <dark> Hmm, more accurately, each revision has an ancestor :)
07:32:13 <dark> Actually I don't know a good terminology for it.  I might be using it inconsistently, too.  Sometimes "revision" means a patchset, sometimes "a revision" means a tree constructed from an entire history of patchsets back to an origin.
07:34:41 <dark> Okay, what seems to be missing from that site is the documentation that comes with arch itself :)
07:36:20 <dark> There's descriptions in that documentation about various kinds of mergings and branchings.
07:36:54 <Heffalump> right
07:37:26 <dark> Arch can compare the history of two revisions, to find the nearest common ancestor (or merge point), and figure out which patches have and have not been applied to each branch, and then merge them selectively.
07:37:36 <Heffalump> ooh.
07:37:45 <Heffalump> can it work out how to reorder patches?
07:38:13 <dark> The docs have examples of, say, figuring out which bugfixes from the stable branch haven't been merged into the development branch yet.
07:39:02 <dark> Hmm, what kind of reordering?
07:39:39 <Heffalump> well, if patch B was applied after patch A on a branch, and you want to apply B but not A to another branch but then later apply B, you need to work out how to reorder A and B
07:39:51 <dark> I think it can figure out that if you have a - > b -> d -> f in Tree1, and a -> b -> c -> d -> e in Tree2, then the best place to merge c in is between b and d.
07:39:58 <ayrnieu> (oh, hey, there's a new version of haskell-mode; /me delays bug-reports)
07:40:29 <dark> I haven't looked all that closely at all the merging commands, though, because so far I've been the only one working on my projects :-)
07:41:53 <dark> I think the main limitation of the arch system is that it's so patchset-oriented that something like "cvs annotate" is very hard to implement.
07:42:06 <dark> In other words, to get a history of a specific file you need the history of the whole tree :)
07:43:14 <Heffalump> I think that's a price worth paying
07:43:35 <Heffalump> solving the difficult problems with version control really requires a patchset-oriented approach, IMO
07:43:46 <dark> I'm still waiting for a revision control system that can figure out things like "function foo was renamed to bar", though.
07:44:03 <Heffalump> that requires a more sophisticated diff, basically
07:44:10 <dark> Rather than recording all occurrences of changing foo to bar and not seeing the pattern.
07:44:32 <Heffalump> ideally you want your source code represented in a better form
07:44:46 <dark> I think it could be built on top of a refactoring browser, where changes are recorded as lists of refactorings :)
07:45:19 <dark> Well, that's abuse of the term "refactoring", because it would also have to represent functional changes...
07:45:19 <Heffalump> yeah
07:45:54 <dark> Anyway, I'll be ready to publish my tool once I have "get" working over HTTP :)  
07:46:07 <dark> Of course it won't do much else than "get" at that point.
08:11:35 <ayrnieu> I'm sending simonmar a bug-report on Haskell-mode, but I think that I don't remember all the bugs I've noticed; the two that come to mind are: -- taken to start a comment even when occuring in a string, '[' breaking indentation.  Does anyone remember any more?
08:12:18 <ayrnieu> well, '(' also breaks indentation.
08:12:51 <ayrnieu> and ']' and ')' fairly badly -- but these are all related.
08:13:50 <ayrnieu> and I suppose that the layout on 'case' is ugly.
08:25:00 * ayrnieu wonders if Vim is more commonly used with functional languages.
09:37:07 <bronaugh> argh.
09:37:20 * bronaugh still can't figure out how to get data type constructors working
09:38:29 <ayrnieu> hm?
09:38:52 <ayrnieu> data Coin = Heads | Tails
09:39:32 <ayrnieu> flipCoin = do n <- randomRIO (1,2); return if n == 1 then Heads else Tails
09:39:37 <ayrnieu> flipCoin :: IO Coin
09:39:47 <ayrnieu> 'Heads' and 'Tails' are both data constructors.
09:39:50 <bronaugh> AGG
09:40:00 <bronaugh> why the hell won't the prof let us use do or let?
09:40:34 <ayrnieu> Possibly he plans on teaching those later =)
09:40:43 <bronaugh> no, he doesn't.
09:40:53 <ayrnieu> oh.  Shrug.
09:41:02 <Igloo> You don't want to use do or let in general
09:41:03 <bronaugh> makes me want to scream how he's limited this.
09:41:10 <bronaugh> Igloo: alright, you got a better idea?
09:41:20 <Igloo> Well, what do you want to achieve?
09:41:32 <bronaugh> Igloo: data Vertex = Vertex {my_coord :: CoordTuple, adj_list :: [CoordTuple], elev :: Int, dist :: Int, path :: CoordTuple}
09:41:33 <Igloo> flipCoin :: Coin
09:41:43 <bronaugh> Igloo: I want to be able to create an instance of that data type.
09:41:44 <Igloo> flipCoin = Heads is equally valid, if a less fair coin
09:42:12 <ayrnieu> Igloo - err, yes.  'flipCoin :: Coin' isn't very useful =)
09:42:36 <Igloo> No, but flipCoin :: IO Coin is a silly way to explain data constructors to someone
09:43:11 <bronaugh> makeVertex :: CoordTuple -> [CoordTuple] -> Int -> Int -> CoordTuple -> Vertex
09:43:13 <bronaugh> makeVertex c a e d p = { my_coord = c, adj_list = a, elev = e, dist = d, path = p}
09:43:17 <ayrnieu> I don't quite understand that, but OK.  I'm still waiting for a question.
09:43:20 <bronaugh> now how the hell can I make this work?
09:43:32 <ayrnieu> bronaugh - you use the constructor =)
09:43:41 <ayrnieu> Vertex { my_coord = c, ...
09:43:54 <bronaugh> makeVertex c a e d p = Vertex { my_coord = c, adj_list = a, elev = e, dist = d, path = p}
09:44:06 <bronaugh> oh ok what the hell
09:44:07 <bronaugh> that worked.
09:44:36 <ayrnieu> data Connection = Connection Handle Hostname PortNumber
09:44:58 <bronaugh> good.
09:44:59 <ayrnieu> obviously you need 'Connection' somewhere in a construction of this type -- listing 'h hname port' somewhere isn't going to create a Connection.
09:55:17 <Igloo> Grrr, I need to get the ith App constructor working outwards
09:55:42 <Heffalump> to find the ith argument?
09:55:47 <Igloo> Yeah
09:56:24 <Heffalump> maybe you should make an uncurried internal representation for yourself
09:56:32 * ayrnieu doesn't understand "ith App constructor working outwards"
09:56:52 <Heffalump> App (App (App (App "f" "1") "2") "3") "4"
09:57:09 <Heffalump> if he needs the 3rd App constructor working outwards, he needs to find the "3"
09:57:10 <Marvin--> appappapp
09:57:15 <Heffalump> by counting outwards from the inside
09:57:27 <ayrnieu> "working outwards"?
09:57:32 <ayrnieu> oh, OK.
09:57:38 <Igloo> Starting at "f"
09:57:51 <Marvin--> I got my hands on SPJ's book today btw :)
09:58:06 <Marvin--> they had it in storage so I couldn't get it yesterday
09:58:42 <ayrnieu> Igloo - why do you want to get the ith App constructor working outwards, and how are you going to use it once you get it?
09:58:56 <Heffalump> he needs the ith argument to function "f"
09:59:13 <ayrnieu> oh.  App is Apply?
09:59:25 <Igloo> I'm unrolling a recursion on the ith argument to a function
09:59:27 <Igloo> Yup
10:00:11 <ludde> Marvin--: I got 58p on the exam :)
10:00:21 * Marvin-- thinks this course on number theory is starting out slow, on one and a half lecture we've only gotten as far as generalized forms of the fundamental theorems of arithmetics and finitely generated abelian groups
10:00:28 <Marvin--> ludde: I got 58p on the semantics exam
10:00:40 <ludde> Marvin--: ok :)
10:01:02 <ludde> i don't think i would have got 58p if I didn't have you to ask in here.
10:01:17 <Marvin--> yeah I've been way too nice to you
10:01:30 <Marvin--> should've made you mail me instead so I could ignore you easier :P
10:01:41 <ludde> :)
10:01:46 <bronaugh> ohh yeah.
10:01:51 <bronaugh> now it's starting to work!
10:01:52 <bronaugh> :)
10:03:47 <ayrnieu> bronaugh - what are you doing?
10:04:17 <bronaugh> ayrnieu: stuff I should have done 2 weeks ago.
10:04:25 <bronaugh> (in other words, this is last minute crap)
10:04:40 <bronaugh> being deathly ill interfered with me getting my homework done.
10:06:02 <ayrnieu> (deathful illness will do that)
10:06:29 <Marvin--> the bright side is that own funeral usually is an acceptable excuse for not handing in homework
10:06:38 <bronaugh> was running a (probably high) fever for about 5 days.
10:06:40 <bronaugh> it sucked.
10:06:44 <bronaugh> Marvin--: heh
10:07:10 <bronaugh> hmm yeah, hmm... which relative can I claim died... :P
10:07:19 <ayrnieu> bronaugh - what bug did it to you?
10:07:20 <Marvin--> bronaugh: *own* funeral :)
10:07:37 <bronaugh> ayrnieu: some kind of flu.
10:07:44 <bronaugh> ayrnieu: just came at a bad time -- right after the last one.
10:10:15 <bronaugh> odd sidenote tho: I had a statistics test in the middle of it. I got an A on it.
10:10:17 <bronaugh> which is bizarre.
10:11:42 <ayrnieu> Would you normally have gotten an A?
10:11:48 <bronaugh> last test I got a C
10:11:50 <bronaugh> go fig.
10:13:12 <bronaugh> you can add tuples eh/
10:14:09 <ayrnieu> Is that a question?
10:14:13 <bronaugh> yeah.
10:15:28 <ayrnieu> Tuples aren't instances of Num, so the standard arithmetic operators won't work on them.  I don't think you want tuples for this, though.
10:16:00 <ayrnieu> add (n:ns) (m:ms) = n+m : add ns ms
10:16:32 <ayrnieu> to start, to produce a third list from the sums of corresponding elements of two lists.
10:18:38 <bronaugh> oh.
10:18:48 <bronaugh> do you have to worry about divide by zero conditions?
10:18:49 <ayrnieu> addTuple (a,b) (c,d) = (a+c,b+d) -- you can't write a function for the general case.
10:19:40 <ayrnieu> bronaugh - well, ghci just crashed on (div 1 0)
10:20:37 <hdaume> ayrnieu: yeah, that's a known issue -- it's fixed in the CVS version
10:20:44 <hdaume> same thing happens with mod
10:20:58 <ayrnieu> hdaume - OK.  Thanks.
10:20:59 <bronaugh> ok.
10:21:05 <bronaugh> I'll do my standard avoidance tricks then
10:21:06 * ayrnieu remembers that he wants to 'cvs co fptools'
10:21:21 <ayrnieu> import Prelude as P
10:21:36 <ayrnieu> safeDiv n 0 = Nothing
10:21:49 <ayrnieu> safeDiv n m = Just $ P.div n m
10:22:20 <ayrnieu> but I perhaps need P. on Nothing/Just.  ick, anyway =)
10:22:50 <bronaugh> hmm.
10:22:56 <bronaugh> is there any way I can modify just part of a record type?
10:23:15 <bronaugh> (because it's a real PITA writing out the same code again and again)
10:23:24 <ayrnieu> bronaugh - you can produce a new record with just that part modified, yes.
10:23:49 <bronaugh> ok how.
10:24:44 <ayrnieu> http://www.haskell.org/tutorial/moretypes.html
10:25:52 <ayrnieu> data Point = { a :: Int, b :: Int }
10:26:38 <ayrnieu> cr p = p { a = 0 }
10:30:52 <ayrnieu> What is the difference between a 'newtype' and 'data'?
10:31:53 <ibid> possible efficiency
10:32:11 <ibid> there are some restrictions on newtype, iirc
10:32:55 <ayrnieu> "The strictness flag, !, can only appear in data declarations."
10:35:59 <ayrnieu> also, data Point = Point { a :: Int, b :: Int }
10:36:01 * ayrnieu boggles.
10:37:26 <hdaume> ayrnieu: don't think of newtypes as a "limited" datatype.  think of them as a renaming of an old type.  that is "newtype Foo = Foo Int" is more like saying "these are really Ints, but I'm going to call them Foos to make the typechecker help me out".
10:37:37 <hdaume> ayrnieu: it's only for convenience that the syntax is virtually identical
10:38:41 <ayrnieu> Oh, OK.
10:39:09 <hdaume> once the code gets past the typechecker (and a few minor things), the newtypes (Foo, in this case) are removed (for the most part)
10:39:50 <ayrnieu> Contrast "type HostName = String", where you're saying "these are really Strings, but I'm going to call them HostNames occasionally -- you don't worry about that"
10:39:58 <hdaume> exactly
10:40:12 <ayrnieu> =)
10:40:22 <hdaume> "type" is for human readability, newtype is to get the typechecker to help you out
10:41:30 <hdaume> for example, with hostname, suppose you have an invariant that they are Strings with (for instance) no spaces.  if you make it a newtype and have a function 'mkHostName :: String -> Maybe HostName" which rejects things which have spaces, you know you're never going to accendtailly use a hostname with spaces (and the typechecker will *prove* this for you)
10:42:48 <ayrnieu> ah!  OK.
10:43:13 <hdaume> (assuming you don't ever construct hostnames as 'HostName "this is bad"' ;)
10:44:09 <ayrnieu> *nod*  I suppose you could deal with that on the module-level, by exporting mkHostName and not the 'real' constructor.
10:44:17 <hdaume> exactly!
10:44:33 <hdaume> and you've got a very efficient, type friendly ADT
10:44:59 <hdaume> of course, any functionality over String which you also want over HostName you will now have to reproduce yourself
10:45:27 <hdaume> for instance, given our invariante, (++) :: HostName -> HostName -> HostName should be valid, but obviously you'll just have to write it yourself
10:45:30 <hdaume> (and call it something else)
10:48:29 <ayrnieu> OK.  Thanks =)
11:14:50 <dark> hdaume: I have a several-hundred-line Names module that does exactly that for an unreasonable number of types :)
11:15:08 <dark> I used to have all of them as String, then I noticed that I was getting confused about which string was which.  I think it was worth it.
11:15:39 <dark> And I could push all the checking code out to the edges, because the internal functions could know from the type signature that their Foos were valid Foos :)
11:15:56 <dark> The only problem is that I think I'm abusing "show" as the back-to-string operator.
11:16:28 <Marvin--> dark: eew :)
11:16:54 <dark> The funny thing is, I then noticed that the best representation for some of them _wasn't_ String, so now a couple of them are data declarations :)  
11:17:18 <dark> That also had a nice effect of the derived Ord type giving the correct sorting order, by choosing the order of the data elements right.
11:17:32 <hdaume> dark: yeah, i use ints for a variety of things...i basically have two "texts" the words of which are ints, and i represent their positions by ints and their counts by ints.  i systematically went through and replaced each type with a newtype and found two major bugs :)
11:18:28 <dark> hdaume: Yeah I noticed that especially with 2-tuples it was easy to get them in the wrong order :)
11:18:35 <hdaume> i also used MPTCs to make sure that i didn't refer to the position in the first text with a position pointer form the second
11:18:35 <hdaume> yeah
11:20:51 <dark> Okay, I decided that making a generic HTTP module is bad for my sanity, I'll just do the parts I need.
11:20:58 <hdaume> :)
11:24:39 <Marvin--> dark: ugh, yes :)
11:32:23 <jadrian_> hi
11:59:10 <Sydx> hi
11:59:16 <ayrnieu> hello Sydx
11:59:19 <Sydx> a somewhat irrelevant question (to haskell)
11:59:26 <Sydx> nevertheless, i will ask it
11:59:41 <Sydx> does anybody know MAPLE on this channel?
11:59:56 <Sydx> if you do, please say so :) (even if u are a novice)
12:00:45 <ayrnieu> No, though I suspect that EFnet:#math would have such people.
12:01:24 <dennisb> Sydx: i've used it once 7 years ago. is that enough?
12:02:05 <Sydx> hi!
12:02:15 <Sydx> do u know MAPLE, ayrnieu?
12:02:35 <ayrnieu> "No, though I suspect that EFnet:#math would have such people."
12:13:42 <hdaume> that was odd
12:15:28 <ayrnieu> It's a skill to be able to ask questions; some people never get past the ask-to-ask stage.
12:17:25 <ayrnieu> "May I ask a question?  Well, do you know about buildings?  I mean, buildings that are painted red.  Like the one we passed on the way here.  Well, it was right before we passed the fourth Wall-Mart.  On the right.  The right 'coming here'.  Well, it had a stairwell.  On the side; I think all the red-painted buildings had stairwells?  No -- I was just wondering, you know, how that one stairwell didn't reach the ground?  Oh, OK.
12:17:26 <ayrnieu> "
12:17:57 <hdaume> haha
12:35:44 <Marvin--> :)
12:52:35 * ibid actually found a bug ib ghc
13:01:51 <dark> ibid: Well... fix it!!
13:02:05 <ibid> hehe
13:02:22 <ibid> it was a panic with linear implicit parameters
13:02:41 <ibid> i doubt the bug diminishes the usefulness of ghc very much :-)
13:02:44 <ibid> (and i reported it)
13:38:39 <dark> Hmm, does Haskell have a logical "implies" operator?
13:38:51 <hdaume> you could define one :)
13:39:21 <hdaume> (==>) a b = not a || b
13:42:29 <dark> Yeah but that would take up more lines than not using it :-)
13:42:46 <dark> Especially if I also have to think about its infix declaration.
13:43:26 <hdaume> :)
13:48:14 <bronaugh> hm.
13:48:22 <bronaugh> how can I check if the result of a function call is an empty list?
13:48:44 <hdaume> 'null x'
13:49:10 <bronaugh> ahh ok.
13:49:15 <hdaume> or use a case
13:49:25 <hdaume> 'case x of { [] -> it's empty ; _ -> it's not }
13:52:30 <dark> I've been thinking of making functions similar to "maybe" and "fromMaybe", but for lists that might be null.
13:52:38 <dark> Can't think of what to call them, though :)
13:55:23 <hdaume> there are the functions 'maybeToList' and 'listToMaybe'
13:58:36 <clausen> catMaybes
13:58:44 <clausen> map Just
14:00:26 <engstad> So listen, anyone read "Design Patterns" by the "Gang of Four"?
14:00:59 <engstad> Has anyone tried to solve the exact same problems as they do in Haskell?
14:01:01 <clausen> yep
14:01:09 <clausen> no
14:01:13 <engstad> ;-)
14:01:13 * dark wonders what a client should do if a server sends a Connection: close header as part of a 100 Continue response.
14:01:31 <clausen> when I last read that book, I didn't really think they were solving problems, hehe
14:01:39 <dark> hdaume: listToMaybe only takes the head, though.
14:01:55 <clausen> dark: ?
14:01:57 <engstad> clausen: What do you mean?
14:02:10 <clausen> well, I guess I didn't find the book very useful
14:02:13 <clausen> I should try again, I guess
14:02:32 <clausen> brb
14:06:12 <dark> I guess I could call one of them "ifnull"
14:06:14 <dark> ifnull "/" path
14:07:05 <clausen> engstad: I guess, I mean that it was very detailed
14:07:13 <clausen> engstad: and there were lots of subtley different models
14:07:17 <clausen> (well patterns)
14:07:21 <dark> foonull "" ('#':) fragment
14:07:34 <clausen> engstad: and, it didn't give a high-level view
14:07:44 <clausen> (what is the difference?  why bother?)
14:08:27 <engstad> clausen: Hmm, I think you kind of missed the point of patterns. It is much more about giving OO programming a nomenclature than anything else.
14:09:08 <clausen> engstad: I thought the point was to "learn from experience"
14:09:16 <clausen> engstad: i.e. lots of these constructs have been used over the years
14:09:22 <clausen> engstad: "so lets write them all down"
14:09:24 <engstad> clausen: In other words, it is about communication within a team of programmers more than how to solve it.
14:10:14 <clausen> well, that's part of it
14:10:16 <engstad> clausen: Well, that too - but as you know, most of the patterns have probably been used by experienced oo coders in some form.
14:10:24 <clausen> but, to communicate, you have to understand what all the patterns actually are
14:10:30 <engstad> Yes.
14:10:32 <clausen> and that's pretty hard without the high-level view
14:10:52 * clausen gets out the book for an example
14:11:06 <engstad> Let me ask you, what do you mean with "high-level view"?
14:11:37 <clausen> ok, say you have abstract factories
14:11:40 <clausen> and factory methods
14:11:44 <engstad> Okey.
14:12:01 <clausen> I don't recall there being a long discussion about how these two fit together
14:12:19 <engstad> Because they don't?
14:12:39 <clausen> well, actually, you usually implement abstract factories with factory methods
14:12:47 <clausen> so, when do you choose an abstract factory?
14:12:52 <clausen> when do you choose a factory method?
14:13:20 <engstad> You choose whatever fits best with your problem, and as a matter of fact, you probably will _change_ the behaviour slightly as well.
14:13:42 <clausen> engstad: that's a pretty glib answer
14:13:53 <clausen> engstad: it doesn't tell me what the difference between the two things are
14:14:01 <clausen> engstad: (nor the similarities)
14:14:07 <engstad> It's not about "how to solve a problem", it's about having a set of tools available to you.
14:14:33 <engstad> There's tons of "almost-the-same" patterns out there.
14:14:45 <engstad> And variations of the themes.
14:15:26 <clausen> brb
14:16:04 <engstad> The usefullness of the patterns is that I can say: Okey, I solved the XXX problem by creating an abstact factory.
14:16:48 <engstad> Or: The YYY is really a Singleton.
14:17:23 <Marvin--> I find it's useful to have design patterns in mind when discussing design with someone
14:17:54 <clausen> ok, my argument is:
14:18:02 <clausen> if you can't really differentiate between design patterns
14:18:07 <clausen> make generalizations, etc.
14:18:12 <clausen> then you don't really understand the patterns
14:18:36 <Blizz> engstad: I read about what you are stating. It was called the communicatability of design or something. I think patterns are great, but there are too much variants which reduce the usefullnes
14:18:37 <engstad> clausen: Now, _that_ is a valid point. 
14:18:49 <clausen> and, I found that "Design Patterns" didn't really help me
14:20:18 <Blizz> There are some really usefull things, like : singleton, object-pool, visitor, observer. These ones are, I think, great but all these other ones never helped me much
14:20:21 <engstad> clausen: but then you are critizising the layout of the book more than the idea of patterns in software design?
14:20:27 <clausen> engstad: correct
14:20:51 <Blizz> engstad: you mean the white/blue book?
14:21:03 <engstad> clausen: yes.
14:21:09 <engstad> blizz: yes, gang of four.
14:21:49 <engstad> blizz: well i've been using a couple of others, the (hmm what was the name) lightweight object.
14:23:05 <clausen> flyweight?
14:23:15 <engstad> Anyways, my real question was this: If you go through the code (written in C++ and Smalltalk) in that book, is there code that shows how you would do it in Haskell.
14:23:22 <engstad> clausen: Yes, that's the one. :-)
14:23:52 <Blizz> engstad: the first book I read on patterns was by G. Larman (Applying UML and Patterns and this title is on my 'don't read it it sucks list' ;) The second one was the GoF book and I kinda liked it. 
14:24:23 <engstad> blizz: Hehe. ;-)
14:24:40 <Marvin--> Blizz: bah, singleton is just a fancier name for global variable
14:24:59 <engstad> It's an _encapsulated_ global variable. :-)
14:25:09 <Marvin--> Blizz: and I agree with you about Larman, man does it suck
14:25:58 <engstad> I really started hating global variables when I was cleaning up a game (I'm a computer games programmer), where I had to get global variables under control.
14:26:12 <Blizz> Marvin--: I agree on the singleton being global
14:26:24 <Blizz> engstad: Ok but for a game the video is a singleton, right?
14:26:42 <Marvin--> Blizz: we used Larman in a course on "object oriented software development" which consisted mainly of a big project
14:26:43 <engstad> We usually call it the "display".
14:27:10 <Blizz> engstad: you sorry, I am not a native ;) 
14:27:16 <engstad> Hehe. :-)
14:27:20 <Blizz> s/you/yeah
14:27:21 <Marvin--> (we started all chapters in our report with a quote, for example me saying "Singleton is just a fancier name for global variable", it was so-so received by the teachers *cough*)
14:27:37 <engstad> *rofl*
14:28:03 <Marvin--> All quotes were authentic from either group members or our project supervisor :)
14:28:27 <Marvin--> like: "That's when you dress in leather underwear, smear yourself in green jell-o and start coding Java/Swing"
14:28:41 <Blizz> Marvin--: Larman works through a supermarket automation or something, bah
14:29:31 * Blizz remembers: he called it POST 
14:29:36 <Marvin--> Blizz: We consistently read the abbreviation POS not as Point Of Sale, but as Piece Of ... :)
14:29:52 <engstad> *grin*
14:29:56 <Blizz> Marvin--: hehe ;-)
14:34:52 * Igloo gets *that* close to actually using unfoldr
14:37:10 <Marvin--> Igloo: haha
14:38:23 <Igloo> Hmmm, I can actually use it if I wrap the input with Maybe, which I think might actually be worth it
14:39:46 <jadrian> lol
14:39:55 <Marvin--> hey wait, I can define my splitter function in terms of unfoldr
14:40:33 * jadrian never actually tried to think in terms of unfoldr... maybe I should...
14:40:34 <Marvin--> splitter f = unfoldr (\xs -> case xs of { [] -> Nothing; Just (f xs) })
14:41:07 <Igloo> I suddenly realised that if I was thinking of using a fold to put Apps back together that using an unfold to split them probably made sense
14:41:17 <Marvin--> err, ; _ -> that is
14:41:55 <Marvin--> rock on, unfoldr is great
14:45:34 <jadrian> hmmm
14:45:43 <jadrian> is there a lazy version of the IO monad?
14:45:52 <jadrian> iterateM     :: (Monad m) => (a -> m a) -> a -> m [a]
14:45:53 <jadrian> iterateM f x = do 
14:45:53 <jadrian> 	       y  <- f x
14:45:53 <jadrian> 	       ys <- iterateM f y
14:45:53 <jadrian> 	       return (y:ys)
14:46:04 <jadrian> I can use this with Lazy version of ST
14:46:28 <jadrian> it's like an iterate but takes a f ::a->m a
14:46:49 <jadrian> but this cannot be used with IO...
14:46:54 <Heffalump> I doubt it
14:47:34 <jadrian> so how do you do, if you want to create an infinite list with some function that uses IO?
14:50:44 * jadrian needs to think
14:50:45 <jadrian> bbl
14:50:57 <Marvin--> you cou-doh
14:51:23 <Pseudonym> Apparently you can't think around here.
15:40:37 <Igloo> Grrrr!
15:40:53 * Igloo gets to the final stage to find a relevant bit of compiler hasn't been written yet
15:41:33 <Heffalump> lol
15:48:19 <Igloo> Euch, Simon has changed "deriving Show" to "deriving( Show )" lots FNAR
16:22:57 <bronaugh> heh
16:22:58 <bronaugh> ahh ok.
16:23:13 <bronaugh> yuck. I should find a key to wipe my backscroll buffer.
16:39:15 <hdaume> hi all
16:39:41 <Heffalump> hi
16:53:34 <Pseudonym> G'day.
16:57:17 <Pseudonym> Woohoo!  We got an entry in the HC&A report!
16:57:21 <Pseudonym> We're official now.
16:58:15 <Igloo> Cool  :-)
16:58:34 * Igloo should read it some time and see if the stuff I've done is worth of mention
16:59:16 <Igloo> Doesn't seem to be on the web yet?
16:59:26 <Pseudonym> Nope.
16:59:32 <Pseudonym> It's not finished yet.
16:59:40 <Igloo> Ah, OK  :-)
16:59:56 <Pseudonym> http://www.cs.ukc.ac.uk/people/staff/cr3/tmp/communities/draft-report.pdf
16:59:59 <Pseudonym> Don't tell anyone.
17:00:31 * Igloo will wait until it's finished, but thanks for the leak anyway  :-)
17:05:43 <hdaume> Pseudonym: which is yours?
17:20:45 <Heffalump> igloo: you should definitely get an entry in it
17:21:04 <Igloo> For what?
17:21:31 * Igloo didn't think about it until I saw the final reminders and couldn't be bothered to rush reading an old one to see if I'd done anything suitable
17:21:53 <Heffalump> it's about who's doing what in the Haskell community
17:22:08 <Heffalump> since you're doing stuff with and for TH, you should be in it
17:22:26 <Heffalump> (possibly only as part of an appropriate entry from SPJ)
17:22:29 <Igloo> cv  :-)
17:33:31 <Pseudonym> hdaume: I did the HFL entry and the IRC entry.
18:07:45 <dark> fold_lines = foldr foldf []
18:07:48 <dark> Haskell might be bad for me.
18:08:55 <creature> Morning, all.
18:09:12 <Heffalump> hi
18:09:26 <bronaugh> woohoo!
18:09:31 * bronaugh has a 500-line program error message.
18:09:45 <creature> As in, the error is 500 lines, or the program is 500 lines? :)
18:10:17 <bronaugh> the error :P
18:12:14 <bronaugh> Program error: {dijkstra_adj [Vertex_Vertex (1,1) (Vertex_Vertex_adj_list (Vertex_Vertex (1,1) [(2,1)] ++
18:12:17 <bronaugh> starts with that.
18:12:32 <creature> Oh my. Rather you than me.
18:12:35 <bronaugh> and goes on like crazy.
18:12:46 <Igloo> I think that means you have unmatched cases
18:12:59 <Igloo> ghc -Wall is yoru friend  :-)
18:13:01 <bronaugh> Igloo: unmatched cases? explain, I'm interested.
18:13:10 <bronaugh> Igloo: this is hugs, I'll give it a shot on ghc just for fun tho.
18:13:29 <Igloo> It's the equivalent of saysing
18:13:36 <Igloo> foo x | x > 5 = 6
18:13:40 <Igloo> foo 3 = 8
18:13:49 <Igloo> and then trying to evaluate foo 2
18:14:01 <dark> Hmm, ghc is smart enough to warn about that?
18:14:16 <bronaugh> dark: what else could it do with 40M of RAM? :P
18:14:20 <dark> I assumed it would give up when faced with arithmetic in the guards :)
18:14:23 <creature> Woohoo!
18:14:34 * creature has just done all his Haskell work for this week, without any aid at all. :D
18:14:42 <dark> creature: Congratulations :)
18:14:44 <Igloo> Oh, GHC might not actually cope with that case, I can't remember OTTOMH
18:14:44 <creature> And it's funky stuff with lists and recursion, too.
18:14:56 <creature> dark - remember what I was playing with last week?
18:15:02 <creature> Most of it was stuff I'd done in there already. 
18:15:09 <dark> creature: Aha, so you'll be able to use proper Haskell code in future exercises :)
18:15:09 <Igloo> But for the dijkstra_adj example it almost certainly will
18:16:02 <creature> dark - hopefully.
18:16:26 <creature> Hmm.
18:16:43 <creature> For question 1, I'm asked "Give line-by-line evaluations of the following functions".
18:17:02 <creature> Do you think it wants me to write out the functions showing how the recursion works, or add in comments for each line?
18:17:16 <dark> Test.hs:4: Warning: Pattern match(es) are non-exhaustive
18:17:16 <dark>     In the definition of `foo':
18:17:16 <dark>         Patterns not matched: GHC.Base.I# #x with #x `notElem` [3#]
18:17:24 <bronaugh> : undefined reference to `__stginit_Main'
18:17:26 <dark> Igloo: Not entirely accurate :)  It also does it if the guard is x /= 3
18:17:28 <bronaugh> joy. ghc just f'd up.
18:17:47 <dark> bronaugh: Looks like you're just missing a Main.main function.
18:17:47 <creature> I think I'll do both.
18:18:09 <dark> creature: Do the functions work on lines, or something?
18:18:23 <bronaugh> dark: ahh. ok.
18:18:25 <bronaugh> I won't worry about that then.
18:18:31 <Igloo> It's being conservative, which is better than assuming things *are* matched if it gets confused
18:18:59 <bronaugh> btw, why would the program error message be so huge?
18:19:13 <dark> bronaugh: It tries to tell you exactly which cases aren't matched. 
18:19:23 <Igloo> Oh, and depending on what type it gives it it might be right as /= and > may not do the obvious thing
18:19:33 <bronaugh> dark: there's a case not matched...?
18:19:33 <bronaugh> hmm.
18:19:40 <creature> dark - no, they work on ints.
18:19:46 <dark> bronaugh: Well that was Igloo's guess :)
18:19:53 <creature> It's stuff like "fac 6", where fac returns the factorial of a number.
18:20:11 <Igloo> It's not showing you what isn't matched, it's showing you what it was trying to evaluate
18:20:26 <dark> creature: Heh... there's a page on haskell.org somewhere showing dozens of ways to write a factorial function :)
18:20:27 <bronaugh> alright...
18:20:36 <bronaugh> Igloo: does that mean all the data too, for all the recursions?
18:20:38 <Fractal> Ya, I saw that.
18:20:56 <Fractal> factorial n = product [1..n]
18:21:03 <Fractal> That's the most elegant one. :)
18:21:20 * Igloo isn't sure exactly what it does OTTOMH
18:22:00 <dark> creature: Well, they might expect you to write it out like this:
18:22:05 <dark> fac 6
18:22:08 <dark> 6 * (fac 5)
18:22:14 <dark> 6 * 5 * (fac 4)
18:22:28 <dark> creature: Depending on what definition they give for fac, of course.
18:23:08 <dark> creature: I always disliked that kind of question :)  Too vague.
18:23:49 <creature> dark - that's what I'm doing, yes.
18:24:14 <creature> Will Haskell wait until it's done all the recursion to do the multiply, as you've done above? 
18:24:19 <creature> Or will it do something like this:
18:24:22 <creature> fac 6
18:24:27 <creature> 6 * (fac 5)
18:24:31 <creature> 30 * (fac 4)
18:24:44 <creature> 120 * (fac 3) 
18:24:48 <creature> etc ? 
18:25:04 <Fractal> Hmm... Good question. It depends on how product is defined, I suppose.
18:25:22 <Fractal> Normally, a factorial function's multiplication would occur during the "unwinding" stage.
18:26:13 <Fractal> Like, for instance, factorial n = if (n == 1) then 1 else n * factorial n-1
18:26:57 <bronaugh> Igloo or dark: so what does the first thing in that long list of crap mean?
18:26:58 <creature> That's how it's defined here.
18:27:28 <bronaugh> Igloo or dark: the one I pasted
18:27:41 <bronaugh> Igloo or dark: why does it say dijkstra_adj rather than something else?
18:29:29 * Igloo hasn't had that sort of problem with hugs for ages so can't really remembr, but I suspect it means you have an unmatched pattern in dijkstra_adj
18:30:20 <bronaugh> ok, well it takes 2 lists as parameters.
18:30:26 <bronaugh> and another data item.
18:30:31 <dark> bronaugh: Haven't used hugs in years, sorry :)
18:30:35 <bronaugh> and I have cases for each of those being []
18:31:26 <bronaugh> Skates.hs:166: Warning: Pattern match(es) are non-exhaustive
18:31:26 <bronaugh>     In the definition of `dijkstra_adj':
18:31:26 <bronaugh>         Patterns not matched: (_ : _) _ (_ : _)
18:31:32 <bronaugh> hmm, thank you ghc.
18:32:41 <Igloo> Hmmm, I don't understand why GHC is failing
18:32:50 <dark> creature: * is declared infixl, so it's left-associative, which means that a fully lazy interpreter will calculate (6 * 5) before expanding the next factorial.
18:33:09 <dark> creature: However, a Haskell interpreter is not required to be fully lazy, which is why this question is vague :-)
18:33:11 <bronaugh>     Warning: This binding for `elev' shadows an existing binding
18:33:12 <Igloo> Oh, yes I do
18:33:15 <bronaugh> what's that about?
18:33:40 <bronaugh>         Patterns not matched: (_ : _) _ (_ : _)
18:33:45 <bronaugh> and twhat's this?
18:33:53 <bronaugh> Igloo: hmm got an idea?
18:34:10 <bronaugh> (and btw, fsck my prof for saying 'oh dont use ghc...'
18:34:18 <dark> bronaugh: That warning about elev means that you're binding elev (in a let or lambda or do somewhere) in a context where there's already an "elev" identifier visible.
18:34:20 <Igloo> bro: What does the pattern (_ : _) mean?
18:34:28 <bronaugh> dark: oh god.
18:34:34 <bronaugh> dark: possible problems are?
18:34:37 <bronaugh> Igloo: I don't know.
18:34:50 <Igloo> Do you know what _ means?
18:34:52 <dark> bronaugh: Possible problem is that you didn't mean to do that, and end up using the wrong elev :)
18:34:59 <bronaugh> Igloo: not entirely.
18:35:05 <bronaugh> dark: oh joy.
18:35:11 <Igloo> OK, _ matches any value
18:35:19 <dark> (_ : _) _ (_ : _) is obviously a pair of well-endowed siamese twins.
18:35:37 <bronaugh> Igloo: ok, well...
18:35:42 <bronaugh> oh I see.
18:35:49 <Pseudonym> dark: I wrote the factorial page.
18:35:54 <Pseudonym> I found a faster one, though.
18:35:59 <dark> Pseudonym: Cool :)
18:36:42 <Pseudonym> It's not as fast for really large n, but for all reasonable n it's straightforward.
18:37:03 <bronaugh> dijkstra_adj [] _ _ = error "Something bad happened in dijkstra_adk"
18:37:03 <bronaugh> dijkstra_adj v _ [] = v
18:37:05 <bronaugh> dijkstra_adj v s (a:as)
18:37:10 <bronaugh> Igloo: there are my patterns
18:37:58 <Igloo> Ermmm
18:38:28 <bronaugh> how does that not handle (_ : _) _ (_ : _)
18:38:44 <Pseudonym> The most straightforward non-naive factorial is to build a tree of multipliers.
18:38:53 * Igloo can't see why
18:38:55 <Pseudonym> productRange b n
18:39:03 <Pseudonym>   | n == 0 = 1
18:39:08 <Pseudonym>   | n == 1 = b
18:39:17 <Pseudonym>   | otherwise = let n2 = n `div` 2
18:39:18 <Pseudonym>       in productRange b n2 * productRange (b+toInteger n2) (n-n2)
18:39:29 <Pseudonym> Then factorial n = productRange 1 n
18:39:56 <bronaugh> Igloo: no idea?
18:39:56 <bronaugh> dang.
18:40:35 <bronaugh> Skates.hs:257: Warning: Pattern match(es) are non-exhaustive
18:40:35 <bronaugh>     In the definition of `sign': Patterns not matched: GHC.Base.I# _
18:40:39 <dark> Pseudonym: What's the toInteger doing there?
18:41:09 <Pseudonym> productRange :: (Integral a) => Integer -> a -> Integer
18:41:22 <Pseudonym> That's what it's doing there.
18:41:31 <bronaugh> Skates.hs:258: Warning: Pattern match(es) are non-exhaustive
18:41:32 <bronaugh>     In the definition of `sign': Patterns not matched: _
18:41:36 <Pseudonym> That way, factorial :: (Integral a) => a -> Integer
18:41:37 <bronaugh> and nwhat the hell's that about?
18:42:54 <Pseudonym> The swing algorithm is the next one, and above that you need to prime factor n, which is hit-or-miss depending on n.
18:43:01 <bronaugh> neato.
18:43:07 <bronaugh> ok, that pattern WASN'T matched.
18:43:09 <bronaugh> how _interesting_
18:43:41 <bronaugh> now I just have to figure out what the F it would match that my other one wouldn't.
18:44:22 <dark> Pseudonym: I see, that way you do the divving in the presumably faster integral class, and still give correct results.
18:45:41 <Pseudonym> Yes.  If you're doing factorial on Ints, it's faster.
18:45:54 <bronaugh> dark: any clue?
18:46:23 <dark> bronaugh: Not without seeing your code, which I'm not going to do at 5 am :)
18:46:41 <Pseudonym> dark: I did this because I needed a fast algorithm of n choose k over large integers./
18:47:02 <bronaugh> dark: alrighty.
18:47:20 <Pseudonym> It's pretty speedy now even on very large integers.
18:50:23 <dark> Pseudonym: I don't see how it gets to be faster than the corresponding definition using product, though.  Surely you're doing about n multiplications?
18:51:10 <Pseudonym> Yes, but a) there's less stack, and b) the multiplications are about the same size, so the Integer multiplier gets to use faster algorithms.
18:51:23 <Pseudonym> THe Katsuba and FFT multipliers only kick in when both numbers are large.
18:51:45 <Pseudonym> Ideally you want to multiply numbers of sufficiently large order of magnitude.
18:52:13 <dark> Ah, I see :)  I was counting all multiplications as the same cost.
18:52:22 <bronaugh> woah wtf.
18:52:31 <bronaugh> it's getting in something wrong as the second parameter...?
18:53:35 <Pseudonym> dark: If you compute the factorial of 1000, the last multiplication is of a 2500 digit number with the number 1000.
18:53:47 <Pseudonym> Very lopsided.
18:54:23 <Pseudonym> Whereas with the tree multiply, it's a 1100 digit number with a 1400 digit number.
18:54:42 <Pseudonym> Which means the Integer package can profitably use a faster multiply algorith,./
18:55:29 <Pseudonym> The stack is also a big consideration.
18:55:30 * Igloo screams at segfaulting compilers
18:55:38 <bronaugh> Igloo: which?
18:55:51 <Igloo> GHC
18:55:54 <bronaugh> ouch.
18:56:35 <dark> Pseudonym: Hmm, does product use the stack at all?  I'd expect an optimizing compiler to make it iterative.
18:57:44 <Pseudonym> dark: I think it depends on the implementation.  product is usually defined in terms of foldr, so it depends on foldr being inlined and strictness analysis to detect that the accumulator is always evaluated.
18:58:02 <Pseudonym> So under hugs, for example, it would.
18:58:17 <Pseudonym> Under compiled GHC it may not make a difference.
18:59:35 <dark> Well, foldl :)
18:59:42 <Pseudonym> Yes, foldl.
18:59:45 * Pseudonym duhs
18:59:48 <dark> But GHC's prelude writes it out as a recursive function.
19:00:36 <Pseudonym> OK, so that's probably not a consideration under GHC.  The other one is still faster, probably because of the GMP multiply operation.
19:03:48 <Igloo> Aha! It doesn't segfault without -O2. I might still get this working tonight...
19:04:13 <dark> We might need a Haskell Gems book someday :)
19:05:41 <dark> Igloo: I wouldn't trust the output if tinkering with the flags makes the segfault go away :)
19:05:54 <Pseudonym> You mean Functional Pearls?
19:06:18 <Igloo> Oooo, it just compiled!
19:06:24 <Igloo> dark  :-)
19:06:39 <dark> Pseudonym: Well, that might be too generic.
19:06:46 <bronaugh> functional perl? :P
19:07:00 <Pseudonym> I'm planning a series of articles I call Functional Granite.
19:07:01 <dark> Pseudonym: I'd be interested in things that work particularly well in Haskell :)
19:07:21 <Pseudonym> It ain't pretty, but it holds things up.
19:07:25 <dark> Heh.
19:07:36 <dark> Granite can be quite pretty if you polish it right, though.
19:07:42 * Igloo wonders how long this is likely to take to run without optimisation...I think I'll turn the resolution down  :-)
19:08:12 <Pseudonym> Igloo: What is it you're writing?
19:08:49 <dark> bronaugh: perl does have first-class functions :)
19:09:17 <dark> perl is even lazy in places.
19:09:18 <bronaugh> dark: yeah.
19:09:30 <bronaugh> btw.
19:09:32 <Igloo> Pseudonym: This is http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/Mandelbrot/
19:09:34 <bronaugh> do you guys see any diff between these two?
19:09:37 <bronaugh> dijkstra_adj v _ (a:as) = 
19:09:43 <bronaugh> dijkstra_adj v s (a:as)
19:09:50 <bronaugh> any functional diff?
19:10:05 <dark> bronaugh: aside from the missing =?
19:10:24 <Heffalump> where is perl lazy?
19:10:25 <Igloo> One binds s, the other doesn't
19:10:27 <bronaugh> yeah, well, there's code after that.
19:10:27 <dark> bronaugh: The only difference is that the first one doesn't bind s, which doesn't matter if you don't use s anyway.
19:10:45 <bronaugh> haskell employs lazy evaluation, right?
19:10:45 <Pseudonym> Igloo: Gotcha
19:10:45 <dark> bronaugh: It might matter a lot if you have s already bound to something, though, and use it.
19:11:04 <bronaugh> dark: already bound to something?
19:11:12 <dark> Heffalump: When looping over an array (with for), and in constructs like while (<>)
19:11:26 <bronaugh> my thoughts here: Haskell uses lazy evaluation, so if a param has an _ it won't evaluate the source, right?
19:11:34 <dark> bronaugh: having a definition in scope
19:11:45 <bronaugh> dark: and what's scope in this case?
19:11:52 <Heffalump> that's not really lazy evaluation any more than a C loop is lazy evaluation
19:12:04 <dark> bronaugh: Indeed, but it doesn't matter whether it's _ or not -- if you don't use a parameter, it won't be evaluated.  (Unless you play with the IO monad)
19:12:32 <bronaugh> ok.
19:12:48 <bronaugh> well, the only diff there is that the source of s there isn't evaluated in one place and is in another.
19:12:55 <dark> Heffalump: It actually doesn't generate the next array element until the loop body for it is entered.
19:12:59 <dark> Heffalump: I call that lazy :)
19:13:14 <dark> Heffalump: You could rewrite the loop to make that explicit, but... you always can.  That's what ghc _does_ :)
19:13:26 <bronaugh> dark: why would _ match something that s wouldn't?
19:13:33 <Heffalump> dark: wdym it doesn't generate the next array element?
19:13:53 <dark> Heffalump: Well, I misspoke -- for loops over lists, not arrays.
19:14:05 <Heffalump> what's a list in perl?
19:14:44 <dark> Heffalump: a literal list is (a, b, c, d).  It's also what (most) subroutines take as arguments.  You don't see lists often in perl, they get easily converted to arrays.
19:14:53 <dark> Heffalump: They're still there, though.  Lurking. :)
19:15:04 <Heffalump> errrm, unless I'm very confused, they really are identical
19:15:18 <Pseudonym> I thought they were identical.
19:15:58 <dark> Well... about as identical as arrays and pointers are in C, perhaps.
19:17:02 <Heffalump> #!/usr/bin/perl -w
19:17:02 <Heffalump> foreach my $splat ("bar",print "foo\n") {
19:17:02 <Heffalump>    last;
19:17:02 <Heffalump> }
19:17:05 <Heffalump> prints out "foo"
19:17:25 <Heffalump> and it wouldn't if what you claim was true
19:17:58 <dark> Hmm, interesting.
19:18:11 <dark> I was misinformed :)
19:18:58 <dark> I'll go confront the person who taught me this.
19:22:24 <dark> About the difference between arrays and lists -- you can't splice a list, for example.
19:23:02 <Pseudonym> Depends how you implement the list.
19:23:19 <Pseudonym> Splicing skiplists isn't too hard.
19:23:58 <dark> The difference is also visible if you use subroutine prototypes, an "@" parameter has to be a real array.
19:23:58 <Heffalump> a skiplist?
19:24:03 <dark> Pseudonym: I'm talking about perl :)
19:24:16 <Pseudonym> Er... that's why Perl doesn't have lists.
19:24:20 <Pseudonym> It has arrays. :-)
19:24:32 <Pseudonym> Heffalump: It's a random-access list data structure.
19:24:39 <Heffalump> ah, ok
19:24:45 <Heffalump> dark: a real array as opposed to what?
19:24:49 <dark> Pseudonym: Perl doesn't have lists as a datatype.  It does have lists in as a language concept.
19:25:14 <Pseudonym> I disagree.  It can perform list operations on arrays.
19:25:41 <Pseudonym> I don't recall seeing the word "list" anywhere in the Perl documentation.
19:25:44 <Heffalump> #!/usr/bin/perl -w
19:25:44 <Heffalump> sub foo (@) {
19:25:44 <Heffalump>    foreach my $splat (@_) {
19:25:44 <Heffalump>       print $splat."\n";
19:25:47 <Heffalump>    }
19:25:49 <Heffalump> }
19:25:51 <Heffalump> foo(5,3);
19:25:52 <dark> Pseudonym: Then try "man perlfunc" sometime :)
19:25:58 <Heffalump> or are you claiming (5,3) is a real array?
19:26:09 <Heffalump> (which it is, but then I don't know what your definition of a non-real array is)
19:26:41 <Pseudonym> Heffalump: I call that an array.
19:26:46 <Heffalump> list and array are used interchangeably in perl, AFAIK
19:26:50 <Heffalump> Pseudonym: well, me too
19:26:51 <Pseudonym> The foreach construct iterates over arrays.
19:26:58 <Pseudonym> In this case.
19:27:22 * Heffalump is just trying to convince dark :-)
19:27:52 <Pseudonym> dark: I stand corrected.  The word "list" does indeed appear in the Perl documentation.
19:28:20 <dark> Ah, \@ does what I was thinking @ does.  I never used prototypes much :)
19:28:38 <dark> splice (5, 3, 2), 1 doesn't work, for example.
19:29:01 <dark> Whereas: @foo = (5, 3, 2); splice @foo, 1; does
19:29:09 <Pseudonym> Yes.
19:29:23 <Pseudonym> That's because splice isn't a "function" in the way that printf() is a C function.
19:29:37 <Pseudonym> It's a primitive operation, internally.   And I'm pretty sure that splice is a keyword.
19:29:59 <dark> sub mysplice (\@$$@) would take arguments exactly the same way.
19:30:07 <Pseudonym> True.
19:30:12 <Pseudonym> I think it's a function, though.
19:30:17 <Pseudonym> Sorry. it's not a function.
19:30:19 <Pseudonym> I think.
19:30:21 <Heffalump> wouldn't you have to call mysplice with \@foo, though?
19:30:27 <dark> No, just @foo
19:30:31 <Pseudonym> It's been so long since I hacked Perl for a living.
19:30:38 <Heffalump> ok, then perl is sicker than I thought it was
19:30:40 <Pseudonym> Heffalump: Nope, Perl does the obvious thing.
19:30:56 <Pseudonym> Perl is only as sick as a natural language.
19:31:00 <dark> Also, compare:
19:31:06 <dark> @foo = (1, 2, 3, 4)
19:31:10 <dark> %foo = (1, 2, 3, 4)
19:31:19 <Pseudonym> dark: OK, that _is_ sick.
19:31:30 <Heffalump> dark: the second line is initialising a hash with an array, actually
19:31:34 <Pseudonym> The fumbling between arrays and hashes is unnecessary.
19:31:38 <Heffalump> you could just as well do %foo = @foo, AFAIK
19:31:41 <dark> Heffalump: It initializes a hash with a list :)
19:31:56 <dark> Heffalump: Yes, but that _would_ involve a conversion (though it probably gets optimized away)
19:32:17 * Heffalump invokes the "as if"
19:32:19 <Heffalump> rule
19:32:19 <Pseudonym> It makes more sense to use => (which is a synonym for comma).
19:32:53 <Heffalump> but I concede that the splice/mysplice thing means that there's an explicit difference between an array variable and its current value
19:33:39 <Heffalump> and thus that there is some sense in which ( , , , ) notation doesn't always define an array even when used in a context where you might expect an array
19:33:41 <dark> Well, it's always helped me to distinguish between lists and arrays.  I guess this is not universal :)
19:34:18 <Heffalump> dark: you need to show observable differences to prove there is a distinction :-)
19:34:47 <dark> Well, you can call foo (@foo, @bar).  How many arrays is that?  How many lists?
19:35:16 <dark> On the receiving side, foo sees a concatenation of @foo and @bar in its @_
19:35:35 <Heffalump> unless foo has a prototype that says (\@\@), presumably?
19:35:41 <dark> Heffalump: Indeed :)
19:36:05 <dark> Heffalump: If I thought of foo as taking an array, I'd get confused by this call.  But I know it takes a list (in absence of prototypes).
19:36:15 <dark> This is how the distinction has helped me.
19:36:15 <Igloo> Bah, all that for no speedup whatsoever. Bother.
19:36:23 <Heffalump> but foo does take an array
19:36:27 <Heffalump> it's just an array of references
19:36:35 <dark> Heffalump: I see no references here :)
19:36:47 <Heffalump> but you admitted earlier that the \s are inserted implicitly
19:37:11 <Heffalump> do you agree you could do "my ($foo,$bar)=@_; my @foo=@$foo; my @bar=@$bar; ..." in the body of foo?
19:37:12 <dark> No, the \ in a prototype doesn't refer to references.  References are scalars and are prototyped with $ :-)
19:37:21 * Heffalump decides to test this
19:37:55 <dark> Heffalump: Right, you could do that, if foo says (\@\@)
19:38:09 <Heffalump> ok, so a reference is being passed...
19:38:10 <dark> Heffalump: Sorry, I was thinking of the caller's side.
19:38:22 <Heffalump> the caller's side must be inserting an implict \, then
19:38:32 <dark> Heffalump: I'm talking about the more common case of foo taking a list, though.
19:38:50 <Heffalump> can you give me an example of a subroutine that takes a list?
19:38:58 <dark> Heffalump: If the caller inserts an explicit \, it won't work, because that's a scalar instead of an array :-)
19:39:28 <dark> Heffalump: All subroutines do, by default.  But you can prototype it with (@)
19:39:48 * Heffalump --> construct an example to disprove dark's claim
19:39:48 <dark> I think there might still be subtle differences between an (@) prototype and no prototype, but I don't know them.
19:40:12 <Heffalump> oh.
19:40:16 <Heffalump> Type of arg 1 to main::foo must be array (not list) at foo.pl line 12, near "))"
19:40:19 <Heffalump> (as a perl error)
19:41:01 <Heffalump> ok.
19:41:03 * Heffalump admits defeat :-)
19:41:14 * dark grins evilly.
19:41:32 * Heffalump 's internal model of perl semantics is now *REALLY* confused.
19:41:40 <dark> Heffalump: Sorry about that.
19:41:51 <Heffalump> well, better than it being wrong.
19:42:02 * Heffalump thinks the solution is simply to rewrite all his perl code in Haskell
19:42:06 <dark> Heffalump: The confusion might mean you're on the right track, given that it's perl :)
19:42:52 <Pseudonym> Heffalump: Do you have an internal model of English semantics?
19:43:01 <dark> Heffalump: But as far as I know, lists are a purely syntactic construct, they don't exist at runtime.  
19:43:59 <dark> Igloo: Well, you turned off -O2, remember...
19:44:03 <Heffalump> Pseudonym: only inasmuch as I've read much more English than perl
19:44:24 <Heffalump> so I have a very complicated internal model of English semantics that I couldn't possibly explain in its entirety
19:44:35 <Igloo> dark: I want a speedup from a non-TH compiled version to a TH-compiled version. Although it's possible I need optimisation on to see that happen
19:44:38 <Heffalump> and therefore can't really reason about
19:45:24 <dark> I don't know if I believe in English semantics as such :)  I mean, this is a language where any noun can be verbed, and any word can be adjective.
19:46:04 <dark> Oh, and a noun use for every verb.
19:46:18 <bronaugh> ok.
19:46:21 <bronaugh> I formally hate this.
19:46:22 <Heffalump> "verbed" isn't correct English
19:46:38 <bronaugh> why the fscking hell does my pattern matching go to hell?
19:46:39 <dark> Heffalump: You mean you didn't know what it meant, according to English semantics? :-)
19:47:14 <Heffalump> I knew what you meant, but it wasn't correct English
19:47:57 <dark> Heffalump: The same used to be true for "incoming" and "ongoing".  They make perfect sense though.
19:47:59 <Heffalump> I can understand a wider range of sentences than are actually correct English; the key point is that "correct English" is by-and-large a standard that others should also understand
19:49:17 <bronaugh> ok.
19:49:22 <bronaugh> major WTF going on here.
19:49:32 * Heffalump goes to bed far later than he intended to
19:49:39 * Igloo too  :-/
19:49:44 <dark> Yeah, I need to get to bed too.  Before my girlfriend wakes up :)
19:49:50 <Heffalump> you don't have to do a class at noon, though :-)
19:49:54 <dark> But at least I have almost an HTTP module now.  And it uses Parsec :)
19:49:57 <Heffalump> cool.
19:50:11 <dark>     318 Client/HTTP.hs
19:50:11 <dark>     142 Client/HTTPParse.hs
19:50:11 <dark>     460 total
19:50:13 <dark> I like Haskell.
19:51:02 <Pseudonym> Night everyone who is going to bed.
19:51:08 <dark> I was a bit surprised that HTTP takes far more code than FTP, though.
19:52:29 <bronaugh> Program error: {head []}
19:52:35 <bronaugh> FINALLY I have a different error.
19:52:43 <Pseudonym> You know what that means?
19:52:47 <bronaugh> nope.
19:52:48 * Pseudonym figures you would
19:52:50 <Pseudonym> Oh
19:52:57 <bronaugh> Skates.hs:168: Warning: Pattern match(es) are overlapped
19:52:57 <bronaugh>     In the definition of `dijkstra_adj':
19:52:57 <bronaugh>         dijkstra_adj v s (a : as) = ...
19:52:59 <Pseudonym> head doesn't make sense on an empty list
19:53:02 <bronaugh> but I know what that means :P
19:55:26 <bronaugh> ohh.
19:55:28 <bronaugh> disorientation.
20:05:05 <bronaugh> oh god.
20:05:11 <bronaugh> I don't even know WHY this is f'ing up now.
20:07:12 <bronaugh> hmm..
20:07:19 <bronaugh> I hope it didn't hit some infinite recursion there.
20:21:18 <Fractal> My haskell book says "The phrase 'deriving Show' is a way to tell the haskell system that you are interested in printing out values of the data type that you are defining." Huh?
20:22:46 <Pseudonym> THat's a slight lie.
20:22:59 <Pseudonym> However.  Do you know about the "show" function?
20:23:07 <Fractal> Bastard. I want my money back.
20:23:13 <Fractal> No, I don't.
20:23:28 <Pseudonym> What Haskell are you using?
20:23:42 <Fractal> Ummm... hugs at the moment. Should it matter?
20:24:30 <bronaugh> btw.
20:24:38 <Pseudonym> It does for what I'm about to suggest.
20:24:41 <bronaugh> how the F can I get hugs to tell me on what line my code F'd up?
20:24:42 <Pseudonym> Type :t show
20:24:54 <Pseudonym> bronaugh: You don't.  You prove your programs correct.
20:25:03 <bronaugh> Pseudonym: using what, a pencil?
20:25:17 <Pseudonym> bronaugh: If you like, sure. :_)
20:25:36 <bronaugh> I'd rather know why my program right now takes seemingly infinite time to run.
20:26:30 <Pseudonym> You might like to try printf-style debugging.
20:26:32 <Fractal> Pseudonym : I don't see what you mean.
20:26:32 <bronaugh> btw, is there any way to get debug output?
20:27:02 <Pseudonym> bronaugh: import Debug.Trace
20:27:14 <Pseudonym> That gives you a function: trace :: String -> a -> a
20:27:25 <Pseudonym> Which prints the string then evaluates the second argument.
20:27:42 <Pseudonym> Fractal: On the hugs command like, type this:
20:27:44 <Pseudonym> :t show
20:28:13 <Fractal> Oh, actually type...
20:28:14 <Fractal> OK
20:30:25 <Fractal> Ok, I think I understand what show does. Why am I adding "deriving Show" to my data definition?
20:31:02 <Pseudonym> OK.  That puts your type in the Show class.
20:31:11 <Pseudonym> It makes a standard version of the "show" function for you.
20:32:25 <Pseudonym> The reason your book indulges in a slight lie is because you can explicitly write your own instead of deriving the default one.
20:32:29 <Pseudonym> If you want to.
20:32:59 <Fractal> Hm... Ok...
20:34:16 <Fractal> Ah. Ok, I think I see. Thanks.
20:35:23 <Pseudonym> No prob.
20:44:42 <bronaugh> argh.
20:44:43 <bronaugh> burn in hell haskell.
20:44:48 <bronaugh> smallest_unknown_2 [] [] = []
20:44:58 <bronaugh> ERROR "Skates.hs":200 - Type error in explicitly typed binding
20:44:58 <bronaugh> *** Term           : smallest_unknown_2
20:44:58 <bronaugh> *** Type           : [Vertex] -> [Vertex] -> [a]
20:44:58 <bronaugh> *** Does not match : [Vertex] -> [Vertex] -> Vertex
20:45:02 <bronaugh> that's line 200
20:45:05 <bronaugh> smallest_unknown_2 :: [Vertex] -> [Vertex] -> Vertex
20:45:48 <bronaugh> why does _THAT_ happen?
20:49:24 <Pseudonym> [] isn't a Vertex
20:49:27 <Pseudonym> It's a list of something.
20:50:08 <Pseudonym> Haskell is telling you that you said the function would return a Vertex, but here you are returning a list.
20:50:33 <bronaugh> I got it anyhow.
20:50:38 <bronaugh> now it's almost not completely F'd.
21:19:26 <bronaugh> I don't understand this at all.
21:19:57 <bronaugh> I don't understand why, when I run my code out of line, it eats 100% CPU and stays there, and when I run it inline, it produces incorrect results, but doesn't do that.
21:25:48 <Pseudonym> What do you mean "out of line"?
21:26:20 <bronaugh> I mean, I take the function, I cook the data so that it would be what it would get, and I reconstruct the call stack essentially.
21:26:33 <bronaugh> Skates> dijkstra (update_dist (add_streets (make_graph [[10, 15, 20, 25],[19, 30, 35, 30],[10,19,26,20]]) [((1,1),(1,4)),((2,1),(2,4)),((3,4),(3,3)),((3,3),(3,1)),((1,4),(3,4)),((2,4),(2,1)),((1,1),(2,1))]) (1,1) 0) (2,1)
21:26:49 <Pseudonym> As opposed to?
21:27:05 <bronaugh> running the main code.
21:27:10 <bronaugh> which runs that.
21:27:14 <bronaugh> with about those parameters.
21:27:26 <Pseudonym> I suspect the devil is in the "about".
21:27:30 <bronaugh> but which I cannot confirm to run that with those parameters because I can't single step or anything.
21:27:54 <Pseudonym> Did you try trace?
21:28:01 <bronaugh> how does that work?
21:28:06 <Pseudonym> import Debug.Trace
21:28:09 <bronaugh> oh right that thing
21:28:15 <Pseudonym> Then trace "Here i am" (foo x)
21:28:25 <Pseudonym> Prints "Here i am" then executes and returns (foo x)
21:28:51 <Pseudonym> Note: trace ("x = " ++ show x) (foo x)
21:28:54 <Pseudonym> Works very nicely
21:29:25 <bronaugh> ERROR "Debug.Trace" - Unable to open file "Debug.Trace"
21:29:34 <Pseudonym> Uhm...
21:29:45 <bronaugh> this is fscking HUGS
21:30:03 <Pseudonym> Oh, you're not using the hierarchical libraries.
21:30:06 <Pseudonym> Just import Trace
21:31:02 <bronaugh> ohh, that function gets called alright...
21:31:06 <bronaugh> which it should.
21:31:11 <bronaugh> but where the hell does the result go.
21:35:51 <bronaugh> Pseudonym: would you mind looking this code over?
21:35:58 <bronaugh> Pseudonym: if you do I apologize for it. it's a rat's nest.
21:36:04 <Pseudonym> How much is there?
21:36:40 <bronaugh> too much.
21:36:43 <clausen> Pseudonym: know of any good rants about why existential types are good?
21:36:52 <clausen> zoltan didn't talk about it much :/
21:36:54 <bronaugh> the pertinent functions are only about 20 lines.
21:37:09 <bronaugh> clausen: hey, didn't you have a clue too?
21:37:51 <clausen> well, I was able to solve your problems last time...
21:38:03 <Pseudonym> clausen: The short answer is "heterogeneous lists".
21:38:22 <Pseudonym> Haskell + existential types == OOP
21:38:24 * clausen googles
21:38:26 <bronaugh> Pseudonym: http://bronaugh.linuxboxen.org/Skates.hs
21:38:52 <clausen> bronaugh: isn't this school work?
21:38:57 <bronaugh> Pseudonym: the pertinent functions are dijkstra and dijkstra_adk
21:38:58 <bronaugh> adj
21:38:58 <clausen> I mean, shouldn't you be doing this yourself?
21:39:11 <clausen> or at least, modifying the code to something really simple for us to help you with?
21:39:13 <bronaugh> clausen: look, I've been at this 12 hours today. I was at it 6 yesterday.
21:39:32 <bronaugh> I got up in the morning and started on this.
21:39:32 <Pseudonym> clausen: Don't worry, I'm not going to do his work for him.
21:39:42 <bronaugh> I'm not asking for anyone to do my work for me either.
21:39:50 <bronaugh> I'm asking for a fresh set of eyes.
21:40:27 <Pseudonym> OK, what does the trace in findpaths print?
21:40:39 <bronaugh> a lot of ugly stuff.
21:40:47 <bronaugh> but basically, it says djikstra_adj runs.
21:40:53 <bronaugh> and runs correctly by the look of it.
21:40:59 <Pseudonym> OK.
21:41:08 <Pseudonym> So what's the problem then?
21:41:09 <bronaugh> it also says that once the data gets to findpaths it has reverted to the original.
21:41:14 <bronaugh> or sorry.
21:41:21 <bronaugh> not quite the original
21:41:31 <clausen> Pseudonym: google isn't helping me here :/
21:41:33 <bronaugh> dist is left at default.
21:41:44 <bronaugh> known is changed to 1 for all
21:41:58 <Pseudonym> You've lost me completely.
21:41:59 <clausen> hmmm, looks like I found something...
21:42:00 <bronaugh> dist and path don't change, and according to me, they should.
21:42:04 <Pseudonym> You know a lot about this code that I don't.
21:42:25 <Pseudonym> I suggest putting calls to trace inside loops.
21:42:28 <bronaugh> I'll paste it in #flood I guess.
21:42:47 <Pseudonym> That can give you a much better idea what's going on internally.
21:43:08 <bronaugh> I don't have any loops.
21:43:18 <Pseudonym> Recursive calls are loops.
21:43:19 <bronaugh> findpaths is on line 156
21:43:52 <Pseudonym> Say, one in dijkstra_adj in the case which replaces v, saying what it's replaced with.
21:44:01 <Pseudonym> That sort of thing.
21:44:29 <Pseudonym> clausen: Suppose you've got a typeclass.  Say:
21:44:35 <Pseudonym> class Class a where
21:44:43 <Pseudonym> method :: a -> String
21:45:03 <Pseudonym> Then you have some instances:
21:45:15 <Pseudonym> instance Class Int where { method x = show x }
21:45:21 <clausen> http://www.math.luc.edu/~laufer/papers/Haskell/Funlist.hs
21:45:23 <clausen> ?
21:45:24 <Pseudonym> instance Class Bool where { method x = "It's a Bool" }
21:45:26 <Pseudonym> And so on.
21:45:36 <Pseudonym> With me so far?
21:45:41 * clausen reading
21:45:59 <Pseudonym> Oh, that code is interesting.
21:46:27 <clausen> yep, with you
21:46:36 <Pseudonym> bronaugh: I'm sorry I can't help you much here.  Your code is impenetrable, given the amount of time I have here.
21:46:50 <Pseudonym> bronaugh: This is not a reflection on you.
21:46:53 <bronaugh> Pseudonym: oh well, thanks for giving it a shot.
21:47:08 <Pseudonym> clausen: OK.  So you can make a list of type Class a => [a]
21:47:21 <Pseudonym> For example.
21:47:29 <clausen> yep
21:47:33 <Pseudonym> That's a list of things of any type so long as that type is in Class.
21:47:38 <clausen> so, this has something to do with existential types?
21:47:42 <Pseudonym> Yes.
21:47:58 <Pseudonym> OK.  But to do OO what you want is a heterogeneous container.
21:48:08 <clausen> (what does it have to do with it?)
21:48:12 <Pseudonym> You want a list of "Classes", not "a single type which happens to support Class".
21:48:35 <Pseudonym> You want the list to be able to contain both Ints and Bools (if you see the instances I wrote earlier).
21:48:43 <clausen> ah
21:48:48 <Pseudonym> With me?
21:48:53 <clausen> so, Class a => [a] is either [1,2,3]
21:48:57 <clausen> or [true, false]
21:49:00 <clausen> but not [1, 2, true]
21:49:01 <Pseudonym> Right.
21:49:11 <clausen> and we're aiming for the latter
21:49:15 <Pseudonym> Yes.
21:49:23 <Pseudonym> You can do this with existential types.
21:49:36 <Pseudonym> In Haskell, you need to introduce a new constructor:
21:49:47 <Pseudonym> data CLASS = forall a. Class a => CLASS a
21:49:57 <Pseudonym> Then you can have a list: [CLASS 1, CLASS True]
21:50:15 <Pseudonym> Then you can do: let CLASS x = head [CLASS 1, CLASS True] in method x
21:51:08 <Pseudonym> In principle you shouldn't have to do this, necessarily.
21:51:26 <clausen> are those two x's the same?
21:51:37 <Pseudonym> Yes.
21:51:40 * clausen doesn't follow how that should parse
21:52:02 <Pseudonym> Well, you're pulling ot the head of the list first.
21:52:08 <Pseudonym> Then you're removing the CLASS constructor.
21:52:10 <clausen> "let CLASS x  = ... "
21:52:20 <Pseudonym> Then you're left with x, which is a member of Class, though you don't know what.
21:52:24 <clausen> like CLASS has already been defined
21:52:27 <Pseudonym> All you know is that you can call method on it.
21:52:49 <Pseudonym> CLASS is a type constructor, like Just
21:53:33 * clausen didn't realize you could do that anonymously
21:53:40 <clausen> like, I thought you'd have to do something like:
21:53:44 <clausen> f (Class X) = ...
21:54:03 <Pseudonym> Nope.  You can do it in a let too.
21:54:06 <clausen> s/Class/CLASS/
21:54:10 <Pseudonym> No!
21:54:23 <Pseudonym> Class is a typeclass, CLASS is a concrete type and a type constructor.
21:54:54 <Pseudonym> This is where Haskell differs from traditional OO languages.
21:55:16 <Pseudonym> Class membership and type are separate in Haskell.
21:55:35 * clausen always found this a bit confusing
21:55:46 <Pseudonym> In, say, Java, a class is a type.
21:56:10 <Pseudonym> Have you done any Java/C++/whatever?
21:56:14 <clausen> yep
21:56:17 <clausen> all of the above :)
21:56:32 <Pseudonym> OK.  Suppose you have a class provided for you.
21:56:39 <Pseudonym> Say, it's in the standard libraries or something.
21:56:53 <Pseudonym> If you want that class to support another interface, you're stuffed.
21:56:58 <clausen> you can even through C++ STL or java.util.* stuff at me :)
21:57:00 <Pseudonym> You have to write a wrapper around it or something.
21:57:10 <clausen> yep
21:57:12 <Pseudonym> Or use overloading, at least.
21:57:24 <clausen> in java, it's particularly painful without multiple inheritance
21:57:28 <Pseudonym> Right.
21:57:34 <Pseudonym> Well, in Haskell you can do it.
21:57:38 <clausen> like, if you have a different interface...
21:57:39 <clausen> in C++
21:57:44 <Pseudonym> You declare your class, then declare the type as an instance of the class.
21:57:45 <clausen> you could just derive both interfaces
21:57:53 <clausen> and override the second with stuff from the first
21:57:58 <clausen> (but, that's probably very yucky)
21:58:10 <Pseudonym> Because in Java or C++, classes and types are one.
21:59:04 <clausen> so, back to existential types...
21:59:08 <Pseudonym> Yes.
21:59:20 <Pseudonym> Let me digress for a moment.  This will make existential types a bit more clear.
21:59:33 <clausen> no worries :)
21:59:37 <Pseudonym> You know how classes are implemented in a language like Java or C++?
21:59:42 <clausen> (/me still confused by this let business, btw)
21:59:45 <clausen> yes
21:59:50 * clausen has written a compiler like java
21:59:57 <clausen> s/like/for a language like/
22:00:01 <Pseudonym> There's a hidden element in each class which points to the vtable.
22:00:08 <clausen> right
22:00:20 <Pseudonym> OK.  If you use Haskell's approach, you can't do that.
22:00:34 <Pseudonym> Because the vtable can be arbitrarily extended.
22:00:50 * clausen recall's mercury's typeinfo's
22:00:55 <clausen> recalls
22:00:56 <Pseudonym> Exactly!
22:01:35 <Pseudonym> In particular, you don't want to have to pass around an arbitrary amount of vtable along with an Int if you don't need it.
22:01:57 * clausen checks how typeinfo's are different
22:02:22 <Pseudonym> Typeinfos in Mercury support (at the time I last worked with them) three operations: unify, compare and index.
22:02:50 <Pseudonym> They're like a little type class just for those operations.
22:03:17 <clausen> aha
22:03:34 <clausen> oops, type-class stuff are separate to type-info
22:03:34 <Pseudonym> Any of this sound familiar?
22:03:35 <clausen> s
22:03:38 <clausen> there's an extra argument
22:03:39 <clausen> yeah
22:03:42 <Pseudonym> Right.
22:03:52 <Pseudonym> Type class stuff is passed separately.
22:03:55 <clausen> this C++/java way of doing things is still in my veins ;)
22:04:00 * Pseudonym nods
22:04:09 <Pseudonym> You can think of the type class stuff as the vtable.
22:04:21 <Pseudonym> But it's only the vtable for the interfaces you care about.
22:04:42 <clausen> right
22:04:51 <Pseudonym> Now back to the heterogeneous list example.
22:05:15 <clausen> what's that let business?
22:05:16 <Pseudonym> The reason I had to introduce a new constructor, CLASS, is because to make a heterogeneous list, I need to put the vtables in the list somehow.
22:05:21 <clausen> (can you rewrite it without it?)
22:05:32 <Pseudonym> clausen: You could use a where clause.
22:05:36 <clausen> (or give me a simple example of let with, say Maybe?)
22:05:39 <Pseudonym> let foo = bar in baz
22:05:47 <Pseudonym> same as: baz where foo = bar
22:05:51 <clausen> ah
22:05:51 <clausen> thanks
22:06:01 <clausen> but, foo can't be a type constructor?
22:06:07 <Pseudonym> Sure it can.
22:06:28 * clausen didn't know that
22:06:29 <Pseudonym> first pair = fst where (fst,snd) = pair
22:06:31 <clausen> that's funky!
22:06:36 * clausen thought where was just a scoping mechanism
22:06:48 <clausen> yep
22:06:58 * clausen has seen that
22:07:01 <clausen> makes sense now :)
22:07:05 <Pseudonym> OK.  The purpose of CLASS is to provide somewhere to put the vtable.
22:07:13 <clausen> aha
22:07:19 * clausen cuts&pastes the code in another window
22:07:35 <Pseudonym> You'll need to enable non-98 features.
22:08:20 <clausen> I wasn't suggesting I'd actually run it!  :P
22:08:31 <clausen> (you don't actually need a computer to do computer science :P )
22:08:40 <Pseudonym> :-)
22:09:44 <Pseudonym> Do you get the idea?
22:09:48 <clausen> sort of
22:10:03 <clausen> so, CLASS is an instance of Class
22:10:03 <Pseudonym> The last question many people have is why they're existential when the Haskell keyword is "forall".
22:10:16 <Pseudonym> No, it isn't.
22:10:26 <clausen> oops
22:10:28 <Pseudonym> CLASS is a constructor with one argument.
22:10:30 <clausen> CLASS Bool
22:10:35 <clausen> say
22:10:43 <Pseudonym> That argument may be of any type so long as that type is a member of Class.
22:10:53 <clausen> so Class True is an instance of CLASS
22:11:01 <clausen> which happens to also be an instance of Class True
22:11:02 <Pseudonym> No.
22:11:07 <Pseudonym> CLASS True is of type CLASS
22:11:16 <clausen> ah, right
22:12:03 <clausen> so, what's the Last Answer?
22:12:23 <Pseudonym> It's related to the semantics of exists and implication.
22:12:41 <Pseudonym> forall a. (a -> B) is the same as (exists a. a) -> b
22:12:45 <Pseudonym> if -> is logical implication
22:12:45 <clausen> yep
22:12:49 <clausen> it looks like it should be:
22:13:04 <clausen> "forall a CLASS a => Class a"
22:13:07 <Pseudonym> Well Haskell function application types are related to implication.
22:13:17 <clausen> "forall a CLASS a => exists Class a"
22:13:17 <clausen> ?
22:13:27 <Pseudonym> Well, this:
22:13:34 <Pseudonym> forall a. Class a => CLASS a
22:13:36 <Pseudonym> is the same as:
22:13:47 <Pseudonym> CLASS (exists a. Class a => a)
22:14:00 <clausen> ah
22:14:02 <Pseudonym> The => is kind of an implication.
22:14:20 <Pseudonym> If you have a member of Class, then you have a valid CLASS.
22:14:35 <Pseudonym> I don't like the syntax either.
22:14:39 <clausen> hmmm
22:14:55 <clausen> CLASS ((exists a. Class a) => a)
22:14:55 <clausen> ?
22:15:03 <Pseudonym> Possibly.
22:15:12 <Pseudonym> Looks like the second a is outside the quantification there.
22:16:00 <clausen> btw, zoltan set us a cool project
22:16:02 <clausen> (I've submitted)
22:16:07 <clausen> declarative debugger
22:16:14 * Pseudonym laughs
22:16:14 <clausen> mine is about 150 lines for the whole thing :)
22:16:24 <Pseudonym> One of his pet topics.
22:16:28 <clausen> ;)
22:16:29 <Pseudonym> It is cool, yes.
22:16:30 <clausen> it's SOO cute!
22:16:35 <clausen> want to see it?
22:16:35 <Pseudonym> Bernie Pope wrote one for Haskell.
22:16:37 <clausen> (in prolog)
22:16:41 <Pseudonym> Nah, gotta go home.
22:16:41 <clausen> yep
22:16:43 <clausen> ok
22:16:45 <Pseudonym> Thanks anyway.
22:16:46 <Pseudonym> Night./
22:16:46 <clausen> thanks for your help
22:16:47 <clausen> cya!
