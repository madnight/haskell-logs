01:52:06 <esap> I used a lot of time to figure out how you can create abstractions over patterns. But it's possible (I'm positively surprised! :-)
02:16:37 <lament> Aren't patterns abstractions by definition?
02:17:18 <esap> well heh, you could say that.
02:17:31 <esap> But in Haskell there is a problem that patterns are too concrete.
02:17:54 <esap> Since there is a syntactic difference between constructors and functions.
02:18:59 <esap> I mean, this difference is important, but you do need a mechanism to be able to build "larger patterns" from smaller ones.
02:19:39 <esap> And it's not immediately obvious how to do it.
02:20:29 <lament> mm - mmm
02:21:25 <lament> Abstaction as in "giving names to patterns"?
02:21:37 <esap> Right.
02:22:13 <esap> maybe the correct word is "hierarhcial (de)composition" or something.
02:22:36 <lament> hm, composition seems rather obvious
02:23:40 <esap> well you can use the case construct, but it gets too complicated very soon.
02:25:29 <esap> here's an example: consider you wanted to match subtrees of a binary tree. You have a set of common forms that you want to match (which need to be parametrizable with other patterns).
02:28:29 <esap> Something like you want to be able to express the inverse of (Node 1 Empty (Node 2 x y)).
02:31:01 <esap> where x and y are arbitrary ways of constructing subtrees. And you want this in a way that in this inverse, you can use a pattern to match something from x and y.
02:32:13 <esap> something like f (Node 1 Empty (Node 2 x y)) = (x,y) but with a mechanism that you could give a pattern for x and y as argument to that.
02:33:22 <esap> But I think I know how this should be done. You write functions with type a -> Maybe b, then use >>= for combining those.
02:34:07 <esap> then the monad syntax gives a nice way of combining such patterns.
02:35:42 <esap> Somehow, now that I know it it's obvious. But before that, I used a lot of time trying to figure that out. Couldn't find any documentation that told that. :-)
02:35:58 <lament> Oh. I don't understand monads yet.
02:36:59 <esap> lament: you can think of monads as an interface for "sequencing".
02:39:09 <esap> lament: that is, x >>= \a -> y  represents a computation that first does 'x' then does 'y' such that y can use the result of x bound to a. There is a nice syntax for this: do { a <- x ; y }
02:47:50 <lament> Hm, that's certainly the best explanation i've read :)
02:49:19 <esap> The 'return' operation for monads is used to build a primitive computation that just returns a particular value.
02:50:12 <esap> The monad interface has also 'fail', such that a computation may indicate it failed.
02:50:35 <lament> What I don't understand is how monads are supposed to provide IO yet keep the language purely functional.
02:51:36 <lament> You could just say about an imperative language that everything is done in the IO monad, but that won't make it functional
02:51:38 <esap> The reason is that monads separate I/O facilities from the functional parts.
02:52:44 <esap> Another way of viewing a monad is like a 'command pattern' used in C++ etc. an object with type 'IO Integer' for example, is a command that can return an integer.
02:54:01 <esap> The type system keeps 'commands' and evaluation separate such that side effects caused by commands cannot cause problems with the referential transparency of the functional side.
02:54:47 <esap> Referential transparency (e.g. that you can substitute any variable by its value) is essential for the functional side.
02:57:00 <esap> This means that whenever the functional solution best fits the problem, you can use it. Without that (e.g. in normal imperative languages), you lose all the benefits [=improved facilities for combining parts of programs and manipulating values]. 
03:01:33 <esap> In effect, Haskell actually has two languages. One is the 'functional side' that performs manipulation of values. Another is a 'I/O' side that uses those values to determine what input/output to do.
03:02:28 <lament> That's pretty disturbing.
03:02:49 <esap> But those interoperate very cleanly.
03:06:11 <esap> It is very easy to connect the functional side computations with I/O operations, and those functional side computations are only performed if one of the I/O operations requires its result.
03:07:22 <esap> The only constraint is that you cannot encapsulate an I/O operation inside a value whose type does not include the corresponding monad encapsulation.
03:07:47 <esap> for example, you KNOW that Integer -> Integer operation cannot do any I/O.
03:08:16 <esap> But one you change that to Integer -> IO Integer, then you can.
03:09:19 <esap> That is, instead of returning just an integer (value), you return a computation that will return an integer when executed.
03:10:30 <esap> Note that you can manipulate the object of type IO Integer as 'black boxes' and combine those to larger I/O computations like with any other values in the functional side.
03:14:00 <lament> Which is what >>= does anyway?
03:14:16 <esap> Yes.
03:16:02 <esap> But for example, you can do something like: let print x = do { putStrLn x ; putStrLn x } in do { print ; print }
03:16:12 <esap> But for example, you can do something like: let print x = do { putStrLn x ; putStrLn x } in do { print "foo" ; print "bar" }
03:16:29 <esap> This prints two times "foo" and two times "bar".
03:18:11 <esap> The do syntax is useful (and is just easier syntax for various uses of '>>='.
03:20:20 <esap> the 'print' in that example has type String -> IO ()
03:21:15 <esap> and the whole expression has type IO ().
03:25:41 <lament> Why can't a function IO a -> a exist?
03:27:46 <esap> Consider a function with this type: f : IO a -> a. Then consider use of that.
03:28:22 <esap> (f readFromKeyboard, f readFromKeyboard), which would have e.g. type (String, String).
03:28:54 <esap> Now, you have two exactly similar expressions that have different value. This breaks everything.
03:29:04 <lament> I realize that.
03:29:10 <lament> That's why it _shouldn't_ exist
03:29:12 <lament> Why can't it? :)
03:29:35 <esap> Heh, well actually GHC for example provides such function as an extension. It's called unsafePerformIO.
03:30:04 <esap> The unsafe is in the name for a reason :-)
03:31:37 <esap> That operation is actually useful in some cases that you WANT to break referential transparency.
03:31:58 <esap> but most often you don't want that.
03:32:35 <esap> one case where you might want to do that is when you write debugging output. (There is a function called 'trace' for that purpose that uses unsafePerformIO).
03:34:39 <esap> The problem with values that perform I/O is that the I/O is done when the value is evaluated. And the behaviour of the functional side evaluation is so complex that it's very hard to reason about when those evaluations are made.
03:35:05 <esap> That's why you want more structured mechanism.
03:36:07 <esap> Monads are that more structured mechanism.
03:38:50 <esap> There is no problem with the evaluation order when you are not performing side effects.
03:39:56 <esap> It might also become an issue if you want good performance.
05:23:10 <dark> Greetingses
05:51:38 <_FaZeNdEiRo_> 7,12hellooooooooo
05:52:09 <_FaZeNdEiRo_> 7,12huuuu
05:52:16 <_FaZeNdEiRo_> 7,12thats cold here
05:52:20 <_FaZeNdEiRo_> 7,12thats nobody
05:52:29 <_FaZeNdEiRo_> 7,12i can speak portuguese alone
05:52:33 <_FaZeNdEiRo_> 7,12ate q enfim
05:52:39 <_FaZeNdEiRo_> 7,12alguem aki me entende?
05:52:47 <_FaZeNdEiRo_> 1H4e1H4e1h4E1h4E1H4e1H4e1H4e1h4E1h4E1H4e1H4e1H4e1h4E1h4E1H4e
05:52:48 <_FaZeNdEiRo_> 1H4e1H4e1h4E1h4E1H4e1H4e1H4e1h4E1h4E1H4e1H4e1H4e1h4E1h4E1H4e
05:52:49 <_FaZeNdEiRo_> 1H4e1H4e1h4E1h4E1H4e1H4e1H4e1h4E1h4E1H4e1H4e1H4e1h4E1h4E1H4e
05:52:49 <_FaZeNdEiRo_> 1H4e1H4e1h4E1h4E1H4e1H4e1H4e1h4E1h4E1H4e1H4e1H4e1h4E1h4E1H4e
05:52:49 <_FaZeNdEiRo_> 1H4e1H4e1h4E1h4E1H4e1H4e1H4e1h4E1h4E1H4e1H4e1H4e1h4E1h4E1H4e
05:53:19 <_FaZeNdEiRo_> 7,12whats happen?
05:53:27 <_FaZeNdEiRo_> 7,12the cat eat your fingers?
05:54:07 <gdsx> hrm
05:54:17 <_FaZeNdEiRo_> 7,12somebody speaks
05:54:21 <_FaZeNdEiRo_> 7,12ohhhhhhhhh
05:54:29 --- mode: gdsx set +q _FaZeNdEiRo_!*@*
05:54:43 <gdsx> no ops here?
05:55:28 <dark> Apparently not.
05:56:13 <dark> I don't know how to ask chanserv who can get ops here :)
05:56:24 <gdsx> /msg chanserv access #haskell list
05:57:38 <dark> Ok, thanks :)
05:57:44 <gdsx> np...
05:57:51 <gdsx> dark: list looks a bit... sparse... :o)
05:58:30 <dark> Well it's not a large channel :)  But yeah, we have at least twice that many regulars.
05:59:36 <Marvin--> that was certainly...err...amusing
05:59:54 <dennisb> shapr used to be here most of the time and take care of the channel, but he moved and is wainting to get DSL again
06:00:29 --- mode: gdsx set +q *!*HellRais*@*.terra.com.br
06:00:46 <gdsx> cp -q _fazendeiro_
06:00:48 <gdsx> err
06:00:50 --- mode: gdsx set -q _fazendeiro_!*@*
06:01:00 * Marvin-- mutters evilly about sold out concerts :(
06:03:27 <dark> I wonder why fazendeiro targeted #haskell.
06:04:14 <gdsx> mp -p
06:04:18 <gdsx> argh
06:04:26 * gdsx kicks the / key
06:04:30 <Marvin--> he must be paid by the evil ML community!
06:04:34 <gdsx> rofl...
06:04:47 <dark> The ML community is evil?  I didn't know that.  Maybe I should join.
06:05:45 * Marvin-- considers everything evil right now, dammit I really wanted to see Carmina Burana :/
06:06:19 <dark> Maybe "haskell" means something in portuguese.
06:06:54 <gdsx> don't think so... (k's are relatively rare in spanish and portuguese)
07:01:56 <shapr> hey delYsid, ltns
07:02:08 <Marvin--> hey shapr
07:02:13 <shapr> hey marvin
07:02:14 <shapr> wassup?
07:02:21 <Marvin--> nothing much
07:02:34 <Marvin--> I won't be able to go to the carmina burana concert tonight since it's sold out :/
07:02:40 <shapr> that sucks :-(
07:02:48 <Marvin--> tell me about it :/
07:02:55 <shapr> we saw some selections from carmina burana last night here in Boden
07:03:06 <Marvin--> cool
07:03:15 <shapr> some amazing singer did the opera part
07:04:25 <shapr> aha, erc-match-enable.. that's what I was looking for.
07:04:42 <delYsid> no!
07:04:53 <delYsid> you're looking for `erc-match-mode'
07:05:01 <delYsid> thats the whole point of the conversion.
07:05:18 <delYsid> you can use customize now to enable the modules if you just once load erc-auto.el
07:05:25 <shapr> oh
07:05:35 <shapr> thanks :-)
07:05:46 <delYsid> np :)
07:05:48 * shapr has been out of the loop with erc
07:05:59 * delYsid is listening to his users, no matter what :)
07:06:04 <shapr> yay!
07:06:51 <delYsid> at least you're back, I've seen you using <cough> irssi
07:06:51 <shapr> hey delYsid, you doing more Haskell?
07:06:55 <shapr> what me?
07:07:06 <shapr> I don't think I've used anything other than erc
07:07:17 <delYsid> ah
07:07:18 <shapr> oh, I used mirc once on someone else's computer
07:07:19 <delYsid> ahhh
07:07:23 <delYsid> mhp what was :)
07:07:26 <shapr> whew
07:07:31 <delYsid> er, not much haskell these days
07:07:39 <liiwi> shapr!
07:07:41 <delYsid> I'm still too much fond of lisp macros to leave it behind.
07:07:43 <shapr> liiwi!
07:07:49 <shapr> hey, Haskell will have macros very soon ;-)
07:07:52 <shapr> Template Haskell
07:07:53 <delYsid> have done ecasound.el recently, and alot of debian packaging
07:08:17 <shapr> latest erc seems much faster
07:08:33 <delYsid> ah, the 1116 snapshot?
07:08:51 <delYsid> or cvs
07:08:55 <shapr> cvs
07:08:59 <shapr> I'm using ERC 2.93 $Revision: 1.312 $ with XEmacs 21.4 (patch 8) "Honest Recruiter" XEmacs Lucid!
07:09:08 <delYsid> I'm using ERC 2.93 $Revision: 1.316 $ with Emacs 21.3.50.1!
07:09:14 <shapr> uh oh, time to update
07:23:38 <Stewart002> hi all
07:26:12 <Stewart002> anyone here wanna help me take my first tender steps in haskell?
07:31:25 <Stewart002> anyone home?
07:32:45 <Marvin--> yes
07:32:54 <Marvin--> ask away
07:33:06 <Stewart002> yay
07:33:52 <Stewart002> I've defined a string variable and yet I get a compile error Syn
07:33:52 <Stewart002> tax error in input (unexpected symbol "str") 
07:35:53 <Stewart002> I'm new to this, used to C++ or java and it's just confusing me (I can do the maths/function side but the syntax/layout is throwing me)
07:38:33 <Marvin--> hmm, what've you written?
07:38:46 <Stewart002> can I paste here without spamming out?
07:38:57 <Marvin--> oh wait, are you using an interactive interpreter?
07:39:02 <Marvin--> hugs? ghci?
07:39:11 <Stewart002> hugs
07:39:24 <Marvin--> you can't define variables from inside of hugs, but maybe you've got the definition in a file?
07:39:52 <Stewart002> I've made a file called haskell.hs and I'm putting everything in there.
07:40:04 <Stewart002> I'm then just loaded or reloading it and getting errors
07:40:26 <Stewart002> (my typing is awful today, ick)
07:40:44 <Marvin--> okay
07:41:01 <Marvin--> you can paste a few lines, but don't paste the whole file :)
07:41:07 <Stewart002> should I paste here or im pm?
07:41:24 <Stewart002> str :: String
07:41:24 <Stewart002> main :: IO ()
07:41:24 <Stewart002> main =  do putStr "Type Something: "
07:41:24 <Stewart002>         str <- getLine
07:41:24 <Stewart002>         putStrLn ("You typed: " ++ str
07:41:25 <Marvin--> doesn't seem to be so much activity here anyway, so go ahead
07:41:35 <Stewart002> that's the relevant parts
07:41:53 <Marvin--> ah, first of all, you don't have to put str :: String there
07:42:07 <Marvin--> the   str <- getLine  part will take care of that automatically
07:42:12 <Stewart002> ah.
07:42:13 <dark> You need to align the str and putStrLn lines under "putStr", too.
07:42:21 <Marvin--> yes
07:42:27 * Marvin-- was getting to that ;)
07:42:37 <dark> Okay, I'll leave you to it then :)  I need to go out with my girl anyway.
07:42:45 <Marvin--> dark: ;) have fun
07:42:58 <Marvin--> Stewart002: in fact, the global declaraton str :: String is totally unrelated to str <- getLine
07:43:08 <Stewart002> undefined variable putStr
07:43:24 <Stewart002> Marvin: I'm a totally newbie to this.
07:43:39 <Marvin--> err, putStr should definitely be defined
07:44:02 <Stewart002> import Prelude hiding (putStr, getLine, sequence_)    <-- problem?
07:44:11 <Stewart002> I copied most of this from the haskell site
07:44:28 <Cryptor> Stewart002: thats definitely a problem.
07:44:31 <Marvin--> err, yes, if you hide the definitions it woun't find them :)
07:44:36 <Marvin--> won't even
07:44:38 <Stewart002> :)
07:44:44 <Stewart002> It compiled :)
07:45:09 <Stewart002> woohoo, it types back to me :P (all I have to do now is make a database in there somewhere...)
07:45:24 <Marvin--> heh
07:45:51 <Stewart002> how would I go about storing  record?
07:46:47 <Stewart002> all unique records with 9 elements
07:47:12 <Marvin--> storing in what?
07:47:37 <Stewart002> erm, ah, erm... Let me start over.
07:48:18 <Stewart002> I have to write a system that will read a set of records (about air flights) so that you could say when does x flight depart, where to, etc.
07:49:34 <Marvin--> hmm, is it a school project or something?
07:49:37 <Stewart002> yes
07:49:43 <Stewart002> programming paradigms
07:49:46 <Marvin--> okay, so you basically want to read some stuff from a file?
07:50:06 <Stewart002> not necessarily from a file (I can store the data in the program)
07:50:29 <Stewart002> I have to do the same program in 4 langauges (pascal, java, prolog and haskell)
07:50:31 <Marvin--> oh
07:50:35 <Marvin--> right
07:50:48 <Marvin--> Then I suggest you have a look at algebraic data types
07:51:06 <Stewart002> I can handle the recurring functions etc but it's the haskell commands that throws me :)
07:51:42 <Stewart002> like this? 'b',4) :: (Char,Integer)
07:52:04 <Stewart002> oops, missed the first (
07:52:32 <Stewart002> ('b',4) :: (Char,Integer)    <---- like that
07:52:37 <Marvin--> tuples is one example of algebraic data types, but you can define your own too
07:53:08 <Stewart002> okay, so intead of a tuple it would be an nineple (or whatever?)
07:54:02 <Stewart002> I've found 2 possible statements, type or data?
07:54:22 <Marvin--> data
07:54:28 <Marvin--> and they're not statements :-)
07:54:40 * Stewart002 holds head and sways
07:55:23 <Marvin--> you can use type to create synonyms...  type MyTuple = (Int, Char)  for example
07:56:45 <Stewart002> (flight number, departure time, arrival time, origin, destination, duration, movie, meal) <-- that's my record.
07:57:18 <Stewart002> (string, float, float, string, string, float, bool, bool)
07:58:28 <Marvin--> sure, you can use a big tuple if you like
07:58:36 <Stewart002> type Record = (String, Float, Float, String, String, Float, Boolean, Boolean) <-- look right?
07:58:55 <Marvin--> yup
07:59:10 <Stewart002> hmm: Und
07:59:10 <Stewart002> efined type constructor "Boolean" 
07:59:32 <Marvin--> sorry, Bool
07:59:36 <Stewart002> thanks
08:00:04 <Stewart002> okay, that compiled.
08:00:26 <Stewart002> now, to populate my set of records?
08:00:49 <Stewart002> ooh, [] around it makes it a set yes?
08:02:58 <Marvin--> no, that makes it a list
08:06:49 <Stewart002> okay, so, I have 22 records to store, how do I generate 22 instances of Record (or a list/set). How would you store this? :)
08:08:49 <Marvin--> well, if you just want to put the information in the program you can write something like...  foo = [("a", 1.0, 2.0, "b", "c"...), ("asdf", 453.13,36,..), (...), ... ]
08:09:27 <Stewart002> and literally foo would work, I wouldn't have to define it as Record?
08:09:45 <Marvin--> Haskell will figure out the type of foo automatically
08:10:09 <Stewart002> Haskell is intelligent then (it's just well hidden)
08:10:54 <Marvin--> heh
08:12:30 <Stewart002> see you in 10 minutes, typing in data now
08:12:58 <Stewart002> ooh, is there a Time type?
08:14:07 <Marvin--> not that I know of
08:14:31 <Stewart002> saves me putting 09.30 then :)
08:14:40 <Stewart002> 9.3 much easier
08:15:52 <Marvin--> wait a sec, there is a Time module
08:16:50 <Marvin--> which has a type CalendarTime, but maybe that's a bit unnecessarily detailed
08:17:03 <Stewart002> yea. just a comparable number works for me.
08:17:34 <Marvin--> maybe you should use (hour, minute) then
08:17:51 <Marvin--> (9, 0) > (8, 59) for example
08:18:17 <Stewart002> 9.0 >8.59 though, it's the same.
08:18:44 <Stewart002> it's just stored, not updated or anything.
08:19:23 <Marvin--> your call :)
08:19:38 <Stewart002> if it all works at the end I might add that :)
08:19:51 <Marvin--> I never trust equality comparison on floats/doubles, but maybe that's unfounded
08:20:13 <Stewart002> so anyway, how do I go about searching/retrievng this data from the list?
08:21:57 <dark> Stewart002: Take a look at "filter".
08:22:40 <dark> You could make for example a function "from" which takes a placename and a Record, and returns a Bool that says if that Record is a flight from that placename.
08:23:03 <dark> Then you could use: filter (from "Amsterdam") foo
08:23:13 <dark> to extract all records that are flights from Amsterdam.
08:23:40 <Stewart002> I'm searching for filter now (haskell.org has no search... :( )
08:23:50 <dark> It should be in the Prelude.
08:24:05 <Marvin--> Stewart002: you can either read the source code or check the ghc docs...
08:24:16 <Marvin--> dunno where the hugs docs are
08:24:45 <dark> I tend to extract the ghc source and look in libraries/base/
08:25:15 <dark> But the standard prelude is at http://haskell.org/onlinereport/standard-prelude.html, and the standard library is at http://haskell.org/onlinelibrary/
08:25:17 <Marvin--> http://www.haskell.org/ghc/docs/latest/html/base/Prelude.html
08:28:54 <Stewart002> so from "Amsterdam"... how does it know which column is the From column?
08:29:00 <Stewart002> or rather which element.
08:29:26 <Marvin--> Stewart002: well, that's for you to define, isn't it? :)
08:29:37 * Stewart002 holds head again.
08:29:58 <Stewart002> in the Type 'statement'?
08:30:02 <Marvin--> I mean, you have a big tuple with different types in the coordinates... surely you have already defined which is the origin?
08:30:39 <Marvin--> so your from function would reflect that by comparing the string argument with the correct coordinate in the tuple argument...
08:31:01 <Stewart002> type Record = [(Flight String, Departure Float, Arrival Float, From String, To String, Duration Float, Movie Bool, Meal Bool)] <-- like that ?
08:32:30 <Marvin--> no
08:32:35 * Stewart002 is stupid
08:32:37 <Marvin--> Flight String is not a type
08:32:58 <Marvin--> what I mean is that you have an informal definition in your mind
08:33:04 <Stewart002> yes
08:33:16 <Stewart002> just not in the program
08:33:17 <Marvin--> you as the author know that the fourth coordinate is the origin
08:33:25 <Stewart002> yes
08:33:57 <Marvin--> so you can write: from s (_,_,_,t,_,_,_,_) = s == s'
08:35:02 <Stewart002> just lost you there
08:35:06 <Stewart002> I'm nearly with it
08:35:07 <dark> He meant s == t
08:35:17 * Stewart002 gets it
08:35:48 <Marvin--> sorry
08:36:02 <Stewart002> so s is the criteria, t is the actual
08:36:17 <Marvin--> I wrote s' instead of t first, but then I thought that maybe the prime is confusing, so I changed to t, but only in one place it would seem :)(
08:36:22 <Marvin--> yup
08:36:24 <dark> Yeah, from has type String -> Record -> Bool
08:37:45 <Marvin--> Stewart002: the interesting thing is partial application of functions, from :: String -> Record -> Bool as you would expect. But also,  from "Foo" :: Record -> Bool
08:37:54 <Stewart002> all I have to do is make it a fucntion and learn how to call it :P
08:38:27 <Marvin--> oh, and the _ are wildcards meaning "I don't care about this"
08:39:16 <Stewart002> right. so now I have to form from into a fucntion... I'll give it a go :P (I'm with you on the theory, again the syntax holds me back)
08:39:31 <dennisb> I would use a record instead of a tuple with eight components
08:39:49 <dennisb> Stewart002: the syntax is written above!
08:40:03 <dark> Stewart002: What Marvin-- showed you is a valid definition of foo, that's one of the cool things about Haskell :-)
08:40:16 <Stewart002> dennisb: read back, you'll see I'm a moron :(
08:40:35 <dennisb> Stewart002: don't worry, we all are
08:40:56 <Stewart002> dennisb: lol, but if your a moron, your a moron who can code haskell :P
08:41:03 <dennisb> true
08:41:03 <dark> Stewart002: It's called "pattern matching", you can write down what a function's arguments should look like, and the Haskell compiler checks that they indeed look like that.
08:41:04 <Marvin--> dark: s/foo/from/ ;)
08:41:12 <dark> Marvin--: Oh, yeah.
08:41:32 <Marvin--> *all* my functions aren't called foo :-)
08:41:38 <dark> Well, all mine are!
08:41:52 <Stewart002> so, flame me now but...
08:41:56 <dark> Sometimes I use foo' and foo'' for clarity.
08:42:35 <Stewart002> from :: String ->Record -> Bool
08:42:35 <Stewart002> 	return s (_,_,_,t,_,_,_,_) = s == t
08:42:42 * Stewart002 holds breath
08:42:48 <dennisb> syntax error
08:43:03 <Marvin--> Stewart002: no, what you did is define a function called 'return' :-)
08:43:09 <dark> Stewart002: foo isn't an IO function, so you don't need "return".  You can just write down what its return value should be.
08:43:20 * Stewart002 turns green
08:43:26 <dark> Well yeah, you also forgot the actual "from =" part :)
08:43:30 <Stewart002> okay, so, no return
08:43:47 <Stewart002> from :: String ->Record -> Bool
08:43:47 <Stewart002> 	from = s (_,_,_,t,_,_,_,_) = s == t
08:43:49 <Marvin--> Stewart002: you can actually write exactly what I said (minus the typo)
08:43:57 <Marvin--> Stewart002: no, now you have two '='
08:44:06 <dark> Sorry about that, I confused you with "from =".
08:44:25 <Stewart002> I'm really confused. I know what I'm doing, just not HOW.
08:44:32 <dark> from s (_,_,_,t,_,_,_,_) = s == t
08:44:54 * Marvin-- watches Stewart002 slap his forehead and go "D'oh!"
08:45:17 <Stewart002> Haskell 98 does not support anonymous type variables 
08:45:39 <dark> This has three parts: the first is "from", the name of the function you're defining.  The second is "s (_,_,_,t,_,_,_,_)", a pattern that describes its arguments (in this case something you call "s" and a 9-tuple where you call the fourth value "t").  The third part is the return value, "s == t".
08:47:01 <dennisb> Compare with the simpler function double, written in haskell: double x = 2*x
08:47:31 <dark> dennisb: Might be confusing to someone who's used to languages where "double x" is a variable declaration :-)
08:47:40 <dennisb> hmm, stupid me
08:47:44 <Stewart002> lol
08:47:45 <dark> twice x = 2 * x
08:47:52 <Stewart002> I get the fucntions thing, it's clearing
08:47:54 <dennisb> twice is a better name
08:48:17 <Stewart002> so s is the group of records, t is the element taken from each, where they match the function returns true?
08:48:22 <dark> Another example, with shorter tuples:
08:48:28 <dark> type Point = (Int, Int)
08:48:49 <dark> xpos (x, _) = x
08:49:06 <Stewart002> dark: A getX routine!
08:49:24 <dennisb> the type of xpos is:   Point -> Int
08:49:24 <dark> You can also use multiple patterns to define a function, in which case the first one that matches is used:
08:49:29 <dark> is_origin (0, 0) = True
08:49:34 <dark> is_origin (_, _) = False
08:50:00 <Stewart002> so I have:
08:50:01 <Stewart002> from :: String ->Record -> Bool
08:50:01 <Stewart002> 	from s (_,_,_,t,_,_,_,_) = s == t
08:50:54 <dennisb> I find it relaxing to explain simple haskell to people... #haskell is like a spa to me..
08:51:00 <Stewart002> this will search them and return true from all matching elements, how do  call it?
08:51:01 <dark> Right.  This is only a helper function, it can be used by another function like filter.
08:51:14 <dark> Stewart002: The searching needs to be done by some other funtion.
08:51:23 <dark> For example: filter (from "Amsterdam") flights
08:51:36 <dark> (I'm assuming "flights" is your big list-of-records)
08:52:11 <Stewart002> actually it's Flights :P
08:52:23 <dennisb> from is just a simple helper function. Look at the type and you should understand what it do
08:52:45 <dark> Stewart002: You can't do that, Flights starts with a capital letter and in Haskell that means it's a type or data constructor.
08:53:03 <Stewart002> ick
08:54:05 <dark> In general, "filter f xs" returns a list of all elements x from xs where f x is true.
08:54:15 <Stewart002> so filter picks out the records, from checks whether the destination is the requested one...
08:54:34 * Stewart002 always hated maths :P
08:54:41 <dark> Stewart002: Whether the origin is the requested one, presumably :)
08:55:28 <dark> Stewart002: filter has a fairly simple recursive definition, if you prefer that to the mathy one.
08:55:32 <Stewart002> from is tool used by filter to filter the records...
08:56:13 <dennisb> yes, it is a help function
08:56:19 <dark> filter f (x : xs) = if f x then x : filter f xs else filter f xs
08:56:21 <dark> filter f [] = []
08:57:06 <dennisb> I think that is hard to read for a beginner..
08:57:08 <dark> if (f x) then (x : filter f xs) else (filter f xs) might be clearer to a beginning haskell programmer :)
08:58:08 <Stewart002> I follow, it's theory of sequences. if it's true keep it in the list, move on, now I see.
08:58:10 <dark> Hmm, yeah, you have to know the syntax for list construction to read that.
08:58:42 <Stewart002> I've studied formal system specification
08:58:51 <dark> Stewart002: Right.  Now, the value for f here, (from "Amsterdam"), is a partial application of the from function.  Marvin-- mentioned that earlier.
09:00:20 <Stewart002> particular application?
09:00:30 <Stewart002> you mean it can be used in different ways?
09:00:37 <dennisb> Stewart002: you get the 5 minute introduction of haskell, including many of the advanced features at once!
09:00:53 <dennisb> The thing to understand is the types
09:00:55 <dark> dennisb: Do you think I'm going too fast?
09:01:06 <dennisb> no, it's up to Stewart002 to say stop
09:01:10 <Stewart002> dennisb: I'm learning more here than in 3 weeks of readying books and net tuts
09:01:23 <dennisb> from :: String ->Record -> Bool
09:01:32 <Stewart002> I'm asking what I don't understand but I'm really happy that you guys are helping :)
09:01:40 <dennisb> I assume you understand that type?
09:02:01 <dennisb> what it really should look like is: from :: String -> (Record -> Bool)
09:02:21 <Stewart002> from takes a string, applied it to a record and returns a bool?
09:02:26 * Stewart002 stabs in the dark
09:02:31 <dark> Ow!
09:02:35 <dark> He stabbed me.
09:02:37 <Stewart002> oops
09:02:39 <Stewart002> lol
09:02:45 <dennisb> no, it takes a string and returns a function of type (Record -> Bool)
09:02:50 <delYsid> yay, partial application!
09:03:12 <Stewart002> ah, I understand, nesting in a form?
09:03:19 <delYsid> take this:
09:03:21 <delYsid> (1+)
09:03:23 <dark> Just for that, I'm going to introduce list comprehension :-)
09:03:30 <delYsid> gives you a functions, which adds one to its argument
09:03:31 <dark> filter f xs = [ x | x <- xs, f x ]
09:03:48 <dark> This definition might look closer to what you're used to from formal system specification.
09:04:03 <dark> "x where x is from xs, and f x"
09:04:21 <Stewart002> not really
09:04:26 <Stewart002> hold on
09:04:40 <Marvin--> it's just like defining a set
09:04:49 <dark> Stewart002: Okay, if it doesn't help, then ignore it :)  It's just an extra bit of syntax.
09:05:01 <dennisb> the list of all x where x is from xs, such that f x is true
09:05:14 <dark> dennisb: I guess that's a more accurate reading.
09:05:26 <dennisb> and xs is a list
09:05:54 <Stewart002> I'll copy an url from my system specification course.
09:06:05 <Stewart002> http://staff.dc.lincoln.ac.uk/~preeve/Teaching/CMP232/currency.rtf
09:06:14 <Stewart002> example assignment specification
09:06:30 <dennisb> hmm... rtf....
09:06:52 <Stewart002> beats pdf (lecturer loves rtf, pdf, ps...bleh)
09:06:55 <dark> I don't have any console tools for viewing rtf :)
09:07:07 <dark> This should probably be rectified.
09:07:12 <Stewart002> dark: ahem, any text editor
09:07:25 <dark> (rectify, v: to insert in one's ass)
09:07:40 <delYsid> dark: if you figure that out, tell me for the Debian Accessibility project, thats a sort of open question for me
09:08:06 <dark> Stewart002: In theory, perhaps... but it's got more markup than text.
09:08:08 <Marvin--> Stewart002: uh, isn't rtf for word processing?
09:08:19 <Stewart002> eg:
09:08:20 <Stewart002> add: C × C à C
09:08:20 <Stewart002> substract: C × C à C
09:08:20 <Stewart002> multiply: C × N à C
09:08:20 <Stewart002> divide: C × N à C
09:08:44 <Stewart002> where à should be and ->
09:09:01 <Stewart002> pre and post conditions
09:09:21 <dark> delYsid: unrtf perhaps
09:09:39 <dark> Or you could do something horrible with rtf2latex, latex, dvi2ps, and pstotext
09:09:42 <Stewart002> Marvin: Maybe, it's the generic type above txt
09:09:43 <delYsid> unreliable..
09:09:46 <dark> And put it in LESSPIPE :-)
09:10:15 <Marvin--> Stewart002: I thought it was defined by microsoft? that makes it less than generic in my book
09:10:32 <dark> Well the best rtf viewer I've found is Ted, but it wants a graphical interface.
09:10:40 <dark> Marvin--: Public specs, though.
09:10:56 <dark> Marvin--: A marked improvement over .doc :)
09:11:01 <Marvin--> I don't see how it's more "generic" than ps though
09:11:36 <dark> delYsid: You've tried unrtf?
09:11:48 <delYsid> yup
09:11:56 <Stewart002> meh, anyway, back to my screaming agonising nightmare.. haskell :P
09:12:01 <delYsid> doesnt work for some files, dunno why
09:12:11 <dark> delYsid: file bugs!
09:12:59 <Stewart002> filter (from "Amsterdam") flights  <-- generates an error, unexpected ')'
09:13:28 <dennisb> this is not a full function definition
09:14:01 <Stewart002> so I need to define filter... right..
09:14:07 <dennisb> foo flights = filter (from "Amsterdam") flights
09:14:18 <dennisb> no, filter is a standard function
09:14:19 <delYsid> filterFrom place = filter (from place) flights
09:14:21 <Marvin--> Stewart002: you should be able to type that in hugs though
09:14:35 <Marvin--> Stewart002: load the file, and then type it at the prompt
09:15:22 <Stewart002> Ha,
09:15:22 <Stewart002>            ("QF6",,,"","",,false,true),
09:15:22 <Stewart002>            ("QF352",,,"","",,true,false),
09:15:22 <Stewart002>            ("QF616",,,"","",,false,false),
09:15:22 <Stewart002>            ("QF529",,,"","",,false,false),
09:15:23 <Stewart002>            ("QF528",,,"","",,false,false),
09:15:25 <Stewart002>            ("QF623",,,"","",,false,false),
09:15:27 <Stewart002>            ("QF5",,,"","",,false,false),
09:15:29 <Stewart002>            ("QF5",,,"","",,false,false),
09:15:32 <Stewart002>            ("BA1707",,,"","",,false,false),
09:15:33 <Stewart002>            ("SQ327",,,"","",,true,false),
09:15:35 <Stewart002>            ("SQ235",,,"","",,true,false),
09:15:37 <Stewart002>            ("QF608",,,"","",,false,false),
09:15:39 <Stewart002>            ("QF944",,,"","",,false,false),
09:15:41 <Stewart002>            ("QF492",,,"","",,fal
09:15:43 <Stewart002> meh
09:15:45 <Stewart002> Haskell 98 does not support anonymous type variables
09:15:54 <dennisb> It's called False and True
09:16:03 <dennisb> not false and true
09:16:36 * Stewart002 screams at Mr Haskell, inventor or my torment :P
09:17:30 <dennisb> I think it is a nice thing
09:17:49 * Stewart002 was joking
09:19:12 <dennisb> I think you should play a little with haskell before writing the big program. For example. Write [1..10] at the prompt. Then you can try: filter (>2) [1..10]
09:20:06 <dennisb> or: filter odd [1..10]
09:20:08 <Heffalump> foldr (.) (\x->x) (map (+) [1..10]) 0
09:20:44 * Stewart002 fears the big program less :)
09:20:53 <dennisb> you can try that to, but it might be a little bit to advanced :-)
09:21:06 <Stewart002> okay
09:21:06 <Stewart002> from :: String ->Record -> Bool
09:21:06 <Stewart002> 	from s (_,_,_,t,_,_,_,_) = s == t
09:21:10 <dennisb> (I was talking about Heffalump's example)
09:21:21 <Stewart002> give an anonymous type error
09:22:21 <dennisb> it shouldn't
09:22:32 <Stewart002> -- is a comment in haskell yes?
09:22:35 <dennisb> yes
09:23:51 <Stewart002> the whole thing is about 40 lines, do you want me to post it in pm?
09:24:16 <dennisb> put it on the web or something if it's possible
09:24:22 <Stewart002> okay
09:24:23 <dennisb> (i don't know what a pm is)
09:24:28 <Stewart002> private message
09:25:01 <dennisb> I think you have some small error in your type declarations somewhere
09:25:20 <dennisb> maybe using int instead of Int or something
09:25:49 <dennisb> Types start with captial letter
09:26:10 <Stewart002> http://www.starwars-csa.com/haskell.hs
09:27:00 <Stewart002> gonna go make a coffee, brb
09:27:01 <Marvin--> Stewart002: you don't have to import Prelude, it's always imported
09:27:18 <dennisb> you must not indent the second from
09:27:33 <Marvin--> Stewart002: oh, you have defined Record as a list type, you probably just want to have it be the tuple...
09:27:36 <dennisb> and the type is wrong
09:27:39 <dennisb> Marvin--: yes
09:28:04 <dennisb> a record should not be a list of things
09:28:35 <Stewart002> arg, what a list to come back to :)
09:29:33 <Stewart002> so how do I sort out the list thing?
09:29:53 <Marvin--> Stewart002: remove the square brackets? :)
09:30:41 <Stewart002> okay, now that gives a horendous error :)
09:31:12 <Stewart002> ERROR "C:\My Documents\University work\programming paradigms\haskell.hs":11 - Ty
09:31:12 <Stewart002> pe error in application
09:31:12 <Stewart002> *** Expression     : ("BA1389",9.3,10.3,"Manchester","London",1.0,False,False) (
09:31:12 <Stewart002> "BA287",13.15,16.25,"London","San Francisco",3.1,False,False) ("BA284",16.45,11,
09:31:12 <Stewart002> "San Francisco","London",5.45,False,False) ("BA1392",11.45,12.4,"London","Manche
09:31:13 <Stewart002> ster",0.5,False,False) ("BA1714",19,21.55,"Manchester","Frankfurt",2.55,False,Fa
09:31:15 <Stewart002> lse) ("QF6",23.55,18.15,"Frankfurt","Singapore",6.3,False,True) ("QF352",19.4,4.
09:31:17 <Stewart002> 5,"Singapore","Brisbane",8.1,True,False)
09:31:19 <Stewart002> *** Term           : (,,,,,,,)
09:31:21 <Stewart002> *** Type 
09:31:30 <Stewart002> : p -> q -> r -> s -> t -> u -> v -> w -> (p,q,r,s,t,u,v,w)
09:31:30 <Stewart002> *** Does not match : a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l ->
09:31:30 <Stewart002>  m -> n -> o          
09:32:20 <dennisb> maybe you got rid of too many [], just the one on the type Record = ... should go
09:32:51 <dennisb> then you can comment out the functions in the end to make sure the first things work
09:33:33 <Stewart002> same error, I'll reublish the code.
09:33:49 <Marvin--> oh, yeah, sorry, just remove the brackets from the definition of Record
09:34:04 <Stewart002> its there
09:34:22 <dennisb> the brackets are still there
09:34:26 <Marvin--> Stewart002: remove the brackets from the Record definition, but put them back where you define flights
09:34:35 <dennisb> you got rid of the wrong one
09:34:44 <Stewart002> okay, it comiles
09:34:52 <Stewart002> compiles rather
09:35:21 <dennisb> flights is now a list of records. In the haskall world that is written [Record]
09:35:49 <dennisb> you can even add above flights:   flights :: [Record]
09:36:00 <Stewart002> type error in filter now.
09:36:15 <Stewart002> ooh
09:36:16 <dennisb> just to tell the haskell system that this is the type you want flights to have (and he will check that is matches)
09:36:19 <Stewart002> flights :: [Record] solved it
09:36:59 * Stewart002 gives everyone an imaginary medal for being so cool and understanding
09:37:58 <dennisb> ooh, that is a bug in hugs
09:38:13 <dennisb> it should work even without flights :: [Record]
09:38:21 <Stewart002> no, I said ooh, not hugs, or, yea, right :P
09:39:01 <Stewart002> so, going out on a limb here, from checks origin. here's to (checking destination)
09:39:28 <dark> "oo, ick" is a different language :-)
09:39:41 <Stewart002> to :: String -> Record -> Bool
09:39:42 <Stewart002> from s (_,_,_,_,t,_,_,_) = s ==t
09:39:53 <Stewart002> ack
09:39:55 <dennisb> Most people don't use tuples that big (there are records that people use). I know that hugs have some things hardcoded for tuples up to size 7, maybe you hit some limit there. The compiler works without the type declaration
09:40:12 <Stewart002> to :: String -> Record -> Bool
09:40:12 <Stewart002> to s (_,_,_,_,t,_,_,_) = s ==t
09:40:28 <dennisb> dark: are you talking about Ook!
09:40:43 <dark> Hmm, I notice that this is actually an 8-tuple, not a 9-tuple like you said.
09:40:52 <Stewart002> dennisb: nah, Ooh Mother!
09:40:54 <dark> dennisb: No, object-oriented Intercal :)
09:41:18 <dark> Intercal is a language for Real Programmers... on acid.
09:41:36 <Stewart002> yes, sorry, I'm looking at some notes here and example given to me has an element 0, quite odd.
09:42:00 <dennisb> http://www.dangermouse.net/esoteric/ook.html
09:42:47 * Stewart002 likes the look of ook
09:42:58 <dennisb> it's fun!
09:43:25 <Stewart002> okay so, record of 8-tuples was my to function correct?
09:43:53 <dennisb> sorry, I don't understand
09:44:05 <Stewart002> <Stewart002> to :: String -> Record -> Bool
09:44:06 <Stewart002> <Stewart002> to s (_,_,_,_,t,_,_,_) = s ==t
09:44:12 <dennisb> yes, it works?
09:44:14 <dark> dennisb: Hmm, my mind's eye sees an Ook interpreter in Haskell :)
09:44:51 <dennisb> dark: why not
09:45:09 <Stewart002> how do I actually run filter then?
09:45:39 <dennisb> I can only think of the librarian in some of pratchets books when I think about ook
09:46:15 <dennisb> Stewart002: write at the prompt: filter (from "London") flights
09:46:42 <Stewart002> ERROR - Cannot find "show" function for:
09:46:42 <Stewart002> *** Expression : filter (from "London") flights
09:46:42 <Stewart002> *** Of type    : [([Char],Float,Float,[Char],[Char],Float,Bool,Bool)] 
09:46:53 <dennisb> yes, another stupid thing with hugs
09:47:11 <dark> Maybe use ghci
09:47:19 <Stewart002> I have to use hugs :(
09:47:29 <dennisb> it's not a good idea to have tuples that big in hugs. The compiler handles it (ghc) but not hugs
09:47:33 <dark> In that case, it's probably better to move from an 8-tuple to something else.
09:47:55 <Stewart002> okay, wanna point me at it and say "Admire this great ... thing?"
09:48:05 <dennisb> yes
09:48:15 * Stewart002 jigs
09:48:15 <Marvin--> Stewart002: algebraic data types :)
09:48:36 <Stewart002> Marvin: point me more specifically :P
09:48:58 <dark> data Point = Point Int Int
09:49:00 <Marvin--> Stewart002: right now I'm going to point myself in the direction of dinner...
09:49:07 <dark> xpos (Point x _) = x
09:49:19 <dark> ypos (Point _ y) = y
09:49:25 <dark> Or, equivalently:
09:49:31 <Stewart002> data Record = Record String Float Float .... etc?
09:49:35 <dark> data Point = Point { x :: Int, y :: Int }
09:49:54 <dark> Oops,
09:50:00 <dark> data Point = Point { xpos :: Int, ypos :: Int }
09:50:15 <dark> This form will define xpos and ypos functions to you automatically, and do some other syntaxy stuff.
09:50:53 <dark> Stewart002: Yes.
09:51:41 <Stewart002> data Record = Record {String :: fno, Float :: arrival, Float :: departure, String :: origin, String :: destination, Float  :: duration, Bool :: movie, Bool :: meal}
09:51:49 * Stewart002 holds breath
09:51:58 <Stewart002> oops
09:52:02 <Stewart002> wrong way around
09:52:04 <dark> Right :)
09:52:06 <Marvin--> Stewart002: :)
09:52:32 <dark> You could shorten it a bit with movie, meal :: Bool
09:52:33 <dennisb> and you have to comment out the rest of the code since that is going to need small changes now
09:52:33 <Marvin--> Stewart002: just to confuse you some more, that thing is called a 'record' in Haskell :)
09:52:53 * Stewart002 cries at Marvin!
09:52:58 * Marvin-- grins and hides
09:53:16 <dennisb> but that is the same name as used in pascal and similar languages
09:53:20 <dark> You can construct Records with Record { fno = "KL345", arrival = 9.56, etc etc }
09:53:26 <dark> And pattern-match them the same way.
09:53:52 <dark> In both cases, you don't have to specify all the fields, and you don't have to have them in the same order.
09:53:59 <Stewart002> data Record = Record {fno :: String, arrivel :: Float, departure :: Float, origin :: String, destination :: String, duration :: Float, movie, meal :: Bool}
09:54:13 <Stewart002> and yes, arrival is spelt wring
09:54:17 <Stewart002> wrong, bleh
09:55:57 <Stewart002> okay, now everything has to be commented out to avoid errors :P
09:56:08 <dennisb> {- multiline -}
09:56:22 <Stewart002> ?
09:56:27 <dark> 10,$s/^/-- /
09:56:38 <dennisb> mutliline comments in haskell
09:56:46 <Stewart002> ah :)
09:56:54 <Stewart002> thanks (everything has --)
09:58:12 <Stewart002> new version uploaded.
10:00:32 <dark> dennisb: I don't understand how you do loops in Ook
10:00:34 <dennisb> Stewart002: the function to doesn't work, why is it not commented out?
10:00:39 <Heffalump> Ook!
10:02:32 <dark> Oh, wait, I see it now :)
10:02:45 <dennisb> Ook! Ook?
10:02:48 <Stewart002> sorry isp
10:03:14 <dark> It's misdocumented, though.
10:03:29 <Stewart002> the function isnt commented out because I uncommented it to test
10:03:53 <dark> Either that or it's not as trivially convertible to Brainfuck as it claims :)
10:04:48 <dennisb> dark: yes, I assume that Ook! Ook? and Ook? Ook! are always in that order and is a loop construct
10:05:12 <dennisb> Stewart002: since the seccond parameter is not a tuples 
10:05:19 <dennisb> tuple now it can not work
10:05:35 <Stewart002> so how do I go about fixing that?
10:06:17 <dennisb> if you have something of type Record called r you can use destination r to get that string
10:06:31 <dennisb> to x r = destination r == x
10:07:52 <dennisb> x is the string, r is the record, and the thing on the right hand side of = is the resulting Bool
10:08:15 <Stewart002> ERROR "C:\My Documents\University work\programming paradigms\haskell.hs":42 - Co
10:08:15 <Stewart002> nstructor "Record" must have exactly 8 arguments in pattern 
10:08:19 * Marvin-- ponders introducing flip
10:08:49 * Stewart002 ponders paying someone to write this :P
10:09:00 <dennisb> Stewart002: did you define it exactly as I wrote above?
10:09:06 <dennisb> to x r = destination r == x
10:09:19 <Stewart002> to :: String -> Record -> Bool
10:09:20 <Stewart002> to s Record = destination Record == t
10:09:24 <norpan> a constructor with eight arguments...that's heavy
10:09:29 <dennisb> Stewart002: not the same
10:10:07 <dennisb> Record starts with a capital
10:10:14 <dennisb> variables does not
10:10:24 <dennisb> to s record = destination record == t
10:10:33 <Stewart002> I got it comiled :)
10:10:37 <dennisb> you did!
10:10:50 <Stewart002> don't really understand it but I'm seeing patterns :P
10:11:38 <dennisb> norpan: it's a record
10:11:42 <Stewart002> just filter that doesn't work now.
10:12:20 <Marvin--> Stewart002: Haskell has lots of patterns ;)
10:12:20 <dennisb> Stewart002: oh, it must do
10:13:10 <Stewart002> filterFrom place = filter (from place) flights
10:13:11 <Stewart002> undefined variable flights
10:13:11 <dennisb> yes, is it defined?
10:13:12 <Marvin--> "Haskell programming is very often lots of pattern-matching (unless you subscribe to the religion that believes that every problem can be solved with a hammer, ehm, I mean foldr ;)"
10:13:12 <dennisb> I think it's commented out
10:13:12 <Marvin--> (quoth Marcin Benke)
10:13:12 <Stewart002> oops
10:13:12 <Stewart002> yes
10:13:42 <Stewart002> Type error in explicitly typed binding
10:13:48 <Stewart002> I'll re-upload.
10:14:14 <dark>    [  Jump past the matching ] if the byte at the pointer is zero.
10:14:14 <dark>    ]  Jump to the matching [.
10:14:22 <dark> Ook! doesn't match the semantics for ]
10:14:34 <Stewart002> uploaded
10:14:50 <dennisb> Stewart002: well, Records are not tuples anymore
10:15:24 <Stewart002> ....I think you said how I add the info... erm...it's gone.. sorry
10:15:32 <dennisb> dark: almost the same at least
10:15:45 <dark> dennisb: I see what's going on, Ook! does jump optimization :)
10:15:46 <dennisb> dark: or maybe exactly the same...
10:15:49 <dennisb> yes
10:15:57 <dark> dennisb: Jumping to the [ is the same as conditionally jumping to the instruction after the [
10:16:11 <dennisb> dark: yes, I was just going to write that
10:16:23 <dennisb> you beat me to it
10:16:35 <Stewart002> this sounds a lot like asm :)
10:16:42 <dennisb> it is
10:16:56 <dark> Well, it's a more primitive language than that :-)
10:17:02 <Stewart002> I had a go at it but it's not easy without a compiler :)
10:17:20 <Stewart002> I might look into the linux asm compiler some time.
10:17:44 <Stewart002> still, adding info to records then?
10:17:45 <dennisb> Here is one record:      Record "BA1389  9.3 10.3 "Manchester" "London" 01.00 False False
10:18:04 <dark> You forgot a "
10:18:13 <dennisb> yes
10:20:43 <Tyers> meh, damn isp
10:20:57 * Tyers is Stewart002
10:22:33 <Stewart002> what did I miss?
10:24:19 <dennisb> <dennisb> Here is one record:      Record "BA1389"  9.3 10.3 "Manchester" "London" 01.00 False False
10:24:19 <Heffalump> what did you last see?
10:24:26 <Stewart002> that :)
10:24:36 <Heffalump> [18:17] <dark> You forgot a "
10:24:36 <Heffalump> [18:18] <dennisb> yes
10:24:53 <dark> No, dennisb engaged in revisionism and added the "
10:24:58 <dennisb> hoho
10:25:05 <Heffalump> oh, so he did
10:25:51 <Stewart002> so is that the 'phrase' (I was reprimanded for saying statement) that adds a record to the record structure?
10:26:31 <Marvin--> yay, haskell time machine
10:26:42 <dennisb> no, the Record .... expression is a value, just like 3 or "fff"
10:26:59 <dennisb> what a wrote corresponds to writing foo = 3 or foo = "bar"
10:27:11 <Stewart002> okay
10:27:12 <dennisb> well, foo = Record ...
10:27:18 <Stewart002> maths notation again :)
10:27:33 <Stewart002> so how do I apply this to my record?
10:27:35 <dennisb> does correspond to that (with the real arguments instead of ...)
10:28:01 <Stewart002> I keep this yea? flights :: [Record]
10:28:32 <dennisb> instead of writing tuple ("BA33","London", ....) you write Record "BA33" London ....
10:28:33 <dark> Where you have (a, b, c, d, ...) now, you write Record a b c d ...
10:28:36 * Stewart002 will brb (coffee escaping)
10:29:23 <dark> I'm glad tea just sits there until I drink it.  Coffee sounds complicated.
10:29:38 * Stewart002 grins
10:29:45 * Stewart002 hunts the wild coffee
10:30:20 <Stewart002> flights = Record "BA1389" 9.3 10.3 "Manchester" "London" 01.00 False False
10:30:20 <Stewart002> ?
10:32:02 <Stewart002> do i use the flights = for each line or just list them underneath?
10:32:02 <Heffalump> what's the type of flights supposed to be?
10:32:22 <Heffalump> you probably want flights = [Record ..., Record ..., etc]
10:32:24 <Stewart002> flight :: [Record]
10:32:27 <Heffalump> yeah.
10:34:26 <Stewart002> woo-hoo
10:38:09 <Stewart002> new version uploading,
10:38:32 <Stewart002> its up
10:41:22 <Stewart002> I still can't run the filter command, cannot find 'show' function
10:42:55 <Heffalump> try adding "deriving Show" at the end of your "data Record = ..."
10:43:36 <Stewart002> it worked
10:43:43 <Stewart002> it's not a pretty output but it works
10:45:15 <Heffalump> yeah
10:45:27 <Heffalump> you need a better "instance Show Record" if you want it to look nice
10:46:35 <Stewart002> how do you mean?
10:46:36 <dennisb> Stewart002: you need to add deriving (Show) to the end of the definition of the Record type
10:46:53 <Stewart002> dennisb: got that, just trying to make it pretty :P
10:47:03 <dennisb> aha
10:47:12 <dennisb> ooh, i', blind
10:47:14 <Heffalump> steward: "deriving Show" means that it makes an automatic instance of the Show class for you
10:47:16 <dennisb> i'm even
10:47:43 <Heffalump> which works but is often ugly
10:47:51 <Stewart002> so I have to define Show Record?
10:47:59 <Heffalump> yeah
10:48:01 <Heffalump> something like
10:48:04 <Heffalump> instance Show Record where
10:48:34 <Heffalump>    show (Records { fno, ... }) = "Flight no: " ++ show fno
10:48:50 <Heffalump> but obviously rather longer to deal with all the other fields too
10:49:40 <Stewart002> Overlapping instances for class "Show"
10:49:45 <Stewart002> error
10:49:48 <Heffalump> get rid of the deriving Show
10:50:08 <TheOtherRainer> Hi, I have a queastion regarding Data declarations. Whats does a construct like "Data Typcon Dxyz Gtztr Hztz = ..." mean, where Dxyz etc. are nonsense identifiers which aren't declared anywhere?
10:50:11 <Heffalump> you can only have one instance of Show, and deriving Show creates one itself
10:50:20 <Stewart002> Undefined constructor function "Records" 
10:50:25 <Heffalump> TheOtherRainer: it's illegal
10:50:31 <Heffalump> sorry, I might have meant Record
10:50:39 <TheOtherRainer> it compiles under GHCi...
10:50:56 <Heffalump> TheOtherRainer: are you sure Dxyz starts with a capital letter?
10:51:07 <dennisb> Heffalump: I told John about this channel and about some guy from India and he directly spelled out your name (I sort of only remembered you handle :-)
10:51:12 <TheOtherRainer> yes
10:51:21 <Heffalump> dennisb: John Hughes?
10:51:24 <dennisb> yes
10:51:35 <Heffalump> well, he was my PhD examiner, so he ought to somewhat remember me :-)
10:51:43 <Stewart002> Haskell 98 does not support missing field bindings
10:51:54 <dennisb> sure, but just from the description: Indian guy
10:51:57 <Heffalump> Stewart002: sorry, I meant that you should fill in the others in the ...
10:52:00 <Heffalump> dennisb: ah :-)
10:52:13 <Heffalump> well, I'm probably the only "Indian guy" he's examined
10:52:18 <dennisb> true
10:52:20 <Heffalump> s/'m probably/ may be/
10:52:29 <Heffalump> actually I'm English, with Sri Lankan parents, but anyway :-)
10:52:49 <dennisb> well, near enough
10:53:08 <dennisb> I just guessed based on your name
10:53:51 <TheOtherRainer> "data Xyz Abc Bcd Efg = XXX deriving (Show)" gets accpeted by GHCi with no errors, just tried it.
10:54:03 <Stewart002> Still gives an error:
10:54:05 <Stewart002> show (Record {fno,arrival,departure, origin,destination,duration,movie,meal}) = "Flight no: " ++ show fno
10:54:15 <Stewart002> do I need to fill in the whole left side too?
10:54:50 <Heffalump> probably, yes
10:55:10 <dark> That's not the problem...
10:55:23 <Heffalump> oh, hang on
10:55:25 <dark> You need to have either Record { fno = fno, arrival = arrival, ... }
10:55:32 <dark> or (Record fno arrival ...)
10:55:35 <Heffalump> oh, duh. I've been corrupted by SML :-)
10:56:09 <dark> The fno = fno part in the first version says to bind the record field fno to the local parameter fno
10:56:25 <Heffalump> SML allows fno as shorthand for fno = fno
10:56:38 <dark> In the second version you only list the local names, and you have to make sure they're in the right order.
10:56:47 <dennisb> some hour ago: <Marvin--> he must be paid by the evil ML community!
10:57:06 <Stewart002> cool. one type sort of error though.
10:57:14 <Stewart002> Main> filterTo "London"
10:57:14 <Stewart002> [Flight no: "BA1389"
10:57:14 <Stewart002> Arrival: 9.3
10:57:14 <Stewart002> Departure: 10.3,Flight no: "BA284"
10:57:14 <Stewart002> Arrival: 16.45
10:57:15 <Stewart002> Departure: 11.0]  
10:57:21 <Stewart002> the [ and ]
10:57:29 <dark> Heffalump: Might be confusing in Haskell, because all of those names are also top-level functions.
10:57:53 <dark> Stewart002: filter is returning a list of one element here.
10:58:08 <Heffalump> dark: but it's in a pattern match, not an expression context
10:58:23 <dark> Stewart002: If you want to format lists of Record differently from the normal list notation, you could also define showList separately.
10:58:41 <dark> Heffalump: Yeah, but it would be confusing in the expression where you use them :)
10:58:58 <Heffalump> true
10:59:18 <Stewart002> I can solve this assignment by just having several functions like filterXXX which print out the whole record that matches.
10:59:26 <Stewart002> rough but meets criteria
10:59:29 <dark> Hmm, showList is a bit more tricky to define than show, because it hooks in to the whole ShowS thing.
10:59:58 <dark> Steward002: If you know that exactly one record will match, you can just ask for head (filterTo "London")
11:00:14 <Stewart002> it's not though, it's several
11:00:14 <TheOtherRainer> "data Xyz Abc Bcd Efg = XXX deriving (Show)" gets accpeted by GHCi with no errors, what does this mean? According to the report Data declarations should go like "Data typeconstr typevar1 typevar2 ..."
11:00:46 <Heffalump> theotherrainer: what if you run ghci +98 ?
11:00:58 <TheOtherRainer> k, ill try that
11:02:02 <TheOtherRainer> hmm, i havent set fglasgow-exts, shoudlnt it tun in hask98 by default?
11:02:10 <Heffalump> I don't think it does
11:02:12 <Heffalump> ICBW
11:02:31 <Stewart002> one more question then I'll leave you for tonight :)
11:02:48 <Stewart002> from :: String -> Record -> Bool
11:02:48 <Stewart002> from x r = origin r == x
11:03:06 <Stewart002> how do I make that search before or after a time (shown as a float)
11:03:16 <Stewart002> e.g. under 8 hours duration
11:03:27 <Heffalump> I don't understand what you mean
11:03:51 <Stewart002> instead of origin it takes duration (a float)
11:04:04 <Stewart002> how do I test if duration is > x?
11:04:19 <Heffalump>  >
11:04:23 <dennisb> :-)
11:04:35 <Stewart002> from x r > x == x   ?
11:04:46 <Stewart002> no
11:05:06 <Stewart002> from x r > duration r == x    ?
11:05:07 <dennisb> == tests for equality, > tests for greater then
11:05:08 <Heffalump> no, from x r = duration r > x
11:05:15 <Stewart002> ah
11:05:17 <Stewart002> thanks
11:05:58 <Stewart002> you might see me in a few days with some worked up code.
11:06:08 <Stewart002> I can't thank you all enough for this.
11:06:51 <Heffalump> np
11:07:08 <Stewart002> ooh, one more, is there a case statement or similar in haskell?
11:07:21 <Heffalump> yep
11:07:25 <Heffalump> it's called "case" :-)
11:07:29 <Heffalump> case foo of
11:07:30 <Stewart002> I wanted to run the functions through the main function (IO)
11:07:34 <Heffalump>   5 -> 6
11:07:36 <Heffalump>   6 -> 7
11:07:38 <Heffalump> or similar
11:08:19 <Stewart002> so if I entered 5 it would run function 6 yes?
11:08:28 <Stewart002> case banana of
11:08:37 <Stewart002>    hello -> helloback
11:08:58 <Stewart002> where helloback is a function that says hello back to you?
11:10:21 <Heffalump> you'd probably mean "hello", not hello
11:10:28 <Stewart002> yes
11:11:10 <Heffalump> but yeah, roughly
11:11:28 <Stewart002> main :: IO ()
11:11:28 <Stewart002> main =  do putStr "Type Something: "
11:11:28 <Stewart002>            str <- getLine
11:11:28 <Stewart002>            case str of
11:11:28 <Stewart002>              "filterTo" -> filterTo "London"
11:11:32 <Stewart002> gives an error
11:11:43 <Stewart002> Type error in final generator
11:11:44 <Heffalump> what's the error?
11:11:58 <Heffalump> oh, try print (filterTo "London")
11:12:22 <Stewart002> Type error in application
11:12:28 <Stewart002> hold on
11:12:49 <Stewart002> it works
11:12:57 <Stewart002> my duration function failed
11:14:55 <Stewart002> woo
11:14:56 <Stewart002> it all works
11:15:03 <Stewart002> you guys are the absoloute best
11:15:18 * Stewart002 dances around handing out manly handshakes to everyone
11:15:38 <Stewart002> I'll come back when it breaks :P
11:16:10 <Heffalump> what's your ISP that keeps breaking, btw?
11:16:16 <dennisb> Fun that it works. you still need some basic understanding of the functional concepts. But as a first program it's nice
11:16:30 <Stewart002> Hull24
11:16:39 <Stewart002> it kicks me after 2.5 hours
11:16:45 <Stewart002> actually more like 20 minutes
11:16:49 <Heffalump> ah
11:18:00 <TheOtherRainer> Heffalump: "data Xyz Abc Bcd Efg = XXX deriving (Show)" gets accepted by GHCi in Haskell98 mode, it doens't show warnings either. Under Hugs it sais:"Illegal left hand side in datatype definition". Wired.
11:18:22 <Stewart002> c'ya all
11:18:27 <dennisb> TheOtherRainer: I would say it is simply a bug
11:18:30 <Heffalump> sounds like a GHC bug to me.
11:18:39 <TheOtherRainer> hmm
12:00:40 <Heffalump> wb
13:55:04 <bas_> i am reading Bird's 'Craft of functional programming'... does anyone know what the definition is of the function 'neList' on page 361 in the book? it is used in a parser function which i really need...
13:57:05 <Heffalump> do you mean Bird's "Introduction to Functional Programming", or Thompson (I think)'s "Craft of Functional Programming"?
13:57:27 <Heffalump> my copy of the former is at work, and I don't have a copy of the latter, so I doubt I can help in either case, though
13:59:55 <bas_> Heffalump: i have 2nd edition of 'the craft of functional programming'
14:00:47 <bas_> i already found out that this neList function was an exercise in the book...
16:43:07 <andersca> argh
16:43:09 * andersca is going crazy
16:45:03 <Heffalump> oh yes?
16:45:52 <andersca> doh!
16:45:56 <andersca> I'm not going crazy anymore :)
16:46:16 <andersca> Heffalump: writing a state monad for a type checker, and the run-state function didn't work
16:46:33 <Heffalump> ah
16:47:47 <andersca> turns out I just used the wrong argument order :)
17:29:49 <Fractal> Hey, does hugs have a Bits module like GHC?
17:30:03 <Fractal> Well, I mean does it have an equivalent?
17:31:57 <Fractal> Er, wait, nevermind... It does have Bits in the ext/ dir.
