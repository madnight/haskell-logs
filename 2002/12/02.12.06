04:43:27 <whee> hooray I figured out my next little project
04:43:53 <whee> optimizing bf interpreter/bf->C compiler :)
04:49:14 <shapr> yow
04:49:24 * shapr bounces
04:49:29 * shapr bounces furiously
04:50:01 <shapr> hmmm
04:56:29 <jewel> bf?
05:05:24 <whee> jewel: http://www.muppetlabs.com/~breadbox/bf/
05:05:53 <whee> I'm thinking of including a full debugger as well
05:05:56 <whee> heh
05:08:55 <shapr> god morgon
05:11:30 <Marvin--> still? :)
05:11:37 <shapr> well, for me it is...
05:11:54 <shapr> what time is it for you?
05:12:17 <shapr> vad tiden är nu?
05:15:28 <Marvin--> kvart över två
05:16:34 <shapr> det är fem hundred nittio fyra
05:16:49 <Marvin--> ?
05:17:02 <shapr> det är internet tiden.
05:17:06 <Marvin--> eew
05:17:17 <shapr> hey, I like internet time :-P
05:17:19 <Marvin--> :)
05:17:42 <shapr> Marvin--: have you picked a masters topic?
05:18:48 <Marvin--> no, not yet
05:18:54 <Marvin--> going to talk to some more people
05:19:21 <Marvin--> Jörgen Gustavsson is doing research on functional programing and semantics, and those are two topics I'm interested in, so...
05:19:29 <Marvin--> definitely going to talk to him :)
05:37:37 * Igloo sighs and checks out the public CVS again on a new machine
06:05:26 <ibid> morning :-)
06:05:46 <shapr> hyvää huomenta!
06:06:24 <ibid> tänään on itsenäisyyspäivä
06:07:11 <shapr> er, holiday?
06:07:41 <shapr> I know .fi has the day off... I remember that it's a national holiday... I've forgotten what itsenäisyys means
06:10:19 <ibid> independence
06:10:39 <shapr> aha
06:10:47 * shapr remembers vapaa
06:11:17 <ibid> there's the big ball at the president's tonight, everybody who's not there watches it on tv... or something
06:11:50 <Marvin--> "yay, finally got rid of the damn Swedes"?
06:11:52 <shapr> oh, I remember that.
06:12:34 <Marvin--> we don't have an independence day ;)
06:12:41 <ibid> Marvin--: russians, not swedes
06:13:05 <ibid> we still haven't gotten rid of the damn swedes :-)
06:13:21 <ibid> (for the record, i'm not one of those who think that way, but the sentiment is not uncommon)
06:13:36 <shapr> that sentiment made living in Tornio very weird
06:13:37 <Marvin--> oh, the russians one
06:14:03 <Marvin--> well, seeing as a lot of you take Swedish in school...
06:14:22 <Marvin--> Sweden doesn't have an independence day, 'cause we've been the ones conquering
06:14:45 <ibid> Marvin--: that's right, you have never been conquered (except by the calmar union?)
06:14:59 <Marvin--> damn danes :P
06:15:02 <ibid> everybody take swedish at school
06:15:06 <shapr> even me
06:15:15 <Marvin--> oh, I thought it was just the "finland swedes"
06:15:17 <shapr> jag studerar svenska
06:15:30 <shapr> well, I'm taking swedish in school right now.
06:15:33 <shapr> just had class this morning.
06:15:37 <ibid> Marvin--: no, sweden is the other official language. everyone is required to know both
06:15:42 <Marvin--> that's because you moved here! :)
06:15:47 <shapr> well... yes.
06:15:49 <ibid> Marvin--: the finland swedes have compulsory finnish
06:15:50 <Marvin--> ibid: I see
06:16:21 <ibid> Marvin--: and that's partly what i referred to above with the getting rid of comment
06:17:16 <ibid> there is a sizable minority of finnish-speaking finns who want to abolish swedish as an official language
06:17:17 <Marvin--> yeah, I can see there could be some resentment about it
06:17:51 <Marvin--> at nuccc we spoke mainly English since there were some non-swedish speaking finns there...
06:18:00 <ibid> nuccc?
06:18:15 <Marvin--> nordic university computer clubs' conference
06:18:35 <Marvin--> it was in Umeå last spring, I think it's in Helsinki next
06:18:43 <ibid> everybody is required to learn the language, but some people take pride in having the lowest possible passing grade in swedish...
06:18:50 <Marvin--> hehe
06:19:34 * ibid - well - ibid has relatives (finland's emigrants) in sweden
06:19:51 <ibid> (and the children of the emigrants)
06:20:14 <ibid> (who think of themselves as swedes)
06:21:05 <Igloo> Presumably they are Swedes?
06:21:12 <Marvin--> heh
06:21:22 <ibid> Igloo: i'm talking about identity
06:21:32 <ibid> Igloo: how they see themselves
06:21:58 <ibid> Igloo: official nationality has nothing to do with it :-)
06:23:40 <ibid> there is an association who was officially giving instructions in the use of the finnish national flag.  the officiality was dropped recently since they refused, as a matter of principle, to give the instructions in swedish when requested
06:24:26 <Marvin--> *sigh*
06:24:32 <ibid> ?
06:24:41 <Igloo> :-)
06:25:01 <Marvin--> oh, just sighing about the trickiness with having more than one official language
06:25:22 <ibid> the officiality, btw, was tied with a handsom amount of money each year
06:25:28 <ibid> from the government
06:28:13 <ibid> am i, btw, here the only one who has the equipment to watch digital television broadcasts?
06:28:20 <ibid> just curious
06:28:37 * ibid does not know of any other personally
06:28:54 <Marvin--> I'm a student, I have an old, cheap, crappy TV, okay? ;)
06:29:17 <ibid> heh
06:29:32 <Igloo> Likewise
06:29:57 <shapr> I don't really like TV
06:29:58 <ibid> actually, this one is a cable digibox, but it does not change anything :-)
08:44:10 <hdaume> i'm really about to kill some people if they continue this stupid tabs discussion
08:44:21 <Heffalump> :-)
08:45:14 * shapr is tempted to take a break from work and read more tabs discussion
09:02:30 <shapr> whoa, Ingo Wechsung says Python is a yet to be established newcomers, so whitespace is inexcusable.
09:02:45 <shapr> I think he's going in the wrong direction.
09:03:00 <shapr> I've been mulling over the issue of two or three dimensional whitespace
09:03:52 <shapr> yow, the tab thread is getting huge
09:07:20 <Marvin--> haha
09:07:23 <Marvin--> tab thread?
09:07:30 <Marvin--> where?
09:07:41 <shapr> er, haskell@haskell.org I think
09:07:55 <Marvin--> should I refer them to PEP666?
09:08:23 <Heffalump> to what?
09:08:24 * shapr doesn't know that PEP
09:08:48 <Marvin--> Python Enhancement Proposal #666
09:08:54 <shapr> I haven't read it.
09:09:09 <Marvin--> http://www.python.org/peps/pep-0666.html
09:09:46 <SyntaxPolice> Marvin--:  I think the tab thread is in haskell-cafe
09:22:33 * Igloo reads the "CVS access?" and looks glad it's not just something personal against me  :-)
09:26:07 <Heffalump> where?
09:39:52 <Igloo> haskell@
09:40:15 * Heffalump pokes his email
09:40:30 <Heffalump> when?
09:40:36 <Igloo> Oh, no, glasgow-haskell-users@
09:43:45 <Heffalump> ah
09:51:09 <hdaume> stupid question: how do you redirect stderr in sh?  something like 'cmd >&2 /dev/null' or something, but that's not quite it :)
09:52:19 <Heffalump> 2>/dev/null
09:52:27 <Heffalump> or 2>&1 if you want to send it to stdout
09:53:24 <hdaume> cool, thanks
09:57:02 <Heffalump> oh, that's bash actually. I imagine sh is the same.
10:00:15 <hdaume> it worked :)
10:02:27 <Heffalump> good good :-)
10:20:41 <hdaume> thank god, it looks like the tab discussion is over
10:25:39 <whee> hooray, I can't think of a way to optimize bf source at all :)
12:45:23 <shapr> well, at least the tab discussion is making traffic on the lists...
12:45:28 <shapr> that's one good thing... I guess.
12:47:36 <lament> tabs vs. spaces?
12:47:43 <shapr> yup
12:47:49 <lament> wow! where?
12:48:02 <shapr> haskell-cafe
12:48:02 * lament feels an urge to flame people
12:48:17 <shapr> urg, I should have kept my mouth shut
12:48:34 * Igloo is resisting the urge to flame someone in that thread  :-)
12:48:47 <shapr> yah, I'm very tempted to tell Ingo what I really think.
12:49:04 <shapr> in short, he may have a one dimensional view of code, but I don't
12:49:21 <Igloo> I don't think it was him
12:49:54 <shapr> ashley?
12:50:04 <shapr> he'd be far too easy to flame ;-)
12:50:40 <Igloo> Andrew J Bromage (is that Pseudonym?)
12:50:47 <shapr> yup it is
12:50:56 <Igloo> Assuming I understood what he meant correctly, anyway
12:51:55 * shapr looks
12:52:10 <shapr> hm, which part?
12:52:27 <lament> it's strange how seemingly unimportant topics such as tabs vs. spaces ALWAYS cause flamewars.
12:52:28 <Igloo> Where he suggests setting sts<ts
12:52:49 <shapr> oh
12:53:05 <shapr> well, at least we all want referential transparency
12:53:41 <Igloo> I guess technically it's sort of OK as Haskell sort of defines tabstops to be every 8 spaces, but it's still nasty nasty horrible
12:53:45 <Igloo> :-)
12:54:21 <lament> Python deals with this nicely afaik. It accepts both tabs and spaces, but warns you when you mix them.
12:54:48 <shapr> yup
12:55:05 <Igloo> Hmmm, that would be tricky in Haskell
12:55:06 <shapr> python is a bit more regular in whitespace than Haskell
12:55:12 <lament> Seems to be the most logical approach. If you're mixing tabs and spaces, you're asking for trouble
12:55:18 <Igloo> <tab>do x <- y
12:55:25 <Igloo> <tab>   return x
12:55:43 <Igloo> is the correct way to do it if you want to use tabs
12:56:13 <lament> why not
12:56:18 <lament> <tab>do x <- y
12:56:22 <lament> <tab><tab>return x
12:56:39 <Igloo> That's parsed as do x <- y return x
12:56:53 <Igloo> It's equivalent to
12:56:57 <Igloo>         do x <- y
12:57:03 <Igloo>                 return x
12:57:25 <Igloo> You could do
12:57:27 <Igloo> <tab>do
12:57:33 <Igloo> <tab><tab>x <- y
12:57:37 <Igloo> <tab><tab>return y
12:57:41 <Igloo> But vertical space is precious
12:57:43 <lament> oh.
12:57:53 <lament> anyway, in your original example
12:58:03 <lament> it doesn't matter what length the tab is
12:58:16 <lament> so it's fine.
12:58:31 <Igloo> Indeed, but it might be hard to work out you don't need a warning
12:59:14 <Igloo> Also, you need to handle things like
12:59:18 <Igloo> <tab>do x <- y
12:59:18 <Igloo> <tab>   case x of
12:59:18 <Igloo> <tab>   <tab>1 -> return 3
12:59:18 <Igloo> <tab>   <tab>_ -> return 4
12:59:28 <lament> ouch.
12:59:44 <Igloo> Did I mention I think everyone should use spaces?  :-)
12:59:49 <shapr> case is the spaciest part of Haskell
12:59:50 <shapr> imho
12:59:50 <lament> I guess the best choice would be to disallow tabs.
12:59:59 <lament> hehe
13:00:07 <Igloo> That's probably what I'd have done
13:00:52 <shapr> \tab == bottom
13:00:57 <lament> yes!
13:02:03 <lament> This Ingo guy seems to be against the whole idea of significant whitespace.
13:02:21 <shapr> yah, I think he is.
13:02:42 <shapr> I like it.
13:02:42 <lament> Which means he's stupid and wrong... Oh wait, i'm not even subscribing to the list
13:02:47 <shapr> hah
13:08:24 <lament> hm
13:08:42 <lament> it's probably bad that haskell allows both whitespace-significant and non-WS-significant styles
13:09:25 <lament> too much choice when working in a group
13:10:34 <shapr> I'd like to have a haskell program that converts for me
13:16:19 <hdaume> shapr: ghc will convert for you
13:16:40 <shapr> to whitespace?
13:16:42 <hdaume> or at least it will convert from layout style to brace style, but not the other way
13:16:50 <shapr> oh
13:17:20 <shapr> I wonder if one of the PrettyPrinters will do layout
13:17:34 <hdaume> got me ;)
15:47:23 <whee> anyone know of a good tutorial/example of using the Parsec module?
16:32:08 <Igloo> whee: Does it not come with something?
16:32:20 <Igloo> Looks like UNSW is broken
16:32:24 <whee> the examples directory is empty 
16:32:31 <Igloo> I meant documentation
16:32:58 <whee> the docs I can find don't cover what I'm having problems with :\
16:33:07 <Igloo> Go on?
16:34:14 <whee> just trying to find an easy example demonstrating how the ParsecToken module works, particulary with reserved operators
16:34:29 <Igloo> Oh, it suggests using do notation for seq comp.; interesting
16:34:43 <whee> I'm attempting to write a parser for bf :)
16:35:13 <whee> seemed like an easy enough thing to do except I can never get anywhere without an example heh
16:35:23 <Heffalump> bf = brainfuck?
16:35:26 <whee> yes
16:35:39 <Igloo> makeTokenParser looks like it has an example that does what you want
16:35:50 <Igloo> In the reference section, http://www.cs.uu.nl/~daan/papers/parsec.html#ParsecToken
16:36:07 * Igloo has never used it though so may be talking rubbish  :-)
16:36:21 <whee> I was looking at that, couldn't find anything using the operators though
16:40:29 <Igloo> Does anyone happen to know if Chilli has a public CVS repository for his stuff?
16:41:31 <whee> oh bah
16:41:45 <whee> the documentation on this page is outdated, so it wouldn't helkp anyway :\
17:49:37 <Janni> hi.
17:50:51 <whee> hello
17:50:56 <Riastradh> Hi.
17:56:31 * Janni is just compiling HOpenGL
17:56:54 <Janni> i'm already looking forward to do some 3D programming with Haskell
18:22:36 <whee> blah
18:23:00 <whee> love fighting with the compiler and types :p
18:39:52 <whee> heh I think I'm going to hav e to give up on this bf thing I can't even get a parser working :\
18:44:39 <lament> don't use a parser.
18:44:57 <lament> although in any case, haskell is not the best language for bf :)
18:45:17 <whee> how else would I do it :P
18:45:26 <whee> parsec looks like a perfect match, but I can't get anything to work
18:53:40 <whee> http://smaerty.ath.cx/bf/ <- ignore the fact that the code is ugly and all, but why does the parse return an empty list :(
18:54:05 <Janni> n*
18:54:09 <Janni> n8 :)
19:30:15 <whee> what's the usual way of parsing anything in haskell, heh
20:01:55 <inkedmn> hi all...
20:02:09 <inkedmn> i'm taking a crack at haskell, so you'll probably be hearing from me alot :)
20:02:39 <inkedmn> jemfinch!
20:02:40 <inkedmn> ;)
20:02:49 * inkedmn just joined this channel about 30 seconds ago
20:02:52 <jemfinch> inkedmn!
20:02:55 <jemfinch> ah, funny :)
20:03:09 <inkedmn> did my interest in haskell renew yours?:
20:03:40 <jemfinch> not really, I generally hang out in this channel because the folx0rs here are smart ones ;)
20:03:54 <jemfinch> and there's no SML channel, but Haskell users generally share my preference for SML over O'Caml here.
20:04:12 <jemfinch> whereas asking SML questions in #ocaml is always sure to start a stupid flamewar.
20:04:25 <inkedmn> ah, gotcha
20:04:39 <jemfinch> but mostly I hang out here because the folks are smart.
20:04:45 <inkedmn> ah, gotcha
20:04:45 <jemfinch> I like the conversation.  Like a smarter #python.
20:04:55 <inkedmn> i have a feeling i'll be spending quite a bit of time here
20:06:04 <inkedmn> hmm...
20:06:14 <inkedmn> looks like recursion is going to be my new best friend...
20:06:26 <jemfinch>  yeah, definitely.
20:06:40 <jemfinch> we like recursion.  SML apparently has a while loop, but I've never even so much as figured out how it works.
20:07:40 <inkedmn> heh
20:08:05 <inkedmn> well, i'm reading through this tutorial, and it has exercises at the end of each chapter
20:08:25 <inkedmn> chapter 3's is to take a list and replace each element with a boolean
20:08:30 <jemfinch> did you get that file I told you to download before?
20:08:34 <inkedmn> oh, crap
20:08:37 <inkedmn> totally forgot
20:09:03 <seth> Anyone tried out the 5.04.2 release?
20:09:52 <seth> No?
20:09:58 <jemfinch> I haven't, I don't think.
20:10:06 <jemfinch> unless it was in FreeBSD ports a few weeks back.
20:10:22 <jemfinch> inkedmn: it's prac1.ps.
20:10:27 <inkedmn> ah, ok
20:12:27 <seth> No, I think it is only a week old.
20:15:02 <inkedmn> jemfinch: is that pracL.ps?
20:15:10 <inkedmn> or prac<ONE>.ps?
20:15:40 <inkedmn> oh, and any word back from sf?
20:15:47 <jemfinch> prac<ONE>.ps.
20:15:54 <jemfinch> I haven't quite checked since around 4pm.
20:15:59 <inkedmn> duder!
20:16:22 <inkedmn> :)
20:16:25 * inkedmn fires up
20:17:09 <inkedmn> i'm looking at a prac1.pdf (prac1.ps wouldn't open right)
20:17:18 <inkedmn> is it like a hw assignment thing?
20:17:27 <jemfinch> yeah.
20:17:34 <inkedmn> ok
20:17:34 <jemfinch> does it describe the soundex algorithm?
20:18:25 <inkedmn> i don't see "soundex" in here anywhere
20:18:34 <jemfinch> what do you see?
20:19:14 <inkedmn> first couple lines:
20:19:38 <inkedmn> bah, won't paste
20:19:49 <inkedmn> it talks about speeding up a piece of code
20:20:12 <jemfinch> oh, that's not what I want.
20:20:13 <inkedmn> memory access
20:20:15 <inkedmn> ok
20:20:17 <jemfinch> can you accept dcc send?
20:20:24 <inkedmn> i think so
20:21:29 <inkedmn> will it look right if i open it in vim?
20:21:37 <jemfinch> a postscript file?
20:21:43 <inkedmn> yeah
20:21:46 * inkedmn doesn't know
20:21:47 <jemfinch> you'll need ghostscript to view it.
20:21:55 <inkedmn> oh...
20:22:06 <jemfinch> ah, good, my mail went through to the O'Caml list.
20:22:56 <inkedmn> ok, got the doc
20:24:38 <inkedmn> downloading ghostscript
20:25:56 <jemfinch> seth: what's new in the new release?
20:28:25 <inkedmn> is isLower a builtin function?
20:28:42 <jemfinch> looks like it.
20:28:44 <jemfinch> do you have hugs installed?
20:28:54 <inkedmn> no, ghci
20:29:04 <inkedmn> but i can install hugs
20:29:08 <inkedmn> i have the installer
20:29:11 <jemfinch> go install hugs, it's a nicer interactive shell, from what I hear.
20:29:18 <jemfinch> Prelude> isLower 
20:29:19 <jemfinch> ERROR - Cannot find "show" function for:
20:29:19 <jemfinch> *** Expression : isLower
20:29:19 <jemfinch> *** Of type    : Char -> Bool
20:29:37 <inkedmn> i tried doing:
20:29:43 <inkedmn> map isLower "Hello"
20:29:48 <inkedmn> gave an error for isLower
20:29:57 <jemfinch> hmm.  Works fine in hugs here.
20:30:05 * jemfinch is no haskell whiz.
20:30:14 <jemfinch> perhaps it's in a module?
20:30:14 * inkedmn installs hugs
20:30:18 <jemfinch> maybe Char.isLower?
20:31:06 <inkedmn> well, the docs say toUpper is a builtin
20:31:11 <inkedmn> i have to believe that isLower is too
20:32:25 <jemfinch`> I definitely want the IRC channel for VgC to be on OPN.
20:32:35 <inkedmn> sounds good to me
20:32:45 <jemfinch`> I don't like oftc.net, I can't see the point in using it.
20:33:32 <inkedmn> ok, hugs worked :)
20:33:50 <jemfinch`> I'm curious why ghci didn't.
20:33:57 <inkedmn> me too
20:36:41 <inkedmn> hmm, nothing on sf.net for vagabond
20:37:04 <jemfinch`> no, they haven't ok'ed it yet.
20:37:31 <whee> isLower is in ghc, Char module
20:37:43 <whee> Prelude> Char.isLower
20:37:43 <whee> No instance for (Show (Char -> Bool))
20:38:25 <jemfinch`> ah, I thought it was something like that.
20:38:25 <inkedmn> hmm
20:38:34 <inkedmn> i didn't have to load anything to use it in hugs
20:38:39 * jemfinch` isn't the person learning Haskell, though, so he didn't really bother looking for it.
20:38:51 <whee> hugs may or may not import it for you automatically
20:39:20 <inkedmn> ah, i see...
20:39:34 <whee> the haskell 98 lirary report specifies it to be in a Char module
20:40:40 <jemfinch`> oooh, inkedmn.
20:40:50 <jemfinch`> http://groups.google.com/groups?dq=&hl=en&lr=&ie=UTF-8&threadm=asqso5%24d11%241%40cantaloupe.srv.cs.cmu.edu&prev=/gro
20:40:57 <jemfinch`> that shows some useful stuff for SML in XP.
20:49:27 * jemfinch` is amazed sometimes as how many people learn programming before they've really got a handle on English.
20:55:03 <dennisb> I learnt basic almost the same time as I learnt english (I'm much better at basic)
20:55:14 <jemfinch`> hehe :)
20:55:29 <jemfinch`> I'm talking more about native speakers who have no excuse not to speak English well.
20:55:42 <whee> I blame that on the internet
20:55:58 <whee> especially things like instant messaging.
20:56:26 <jemfinch`> native speakers of other languages have all the excuse they need to suck at English.  But when I read some teenager's horrid English with respect to programming, I want to tell him, "Improve your communication skills and ask me when you've gotten better at English."
20:57:32 * jemfinch` goes to sleep until Meg comes over.
21:04:20 <dennisb> whee: did you get parsec working?
21:04:47 <dennisb> I've used it once or twice with good result
21:23:44 <inkedmn> so, is there anywhere i can find a list of all the modules, etc that come with haskell?
21:24:52 <inkedmn> ah, i'm a retard
21:24:56 <dennisb> the ghc manual shows "most" that comes with ghc..
21:30:45 <inkedmn> hmm... interesting
21:31:06 <inkedmn> so, if i want to use Network.Socket, can i "import" it within the .hs file?
21:31:19 <inkedmn> or do i have to pass it at the command line when i compile?
21:33:28 <seth> You can import in the file.
21:34:06 <inkedmn> ok, cool :)
21:34:13 <inkedmn> man, learning a new language is exciting :)
21:34:40 <seth> Yes; a bit frustrating at first, but worthwhile especially with Haskell.
21:34:45 <inkedmn> can you recommend a tutorial/book that's good for people with no functional programming experience?
21:34:49 <inkedmn> yeah, that's what i'm told :)
21:34:59 <seth> You have to reorient your thinking a bit.
21:35:14 <seth> Plus deal with the mechanics as with any language.
21:35:14 <inkedmn> yeah, i'm a pythoh/java guy
21:35:20 <inkedmn> er
21:35:22 <inkedmn> python :)
21:35:41 <seth> Actually, Python uses some important Haskell-like language features.
21:35:44 <inkedmn> not having any sort of loop is just weird to me :)
21:35:51 <inkedmn> such as?
21:36:09 <seth> lambdas, some of the list processing, and automatic strong typing.
21:36:19 <inkedmn> ah
21:36:30 <seth> By the way, you actually can do loops in Haskell, although they look a bit weird.
21:36:41 <seth> With the >>= and >> combinators.
21:37:01 <inkedmn> well, i read that they're not SUPPOSED to be in there (or something), but they could be implemented...
21:37:11 <inkedmn> (didn't really understand what they meant by that)
21:37:43 <seth> Strictly speaking they aren't loops, but they are equivalent.  Normally there is a better recursive structure available, so they discourage the loop constructs.
21:37:57 <inkedmn> yeah, i read that too :)
21:38:00 <seth> But if there is something that in fact can only be done with a loop, you can still do it in Haskell.
21:38:07 <inkedmn> i've only dealt with recursion a bit, not very much
21:38:11 <inkedmn> cool
21:38:33 <seth> Recursion in this context doesn't mean the same thing as recursion in C
21:38:43 <seth> Or Java, which is the same thing w.r.t. recursion.
21:39:29 <seth> Python and Haskell have very similar type inference systems, but Haskell does it all at compile time, which is really amazing.
21:42:24 <inkedmn> hmm...
21:42:29 <inkedmn> yeah, this is VERY different
21:44:26 <seth> Yes.
21:46:58 <inkedmn> ok, i did this:
21:47:14 <inkedmn> List> length (filter isLower "hEllO")
21:47:19 <inkedmn> and it worked fine
21:47:28 <inkedmn> my question is, is that the RIGHT way to do what i did?
21:47:41 <inkedmn> rather, the most correct/best way?
21:48:58 <seth> It might be more "haskell-like" to compose the functions, as in length . filter isLower "hEllo"
21:48:59 <dennisb> it's the right way
21:49:39 <inkedmn> ah, ok...
21:50:16 <seth> Which is the same thing, really, but it looks better (to me)
21:50:39 <dennisb> seth: except that you need to put in parentesens to get your example to work
21:51:06 <lament> which is the annoying part.
21:51:20 <seth> Oh, so it consumes both arguments on the call to filter...
21:52:38 <dennisb> Hmm, I blaim the spell checker for substituting in parentesens, I don't even know exactly what it means. Good thing jemfinch left :-)
21:53:12 <dennisb> It probably has something to do with () at least
21:53:38 <inkedmn> so should i have not used the parentheses?
21:53:45 <seth> No, you should
21:53:49 <inkedmn> ok
21:54:01 <dennisb> don't mind me, I'm just talking to myself
21:54:05 <seth> They are just saying it would be more user friendly if you didn't have to.
21:54:24 <inkedmn> got it
21:55:25 <inkedmn> hmm, this exercise tells me to get the maximum value in a list using a fold...
21:56:19 <inkedmn> oh, and using max
21:56:21 <dennisb> normal function application binds the hardest, when one write a + f g it will first perform f g and then the addition
21:58:19 <dennisb> and same thing for other operators like . (which is function composition)
21:58:55 * dennisb is bored
21:59:13 * inkedmn is wondering how he's going to do this...
21:59:14 <dennisb> I need to do something.. question is what...
21:59:25 <dennisb> ask away!
21:59:49 <inkedmn> ok, from what i've read, it says that folds take an int, an operator, and a list
22:00:20 <dennisb> it could take that, fold is actually even more general
22:00:22 <inkedmn> and, depending on the first two arguments, return an integer based on the list elements
22:00:32 <inkedmn> is there just "fold"?
22:00:39 <inkedmn> as opposed to foldl and foldr
22:01:02 <dennisb> no function just called fold
22:01:10 <inkedmn> ok
22:01:17 <seth> I don't think so.  If there were, it would be an alias for one of them anyway.
22:01:25 <seth> So better to be explicit.
22:01:34 <inkedmn> alright, i understand what fold(l|r) does
22:01:35 <dennisb> Think of lists, there you have a long row of values. Fold puts an operator between all the values
22:02:40 <inkedmn> ok, but it wants me to return the largest value in the list...
22:02:41 <dennisb> then to the right (for foldr) you put in an extra value that is not in the list (the integer in you example, but it does not have to be an integer)
22:03:36 <dennisb> there are functions for that already in the prelude (but you can define the function for that your self of course)
22:03:56 <inkedmn> i'm assuming it wants me to do it manually
22:04:01 <dennisb> it?
22:04:12 <inkedmn> get the largest value using fold
22:04:14 <inkedmn> and max
22:04:23 <dennisb> sure, should work
22:04:26 <inkedmn> instead of just sorting the list and grabbing the last element
22:04:55 <inkedmn> i guess i'm just not totally understanding fold then...
22:05:13 <inkedmn> i thought it just performed an operation on a list of integers...
22:05:17 <dennisb> I think it's easier to understand with easy operators like plus
22:05:37 <dennisb> say you have list [1,2,5] and you want to sum the elements, okay
22:05:43 <seth> It performs an operation on a list, which is not necessarily a list of integers.
22:05:52 <inkedmn> ok
22:06:01 <dennisb> what you can do with fold is to put the operator + between the elements to form 1+2+5
22:06:31 <dennisb> except that foldr adds an extra element to the right, which if you put in 0 would form 1+2+5+0
22:06:54 <dennisb> so try: foldr (+) 0 [1,2,5]
22:06:54 <inkedmn> foldl (+) 0 [1,2,5]
22:07:16 <inkedmn> oh, didn't see that... :)
22:07:18 <inkedmn> ok
22:07:46 <inkedmn> returned 8
22:07:47 <dennisb> with other operators and another end value you could get back something that is not an integer
22:08:17 <dennisb> but it's easiest to understand with integers in the beginning i guess
22:08:32 <inkedmn> yeah, i'm only on section 3 of this tutorial :)
22:08:43 <inkedmn> haven't gotten into anything hairy yet
22:09:07 <dennisb> foldr would extually form the value (1+(2+(5+0))), it starts to calculate from the right
22:09:14 <inkedmn> ok
22:09:17 <dennisb> foldl starts from the left
22:09:25 <inkedmn> yeah
22:09:41 <dennisb> for + it doesn't really matter since you get the same result (except that one might be more efficient)
22:10:00 <inkedmn> yeah, it said foldl is generally more efficient that foldr
22:10:36 <dennisb> the function + can be used in two ways. either you write 4 + 5 or (+) 4 5
22:10:46 <inkedmn> ok
22:11:40 <dennisb> and a function max with two arguments can be used in two ways. Either you write max 4 5 or 4 `max` 5
22:11:51 <dennisb> do you use hugs or ghci?
22:12:02 <inkedmn> hugs
22:12:07 <inkedmn> but i have ghci too
22:12:23 <dennisb> good, then it's easy to test stuff. Just as long as you don't compile everything
22:12:29 <inkedmn> heh, no
22:12:46 <inkedmn> so, can you pass max to foldl?
22:12:50 <inkedmn> like :
22:12:52 <dennisb> yes
22:13:00 <inkedmn> foldl (max) 0 [1,2,5]
22:13:03 <inkedmn> ah..
22:13:35 <dennisb> you want to form (1 `max` (2 `max`  (5 `max`0)))
22:13:45 <inkedmn> hmm
22:13:59 <inkedmn> the way i typed it gave me a type error
22:13:59 <dennisb> which is what it do
22:14:05 <dennisb> foldr
22:14:06 <inkedmn> so, foldr
22:14:08 <inkedmn> :)
22:14:24 <dennisb> foldl takes the value to the left
22:15:06 <dennisb> no it doesn't, i'm confused
22:15:23 <inkedmn> ok, that worked...
22:17:50 <dennisb> have you seen ++ ? (I assume you have)
22:18:09 <dennisb> then you might figure out what this is: foldr (++) []
22:18:17 <inkedmn> i haven't yet
22:18:36 <dennisb> aha, just try: "fff" ++ "hhh"
22:18:59 <dennisb> it concatenates to lists
22:19:15 <dennisb> strings are just lists of characters
22:19:22 <inkedmn> ah, ok
22:20:14 <dennisb> you can give foldr (++) [] a list of strings and it will concatenate all of them into one big string
22:20:28 <inkedmn> nice...
22:20:45 <inkedmn> ok, last exercise :)
22:20:53 <dennisb> same thing as before, just puts the ++ between the strings in the list
22:20:56 <dennisb> sure
22:21:07 <inkedmn> i have a list of tuples
22:21:15 <inkedmn> (at least 3 elements)
22:21:28 <inkedmn> need to grab the first element in the second tuple
22:21:36 <dennisb> ok
22:21:53 <dennisb> and what is the problem? ;-)
22:21:58 <inkedmn> heh
22:22:06 <inkedmn> hmm...
22:22:14 * inkedmn thinks REAL hard
22:22:47 <dennisb> I can think of ar least two different ways: pattern matching or list functions in the List module
22:23:20 <inkedmn> well, i'm sure there's an easy way to do it using some sort of indexing, but i'm trying to only use what the chapter has showed me up to this point
22:23:22 <inkedmn> which isn't much
22:25:19 <inkedmn> i'm assuming i'll be using fst and/or snd
22:25:26 <dennisb> Well it's not that little either, some people have lots of trouble understanding folds. I don't know why but that is the truth
22:25:40 <dennisb> yes, fst or snd to pick out a part of a tuple
22:25:48 <inkedmn> folds seem pretty straightforward to me (atm)
22:25:51 <dennisb> left to do is to get the second tuple in the list
22:25:56 <inkedmn> yeah
22:26:42 <inkedmn> would (read: could) i use a fold in this situation?
22:27:17 <dennisb> well, fold would go through the whole list with some operator. doesn't seem to be what we want
22:27:25 <inkedmn> yeah
22:27:31 <inkedmn> i was thinking the same thing...
22:27:55 <inkedmn> hm...
22:27:58 <dennisb> I don't know what it is that you have learned in the chapter you've read so I don't know what solution they want you to arrive at
22:28:08 <dennisb> pattern matching is what I would use
22:28:25 <inkedmn> heh, haven't covered that yet :)
22:28:43 <inkedmn> do lists in haskell do any index-type things?
22:28:48 <dennisb> yes
22:28:52 <inkedmn> ok
22:29:17 <dennisb> there is an operator called !!
22:29:34 <inkedmn> ok
22:30:01 <dennisb> try this in hugs: :t (!!)
22:30:06 <dennisb> :t is very useful
22:30:44 <dennisb> hugs tells you the type of the thing after :t
22:30:58 <inkedmn> ah
22:31:34 <dennisb> I use it all the time, for example to know what arguments foldl expects, and in what order
22:31:44 <inkedmn> ok
22:31:53 <inkedmn> so !! takes a list and an int
22:32:00 <inkedmn> returns list[int]
22:32:07 <inkedmn> yes?
22:32:23 <dennisb> no
22:32:27 <inkedmn> ok
22:32:32 <dennisb> [a] -> Int -> a
22:32:55 <inkedmn> would you translate that for me? :)
22:33:03 <dennisb> takes a list with values of type a (can be any type, a is a type variable), it takes an Int, and it gives a value of type a
22:33:14 <inkedmn> ok
22:33:15 <lament> inkedmn: yes, list[int] if you use Python terminology
22:33:21 <lament> but don't use it :)
22:33:26 <inkedmn> lament: heh, ok
22:33:27 <dennisb> aha, I don't know python
22:33:42 <inkedmn> yeah, that's list[index]
22:33:54 <inkedmn> returns the corresponding element
22:33:57 <inkedmn> anywa
22:33:57 <inkedmn> y
22:34:38 <inkedmn> oh, how do i create a list and assign it a "variable" name?
22:34:42 <dennisb> i've written a couple of python program thought. I even wrote one last week
22:34:56 * inkedmn writes python stuff all day long
22:35:02 <dennisb> let x = [1,2,3,4] in ....
22:35:24 <dennisb> if you put your definition in a file that you load into hugs you can just write my_list = [1,2,3]
22:36:09 <inkedmn> ah ok
22:36:11 <dennisb> In hugs all definition must be in a file, you can only evaluate expressions on the command line. Not define new things
22:36:22 <inkedmn> ok
22:36:30 <inkedmn> could you show me a quick example of !! in action?
22:36:47 <dennisb> (!!) [1,2,3] 2
22:37:05 <dennisb> compare with the type: [a] -> Int -> a
22:37:22 <dennisb> or if you use it as an operator: [1,2,3] !! 2
22:37:50 <dennisb> !! takes a list and an integer
22:37:56 <inkedmn> ok
22:39:36 <dennisb> The types are very important in haskell (and other strongly typed languages). Actually, it is equally important in other languages but you don't notice until you get a runtime error :-)
22:39:45 <inkedmn> heh
22:39:49 <inkedmn> ok, here's what i did:
22:39:50 <inkedmn> List> fst([(1,'a'), (2,'b'), (3,'c')] !! 1)
22:39:58 <inkedmn> that returned 2
22:40:04 <inkedmn> done correctly?
22:40:08 <dennisb> yes, that works. Now make it into a function
22:40:30 <inkedmn> heh, um...
22:40:40 <inkedmn> let fun myFun = ...?
22:40:42 <dennisb> I would guess the type of the function to be:  [ (a,b) ] -> a
22:40:53 <dennisb> do it in a file foo.hs that you load with :l foo.hs
22:41:09 <dennisb> or I can just show you
22:41:18 <inkedmn> that'd be cool :)
22:41:26 <inkedmn> since i really have no idea where to begin with that
22:41:29 <dennisb> foo xs = fst (xs !! 1)
22:41:47 <dennisb> that is the line you put in your program and then you can do: foo [(1,'a'), (2,'b'), (3,'c')]
22:41:57 <inkedmn> ah, ok
22:42:05 <inkedmn> foo is the function name, xs is the argument
22:42:06 <dennisb> it's as simple as that
22:42:07 <dennisb> yes
22:42:11 <inkedmn> ah, ok :)
22:42:19 * inkedmn tries it real quick
22:42:27 <dennisb> it's a function definition so we cant do it on the command line
22:42:42 <dennisb> at the command line even
22:44:41 <inkedmn> do i have to compile it before i can load it?
22:44:45 <dennisb> maybe I should get some breakfast, it's almost 8 a clock
22:44:46 <dennisb> n
22:44:47 <dennisb> no
22:44:50 <dennisb> just load it
22:44:58 <inkedmn> :load Practice ?
22:45:00 <dennisb> hugs is an interpreter
22:45:05 <dennisb> what is the filename
22:45:09 <dennisb> :l filename
22:45:10 <inkedmn> Practice.hs
22:45:22 <inkedmn> do i need the:
22:45:25 <inkedmn> module Practice
22:45:29 <dennisb> no
22:45:31 <inkedmn> ok
22:46:10 <dennisb> for bigger programs you want modules that you can import and so on, but for playing this is just a one line file
22:46:16 <inkedmn> unable to load file Practice
22:46:25 <dennisb> hmm
22:46:33 <dennisb> try :l Practice.hs
22:46:33 <inkedmn> does it have to be in a certain directory?
22:46:41 <inkedmn> tried that too, same deal
22:46:49 <dennisb> current directory where you started hugs
22:46:56 <inkedmn> oh...
22:47:17 <inkedmn> can i add directories for hugs to look in?
22:47:22 <dennisb> you can also specifiy the whole path, and do :cd I guess
22:47:47 <dennisb> I don't think so, I just start it from the command line with hugs foo.hs
22:48:04 <dennisb> then hit :r to reload the file when I edit it
22:48:17 <inkedmn> heh, ok 
22:48:20 <inkedmn> the whole path thing worked
22:48:36 <dennisb> after it's loaded you can do :r
22:48:36 <inkedmn> and the function ran fine :)
22:48:50 <dennisb> nice!
22:48:55 <inkedmn> :)
22:49:00 <inkedmn> thanks a ton for your help man :)
22:49:12 <dennisb> no problem
22:49:13 <inkedmn> oh, i'm thinking about buying a book on this stuff
22:49:16 <inkedmn> any recommendations?
22:49:39 <inkedmn> something for the functional retard, if possible
22:50:19 <dennisb> I've not read many books so I'm not sure which is the best
22:50:28 <inkedmn> gotcha
22:50:33 <inkedmn> say, where are you?
22:50:39 <inkedmn> (geographically, i mean)
22:50:43 <inkedmn> UK?
22:50:47 <dennisb> I learnt another functional language first and then I just read the standard and other stuff
22:50:48 <dennisb> sweden
22:51:45 <dennisb> I'm sure you can get some recomendation later of in this channel from someone else..
22:51:51 <inkedmn> cool :)
22:52:02 <inkedmn> gotta go get some gin for my wife :)
22:52:14 <inkedmn> thanks again, i'll be back here real soon i feel :)
22:53:27 <dennisb> No, problem. You are welcome. Breakfast it for me...
