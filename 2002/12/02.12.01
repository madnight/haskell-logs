00:22:48 <aquacable> just online
01:12:38 * shapr plays with elisp macros
01:13:07 * shapr can barely wait for TH
01:13:15 <shapr> hi kev
01:13:35 <shapr> cool, new people here
01:15:36 <tez> TH? Oh template Haskell
01:15:42 <shapr> hi tez, wassup?
01:15:43 * shapr bounces
01:15:51 <tez> Hello :)
01:16:02 <tez> Not much.  I'm thinking about getting a sharp Zaurus.
01:16:14 <shapr> hey, can't those run Hugs?
01:16:19 <tez> (hugs has been ported over)
01:16:20 <tez> yes, lol
01:16:28 * shapr is very interested in a palm Haskell
01:16:35 <tez> python too.
01:16:42 <shapr> well, I have Python on my Palm III
01:16:48 <shapr> works just fine
01:16:56 <tez> Python has been ported on to the Palm?
01:16:59 <shapr> yah, sure
01:17:00 <shapr> long ago
01:17:02 <shapr> Pippy
01:17:03 <tez> How much space does it take?!
01:17:12 <shapr> lots of space
01:17:13 <tez> I have an 8Mb PalmV somewhere.
01:17:14 <shapr> 200k or so
01:17:19 <shapr> oh you have *plenty*
01:17:22 <tez> Oh, that's not too bad.
01:17:27 <shapr> I'm running on a 4Mb Palm III
01:17:43 <shapr> and I still have lots of spare space
01:18:34 <tez> Oh, well my Palm is filled with lots of useless stuff.
01:18:44 <shapr> I take lots of notes with mine
01:18:50 <shapr> I've worn out the graffiti pad :-(
01:19:02 <tez> Yeah, me too - lots of spurious spots and strokes.
01:19:13 <shapr> mine has a frosted look
01:19:22 <shapr> it's gotten to the point where making å is difficult
01:19:46 <tez> lol.  I use one of those screen protectors.  But character recognition is starting to suck.
01:20:07 <shapr> I didn't know about screen protectors till after mine was fuzzed.
01:20:13 <tez> lol
01:22:50 <tez> I use my palm for taking short notes, and reading websites, news, reference stuff.  I don't do too much writing on it.
01:23:27 <shapr> I always forget to carry writing tools, and my palm is attached to my belt 100% of the time, so it's simpler for me.
01:23:29 <shapr> I should really upgrade.
01:23:41 <tez> Although I did use to play a lot of Galax.  One of my buttons is completely knackered.
01:23:51 <shapr> heh
01:25:42 <tez> Right, I'm off.  It's Sunday morning - I'm going to buy a paper.
01:26:04 <shapr> cya
01:36:06 <shapr> Logan: hey, feature request... I want to be able to ask xmms-shell what state shuffle and repeat are in...
01:37:09 <shapr> oh, you already did that with the new release.. duh
01:40:32 <shapr> thanks Logan
02:15:38 <shapr> gutentag ustenzel
02:16:38 <ustenzel> hello
02:16:45 <shapr> how are ya?
02:18:20 <ustenzel> just fine
02:19:35 <shapr> written any cool Haskell code lately?
02:20:00 <ustenzel> no, though i wish i had.
02:20:05 <shapr> heh, me too
02:20:11 <shapr> read any cool Haskell code lately? :)
02:20:18 <aquacable> And me just still trying to understand it....
02:20:27 <ustenzel> i've been looking for some interface between haskell and some database.
02:20:36 <aquacable> is there something like a global var in haskell?
02:20:53 <ustenzel> couldn't find anything that worked and was nicer than Perl's DBI...
02:21:21 <shapr> there is a way to do global vars in Haskell... John Hughes posted something to one of the mailing lists recently
02:21:39 <shapr> HaskellDB is by far the niftiest interface
02:21:43 <aquacable> I'm trying to write something for my auth.log
02:21:50 <aquacable> read the lines
02:21:51 <shapr> but it requires Hugs and ODBC, or DB specific support
02:21:57 <shapr> currently HaskellDB does MySQL also
02:22:10 <shapr> if it does Postgresql, I'm on it like white on rice
02:22:21 <aquacable> and specify the times of the messages something took place in a month
02:22:31 <shapr> aquacable: tried Parsec?
02:22:38 <aquacable> parsec?
02:22:39 <aquacable> nope
02:22:43 <aquacable> is that a function?
02:22:49 <shapr> nah, it's a parsing library
02:22:51 <shapr> comes with GHC
02:22:53 <shapr> it's very nice
02:23:13 <ustenzel> HaskellDB indeed is nice.  It needs another backend and should work with GHC, though.
02:23:29 <shapr> yah, I agree
02:23:36 <aquacable> I'll check it
02:23:44 <shapr> HaskellDB + GHC + Postgresql would put it at the top of my list.
02:23:50 <aquacable> but this should be able to be done without that
02:24:07 <shapr> aquacable: I'm sure it can be, but Parsec is awesome and powerful...
02:24:18 <shapr> if you're just starting you may want to skip Parsec for the moment.
02:24:30 <aquacable> I'm actually just starting :)
02:24:36 <ustenzel> shapr: Right.  Unfortunately GHC does not support Trex, which breaks HaskellDB completely.
02:24:49 <shapr> right, which very much sucks
02:24:59 <ustenzel> Or is Trex-support for GHC planned?
02:25:05 <shapr> I don't know
02:25:22 <shapr> someone asked that recently on the mls
02:25:25 <shapr> I forget the answer
02:26:17 <shapr> iirc, Trex is about runtime extensible records/types
02:26:22 * shapr begins to remember
02:26:35 <shapr> Simon PJ said something about Trex being picky and painful, but possible
02:26:37 <shapr> I think that's true.
02:26:44 * shapr looks in his local archives
02:26:49 <ustenzel> I think fundeps have enough power to build something similar to HaskellDB, but would require a different syntax.
02:27:29 <shapr> I only know that fundeps exist, I don't really understand them.
02:28:19 <ustenzel> The interesting part is that they allow calculations in the type system.
02:28:25 <shapr> aha, ghc-users, november seventh
02:28:40 <shapr> well, tcp/ip allows calculations in the hostmask...
02:29:04 <shapr> nearly any system can do calculations if you look at it from a certain direction :-)
02:29:17 <ustenzel> Yeah, but the type checker runs at compile time.
02:29:41 <shapr> true
02:30:04 <shapr> I think part of the big idea of strongly typed languages is to move calculations into compile time
02:30:04 <ustenzel> Say you were building something HaskellDB alike.  You would have operations that took two tuples and returned a tuple.
02:30:10 <shapr> totally the opposite of Python for example
02:30:48 <ustenzel> those tuples need types, and with relational operators finding those types is not exactly trivial.  But doable, I think.
02:31:11 * shapr is out of his depth, but is willing to listen :-)
02:32:21 <shapr> well, anything that'll get me closer to HaskellDB using Postgresql, I'm interested.
02:33:09 <ustenzel> if you're content with hugs you only need some greencard code, I think.
02:33:18 <shapr> I don't use Hugs
02:33:25 <shapr> only rarely to check weird error msgs
02:33:51 <ustenzel> gtk+hs doesn't work with Hugs.  Sad, isn't it?
02:33:59 <shapr> yes, it is
02:34:11 <shapr> we really need both gtk and curses interface
02:34:29 <shapr> even better, something like Python's anygui that gives a standard interface to multiple windowing toolkits
02:34:54 <ustenzel> so I either have HaskellDB or Gtk+hs... bad luck, when you're building a db frontend.
02:34:55 <shapr> tcl interface would be a good start, since tcl runs on both win32 and linux
02:35:01 <shapr> yah, truly :-(
02:35:28 <ustenzel> FranTK is said to be quite useful.
02:36:21 <ustenzel> but somehow I don't like the idea of linking a tcl interpreter into my program and then having to generate code for that.
02:37:20 <shapr> if it works like Python, it would let you write one program for both win32 and linux
02:39:20 <ustenzel> and that is really useful?
02:39:28 <shapr> for me it is
02:39:38 <shapr> I have paying customers who use win32
02:39:44 <ustenzel> such a programm will need more cross-platform interfaces.
02:40:26 <ustenzel> a portable gui with no portable functionality underneath is not much good.
02:40:43 <shapr> that's true.
02:41:07 <shapr> if HaskellDB had a tcp/ip postgresql interface, it should be portable
02:41:52 <ustenzel> hm, right.  
02:42:31 <ustenzel> yeah, that's useful.
02:42:54 <ustenzel> could save my "customer" from installing linux :)
02:43:07 <shapr> ustenzel: right
02:43:13 <shapr> and you could still use a linux backend
02:43:18 <shapr> and they wouldn't have to know or care
02:43:23 <shapr> god morgon Marvin--
02:43:36 <Marvin--> morrn :)
02:48:39 <ustenzel> Does anyone know what's up with the Haskell wiki?
02:48:57 <ustenzel> it is dead, large parts of it at least.
02:50:32 <shapr> yah, it's dead :-(
02:50:36 <shapr> I'm not happy about that.
02:51:01 <shapr> I offered to convert the content to something else on the mailing list, and I emailed the people I thought might be responsible, but no response
02:51:58 * sethk is away: I'm busy
02:52:27 <ustenzel> Sad.  There used to be a page "HaskellWorldDomination".  Doesn't seem to happen atm...
02:52:35 <shapr> yah,I wrote that page :-)
02:52:55 <shapr> obviously we need to figure out who has shell access on that box and rip off the content ourselves...
02:52:59 <shapr> hostile takeover time!
02:53:09 <ustenzel> good idea.
02:53:22 <shapr> hey Igloo, are you awake?
02:53:27 <ustenzel> so porting CPAN was your idead?  I like it :)
02:53:37 * shapr suspects Igloo has best shell access to the box with the Wiki
02:53:57 <shapr> well, tmoertel jokingly suggested it, and I thought it was genius :-)
02:54:29 <Marvin--> shapr: how do you like Sweden so far? :P
02:54:35 <shapr> my recent idea is to create alt.comp.lang.haskell and alt.comp.lang.haskell.sources for snippets
02:54:42 <shapr> Marvin--: det är kul!
02:55:19 <Marvin--> shapr: found a Swedish keyboard, eh? ;)
02:55:32 <shapr> nah, x-symbol in xemacs
02:55:35 <Marvin--> aha
02:55:44 * shapr uses dvorak on a kinesis contoured keyboard
02:55:49 <shapr> well, heavily hacked dvorak layout
02:55:59 <Marvin--> eek
02:56:10 <shapr> I've added Hyper and Super, and lots of interesting keybindings
02:56:15 * Marvin-- has never bothered anything but qwerty
02:56:38 <shapr> kinesis rocks, it moves most of the modifier keys to your thumbs
02:56:38 * Marvin-- goes to mark programming assignments, sigh
02:56:43 <shapr> that's good for chording
02:56:52 <Marvin--> let's see what kind of weird skip lists these groups have implemented
02:56:54 <shapr> Marvin--: you have access to wiki sources on haskell.org ?
02:57:15 <shapr> or know someone who does?
02:57:20 <shapr> it's time for a hostile takeover
02:57:44 <Marvin--> uh, no
02:57:47 <shapr> hmm
02:58:02 <Marvin--> I have no idea who have access to that machine
02:58:06 <shapr> Heffalump: could you rip off the wiki sources?
02:58:31 --- topic: set to '["mo' nads than you", "We put the Funk in Funktion", "See logs @ http://tunes.org/~nef/logs/haskell/", "Gtk+HS 0.14.10: http://www.cse.unsw.edu.au/~chak/haskell/gtk/", "HWS-WP: http://www.dum.chalmers.se/~marvin/hws-wp/", "need HaskellWiki source text, contact shapr"]' by shapr
02:58:51 <shapr> hopefully someone will have access.
03:01:01 <Marvin--> wow, this is impressive, their skiplist is faster than the red-black tree they were given
03:48:57 <Marvin--> damn
03:49:03 <Marvin--> my computer is too fast
03:49:05 <shapr> ?
03:49:16 <andersca> Marvin--: now that's a problem
03:49:38 <Marvin--> I'm testing the groups' programs for different implementation of ordered dictionaries
03:50:02 <Marvin--> but even when I run the program on the largest test file, it's hard to see a difference, most of the time is java start up time
03:52:24 <shapr> good students, sucky java ;-)
03:53:04 <Marvin--> no, silly test files that are large enough for the crappy sparcs on the university network but not large enough for my athlon 1.4 :P
03:53:11 <shapr> oh
03:53:12 * Marvin-- ponders drinking some coffee
03:53:16 <shapr> yes!
03:53:17 <shapr> coffeeeee!
03:53:20 <Marvin--> coffee it is
03:53:51 * andersca finds a bug due to lack of type safety in C
03:54:34 * shapr finds a bug due to lack of understanding regexps in elisp
03:57:20 <Heffalump> I think the only people with access to the wiki data are the people who run it
03:57:34 <Heffalump> but they did ask for help migrating to different software, IIRC
03:58:06 <shapr> and I'm willing to help..
03:58:12 <shapr> and I've posted to haskell@haskell.org saying that :-)
03:58:29 <Heffalump> oh, maybe I'm misremembering what they said then
03:58:40 <shapr> no, they really did say that
03:58:44 <Heffalump> ah, ok
03:59:06 <shapr> I posted my offer of help months later.
03:59:12 <shapr> just haven't had any kind of response since then.
04:00:48 <Heffalump> try emailing the admins personally
04:01:21 <shapr> I emailed John Heron, and someone else...
04:01:24 <shapr> I'll find others to email.
04:10:01 <Marvin--> bleh, enough marking for now
04:11:36 <shapr> crap, I should have checked in this file an hour ago...
04:11:49 <shapr> I've forgotten what worked.
04:16:01 <Marvin--> hmm, should I do this with a toposort and list traversal, or with tree traversal directly, hmm
04:16:44 <Marvin--> dark
04:16:46 <dark> Greetings
04:17:54 <shapr> hi dark
04:17:57 <shapr> wassup?
04:18:02 <shapr> hello Cryptor
04:18:06 <dark> I'm trying to use HOpenGL :)
04:18:13 <Cryptor> hello shapr..
04:18:14 <shapr> yay!
04:18:19 <dark> Is it correct that the version in the ghc packages doesn't actually work and isn't complete yet?
04:18:45 <shapr> dark: I don't know... I gave up on it and built my own ghc, with which I haven't tried HOpenGL at all.
04:18:56 <dark> Most of the symbols mentioned in the tutorial seem to be missing from it :)
04:19:08 <shapr> the tutorial is old :-/
04:19:15 <shapr> Cryptor: new to Haskell? have questions?
04:19:20 * shapr fights with elisp
04:19:44 <dark> I can build my own HOpenGL but as a proper Debian developer that means I have to package it :-)
04:19:47 <Cryptor> not particular new, but monads are messing my head, how do I run external commands, and get their stdout as a string?
04:20:03 <shapr> dark: I'd be happy if you did so.
04:20:24 <shapr> I'd be even happier if HaXml were *not* part of the ghc5 package, but instead a separate package
04:20:30 <dark> As an alternative I'm considering making Haskell bindings for SDL.  I like SDL.  But I see on various mailing lists that it doesn't use acceleration features.  Not that I really care, as long as my own card doesn't have those ;-)
04:20:47 <shapr> I have heavy duty OpenGL accel here
04:20:49 <dark> shapr: It's conflicting with your own installation of it?
04:21:04 <shapr> yes, I can't use HaXml in GHCi, because it's built into the base libs
04:21:06 <dark> shapr: How much do you get with glxgears?
04:21:12 <shapr> hm, lemme look..
04:21:29 <Cryptor> ive tryed "do output <- system ("echo \"" ++ string ++ "\" | command") but it doesn't seem to work well.
04:21:34 <shapr> er, what's the fps switch?
04:22:19 <dark> shapr: Hmm it does it on its own for me.  Prints a line after a while.
04:22:32 * shapr decides to hang around and stare at it then
04:22:40 <dark> Cryptor: The system function isn't designed for that, it just runs the program.  You could redirect output to a file and then read the file later, but that's clunky.
04:22:57 <Cryptor> dark: very clunky.
04:22:58 <shapr> 11064 frames in 5.0 seconds = 2212.800 FPS
04:22:59 <dark> Cryptor: Check out the popen call in the Posix module.  Let's see where it is...
04:23:12 <dark> shapr: Heh, 142.200 FPS here.
04:23:18 <Cryptor> dark: its not standard?
04:23:27 <shapr> I play counterstrike in OpenGL mode :-)
04:23:48 <shapr> I can easily get 100 fps @ 1280x1024 in winex
04:23:56 <shapr> and I have max_fps set to 100, so I dunno how far up it goes
04:24:01 <Cryptor> dark: isn't the ability to make big programs out of little programs essential? 
04:24:17 <shapr> Cryptor: sounds like you want scsh
04:24:23 <shapr> which would be very cool in Haskell
04:25:16 <Cryptor> most programming languages have a 'system' command that returns stdout. Even QBasic, I believe.
04:25:35 <dark> Cryptor: Note that C doesn't.
04:25:36 <shapr> dark: I built this box for CS, so it better be fast in OpenGL :-)
04:26:07 <shapr> I only wish I'd know that NVidia drivers have SMP problems beforehand :-(
04:26:10 <Cryptor> dark: I don't know C, but I don't think it has many stardard functions, besides sqrt.
04:26:52 * shapr has thought of a good name for a Haskell assembler .. "dissembly"
04:27:06 <shapr> dark: SDL bindings would be very cool
04:27:11 <ustenzel> isn't there a seperate popen-library that reads the output as a lazy string?
04:27:14 <shapr> iirc, SDL works in win32
04:27:18 <Cryptor> still, I would think it essential, especially in a functional programming language. I've made four little programs, and all I want to do is glue them together.
04:27:23 <shapr> there is popen.hs, I donno how it works.
04:27:26 <ustenzel> i think i saw it on the website somewhere
04:27:34 <dark> There's POpen in the posix package.
04:27:35 <Cryptor> dark: is that design mentality non-standard?
04:27:44 <dark> And runProcess in Posix.hs
04:27:58 <shapr> Cryptor: it's standard if you want to stick those programs together into one binary
04:28:17 <dark> shapr: There's already a functional language called SDL, I wonder how to avoid confusion.
04:28:20 <shapr> ime, FP is more about combinator code
04:28:41 <dark> Cryptor: In Haskell the normal approach would be to turn them into modules and import them.
04:28:54 <shapr> I've never heard of SDL, so I think confusion avoidance shouldn't be so hard.
04:29:08 <dark> shapr: I found it while googling for "haskell sdl" :)
04:29:27 <shapr> oh
04:29:28 * shapr looks
04:29:34 <Cryptor> dark: thats a windows design mentality though...
04:29:55 <Cryptor> dark: make big bloated programs instead of lots of simple little ones.
04:30:07 <dark> Cryptor: Well, the unix approach would be to chain the programs in a pipe instead of having them invoke one another :)
04:30:36 <Cryptor> dark: I would, but they don't click that well together...
04:30:55 <Cryptor> dark: I guess I could do a lot of sed work...
04:30:59 <dark> Cryptor: Well, then there's runProcess and popen in the posix package.
04:31:14 <dark> Cryptor: Or write a fifth program to put between them :)
04:31:42 <shapr> yah, small selfcontained pieces that are used by a glue piece
04:31:58 <dark> I think Haskell is intended to be portable to non-posix systems, in case people still have some somewhere.
04:32:15 * dark kicks System.Directory viciously.
04:32:32 <o3> woooooooooot
04:32:41 * o3 got runtime loader and hopengl working on GHC on Mac OS X
04:32:49 <Marvin--> heh
04:32:49 <o3> wolfgang == legend
04:32:53 <dark> o3: Did you have to compile your own hopengl?
04:33:57 <o3> dark: yeah.  had to add a GL include directory so that ghc could find the GL headers, but it worked flawlessly after that
04:34:06 <dark> shapr: I'm thinking of making a hexgrid-based wargame, a la battle isle and fantasy general.  Would you recommend OpenGL or SDL?  I do intend to use lots of alpha blending to fit the map pieces together.
04:34:07 <o3> haskell code on os x seems more portable than c code on os x :)
04:34:47 <Marvin--> haha
04:34:55 <dark> o3: C stopped being portable when system vendors discovered cpp :)  I think this was in 1975...
04:34:56 <shapr> dark: I'd recommend OpenGL for alpha blending, but I don't much about SDL
04:35:09 <o3> dark: OpenGL and SDL are orthogonal, you can use both
04:35:16 <o3> (in fact, SDL has an OpenGL binding)
04:35:23 <shapr> yah, pygame uses both
04:35:33 <shapr> dark: you should check out FunGen
04:35:39 <dark> shapr: Yeah I looked at it.
04:35:44 <o3> i'd probably prefer to use SDL, since that provides a complete framework (with audio etc), and i prefer its design more
04:35:50 <shapr> the author(s) said they're completely rewriting it right now
04:35:57 <o3> and use OpenGL for all the graphics stuff inside that
04:35:58 <shapr> yah, SDL bindings would be spiffiest
04:36:03 <shapr> OpenAL, etc
04:36:04 <dark> o3: That sounds nice.
04:36:31 <dark> o3: And using OpenGL for all the 2D stuff works fine?  The SDL graphics interface doesn't get in the way?
04:37:16 <dark> Hmm this would mean I would still need to get HOpenGL working, I would just be able to avoid GLUT :)
04:37:23 <Cryptor> anyway of using 'IO.openfile' to do what I was trying to achieve earlier?
04:37:25 <dark> Unless I start with using only SDL.
04:37:29 <Cryptor> maybe through a fifo?
04:37:45 <o3> dark: as long as you don't touch any of the sdl graphics calls while opengl is active (like swapbuffers or whatnot), it works great.  you can even use sdl textures as opengl surfaces
04:37:47 <shapr> Cryptor: you should try popen, it's probably what you want
04:38:08 <shapr> jens wrote it for similar purposes iirc
04:38:09 <o3> s/textures/surfaces/
04:38:44 <o3> so you can do stuff like use sdl's texture loader to load a jpg texture file, render that to an SDL surface, and tell opengl to use the SDL surface.  i.e. you don't have to write your own OpenGL texture loader
04:39:00 <o3> ditto for the sdl libraries; things like fonts can be rendered to SDL surfaces, which can then be used by OpenGL
04:39:12 <o3> (this is what i know of, btw, i haven't actually tried it :)
04:39:21 <dark> Well it sounds good :)
04:39:27 <o3> the "Programming Linux Games" book is a really, really good introduction to SDL ... it's downloadable now
04:39:34 <o3> i'm sure googling for it will turn up something
04:39:45 <o3> just need to write SDL bindings for haskell
04:39:52 <o3> and maybe some cocoa bindings for haskell ;)
04:41:04 <shapr> o3: hey, that guy shows up on #emacs sometimes
04:41:07 <shapr> and other channel
04:41:08 <shapr> s
04:41:11 <shapr> as "overcode"
04:41:14 <o3> overcode?
04:41:21 <o3> heh, yeah.  he writes very well
04:41:25 <shapr> yah, he's a cool guy
04:41:33 <o3> PLG was one of the best linux books i've bought
04:41:54 <dark> Looks like http://www.overcode.net/~overcode/writing/plg/ is the download place.  But it's a bit unclear which PDF I need :)
04:42:56 <o3> "mirror on a random Apple iBook", nice
04:43:27 <o3> dark: hehe, just get both.  bandwidth is cheap
05:13:35 * shapr bounces
05:16:48 <Igloo> In x^power, is there a nice descriptive name for x?
05:17:29 <shapr> mantissa
05:17:35 <shapr> ?
05:17:49 * shapr isn't sure of that
05:17:54 <Igloo> Not AIUI
05:18:00 <ibid> base?
05:18:33 <Igloo> Hmmm, could do. Radix is the other possibility I came up with
05:21:01 <ibid> yeah, mantissa would be a in a+x^y, or something similar
05:21:14 <Igloo> YM *, not +, I think
05:21:43 <ibid> yeah
05:22:04 * ibid subscribed to haskell-doc
05:22:45 <Igloo> Hmm?
05:23:51 <ibid> pts
05:24:17 <Igloo> Ah, right
05:25:45 <Igloo> We need to write some magic scripts to make it easy the upstream tarball and Debian package build out of the arch repository
05:26:35 <ibid> something like cvs-buildpackage?
05:27:34 <Igloo> Probably. I've only had a quick look at it, though
05:27:46 <o3> Igloo: base or radix, i think
05:28:05 <o3> base is probably easier to understand :)
05:28:24 * Igloo has gone with radix, but I'm sure there should be a more applicable word
05:36:22 <dark> exponand?
05:37:20 <Heffalump> radix is wrong
05:37:24 <Heffalump> (as is base)
05:37:33 <o3> it is?
05:38:06 <Heffalump> they both apply to the value of x in the power series a*x^n+b*x^(n-1)+... when that power series is being used to represent a number
05:38:23 <Igloo> exponand doesn't exist
05:38:28 <Igloo> Even google only gets 1 hit for it
05:38:58 <ibid> Heffalump: yeah, so?
05:39:16 <ibid> Heffalump: x^n = 1*x^n + 0*x^(n+1) + ... :-)
05:39:50 <o3> i'm sure base is right
05:40:05 <dark> "logarithm" might be the actual name for it :)
05:40:10 <o3> googling for "base exponent" seems to support me
05:41:14 <ibid> dark: no
05:41:25 <ibid> dark: logarithm is the exponent :-)
05:42:05 <Heffalump> oh, googling suggests base is right too
05:50:37 <dark> Heh, PLG describes Nethack as "a very strange free RPG project"
06:04:05 * liiwi describes Nethack as major addictive thing
06:04:32 <ibid> liiwi here?
06:04:37 * ibid did not realise
06:07:39 * dark is more addicted to crawl.
06:07:49 <dark> liiwi is responsible for me being here :)
06:08:23 <dark> On this channel, I mean.  Not in a metaphysical sense.
06:08:42 <shapr> heh
06:10:24 <ibid> oh
06:10:30 <ibid> strange
06:10:46 * ibid has noticed dark here numerous times, but never liiwi
06:11:13 * shapr sproings
06:17:46 <liiwi> ibid:?
06:18:02 <liiwi> ah, erm. foo
06:18:29 <dark> bar
06:18:38 <shapr> baz
06:19:11 <dark> Hmmm, chocolate tea.
06:19:26 * dark flaunts his newfound decadence.
06:20:14 <o3> quuuuuuuuuuuux!
06:20:19 <liiwi> tea?
06:20:21 <dark> xyzzy?
06:20:37 <dark> quux comes after xyzzy, afaik.
06:21:02 <lament> no
06:21:06 <o3> oh, i always thought it was foo bar baz quux
06:21:15 <lament> xyzzy is not a metasyntactic variable at all
06:21:31 <lament> well, it can be used on rare occasions, but it's not in the standard list
06:21:50 <o3> excellent
06:21:50 <o3> http://www.tuxedo.org/~esr/jargon/html/entry/metasyntactic-variable.html
06:21:53 <lament> it's a teleportation spell
06:22:53 <o3> python programmers use spam and eggs, eh
06:23:12 <o3> wonder what haskell should use
06:23:14 <shapr> Haskell programmers use curry
06:23:21 <lament> heh
06:23:23 <o3> well, that's what i would think
06:23:34 <o3> what goes well with curry?
06:23:39 <o3> beefVindaloo is a bit too long :)
06:23:44 <shapr> chicken?
06:23:47 <shapr> curried chicken
06:23:56 <o3> and inAHurry probably isn't politically correct ...
06:23:56 <lament> chicken x y = ...
06:23:59 <shapr> heh
06:24:06 <dark> haskell programmers use single letters :)
06:24:14 <shapr> that gets scary sometimes
06:24:18 <dark> Even "foo" is far too long if you can use "f".
06:24:29 <shapr> f where f = a b c
06:24:36 <shapr> in x y z
06:24:37 <lament> haskell programmers are evil
06:24:51 <shapr> I usually end up looking like this --> %-O
06:25:02 <o3> i think we should do a gigantic cvs merge of the ghc tree and change all the tmp/foo/bar variables to curry/chicken/bork
06:25:06 * shapr laughs
06:25:09 <o3> i'm sure the ghc guys will be happy about that
06:26:53 <dark> What does bork have to do with it, though?
06:27:07 <shapr> export LOCALE=se_CHEF
06:27:08 <Heffalump> :-)
06:27:44 <o3> ooo
06:27:50 <o3> that'd be a nice easter egg in glibc
06:28:16 * shapr grins
06:28:23 <shapr> I didn't come up with that, zigg (Matt Behrens) did
06:28:51 <dark> (chicken : pot) ++ replicate 3 bork
06:29:05 <o3> does google still have the xx-bork thing?
06:31:31 <dark> "Its API is not especially pretty, but if you close your eyes and pretend you're doing something fun you can almost forget about it"
06:31:54 <shapr> o3: last I checked it does.. I use xx-hacker
06:32:25 <o3> dark: what's this in reference to?
06:32:49 <dark> o3: Open Sound System
06:33:00 <o3> oh yeah, that thing :)
06:33:03 <shapr> happily, ALSA is far superior
06:33:15 * shapr luvs ALSA
06:34:31 <dark> I needed ALSA to get sound at all on this machine :)
06:34:44 <dark> I still don't understand why it defaults to everything being muted, though.
06:34:48 <shapr> you can fix that
06:35:00 <dark> The Debian packaging for it seems to suck a bit.
06:35:06 <shapr> works fine for me
06:35:15 <dark> I zapped all of the init scripts and replaced them with an "alsactl restore" from a known-good setting.
06:35:31 <dark> (And I call that when loading the module)
06:35:47 <shapr> I just use aumix to load settings
06:36:01 <shapr> I'm happy stuff is muted when I'm switching 'tween headphones and speakers
06:36:08 <dark> Yeah but does it still try to remember settings across reboots?
06:40:13 * shapr isn't sure
07:57:07 <BlitzNL> I am working myself through some docs on writing folds and algebras. The problem is I need to write one for a quite complext datatype, the datatype of DTDs, and the examples are only showing simple solutions for binary trees and lists. Can anyone point me to a better doc? 
07:58:59 <Heffalump> I doubt there are any.
08:00:57 <BlitzNL> Heffalump: ok, I'l have to think harder than
08:01:34 <Heffalump> it is all fairly mechanical
08:01:47 <Heffalump> a fold provides a function to replace each constructor
08:50:32 <dark> Hmm... audio mixing just begs for lazy evaluation :)
08:51:31 <Heffalump> IWW?
08:52:51 <dark> IWW?
08:53:00 <Heffalump> in what way
08:53:35 <dark> Oh, you need to feed the sound card with a new chunk of data several times per second.
08:54:40 <dark> SDL does it with callbacks, which seems awkward.
08:56:04 <Heffalump> ahh
08:56:18 <Heffalump> but what happens if you want to change the data after you feed the soundcard a lazy stream?
08:56:28 <dark> Yeah I'm wondering about that :)
08:56:43 <Heffalump> I guess you could end the lazy stream with "ask me again now"
08:56:50 <Heffalump> though that ends up being a callback anyway, then
08:56:55 <dark> Or maybe unsafePerformIO :-)
08:57:19 <Igloo> play_sound :: Data -> IO Id; stop_sound :: Id -> IO ()
08:57:22 <dark> I guess it depends on the application.  Background music could easily be a lazy list.
08:58:07 <dark> Hmm, it's tempting to build on top of SDL instead of just wrapping it.
09:00:13 <dark> Making a Haskell sound mixer should probably be a separate project, though :)
09:00:33 <andersca> it's a shame I can't get gtk2hs to compile :/
09:01:51 <Igloo> Why do you need that rather than gtk+hs?
09:24:45 <BlitzNL> Heffalump: I finished it. I had to include all mutually recursive types. This is very mechanical, indeed ;)
09:26:11 * sethk is back (gone 06:34:13)
09:26:18 <Heffalump> yeah.
09:26:49 <Heffalump> I need to write an automatic fold and fusion rule generator for MAG (my Haskell-ish program transformation system) but I haven't got round to it yet
09:27:31 <BlitzNL> sounds cool
09:27:45 <andersca> Igloo: because that's for gtk+ 2
09:28:24 <Igloo> Ah, if you need GTK+ 2 features then fair enough
09:28:46 <andersca> Igloo: I'm a gtk+ developer so i always want to use the latest stable version :)
09:29:13 <Igloo> Well, I'm sure Chilli would welcome patches  :-)
12:18:19 <dark> Painful... all SDL function calls start with SDL_, so they're not suitable as Haskell function names.
12:18:28 <dark> This makes all the "foreign" declarations twice as long.
12:19:32 <Igloo> As a datapoint, I think gtk+hs drops gtk_ and gdk_ prefixes
12:21:28 <dark> Yeah, HOpenGL does the same with gl.
12:23:34 <dark> I plan to go both ways :)  An SDL module that exports a pretty interface, and an SDL.Bare module that exports all the foreign functions.
12:23:58 <dark> That way people have an escape hatch if the wrapper doesn't do what they need.
12:24:26 <dark> I guess I could still drop the sdl_ and access the functions as Bare.foo
12:25:21 <dark> On the other hand it's convenient to be able to translate SDL_INIT_TIMER as sdl_INIT_TIMER :-)  Otherwise it'd be something strange like iNIT_TIMER
12:38:29 <dark> By the way, this dropping means that GL has to do "import Prelude hiding (init)" :)
12:42:46 <Igloo> That won't work under H98 will it?
12:43:26 <Igloo> import GL hiding (init); import GL qualified is, though
12:50:29 <dark> Section 5.6.1 says it will.  If you import Prelude explicitly, it overrides the implicit import.
12:52:42 <Igloo> Ah, OK
12:53:05 * Igloo wonders if that changed after the no-implicit-prelude discussion
12:53:47 <Igloo> Ah, no, it's just not as flexible as was needed
13:57:13 <Rochler> hi. finally, i have fond a haskell channel :)
13:58:36 <Rochler> i'll start with a question. it's about currying. if i have a function, which has to parameters and i want to curry only the second one, how can i do that? example follews...
14:00:38 <Igloo> Hi
14:00:52 <Rochler> i have a "func :: Int -> Char -> String". i want to define a "func2 :: Int -> String" by doing "func2 = func ? 'x'". is there a syntax element for my '?' which works?
14:01:38 <Igloo> func2 = flip func
14:01:38 <Rochler> s/to parameters/two parameters
14:01:53 <Igloo> Ooops, func2 = flip func 'x'
14:02:15 <Rochler> ok. thx. i'll have a look at it..
14:03:39 <Rochler> does ($) have any use?
14:03:45 <Igloo> Yes.
14:03:52 <Rochler> can you tell me?
14:03:55 <Igloo> :-)
14:04:12 <Igloo> Well, you can't pass space as an argument to a function
14:04:18 <Igloo> Like in zipWith ($)
14:04:33 <Igloo> Also, it is right-associative and low precdence (vs left- and high for juxtaposition)
14:05:11 <Rochler> Igloo: ok, i'll have a look at the documentation about it...
14:06:31 <Rochler> Igloo: but there isn't an operator doing the same as the one I called '?'. it would be very practical...
14:07:15 <Igloo> Well, you could use flip as an operator. This is starting to sound like a homework assignment.
14:07:50 <Rochler> well, it doesn't exactly the same as flip.
14:08:03 <Rochler> it could be used on function with many more parameters
14:09:45 <Rochler> it would shift the replaced parameter behind the last parameter.
14:10:27 <Rochler> i guess it is impossible to define such an operator without changing the language specification...
14:12:37 <Rochler> can you confirm this, or am i perfectly wrong?
14:19:11 <Rochler> i guess, I'm not.
14:19:29 <Rochler> have, to go offline now. see you soon...
15:20:27 <dark> This sounds exactly like the wildcard sections we discussed earlier :)
15:20:48 <dark> (f _ 'x' _)
15:54:49 <andersca> gtk2hs is really sweet
16:14:37 <lament> Is there a good Haskell/Scheme/ML comparison anywhere?
16:31:55 <dark> I like how wrapping a library in Haskell gives better typechecking :)
16:32:44 <dark> Here's a function that takes one of those callbacks with a void * parameter, and Haskell can actually check that it's the right type.
16:33:55 <Heffalump> heh
16:45:45 <dark> Hmm, is there a trick for handling C structs with FFI, or do I have to write wrapper functions to convert to and from a Haskell representation?
16:46:28 <Igloo> c2hs does magic, I think
16:47:00 <Igloo> (Gee, I should ask Chilli for commission the rate I'm going  :-)  )
16:48:34 <dark> Hmm, I'm using hsc2hs :)
16:48:55 <Chilli> Igloo: heh? :-)
16:49:17 <Igloo> Chilli: I seem to be advocating either gtk+hs or c2hs once an hour  :-)
16:49:23 <andersca> :)
16:49:24 <Chilli> Igloo: thanks for the second patch btw
16:49:39 <Igloo> By the way, am I wrong in thinking the lexical syntax in the FFI spec is insufficient?
16:49:43 <Igloo> No problem
16:50:34 <Chilli> Igloo: I have a pile of FFI email in my inbox, which I haven't had a close look at yet (including yours)
16:50:47 <Igloo> Ah, OK, cool  :-)
16:50:47 <Chilli> Deadline for the revised lecture notes for AFP is today
16:51:02 <Chilli> and on Thursday the marks for the whole uni for this session are due
16:51:13 <Chilli> pretty chaotic atm
16:51:25 <Igloo> Right, no rush. Just wondered at the lack of response  :-)
16:51:36 <Chilli> yeah, sorry...
16:51:44 <Igloo> np
16:52:02 <Chilli> btw, re Clause and Statement: I fully agree with you
16:52:15 <Chilli> in fact, I asked proposed the same thing a while ago, too
16:52:34 <Chilli> (actually, I think, we were talking in irc about it)
16:52:53 <Igloo> Cool
16:54:13 <Igloo> I realised default (type defaulting) declarations are going to be a PITA for the type annotation stuff I want by the way
16:54:35 <Igloo> As you don't know the type of the 2 in x^2 until you have looked at the whole module
16:55:37 <Chilli> hmm
16:56:06 <Chilli> I guess, you need a query function in Q that tells you the current defaulting decl
16:56:36 <Igloo> That doesn't help, though
16:56:45 <Chilli> why?
16:56:51 <Igloo> foo = 2
16:57:03 <Igloo> $( x <- reifyDecl foo; f x )
16:57:13 <Igloo> default (Word8)
16:57:39 <Igloo> If f asks what the current default is it will be told Integer
16:58:02 <Igloo> But if you want to do partial evaluation you need to know that foo really has type Word8
16:58:04 <Heffalump> presumably default applies across the whole module?
16:58:20 <Heffalump> and if so, why wouldn't f be told Word8?
16:58:22 <Igloo> Yes, but TH works top to bottom so you can reify things in the same module
16:58:28 <Heffalump> ahh.
16:58:45 <Heffalump> well, ban reifing "default" decls, and do a first pass to get them
16:59:01 <Igloo> That's something I thought about, yeah
16:59:07 <Chilli> it doesn't quite work to-to-bottom IIRC
16:59:09 <Igloo> But it's a bit ugly
16:59:10 <Heffalump> it's a bit ick though, I guess
16:59:15 <Heffalump> ahem
16:59:16 <Chilli> it does all the manifest topdelcs first
16:59:18 * Heffalump is *not* Igloo
16:59:25 <Chilli> and then it grabs the first top-level splace and does that
16:59:33 <Chilli> then, the next top-level splice etc
16:59:48 <Igloo> OK, I hadn't looked at the details, but that default declaration could have been spliced in
17:00:13 <Chilli> well with the splicing in, you get dependent ion the order
17:00:20 <Chilli> but that's true for all spliced in topdelcs
17:00:20 <Igloo> What I'd like is a dependency analysis system, but Oege wants me to work on examples first
17:01:44 <Chilli> what if you try to reify a topdecl that you splice in?
17:01:44 <Chilli> that has an  undefined behaviour, too
17:01:44 <Chilli> why should the situation with spliced default decls be better
17:01:47 <Igloo> I don't think the dependence ever causes things to change rather than just not work in other situations, though
17:01:47 <Chilli> In other words, it is not nice, but it is consistent
17:01:54 <Heffalump> "default" and "infix" decls are the only things that can go anywhere in the code but can affect the entire thing apart from just what's in scope, right?
17:02:24 <Igloo> Oh, and infix, good point
17:02:31 <Chilli> what's the entire thing?
17:02:35 <Igloo> The whole module
17:02:51 <Chilli> all topdelcs are visible in the whole module
17:03:17 <Heffalump> can you have two infix declarations for the same operator?
17:03:19 <Chilli> Haskell usually doesn't have an ordering on topdecls, but toplevel splice introduce an order
17:03:28 <Chilli> that's ugly, but it's ugly for all topdelcs
17:03:31 <Igloo> Yes, but if you put function in the wrong order the compiler will tell you the function doesn't exist rather than giving you the wrong definition
17:03:35 <Heffalump> and if not, is an infix declaration only looked at when otherwise an error would have been reported?
17:03:36 <Chilli> Heffalump: no
17:04:08 <Chilli> Igloo: not sure about this
17:04:31 <Chilli> keep in mind that multiple fun decls are only reported if they are used (when one is imported)
17:04:35 <Chilli> so, let's have the follwoing
17:04:40 <Chilli> import M (foo)
17:04:46 <Igloo> OK, true
17:04:46 <Chilli> bar x = foo x
17:04:55 <Chilli> $(<code produucing a foo)
17:05:06 <Chilli> do you get an error or not?
17:05:41 <Chilli> or how about a producing a type sig for foo in one splice and an equation in another splice
17:05:54 * Heffalump thinks a cut-down version of Haskell needs to be produced for TH to manipulate
17:06:07 <Chilli> the fact that toplevel splices intrpduce an ordering into toplevel decls doesn't fit into H98 at all
17:06:11 <Heffalump> (not hugely cut-down, just things that can cause nasty things like this forbidden completely)
17:06:16 * Igloo wonders if TH should be explicitly targetted for a cleaner Haskell 2
17:06:31 <Chilli> in an ideal world, yes
17:06:41 <Chilli> but if we want to use it now, no :-)
17:06:41 <Igloo> Why can we not live in such an ideal world?
17:06:54 <Chilli> Because we are doomed *evil laughter*
17:06:57 <Chilli> ;-)
17:06:57 <Heffalump> you could find someone to volunteer to lead Haskell 2
17:07:11 <Chilli> Heffalump: ok, I volunteer you :-)
17:07:28 * Igloo volunteered, but no-one offered me lots of money in exchange  :-)
17:07:38 * Chilli is suprised
17:07:40 <Igloo> Well, to be more precise Heffalump and shapr didn't
17:08:14 <Chilli> Anyway, this mess needs to be cleaned up
17:08:35 <Heffalump> ok, someone who would be qualified to do so :-p
17:08:39 <Chilli> either by defining that some things have an undefined behaviour
17:08:55 <Chilli> or forbidding these htings altogether
17:09:11 <Heffalump> the former and have a compiler warning sounds best
17:09:28 <Igloo> It wouldn't take many restrictions - infixs next to (in the sense type signatures are) function definitions and default between imports and topdecls would sort a lot of it out
17:10:03 <Chilli> Should splices for default decls be allowed at all?
17:10:19 <Chilli> They are a nuisance, but barely helpful
17:10:27 <Igloo> If they have to be first I don't see the harm
17:10:59 * Igloo wonders how one gets to be qualified to lead Haskell 2
17:10:59 <Chilli> problem is that all the static topdecls are typechecked before the first splice is executed
17:11:14 <Chilli> so, the static topdecls will already have used the default default
17:11:44 <Igloo> That doesn't have to be done though, does it?
17:13:25 <Chilli> Igloo: similar as becoming a prophet: you need enough followers (and too much time on your hands
17:13:37 <Chilli> have too go
17:13:39 <Chilli> cu later!
17:13:45 <Igloo> I think you could do it quite nicely with dependency analysis and working out what decls each splice provides. This is more complex than I can explain easily on IRC at the moment, though
17:13:49 <Igloo> See ya
17:13:51 <Igloo> :-)
17:18:07 <dark> Hmm, currently Haskell doesn't have any "undefined behaviour", does it?  As long as you stay away from FFI.
17:18:14 <dark> I wouldn't like to introduce the concept.
17:18:35 * Igloo tries to treat undefined behaviour as forbidden wherever possible
17:19:01 <Igloo> This is inconvenient when POSIX says the behaviour of a script starting #! is undefined, though
17:20:08 <Igloo> The only thing I can think of, other than the precise size of Int, is that I can't remember if it defines how floating point numbers work
17:23:29 <dark> "The results of exceptional conditions (such as overflow or underflow) on the fixed-precision numeric types are undefined;"
17:23:56 <dark> floating point semantics are "implementation-defined", that's different :)
17:24:23 <Igloo> I really meant whether or nto they were defined to be IEEE *mumble* or not
17:24:31 <dark> That's only a "should".
17:24:40 <Igloo> Right
17:25:45 <dark> I guess overflow is undefined for the same reason that Int only has to be 30 bits: to reserve 2 bits for tagged values.
17:26:47 <dark> If you use the lower 2 bits for that then you still get nice overflow/underflow behaviour :)
17:28:55 <dark> Hm, SDL uses asynchronous callbacks.
17:46:51 <dark> I can't figure out from the FFI spec whether the "dynamic wrapper" import type is supposed to be able to deal with that.
17:48:27 * Igloo isn't up on anything more than simple static imports and doesn't have time to play at the moment unfortunately
18:02:34 <Igloo> Is there a better way of saying what I mean than "a single, or list of, foos or bars"?
18:04:17 <dark> The better way is probably by finding a generic word for foos or bars.
18:04:41 <dark> With single, do you mean unadorned by list syntax?
18:06:38 <Igloo> f :: Wibble a -> [String]  where Foo, Bar and Wibble a => [a] are instances of Wibble
18:07:03 <Igloo> (foo and bar are patterns and declarations)
18:09:14 <Igloo> All the clear ways of wording it seem to require much repetition
18:46:17 <dark> Bedtime :)
23:56:06 <aquacable> how do I convert an int to a string?
23:56:11 <aquacable> in c atoi...
23:56:19 <aquacable> no
23:56:24 <aquacable> that was the other way around
23:56:26 <aquacable> anyways
23:56:34 <aquacable> you hopefully know what I mean
