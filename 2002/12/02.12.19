01:18:31 * Marvin-- goes "err"
01:26:15 <Heffalump> err?
01:27:06 <Marvin--> I'm reading a paper by Dave Sands
01:27:21 <Marvin--> and I'm trying to understand the definitions ;)
01:27:27 <Marvin--> maybe I should start reading papers depth-first
01:27:49 <clausen> Marvin--: unfortunately, that isn't guaranteed to terminate, hehe
01:28:02 <Marvin--> damn, cyclic references
01:29:17 <Marvin--> aargh, lots of complicated operators
01:30:23 <clausen> perhaps some cantor diagonalization method?
01:31:42 <Marvin--> I wonder if that'll help my understanding though
02:15:16 <clausen> goulash!
02:15:28 <goulash> 5,00;4,00)
02:16:00 <Heffalump> clausen: it is if you memo(r)ise
02:16:11 <clausen> hehe
03:07:51 * sethk is away: Don't say anything until I return.
03:55:48 <clausen> goulash_: mais uma?
05:07:54 * Igloo splutters
06:02:03 <xkb_> test
06:03:17 <xkb_> Does random also work in Hugs?
06:03:34 <mgoetze> xkb_: have you tried it? :)
06:03:53 <xkb_> hehe no
06:07:24 <xkb_> Do u also need to import modules in hugs?
06:07:30 <xkb_> I guess so
06:07:46 * mgoetze doesn't need hugs.... :)
06:08:00 <xkb_> hehe.. neither do I normally
06:08:19 <xkb_> I thought I could type in definition in hugs as well
06:39:06 * Marvin-- sighs
06:46:32 <Marvin--> lo shapr
06:46:38 <shapr> y0 Marvin--
06:46:44 <shapr> wassup?
06:48:06 <Marvin--> still trying to decide on a master project :/
06:48:15 <shapr> have you narrowed the line of suspects?
06:49:29 <Marvin--> since it turns out that neither Jörgen nor Dave feel they have the time or energy to supervise a project concerning space improvement, I can narrow away that one anyway :P
06:49:46 <Marvin--> I was at the multimeeting today
06:50:02 <Marvin--> (the Thursday meeting of the research group for functional programming)
06:50:45 <shapr> good meeting?
06:51:06 <Marvin--> one of the PhD students was talking about how to implement a polytypic programming language in Haskell, using type classes
06:51:20 <Marvin--> yeah it was interesting
06:51:41 <Marvin--> but I'm still confused about the differences or similarities between template haskell, generic haskell and polyp
06:55:42 <Marvin--> I've sent a mail to Patrik begging him for more information :P
06:57:27 <shapr> from what little I understand
06:57:45 <shapr> generic haskell is about doing to every function what lists can do..
06:57:55 <shapr> "be polymorphic" or "operate on any type"
06:58:19 <shapr> I don't really understand the difference between list polymorphism and typeclasses, they seem similar to me
06:58:35 <Marvin--> Hmm, GH seems to be derived from PolyP
06:58:39 <shapr> template haskell is about compile-time generated code, right?
06:58:51 <shapr> you could use that to generate instances for typeclasses
06:59:23 <Marvin--> well, that's how you compile polyP code, I think :)
06:59:54 <shapr> how's that related to DrIFT?
07:00:29 <Marvin--> never heard of it
07:01:09 <shapr> it's short for "deriving run time instances" or something like that
07:01:12 * shapr looks it up
07:01:14 <Marvin--> okay
07:01:17 <Marvin--> brb, laundry
07:01:29 <shapr> http://repetae.net/~john/computer/haskell/DrIFT/
07:01:53 <shapr> iirc, DrIFT is an integral part of Strafunski
07:02:27 <shapr> maybe I should ask on the mailing list
07:02:55 <shapr> hal: you awake?
07:03:39 <shapr> hdaume: do you know the differences among Generic Haskell, PolyP, Template Haskell, and DrIFT?
07:07:51 <Marvin--> back
07:18:37 <Marvin--> GAH
07:18:44 <Marvin--> I didn't know it was possible to patent algorithms in Sweden :(
07:20:11 <mgoetze> Marvin--: usa 0wnz ju
07:22:36 <Marvin--> arrrgggghhhh
07:22:51 <Marvin--> it says explicitly on the homepage of the Swedish patent office that you cannot patent computer programs
07:23:29 <Marvin--> "Det kan inte vara en ren upptäckt eller teori. Datorprogram, konstnärliga skapelser eller medicinsk behandlig kan inte heller patenteras."
07:23:50 <Marvin--> "It may not be a pure discovery or theory. Computer programs, artistic creations or medical treatments cannot be patented either"
07:24:06 <Marvin--> so how the heck can he have patented an algorithm used for solving SAT?
07:24:56 <andersca> who did?
07:25:27 <Marvin--> Gunnar Stålmarck
07:26:34 <Marvin--> hmm, I can't seem to find the patents online
07:30:33 <Heffalump> an algorithm and a computer program might be considered different things
07:31:39 <Marvin--> yes, but is an algorithm a technical invention?
07:32:08 <Marvin--> "Uppfinningen ska fungera tekniskt och lösa ett problem på ett tekniskt sätt för att ha teknisk effekt."
07:32:24 <Marvin--> "The invention should work technically and solve a problem in a technical way for technical effects."
07:32:36 <Marvin--> not that I understand what that sentence means myself
07:32:37 <shapr> software patents are stupid
07:33:14 <shapr> it's not the USA exactly, (since I identify with that country) it mostly stems from the media zaibatsu
07:33:32 <mgoetze> Marvin--: what does "att ha" mean?
07:33:41 <Marvin--> mgoetze: "to have"
07:33:54 <Marvin--> mgoetze: in some contexts, at least :)
07:34:13 <Marvin--> maybe it should be "in order to have technical effects" instead
07:34:21 <mgoetze> and you're sure that "foer" translates to "for" in this context? :)
07:34:37 * Marvin-- stops grumbling about the patent and starts reading about the algorithm instead
07:35:49 <mgoetze> Marvin--: the question is whether it must have direct technical effects, or whether indirect technical effects (e.g. via implementation) are sufficient
07:36:38 <Marvin--> mgoetze: IANAL
07:38:42 <mgoetze> Marvin--: yes, that's the problem, isn't it? maybe we should all be lawyers so that the world can be guaranteed to stop working (as opposed to having only a 99% chance)
07:39:48 <Marvin--> :)
07:48:44 <shapr> I read a quote that said "whenever a society require experts who are employed to understand and interpret its rules, control of that society is out of the hands of the everyday person"
07:49:19 <Heffalump> that's Heinlein.
07:49:23 <Heffalump> so take it with a pinch of salt
07:49:38 <Heffalump> (at least I think it is, it certainly sounds like something from him)
07:50:06 * sethk is back (gone 04:42:15)
07:52:10 <shapr> of course, Heinlein is the first sci-fi I've read, and still my favorite :-)
07:52:56 <Heffalump> I like it, and I agree with a lot of the politics (to some extent), but it gets a bit reptitious
07:53:07 <Heffalump> s/reptitious/repetitious/
07:53:17 <shapr> I've read most of Heinlein, I like most of his worldview.
07:53:48 <shapr> polyamory just isn't for me though
07:54:05 <Heffalump> likewise
07:55:50 <Heffalump> and without wishing to get into a completely off-topic debate on the subject here, I think the polyamorous people I know are generally also those with personal problems and I have a suspicion the polyamory is related to those rather than being a good idea per se.
07:57:17 * shapr considers pursuing that thread further
07:58:05 <shapr> in summary, I agree with you. 99% of poly people have personal problems, and that's why they go for polyamory.
07:58:12 <shapr> that's been my experience at least.
07:58:33 <Igloo> They think polyamory will solve their problems?
07:58:37 <shapr> er, kind of
07:59:04 <Heffalump> it helps to reduce some insecurities but creates a whole new set, I think.
07:59:10 <Marvin--> can you write multi-parameter class names with infix notation? :)
07:59:10 <Heffalump> s/creates/ends up creating/
07:59:15 <shapr> bah, on-topic :-P
07:59:19 <Heffalump> Marvin--: nafaik :-)
07:59:26 <Heffalump> though it would be nice to be able to
07:59:27 <Marvin--> shapr: sorree! :)
08:00:40 <shapr> Igloo: a) some people want to have "backup" relationships b) some want to have a patchwork perfect mate made from multiple relationships c) some people have so much trouble accepting themselves that they go to a fringe group in hopes of finding other desperate people that will accept them
08:01:24 <shapr> none of those are related to the ideal of polyamory, much like the USSR has never been close to the ideal of communinism
08:02:39 <shapr> sooo
08:03:17 <shapr> what's the relationships among Generic Haskell, PolyP, Template Haskell, and DrIFT?
08:03:23 <shapr> are there more things like that?
08:05:00 <Heffalump> hmm.
08:05:11 <Heffalump> PolyP is mostly dead in the water, and subsumed by Generic Haskell.
08:05:41 <Heffalump> DrIFT is a sort of "poor man"'s Generic Haskell; it does that kind of thing but only for type class instances
08:06:08 <Heffalump> Template Haskell is much more general than Generic Haskell, and in theory GH (or in fact just about anything) could be implemented in TH in some way
08:06:20 <Heffalump> but I don't think that would necessarily make sense to do
08:08:02 <Marvin--> okay, so what's the relation between generic programming and polytypic programming?
08:08:23 <Heffalump> I think they're the same thing.
08:08:30 <Heffalump> oh, no, sorry.
08:08:41 <Heffalump> polytypic programming is a specific kind of generic programming
08:08:54 <Heffalump> PolyP and Generic Haskell are both polytypic systems (AFAIK)
08:09:23 <Heffalump> for many other languages, such as Java, C#, C++, "generic programming" means adding polymorphism, not polytypism.
08:09:39 <Marvin--> oh
08:10:01 <Marvin--> hmm
08:10:21 <Marvin--> I just got the offer to buy shares in the company I work at during summers, at a reduced price
08:10:45 <Marvin--> the catch is, I suppose, that I can't exercise the warrant until 2006
08:11:08 <Heffalump> so you have to fork out money now and can't release it until 2006?
08:11:14 <andersca> I got an offer like that a long time ago
08:11:25 <shapr> Marvin--: do it! you'll be rich!
08:11:40 <Marvin--> Heffalump: I suppose that's the usual catch.
08:11:45 <shapr> c'mon any company with Creighton in it is going to be legend.
08:11:50 <Marvin--> heh
08:11:57 <Heffalump> Marvin--: I've never heard of such a thing myself, TBH.
08:12:08 <Heffalump> If you actually have to fork out money now, you should be getting something you could also sell now.
08:12:13 <Marvin--> Heffalump: digging through the legal text they mailed me, it seems like a common thing to do
08:12:21 <Heffalump> If you're just being granted reduced-price options, that's a different matter.
08:12:34 <Marvin--> yes, it's actually options on shares of course
08:12:45 <Heffalump> but you have to pay for the options?
08:13:00 <shapr> you guys should make LAC head of Marketing, she's already a legend in the computer world
08:13:47 <Marvin--> the way I read it, I pay 75 SEK now (about 7-8 euro or dollars) now, and will get 2500 shares in the company in 2006
08:14:22 <Marvin--> hmm, wait a sec
08:14:49 <Marvin--> guh, I'll have to let someone look through this :)
08:15:15 <andersca> I remember that our contract was weird
08:15:17 <Heffalump> 75SEK per share, or in total?
08:15:39 <Marvin--> the point is that since Strakt hasn't made a sale yet, the tax authorities have agreed that the company is worthless at this moment, which is why I have to pay the money before the end of the year
08:16:16 <andersca> where do you get money from?
08:16:30 <Marvin--> where I get the 75 sek from? ;)
08:16:37 <andersca> you as in the company
08:16:49 <Marvin--> the company is Strakt, I work there during summers, remember?
08:16:54 <andersca> yes
08:17:06 <andersca> but if strakt hasn't had a sale, how can strakt pay its employees?
08:17:12 <Marvin--> wait, let's see, I pay 75 sek now, and get a warrant that will let me buy shares at a reduced price in 2006
08:17:21 <Marvin--> andersca: investors? :)
08:17:29 <andersca> Marvin--: soudns like codefactory :)
08:17:37 <andersca> although we've had sales :)
08:17:40 <Marvin--> I'm not sure how much I'm allowed to say
08:18:01 <Heffalump> but it is 75SEK total?
08:18:25 <Marvin--> Heffalump: no, but I guess that if I choose not to exercise the warrant in 2006, all I've lost is the 75 sek
08:18:37 <Marvin--> I should read up on economics, options in particular
08:18:52 <Heffalump> IM is it 75SEK total now?
08:18:57 <Heffalump> as opposed to 75SEK per share.
08:19:04 <shapr> yah, I'd expect 75SEK per share
08:19:16 <shapr> if it's only 75SEK total, just do it and don't worry about it
08:19:19 <andersca> that's a lot for options, isn't it?
08:19:27 <Heffalump> 75SEK per share sounds like a huge amount
08:19:34 <Heffalump> total sounds like nothing and you might as well do it
08:19:35 <Marvin--> no, I pay 75 sek for the warrant, and then I think I pay USD0.11 per share in 2006, but I don't know if that's for UP TO 2500 shares, or EXACTLY 2500 shares
08:19:54 <Heffalump> almost certainly UP TO
08:20:06 <Heffalump> anyway, it can't hurt, really
08:20:07 <shapr> I'd say it's worth it
08:20:08 <andersca> yeah
08:20:35 <mgoetze> heck, you can't even get a decent dinner for SEK 75... :)
08:20:48 <shapr> well, they have some nice burgers around the corner...
08:20:48 <Marvin--> :)
08:20:58 <Marvin--> gotta love words such as "hereinafter"
08:21:01 <shapr> oh, that's about 110SEK, never mind
08:21:04 <andersca> shapr: have you had norrlands guld yet?
08:21:15 <shapr> no, but I've seen the signs
08:21:28 <shapr> I thought it was a jewelry store....
08:21:37 <andersca> haha
08:21:39 <shapr> maybe it's beer like Lapin Kulta?
08:21:57 <shapr> lappish gold == lapin kulta
08:22:13 <Igloo> Grrr, writing code you can't test is annoying
08:22:19 * andersca bought oyster stout the other day
08:22:47 <shapr> Igloo: why can't you test it?
08:22:56 <shapr> I'm always suspicious of code I can't test
08:23:00 <Heffalump> cos the compiler is broken, probably
08:23:14 <andersca> shapr: especially when they involve bit shifting
08:23:17 * andersca had an exam today
08:23:36 <Marvin--> right, I'll better call them and ask what the heck it all means :)
08:23:45 <Marvin--> but right now, I've got a christmas party to go to
08:23:54 <andersca> sounds like fun
08:24:01 <Marvin--> yup :)
08:24:02 <Igloo> Yeah
08:24:04 <Marvin--> later
08:24:15 <andersca> merry christmas and all that
08:24:15 <Heffalump> I suspect the SEK75 will just be an administration fee.
08:24:16 <Igloo> I'm quite impressed that I can fix some segfaults by removing comments from my code
08:24:24 <Heffalump> TICBW
08:24:24 <Marvin--> Heffalump: nod
08:24:37 <andersca> Igloo: you aren't writing a parser are you? :)
08:24:40 <Marvin--> tticbw?
08:24:41 <Heffalump> IME it's not usual to charge employees for stock options themselves.
08:24:50 <Heffalump> Though I Could Be Wrong
08:24:55 <Marvin--> ah
08:24:58 <Marvin--> well, I'm off
09:25:57 * shapr decides to write a swedish text matching tool named åk
09:26:11 <shapr> (spoken "awk")
09:26:29 <Igloo> Hmmm, nothing from SPJ yet, and I have a meeting with Oege tomorrow
09:27:05 <Heffalump> nothing from SPJ about what?
09:27:11 <Igloo> The segfaulting
09:27:58 <Heffalump> ah
09:32:17 * shapr desperately wishes for HaMacs that works like PyMacs
09:32:35 <Igloo> How's that?
09:33:03 <shapr> pymacs lets elisp and python call each other
09:33:44 <inkedmn> howdy friends
09:33:48 <shapr> http://www.iro.umontreal.ca/~pinard/pymacs/
09:33:50 <shapr> hiya inkedmn
09:34:11 <inkedmn> if you're interested, my buddy and i have a programming bb we just put up
09:34:17 <inkedmn> www.sourcereview.net
09:35:10 <shapr> looks nice
09:35:19 <inkedmn> thanks
09:35:36 <inkedmn> hoping to get some more functional-type folks involved...
09:35:39 <inkedmn> only got a couple atm
09:37:12 * shapr registers
09:37:21 <inkedmn> :)
09:37:28 * hdaume registers :)
09:41:43 <tez> What's your privacy policy? :-)
09:43:12 <inkedmn> tez: we sell ALL addresses to ANYBODY WHO WILL PAY FOR THEM
09:43:13 <inkedmn> ;)
09:43:46 <tez> Oh.  Standard practice then.  That's fine.
09:43:51 <inkedmn> :)
09:43:53 <Heffalump> I'll give you 1p
09:44:04 <inkedmn> lp?
09:44:13 <tez> one pence.
09:44:17 <Heffalump> 0.01 pounds sterling
09:44:17 <inkedmn> ah
09:44:40 * inkedmn has no idea how much that is worth
09:44:56 <Heffalump> 0.0066 euro
09:46:21 <tez> Isn't it the other way round?  About 0.015 euros?
09:47:08 <Heffalump> oh yes, sorry.
09:47:15 * Heffalump looks foolish
09:47:29 * inkedmn lives in the US and is totally oblivious to this sort of thing, sadly...
09:47:29 * tez looks like a pedant
09:47:40 * shapr looks bland
09:48:19 <Heffalump> inkedmn: 0.015 cents too
09:48:24 <Heffalump> IM dollars
09:48:25 <Heffalump> 1.5 cents
09:48:26 <inkedmn> ah, ok
09:48:36 <Segora> the dollar isn't worth a euro atm ;)
09:48:41 <Heffalump> it is roughly
09:48:55 <Heffalump> I'm sure I have a 1c coin I could give you too, though :-)
09:49:38 <Segora> anyway i don't like phpBB or any web board. I much prefer traditional UseNet.
09:50:48 <Heffalump> yes
09:50:56 <shapr> I haven't been able to subscribe to comp.lang.haskell
09:51:20 <tez> <gasp>
09:51:25 <Segora> shapr: hu? what news client, which server?
09:51:51 <Segora> oh my, doesn't exist yet
09:52:27 <Segora> mailing lists are not half bad, either
09:52:55 <Heffalump> I think news is the right way to do it (TM)
09:52:56 <shapr> the mailing lists feel a bit too formal a place for me to submit my haskell code for review
09:53:12 <Heffalump> even haskell-cafe?
09:53:15 <Segora> shapr: maybe you should take a look at www.gmane.org and/or subscribe to haskell cafe
09:53:20 <tez> Well, the comp.lang.functional only get seems to get moderate traffic.  I suspect a comp.lang funtional would be quite empty (unfortunately).
09:54:42 <tez> oops.  That last "comp.lang.functional" was supposed to be "comp.lang.haskell"
09:55:27 <hdaume> if comp.lang.haskell existed i would be sure to do my part to keep it alive ;)
09:55:34 <hdaume> (though i'm sure that's pretty obvious)
09:56:08 <shapr> yah, same here
09:56:29 <shapr> maybe we should assume that c.l.f is c.l.h...
09:56:44 <shapr> then if there's really enough traffic, everybody else will ask us to go get our own newsgroup
09:57:03 <shapr> I like that plan.
09:57:17 <hdaume> pretty much all the posts to clf are either haskell questions or static typing flames or OO flames
09:57:23 <shapr> true
09:57:50 <shapr> with some small numbers of SML or OCaml posts
09:58:05 <shapr> the lisp/scheme guys don't really identify with c.l.f
09:59:15 <Segora> shapr: no wonder, they got their own group.
09:59:58 <shapr> in that case, I guess it's safe to assume that c.l.f == c.l.h
10:08:08 <hdaume> shapr: well, that and l/s aren't really fps :)   (i think someone should psot that the clf and see what happens -- i'll be the l/s folk will come out of their shells)
10:08:19 <shapr> probably so
10:08:44 <shapr> imho, l/s are about halfway between procedural and functional
10:08:53 <tez> Oh, oh, and cross-post it.
10:09:00 <hdaume> *grin* that would be good
10:09:20 <tez> lol
10:09:58 <Heffalump> cross-post to where, the non-existent c.l.h?
10:10:08 <Heffalump> OIC :-)
10:10:25 <Heffalump> that's the kind of behaviour that slashdot invented "-1 (Flamebait)" for.
10:11:17 <hdaume> wow, ghci is REALLY slow when not built with -O
11:31:58 <shapr> oy
11:32:25 <inky> howdy!
11:32:28 <shapr> hiya
11:36:08 <Igloo> hdaume: Why were you doing that?
11:42:41 * shapr bounces
11:50:20 <tez> You bounce a lot, don't you?
11:50:27 <shapr> yes I do
11:50:35 <shapr> you should see me in person...
11:50:49 <tez> In fact, you bounce so often,  I would find it hard to believe you weren't a small rubber ball.
11:50:57 <tez> :)
11:51:01 <shapr> well, I'm not small.
11:51:12 <tez> Ah
11:51:16 <shapr> medium size human spring maybe
11:51:26 <tez> Oh, like that.
11:51:27 <shapr> jag springer!
11:52:23 <tez> Yes, human spring is a better image than small rubber ball.  But I don't know why.
11:52:36 * shapr doesn't know either
11:53:58 <tez> Luckily for humankind, you've chosen to use your powers in #haskell, and not for evil (or something).
11:54:04 <shapr> right!
11:54:11 <shapr> I spring for good!
11:54:34 * shapr wonders just how surreal this conversation appears to others.
11:54:37 <Igloo> tez: He writes Java code too...
11:54:47 <tez> <gasp>
11:54:53 <Igloo> Compared to some, this one is positively normal  :-)
11:54:55 <tez> Merely your alter ego, I hope.
11:54:59 <shapr> nooo, my hidden weakness is showing!
11:55:47 <tez> Are there mild-mannered Java programmers?
11:55:53 <shapr> it's hard to type while bouncing.
11:56:05 <shapr> tez: no, java is too frustrating for that
11:56:38 <shapr> Java programmers are a cranky lot...
11:57:09 <shapr> always saying stuff "what do you mean inner classes must be final and immutable?"
11:57:18 <tez> lol
11:58:10 <shapr> I used to champion Python and Haskell on the #java channel lots
11:58:14 <tez> As long as they don't blurt sentences like that at, say, the supermarket, that seems ok.
11:58:32 <tez> Was it appreciated?
11:58:35 <shapr> sometimes
11:58:53 <shapr> most of the Java programmers haven't used anything other than C, C++, and maybe VB
11:59:10 <tez> Ah.
11:59:12 <shapr> so in their eyes Java is righteous
11:59:15 <shapr> with good reason
12:00:09 <shapr> but then I start talking about first class functions, continuations, coroutines, and more
12:00:36 <Igloo> Does python have coroutines?
12:00:42 <shapr> stackless python does
12:01:01 <Igloo> Is what I get when I type python stackless, stackful or either?
12:01:01 <shapr> though in v2 of stackless they've become tasklets
12:01:10 <shapr> python is normally stackful
12:01:21 <shapr> it uses the C stack normally, and is occasionally recursive
12:02:14 <shapr> once you explain a few of the concepts behind functional programming to a Java programmer, then you get really ridiculed
12:02:36 <shapr> and six months later they come back and ask you for more information, since they've now seen places in their code where that stuff would be great
12:05:33 <shapr> most people just learn what they need to learn to keep their job (at least, it seems that way to me)
12:05:52 <shapr> Haskell and FP does not usually fit into that
12:25:51 <Igloo> Yeah  :-(
12:27:30 <shapr> on the good side of that, people are here because they want to be
12:27:35 <shapr> (unless they're doing homework)
12:38:18 <Igloo> Hmmm, GHC needs a tinterbox
12:38:24 <shapr> what's that?
12:38:26 <Igloo> tinderbox
12:38:45 <Igloo> The things that glare at you if you break the CVS tree
12:39:00 <shapr> ?
12:39:48 <Igloo> http://www.mozilla.org/projects/tinderbox/
12:40:22 <shapr> oh, nice
12:40:34 <shapr> regression test summary tool
12:40:42 <Igloo> Also see http://tinderbox.mozilla.org/showbuilds.cgi?tree=SeaMonkey
12:41:48 <shapr> wow,
12:41:49 <shapr> nice
12:43:03 <Igloo> Or maybe the nightly builds should just be run so as to finish an hour before Simon Marlow goes home  :-)
12:46:20 <Igloo> Hmmm, perhaps I should set one up
12:46:50 <shapr> yah, go for it
12:48:50 <Igloo> In my CFT  :-)
12:48:58 * shapr grins
12:49:23 <Heffalump> not hard surely?
12:50:01 <Igloo> Depends if it is built as a Mozilla tool or a generic tool
12:50:29 * Igloo will check it out and give it a whirl, anyway
13:55:02 <engstad> Greets... I'm doing voluntary home-work (lunch-break). I'm trying to implement sequence :: Monad m => [m a] -> m [a].
13:55:06 <engstad> Here's my solution:
13:55:13 <engstad> sequ :: Monad m => [m a] -> m [a]
13:55:13 <engstad> sequ ms = seq' [] ms where
13:55:13 <engstad>     seq' ns (m:ms) = m >>= \n -> seq' (n:ns) ms 
13:55:16 <engstad>     seq' ns []     = return ns
13:55:23 <engstad> Is that good?
13:56:56 <Heffalump> it looks excessively complicated to me
13:57:02 <Igloo> It'll reverse the order won't it?
13:57:09 <Heffalump> sequence [] = return []
13:57:21 <Heffalump> sequence (x:xs) = do a <- x
13:57:23 <engstad> Oh, it might... I could just reverse it.
13:57:32 <engstad> No do's please. ;-)
13:57:47 <Igloo> Why not?
13:58:00 <clausen> I bet you could use fold
13:58:01 <engstad> I've not yet grokked them. :-)
13:58:09 <Heffalump> ok, x >>= (\a -> sequence xs >>= (\as -> return (a:as)))
13:58:15 <Heffalump> instead of do ...
13:58:35 <Igloo> There are very simple mappings between the two notations
13:58:40 <engstad> Ah, clever! 
13:58:47 <Heffalump> it's in the prelude, you know :-)
13:58:52 <tez> lol
13:58:58 <Igloo> Primarily    x <- y     is equivalent to    y >>= \x ->
13:58:59 <engstad> The 'a' bound in the beginning is used in the return.
13:59:20 <Heffalump> well yes, this is kind of important
13:59:23 <engstad> That's nice.
13:59:33 <Igloo> (roughly speaking - the prelude has better rules and a complete set of them)
13:59:48 <engstad> Yes, I know it's in the prelude. I'm learning to understand, I'm not a student. ;-)
13:59:49 <Igloo> s/prelude/report/
14:00:09 <Heffalump> igloo: better rules?
14:00:20 <Igloo> Well, the above isn't very formal
14:00:45 <Heffalump> wdym formal?
14:00:57 <Heffalump> it works, doesn't it?
14:01:05 <engstad> Now, here's a question for the nice solution: HOW ON EARTH did you think in order to come up with this solution?
14:01:42 <Heffalump> well, there's no other way of writing the [] case
14:01:56 <Heffalump> it's the only possible type correct solution
14:02:39 <Igloo> Yeah, I guess it does
14:03:33 <engstad> Mine was "correct" (except reversal), yet longer.
14:03:36 <Heffalump> I got the : case just by thinking about how to do things recursively
14:03:51 <Heffalump> engstad: well, it would have returned the same result for [], I'm sure
14:04:11 <Heffalump> basically my solution follows naturally (for me) from the decision to pattern match on the input list
14:04:24 <engstad> *nod*
14:05:18 <engstad> I think I still have problems with thinking of _computations_ as units you can mess around with.
14:05:32 <engstad> Still thinking imperative I suppose.
14:06:24 <tez> It's imperative that you don't! <ducks>
14:06:53 <engstad> hehe
14:09:53 <engstad> Ok, I've translated it to do's: sequ (m:ms) = do { r <- m; rs <- sequence ms; return (r:rs) }
14:10:02 <engstad> Correct?
14:13:25 <Heffalump> yep.
14:28:21 <Janni> hi. finally i got dsl and my flatrate. now i can stay here longer...
14:31:13 <kev> Janni: and here the irc addiction starts
14:47:37 <whee> what's the best mailing list to send a question about GUIs in OS X to?
14:54:03 <clausen> whee: I don't know, but maybe ppl in #mklinux do
14:54:17 <whee> (GUIs done in haskell :P)
14:54:34 <whee> ghc-users?
15:05:19 <whee> speaking of OS X, 10.2.3 is out :)
15:08:40 <engstad> What's the easiest way to parse lines of the form: "a string","another string",123.45,"third string",141.12414
15:09:21 <whee> would the whole Read thing work?
15:09:49 <engstad> Read?
15:10:10 <whee> Read is typically the opposite of Show
15:10:25 <whee> I think. heh.
15:10:36 <engstad> Oh. Perhaps... I'll try.
15:10:47 <Heffalump> no, it won't
15:11:01 <Pseudonym> I think what you have there is CSV.
15:11:10 <Heffalump> oh, hangon.
15:11:48 <engstad> Yes, it's a csv.
15:11:54 <inkedmn> kill me
15:12:14 <whee> inkedmn: amend your will first :)
15:12:22 <Pseudonym> http://www.xoltar.org/languages/haskell/CSV.hs
15:12:24 <engstad> Parsing it would be overkill..
15:12:29 <Heffalump> ok, you /could/ use readsPrec from the read class
15:12:31 <engstad> Cewl.
15:12:52 <Pseudonym> If it's a known format, like CSV, chances are pretty good someone else has already written a parser.
15:13:00 <engstad> Whoa, it's using Parsec. :-)
15:13:06 <Pseudonym> :-)
15:13:14 <Pseudonym> Still, it's code you don't have to write.
15:13:19 <engstad> *nod*
15:14:06 <dark> You mean... code written by *other people*?  Ewwww.
15:14:16 <Pseudonym> Yes.  It's NIH.
15:14:29 <Pseudonym> In fact the code is kinda ugly, but it's very very short.
15:14:50 * whee loves parsec now
15:14:55 <Pseudonym> Actually, a hand-written continuation-based parser might be even shorter.
15:15:03 <Pseudonym> And a lot faster, too.
15:15:22 <whee> it shouldn't be too hard to write a custom parser for a CSV like that
15:15:31 <andersca> parsec is cool
15:15:36 <engstad> No, it should be easy, I might try it actually.
15:16:01 <whee> it took me a while to figure out how to use parsec, but I like it better than lex/yacc now
15:16:36 <engstad> I've been using Ocaml's Stream libraries with success.
15:16:48 <andersca> whee: I've tried both, and I think happy is easier to use but parsec is cooler
15:30:09 <inkedmn> later all
15:30:28 <engstad> Btw, in Ocaml I've always found it useful to look at the mli header files. Is there something like that for hugs or ghci? I can't find any .hs files...
15:44:04 <Igloo> hugs ships with the sources - it tells you the prelude location when it starts
15:49:36 <Marvin--> whee, kernel panic
15:49:45 <andersca> Marvin--: ugh
15:50:03 <Marvin--> not on my real computer, in vmware :)
15:50:16 <Marvin--> I guess using a cvs version of busybox was a bad idea
15:50:19 <andersca> ah
15:50:30 <Heffalump> still shouldn't cause a kernel panic, should it?
15:50:43 <Marvin--> no, you'd think so
15:51:10 <Marvin--> it tries to install a non-reduced libc from the CD, and then spits out "cramfs: wrong magic", and kernel panic
15:51:23 * Marvin-- mutters
15:51:28 <Heffalump> oh, is it trying to use that for / ?
15:51:39 <Heffalump> not being able to get a / is a good reason for a kernel panic
15:52:41 <Marvin--> I just don't understand what the big difference is between the released busybox and the cvs busybox that causes the kernel panic
15:52:49 <Pseudonym> Heffalump: In Unix, maybe.
15:52:53 <Marvin--> and right before the panic, everything slows down to snail speed
15:53:12 <Pseudonym> Personally I think this is an excellent argument for a better error message.
15:53:23 <engstad> Why is "fail" a member of class Monad?
15:53:37 <Heffalump> engstad: because of guards in do syntax
15:53:40 <Pseudonym> engstad: Here's a can labelled "worms".  Would you like my can opener?
15:53:44 <Heffalump> s/guards/pattern matches/
15:54:09 <Pseudonym> Heffalump: Guards too.  Well, the "guard" function, anyway.
15:55:13 <Pseudonym> Heffalump is right, though.  Some monads want to catch errors, others don't.  When a pattern match (or call to "guard") fails, there needs to be some mechanism for monads which want to catch errors to do so.
15:56:00 <Heffalump> (pattern match in a do foo <- bar type binding, not in a let, btw)
15:56:24 <Heffalump> anyone here actually make use of this facility, OOI?
15:56:30 <Pseudonym> Gofer used to have an explicit MonadZero class.
15:56:35 <dark> I didn't know failed pattern matches triggered a monad fail.  I thought they were handled like other failed pattern matches.
15:56:38 <Marvin--> hmm, relocation errors
15:56:42 <Pseudonym> Sorry, you mean does anyone use fail?
15:56:46 <Pseudonym> Sure, I do.
15:56:55 <Marvin--> dark: you mean like LC pattern matches? :)
15:57:09 <Pseudonym> I use failing pattern matches, too.
15:57:11 <Heffalump> I really mean does anyone make use of the failing pattern matches thing
15:57:15 <Pseudonym> Yes.
15:57:20 <Heffalump> what for?
15:57:24 <dark> Well I didn't even know it was there :)  How does it work?
15:57:29 <Pseudonym> Logic programming. :-)
15:57:39 <Marvin--> dark: [ x | Just x <- ys ] ?
15:57:48 <dark> That's not do syntax.
15:58:19 <Pseudonym> Logic programming requires deconstruction unifications which may fail.
15:58:27 <Pseudonym> Or test unifications, of course.
15:58:55 <Marvin--> dark: no, but I mean it's pattern matching that's handled a bit differently...
15:59:16 <dark> Marvin: Took me ages to realize that, too :)
15:59:24 <Pseudonym> Heffalump: As Marvin points out, we effectively use it all the time in list comprehensions.
15:59:32 <Heffalump> I wish they hadn't thrown away the "use list comprehensions on MonadPlus" thing
15:59:39 * Pseudonym agrees
15:59:42 <Heffalump> Pseudonym: not the specific feature that requires fail to be in the Monad class
15:59:43 <Pseudonym> I like monad comprehensions.
16:00:27 <dark> I remember Haskell being advertised as having them.  Did that change?
16:00:34 <Heffalump> yes, in Haskell 98
16:00:39 <Heffalump> or maybe from 1.3 to 1.4 or something
16:00:57 <Pseudonym> Heffalump: Erm... yes and no.  The fail operation needs to be in the monad class so that do syntax can support failing pattern matching.
16:02:43 <Pseudonym> But if this is what you meant, I don't use it on any monads where fail _ /= mzero
16:02:55 <Pseudonym> I can see how I would, though.
16:03:27 <Pseudonym> If I needed something sufficiently robust that it threw an exception instead of calling error, for example.
16:03:29 <Heffalump> I'm essentially wondering if (in my opinion) Haskell 2 should remove fail from the Monad class and reinstate MonadZero
16:03:35 <Heffalump> [I think it should reinstate MonadZero anyway]
16:03:42 <Pseudonym> I think you need the message.
16:03:48 <Pseudonym> And yes, I think we need MonadZero.
16:04:06 <Heffalump> you can catch error from IO anyway, can't you?
16:04:17 <Pseudonym> Well yes.
16:04:27 <Pseudonym> In non-H98, anyway.
16:04:31 <Heffalump> so the only benefit of an exception is decent types
16:04:38 <Heffalump> well, exceptions aren't H98 either, are they?
16:04:58 <Pseudonym> Monad-based exceptions are.
16:05:30 <Pseudonym> Well, the formulation which doesn't use multi-parameter type classes, anyway.
16:06:02 <Pseudonym> I think you need the string message in fail.
16:06:13 <Pseudonym> It's handy to have.
16:06:30 <Heffalump> oh, yes, true
16:06:31 * Pseudonym hmmms
16:06:48 <Pseudonym> Can you think of a use for MonadZero which doesn't also have a logical "not" operator?
16:06:55 <Pseudonym> mnot mzero = return ()
16:07:01 <Pseudonym> mnot (return _) = mzero
16:07:22 <Heffalump> umm, lists are MonadZeros
16:07:34 <Pseudonym> Yeah, but they're MonadPluses.
16:07:39 <Heffalump> well yes
16:07:53 <Pseudonym> I mean monads which don't support mplus, do support mzero, and for which mnot is not reasonable.
16:08:34 <Pseudonym> Cases where mzero just calls error don't count.,
16:09:12 <engstad> Hehe... I'm being filmed as we speak. :-)
16:09:19 <Pseudonym> Oooh.
16:09:28 <Heffalump> why is engstad being filmed?
16:09:39 <Pseudonym> Can we flash our slogans at the camera?
16:09:49 <engstad> Oh, it's the "making of Jak & Daxter II".
16:09:53 <Heffalump> Pseudonym: well, TBH I've never really understood the point of your not operator
16:09:57 <Pseudonym> "HASKELL 3:16"
16:10:13 <Pseudonym> Heffalump: Fair enough.
16:10:35 <Pseudonym> MonadNegate is actually an abstract form of Maybe.
16:10:50 <Pseudonym> Like how nondeterminism monads are abstractions of lists.
16:11:55 <Pseudonym> I've never liked it that Maybe is a MonadPlus.
16:12:14 <Heffalump> because it's not symmetric?
16:12:17 <Pseudonym> Right.
16:12:19 <Pseudonym> or something.
16:12:33 <Pseudonym> It's not in the Boehm hierarchy, anyway.
16:12:59 <Heffalump> the what?
16:13:04 <Pseudonym> Erm.
16:13:08 <Pseudonym> I may have gotten that wrong.
16:13:13 * Pseudonym thinks
16:13:19 <Pseudonym> It's a hierarchy of operators.
16:13:52 <Pseudonym> If your binary operator isn't associative, you can think of it as a binary tree.
16:14:11 <Pseudonym> If it's associative but not commutative, it's like a list.
16:14:29 <Pseudonym> If it's associative and commutative but not idempotent, it's a multiset.
16:14:33 <Pseudonym> If it's all of the above, it's a set.
16:14:41 <Pseudonym> Kind of thing.
16:14:47 <Pseudonym> Maybe isn't any of the above.
16:15:09 <Marvin--> I'm off to bed
16:15:17 <Pseudonym> What I think you actually want is a different operator than mplus.
16:15:21 <Marvin--> merry christmas everyone I won't see before that :)
16:15:38 <Pseudonym> Marvin: Merry Christmas to you, and to you a good night.
16:15:44 <dark> I think I've almost used Maybe's MonadPlus several times, and ended up needing something else.
16:15:45 <Heffalump> Maybe isn't an operator.
16:15:48 <Heffalump> bye Marvin
16:15:53 <Pseudonym> No, mplus is an operator.
16:16:08 <Pseudonym> It's the operation of mplus on your object.
16:16:29 <Heffalump> but it is associative
16:17:16 <Pseudonym> Maybe I've just spent too long as a logic programmer. :-)
16:17:33 <Pseudonym> mplus just seems the wrong fit for what is effectively a soft cut.
16:18:05 <Pseudonym> WHat you really want is "or-else", not "plus".
16:20:04 <Heffalump> it obeys all the rules
16:20:54 <Pseudonym> This is entirely a matter of taste, I admit.
16:22:50 <Heffalump> I think Maybe should be thought of as the option type that happens to have a first-choice mplus operator.
16:23:12 <Pseudonym> See, I think of it as the identity monad extended with a zero object.
16:23:12 <Heffalump> Another option type that happened to have second-choice, or even did something weirder, could also be defined.
16:23:39 <Pseudonym> And mplus makes no sense on the identity monad.
16:23:45 <Pseudonym> OK, that's not true.
16:23:49 <Pseudonym> m `mplus` n = m
16:23:59 <Pseudonym> I guess that's a sensible mplus.
16:24:17 <Heffalump> indeed
16:24:31 <Pseudonym> In which case, why abstract out MonadPlus at all?
16:24:43 <Heffalump> because some monads don't have one
16:24:46 <Heffalump> e.g. state
16:24:56 <Pseudonym> You can use the same one:
16:24:58 <Pseudonym> m `mplus` n = m
16:25:15 <Pseudonym> Why not?
16:25:16 <Heffalump> oh, duh
16:26:02 <Heffalump> ok, because there are monad transformers that cannot preserve mplus semantics? </tenuous>
16:26:10 <Pseudonym> Hmmm./
16:26:19 <Pseudonym> OK, that's true.
16:26:25 <Pseudonym> The list monad transformer, for example.
16:26:36 <Heffalump> ok, are there any that do? :-)
16:26:43 <Pseudonym> :-)
16:27:05 <Pseudonym> Plenty.
16:27:13 <Heffalump> what's the definition of the list monad transformer?
16:27:44 <Pseudonym> Have a look in Control.Monad.List.
16:29:06 <Pseudonym> It has MonadPlus there, but in fact it's slightly bogus.
16:30:04 <Heffalump> what's the easiest way to read the source for a hierarchical library?
16:30:22 <Pseudonym> I type "locate List.hs". :-)
16:30:44 <Heffalump> that worked, but only thanks to Igloo, I think
16:31:13 <Heffalump> (he has lots of GHC build trees lying around on the machine I did it on)
16:31:16 <Pseudonym> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/libraries/base/
16:31:42 <Heffalump> ah, yes
16:32:00 <Pseudonym> The reason this is bogus is because if you type:
16:32:00 <Heffalump> well, the MonadPlus clearly doesn't preserve the semantics of an underlying MonadPlus
16:32:09 <Heffalump> given that it's Monad m => MonadPlus (ListT m)
16:32:24 <Pseudonym> I think that's not going to happen anyway.
16:32:35 <Pseudonym> I think the problem is with "lift".
16:32:36 <Heffalump> ok, that was my original question.
16:32:53 <Heffalump> surely that is the obvious definition for "lift"?
16:33:18 <Pseudonym> Obvious perhaps, but it's not nice on your evaluation order.
16:33:44 <Pseudonym> If you type: lift m1 `mplus` lift m2, both m1 and m2 get evaluated even if you only need the first element of the list.
16:34:24 <Heffalump> in what underlying monad?
16:34:31 <Pseudonym> Anything.  IO, say.
16:34:43 <Heffalump> IO is strict, though
16:34:49 <Heffalump> so that figures
16:35:10 <Pseudonym> Also if you skip the first argument of the list and go straight to the second, m1 gets evaluated.
16:35:11 <Heffalump> I don't quite see why it would for a lazy monad.
16:35:20 <Heffalump> oh, hangon.
16:35:23 <Heffalump> of course it has to.
16:35:26 <Pseudonym> Right.
16:35:27 <Heffalump> e.g. threaded state
16:35:43 <Heffalump> the only way you can avoid that is to have a [m a] rather than m [a]
16:35:57 <Pseudonym> Now here's my logic monad:
16:35:58 <Pseudonym> data LogicT m a
16:35:58 <Pseudonym>     = FailT
16:35:58 <Pseudonym>     | ConsT a (LogicT m a)
16:35:58 <Pseudonym>     | forall b. LiftBindT (m b) (b -> LogicT m a)
16:35:59 * Heffalump had exactly this problem with some of the code for his thesis
16:36:18 <Pseudonym> The secret (thanks to Ralf Hinze) is to add another constructor which handles the "lift" case.
16:37:01 <Heffalump> but what happens to underlying threaded state, for example?
16:37:44 <Pseudonym> It's fine because the calls get suspended until they're needed.
16:37:54 <Pseudonym> In the LiftBindT constructor.
16:38:05 <Heffalump> needed for what?
16:38:16 <Pseudonym> Needed for actual computation.
16:38:17 <Heffalump> in the threaded state example, m2 won't get evaluated unless you actually use the state again
16:38:30 <Pseudonym> That works here too.
16:38:36 <Pseudonym> Let me show you mplus:
16:38:47 <Heffalump> and similarly m1 will only be evaluated enough to get the state out if you never want its value
16:38:50 <Pseudonym>     mplus FailT           n = n
16:38:51 <Pseudonym>     mplus (ConsT a m)     n = ConsT a (m `mplus` n)
16:38:51 <Pseudonym>     mplus (LiftBindT m k) n = LiftBindT m (\a -> k a `mplus` n)
16:39:17 <Pseudonym> Oh, and lift:
16:39:35 <Pseudonym>     lift m = LiftBindT m (\a -> ConsT a FailT)
16:39:50 <Pseudonym> So if you look at what happens to (lift m1) `mplus` (lift m2)
16:39:58 <Pseudonym> What you end up with is basically:
16:40:19 <Pseudonym> LiftBindT m1 (\a -> ConsT a (lift m2))
16:40:34 <Pseudonym> m2 never gets called unless the tail of the Cons is needed.
16:40:35 <Heffalump> how is this more lazy than the "standard" one?
16:40:49 <Heffalump> what if you need the state?
16:41:55 <Pseudonym> OK, I'm not understanding you here.
16:42:10 <Pseudonym> You're building a nondeterminism transformer on top of a state monad?
16:42:18 <Heffalump> for example.
16:42:40 <Pseudonym> Well it depends on the observer.
16:42:44 <Heffalump> oh, hangon
16:42:46 <Pseudonym> My monad uses:
16:42:49 <Heffalump> you have a [m a] not a m [a]
16:42:59 <Pseudonym> runLogicT :: (Monad m) => LogicT m a -> m a
16:42:59 <Heffalump> so your monad is different for that reason.
16:43:05 <Pseudonym> Er... yes and no.
16:43:12 <Pseudonym> It's kind of like that, but not quite.
16:44:04 <Pseudonym> It's actually list with a different constructor.
16:44:17 <Pseudonym> A third constructor to handle lifted monads.
16:45:31 <Heffalump> I completely fail to understand the point of said constructor.
16:45:56 <Pseudonym> :-)
16:46:02 <Heffalump> in Haskell there is no difference at all between (\x -> b) a and b[x/a], afaik
16:46:08 <Pseudonym> Hang on.
16:47:06 <Pseudonym> http://www.informatik.uni-bonn.de/~ralf/publications/ICFP00.ps.gz
16:47:31 <Pseudonym> Good paper.
16:47:44 <Pseudonym> Explains the point of said constructor. :-)
16:52:11 <Heffalump> hmm.
16:52:35 <Heffalump> Is the explanation in section 4.2?
16:53:24 <Heffalump> or did I skip over something earlier?
16:54:32 <Pseudonym> Er... yes.
16:54:36 <Pseudonym> That's the short answer.
16:55:01 <Pseudonym> Well we know why the list monad doesn't work. :-)
16:55:18 <Pseudonym> Section 4 basically derives a monad which does work.
16:58:29 <Pseudonym> Incidentally, using Hughes' method on my soft cut monad is really, really ugly.
16:58:35 <Pseudonym> The problem is the soft cut operation.
17:04:45 <Heffalump> what's a commutative monad?
17:04:51 <Heffalump> (cba to chase the ref)
17:06:46 <engstad> Does the paper also describe how to make branch and bound type monads?
17:07:15 <Pseudonym> A commutative monad is one where m1 >> m2 >> return () is the same as m2 >> m1 >> return ()
17:07:17 <engstad> I.e., when you backtrack you also keep around information you gathered from going down the search tree.
17:07:33 <Pseudonym> Uhm.
17:07:36 <Pseudonym> No, sorry.
17:07:44 <engstad> Ok.
17:08:04 <Pseudonym> One where do { x1 <- m1 ; x2 <- m2 ; return (x1,x2 } is the same as do { x2 <- m2 ; x1 <- m1 ; return (x1,x2) }
17:08:18 <Pseudonym> Modulo syntax errors.
17:09:29 <Heffalump> ok.
17:09:48 <Heffalump> why does Hinze's paper claim that the list monad transformer only works on commutative monads?
17:10:00 <Pseudonym> Well, consider what we were doing earlier:
17:10:15 <Heffalump> hmm. I've read [7] and I still can't remember the answer to that question :-)
17:10:28 <Pseudonym> (lift m1 `mplus` lift m2) >> lift m3
17:10:49 <Pseudonym> If the underlying monad isn't commutative, the result may be different depending on whether or not m2 is ever executed.
17:11:16 <Pseudonym> But in the list monad, it's _always_ executed.
17:18:15 <Heffalump> why does that matter?
17:18:44 <Pseudonym> (lift (mkdir "foo") `mplus` lift (rmdir "foo")) >> lift (readdir "foo")
17:18:45 <Pseudonym> Say.
17:19:07 <Pseudonym> This isn't a practical example. :-)
17:19:07 <Heffalump> what's `mplus` for IO?
17:19:13 <Heffalump> I don't think I buy it, for that reason.
17:19:14 <Pseudonym> You don't need one.
17:19:23 <Heffalump> oh, duh, sorry
17:19:29 <Pseudonym> This is a nondeterminism monad transformer stacked on top of IO.
17:19:37 <Heffalump> yeah
17:20:16 <Heffalump> I still don't see any problem here.
17:20:48 <Heffalump> oh, ok.
17:20:49 <Pseudonym> OK, assume you're only getting the first solution.
17:20:55 * Heffalump realises it's supposed to be backtracking.
17:20:57 <Pseudonym> Right.
17:21:09 <Pseudonym> But say you only want one solution for a moment.
17:21:30 <Pseudonym> In the nondet monad, the above code will successfully readdir the directory you just made.
17:21:34 <Pseudonym> And fail on backtracking.
17:21:35 <Heffalump> I still don't see the difference between Hinze's monad and [m a]
17:21:53 <Pseudonym> Probably efficiency.
17:22:03 <Heffalump> umm, why?
17:22:04 <Pseudonym> Or something.
17:22:09 <Pseudonym> Let me think.
17:22:13 <Pseudonym> Oh, I know.
17:22:25 <Pseudonym> lift m1 >>= (\x -> m1 x `mplus` m2 x)
17:22:33 <Pseudonym> In [m a], is m1 executed multiple times?
17:22:37 <Pseudonym> I think it might be,
17:23:07 <Igloo> Is there a way to ask cvs for the date of a checked out tree such that co with -D date will give you the same tree?
17:23:08 <Heffalump> you can't mean that, it's not type correct
17:23:24 <Heffalump> igloo: you might be able to look in CVS/Entries
17:23:32 <Pseudonym> Hang on.
17:23:33 <Heffalump> but in general, no, since there isn't always a consistent date
17:23:36 <Pseudonym> OK, this then:
17:23:38 <Igloo> That's per file though
17:23:47 <Pseudonym> lift m1 >> (m1 x `mplus` m2)
17:23:50 <Pseudonym> lift m1 >> (m1 `mplus` m2)
17:23:52 <Pseudonym> Sorry.
17:24:00 <Pseudonym> On backtracking, is m1 evaluated a second time?
17:24:02 <Heffalump> igloo: well, per-file is all that exists
17:24:11 <Heffalump> that's still not type correct...
17:24:11 <Pseudonym> Oh, I see.
17:24:12 <Pseudonym> Duh.
17:24:13 <Igloo> Oh, are write locks per file in CVS then?
17:24:18 <Pseudonym> lift m1 >> (m2 `mplus` m3)
17:24:19 <Pseudonym> Sorry.
17:24:22 <Heffalump> igloo: errm, no clue.
17:24:47 <Heffalump> Pseudonym: <thinks>
17:27:15 <Pseudonym> Igloo: Per-file and per-directory, I thought.
17:27:25 <Igloo> Hmmm, OK
17:27:32 <Heffalump> Pseudonym: no, I don't think it is
17:27:42 <Pseudonym> Let's have a think here.
17:27:47 <Pseudonym> lift m = [m]
17:27:52 * Igloo might take tinderbox apart some time and see how it works
17:27:59 <Pseudonym> m `mplus` n = m ++ n
17:28:00 <Pseudonym> Right?
17:28:00 <Heffalump> ok to past 7 lines?
17:28:03 <Heffalump> paste
17:28:12 <Heffalump> no, 4.
17:28:21 * Heffalump just pastes them
17:28:21 <Heffalump>         m >>= k  = ListT $ do
17:28:21 <Heffalump>                 a <- runListT m
17:28:21 <Heffalump>                 b <- mapM (runListT . k) a
17:28:21 <Heffalump>                 return (concat b)
17:28:37 <Heffalump> so in >>=, m is only run once
17:28:59 <Pseudonym> (lift m1) >>= \_ -> (m1 `mplus` m2)
17:29:12 <Pseudonym> = [m1] >>= \_ -> (m1 `mplus` m2)
17:29:18 <Pseudonym> Sorry, doing my derivation here. :-)
17:30:09 <Pseudonym> = do { a <- runListT [m1] ; b <- mapM (runListT . ( \_ -> (m1 `mplus` m2)) a ; return (concat b) }
17:30:18 <Pseudonym> Yes, I think you might be right.
17:30:28 <Pseudonym> Oh!
17:30:32 <Pseudonym> I see the problem, I think.
17:30:51 <Pseudonym> Hmmm.
17:31:25 <Pseudonym> (possibly_failing_monad `mplus` (lift m1)) >> m2
17:31:31 <Pseudonym> Erm.
17:31:48 <Pseudonym> OK, maybe not.
17:32:17 <Pseudonym> Let me think about this.  I'll look at Hinze's axioms and see which one(s) the ListT monad breaks.
17:32:39 <Pseudonym> That's going to be the easiest way to tell, I think.
17:32:47 <Pseudonym> Lunch.
17:33:05 <Heffalump> hangon, duh
17:33:17 <Heffalump> you asked about [m a] and I answered about m [a]
18:05:28 <engstad> Okey this is anoying me. I'm running Linux, but I've got a Microsoft keyboard and a Microsoft mouse. :-(
18:05:41 <engstad> But... they are the best I've tried.
18:06:44 <sethk> engstad: The keyboard I agree.  The logitech dual sensor optical mouse is much better than any Microsoft mouse.
18:07:34 <engstad> Really? I've got one with optical red light under it, and it feels good. I've got logitech at home, wireless, and it sucks.
18:08:01 <sethk> engstad: I don't like the logitech wireless either.  The wired USB dual sensor is an excellent mouse.
18:08:19 <engstad> Hmm, I'll have to buy one for home then. :-)
18:08:45 <engstad> The optical thing is really neat. Kudos to whoever invented it. :-)
18:09:14 <sethk> With the USB natural keyboard and the logictech mouse, I only need one wire from the KVM to the box.
18:09:26 <engstad> KVM?
18:09:32 <sethk> The optical mouse was available on Sun workstations 15 years ago, although the newer ones are better.
18:10:03 <sethk> KVM means keyboard, monitor, and I forget what the V is for; it is for using a screen, keyboard, and mouse with more than one computer.
18:10:05 <engstad> I've got the problem that I've got USB printer, USB scanner, USB keyboard and USB mouse....
18:10:14 <sethk> VGA, that's what the V means.
18:10:43 <sethk> With this new KVM switch I just bought, it has four USB inputs: keyboard, screen, and then two for any other devices.
18:11:15 <engstad> Isn't there bandwidth problems? E.g., when scanning a huge picture your mouse starts going jittering...
18:11:19 <sethk> It's really slick.  My USB wheel mouse now works with both Linux and Windoze through the switch.
18:11:44 <sethk> engstad: I haven't tried scanning yet, but usually a scanner's mechanical load dwarfs any bandwidth affect.
18:12:24 <sethk> engstad: Plus one wire, instead of four, multipied by four computers...
18:12:42 <engstad> So the switch is 4 USB in -> one USB out?
18:13:09 <shapr> urf
18:13:17 <sethk> Right.  video and USB out, times four (because it is a four port KVM).
18:13:36 <engstad> Ah! Video as well. That's neat.
18:14:03 <engstad> So, if you've got four boxes you can easily switch between them?
18:14:38 <sethk> They've been around for a while, but this is the first USB one I've tried that actually works.  It has four buttons to select one of the four machines, plus it has keyboard shortcuts for switching.
18:18:12 <engstad> sethk: what brand is it?
18:18:39 <sethk> engstad: IOGEAR.
18:19:01 <sethk> engstad: The MiniView III is the one that works.  The earlier model almost works but not quite.
18:20:05 <sethk> engstad: The hard part on a KVM switch is letting the machine boot up (with keyboard and mouse detected) even when that machine is not selected.  The MiniView III does this for Linux and also for windoze XP.  As you might guess, XP is the troublesome case.
18:20:47 <engstad> *no*
18:20:53 <engstad> *nod* rather.. ;-)
18:35:37 * shapr c.l.f
18:35:43 <shapr> er, "reads c.l.f"
18:41:23 <shapr> time to sleep, g'nite fokes
18:42:26 <sethk> night
18:43:32 <andersca> night shapr
18:49:27 <Akriel> Anyone up?
18:49:52 <sethk> Vaguely
18:50:06 <Akriel> sethk: Do you know haskell pretty well?
18:50:28 <sethk> Reasonably.  Not as well as the true gurus, but not too bad.
18:50:42 <Akriel> Can I pm you please
18:50:49 <sethk> OK
19:27:04 <engstad> Sometimes I just can't get started on Haskell stuff. :-(
19:29:00 <sethk> It can be a bit tricky...
19:29:59 <engstad> See, here's my little "task" that I made for myself.
19:30:22 <engstad> I've downloaded all the information from finance.yahoo.com about my accounts into CSV files.
19:30:41 <engstad> Also downloaded all my stocks performance through the year.
19:31:30 <engstad> Now I want to read in the transactions, and classify the data (so i.e. Check #1042 is "Housekeeping" because I know it is).
19:31:52 <engstad> But.... I don't know how to even start...
19:32:12 <engstad> I _do_ know how to do this in C++, even in Ocaml - just not in Haskell.
19:32:20 <sethk> How do you know 1042 is housekeeping?  You may know it is, but the program doesn't.  :)
19:32:54 <engstad> Well, the program has to ask me and save the responses. It should also support regexpes: (*vons* => Groceriec).
19:33:45 <engstad> Now, since this is a learning experience, I'd use as little external libraries as possible.
19:34:16 <sethk> engstad: Well, you certainly don't want to write your own regex processor.  Prompting and getting responses is not terribly difficult.
19:34:34 <engstad> Well, on that... I'd like to use ncurses.
19:34:43 <engstad> With tab completion.
19:35:10 <engstad> Yes, some ncurses library and regex library is fine.
19:35:33 <sethk> That I haven't done (curses, that is).  You can use GNU readline for tab completion, and the hs/gtk library to make an interface.  Curses might be possible; I've never tried using it in Haskell.
19:36:20 <engstad> See, I'd like to make it telnet-able. I can only run programs at my home machine though telnet.
19:36:54 <sethk> OK, we'll look around.
19:37:11 <engstad> Besides, I'm "retro" - I think ncurses programs are really cool.
19:38:50 <engstad> ginsu -- ginsu is my chat client implemented completely in Haskell. there is probably quite a bit of reusable code there, including a pretty complete ncurses interface. 
19:57:54 <engstad> Well, gotta go. CYs
22:30:00 <cmoline> is there a way to pass in a updater fun for a record(is that what they are called?)?
22:33:30 <cmoline> ie instead of foo {bar=baz} or foo {bar = baz $ bar foo} i would like setBar foo and updateBar foo instead
22:33:46 <cmoline> or do i have to create these myself?
22:34:06 <cmoline> the names arent important but the functionality is
22:36:38 <cmoline> the reason i want it is cause i have a fun updateEnemy updateFun spriteState enemy
22:37:12 <cmoline> and the updateFun that i want to pass in differs depending on the spriteState i am passing in
22:38:17 <cmoline> and the updateFun updates different labels depending on the spriteState being passed in
22:39:04 <cmoline> as it is i have to pattern match on each spriteState and use the {bar=baz} syntax
22:39:51 <cmoline> its redundant having to retype the same fun body seven times and each time only differs in one field label
22:41:19 <cmoline> ok. nevermind then
