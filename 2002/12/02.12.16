01:26:34 * seth is away: Don't say anything until I get back.
02:47:16 <shapr> hy
02:53:03 <Marvin--> morning shapr
02:53:26 <andersca> hey Marvin--, shapr
02:54:49 * Marvin-- sighs
02:54:59 <Marvin--> feels like I'm going to fail the exam on distributed systems
02:55:27 <andersca> what's that course about?
02:55:30 <andersca> client server stuff?
02:55:34 <shapr> g'morning
02:55:40 <ludde> hi
02:58:15 <Marvin--> it's about *anything* you can think of that's related to distributed systems but not interesting
02:58:34 <Marvin--> heck they even go through how DES and RSA work, which feels so irrelevant that I want to puke
02:58:52 <andersca> ugh
02:58:53 <Marvin--> it's a total cramming course, no element of problem solving whatsoever
02:58:54 <shapr> that's not very distributed
02:59:00 * andersca distchecks libgnome* instead
02:59:14 <Marvin--> well, you want to have security in your distributed systems, so let's talk about cryptography for three lectures
02:59:15 <Marvin--> bleagh
02:59:29 <shapr> why not talk about capability security in E?
02:59:35 <shapr> that's interesting and distributed
03:00:08 <Marvin--> of the ten chapters in the compendium, it feels like about one or two are relevant for the course name
03:00:26 <Marvin--> (one on node synchronization and one on distributed algorithms)
03:01:13 <Marvin--> so the course has been a total bore and I haven't bothered with it
03:01:29 <Marvin--> so now I'm afraid I'll fail it, and that's not good since I need the credits if I'm going to have my degree at the end of spring :)
04:17:24 * shapr bounces
04:18:03 <Igloo> Yo shapr
04:18:07 <shapr> y0 Igloo
04:18:16 <shapr> how are ya?
04:18:34 <shapr> Your fractal program has inspired me to write a tiny program in several different languages
04:18:35 <Igloo> I have some working derive code (it was basically a compiler bug)
04:18:40 <shapr> oh cool!!
04:18:41 <Igloo> Cool  :-)
04:18:49 <shapr> where is it?
04:20:29 <Igloo> http://urchin.earth.li/~ian/Derive-in-progress.tar.gz
04:21:09 <Igloo> Foo prints "Main:Bar (Main:Foo 5) 8 (Main:Bar (Main:Foo 7) 9 (Main:Foo 1))"
04:22:18 * shapr reads source
04:22:20 * Igloo helped someone (who'd got a GUI library working) to write a Mandelbrot viewer in LISP in a LISP hands-on
04:22:26 <shapr> neat!
04:23:17 <Igloo> Oh, and there's a GTK interface to Fraskell now. I need to add support for zooming by selecting an area with the mouse
04:23:25 <shapr> cool!
04:23:29 <xkb> shameless plug: http://lambda.weblogs.com/
04:23:30 <xkb> :D
04:23:40 <shapr> xkb: are you on lambda today?
04:23:49 <xkb> reading yes
04:23:53 <xkb> writing no
04:23:58 <shapr> I write on lambda
04:24:03 <xkb> Lol
04:24:10 <xkb> whats your name there?
04:24:41 <xkb> Ill post some on my exception handling stuff if I think it is readable enough
04:25:02 <shapr> one of my friends got lambdadotted recently :-)
04:25:10 <xkb> neel?
04:25:12 <shapr> heh
04:25:14 <shapr> I wish
04:25:21 <shapr> no, I'm Shae Erisson
04:25:25 <shapr> I've posted stuff about Joy mostly
04:25:28 <xkb> ah.. needle looks very promissing
04:25:34 <xkb> hmm bad spelling?
04:25:41 <shapr> who, me?
04:25:45 <xkb> no me
04:25:48 <xkb> on promissing
04:25:49 <Igloo> promising
04:25:51 <xkb> ah
04:25:52 <shapr> neel krishnaswami is an amazing guy
04:25:54 <xkb> thanks
04:26:01 <xkb> yeah
04:26:16 <xkb> indeed.. his views on programming is amazing.
04:26:29 <xkb> I viewed the webcast last night
04:26:38 <xkb> (of the presentation of needle)
04:27:00 <shapr> I'll like needle if it's referentially transparent
04:27:03 <shapr> but I don't think it is
04:27:17 <xkb> hmm.. thats a downside indeed
04:27:20 <shapr> needle is gorgeous though
04:27:25 * Igloo -> comlab
04:27:42 <shapr> bus :: Igloo -> Comlab
04:27:43 <shapr> ?
04:27:48 <xkb> lol
04:28:03 <shapr> Template Haskell is powerful stuff
04:28:08 <shapr> I just gotta get my head wrapped around it
04:28:14 <xkb> Does anyone here know any good readable books on denotational semantics?
04:28:22 <xkb> wrt programming languages
04:29:56 <xkb> Clean now has some very nice generics support
04:30:10 <shapr> isn't clean commercial?
04:30:25 <xkb> only if used commercially
04:30:40 <xkb> A new license model has been introduced just weeks ago
04:33:17 <Heffalump> no, walk :: Igloo -> Comlab
04:33:27 <Heffalump> in fact, walk_very_fast :: Igloo -> Comlab
04:35:35 <xkb> for some posters on clean see: http://www.hypernation.net/clean/
04:35:44 <xkb> everything with a 2 in it
04:35:56 <shapr> I'd like to use Haskell commercially.
04:36:09 <xkb> with haskell that is possible right?
04:36:13 <shapr> yes, it is
04:36:16 <xkb> GPL?
04:36:19 <shapr> yup
04:36:22 <xkb> nice
04:36:28 <xkb> Clean should move that way 2
04:36:51 <xkb> however, the prof has a little company called Hilt.. so that might prevent it
04:37:23 <shapr> bonjour Kokko
04:37:39 <Kokko> bonjour
04:37:46 <shapr> possibly you are Nicolas Oury?
04:37:51 <Kokko> Yes
04:37:59 <shapr> hi, I'm Shae Erisson
04:38:09 <Kokko> OK
04:38:25 <Kokko> Have you try dark's SDL binding?
04:38:43 <shapr> I've only done "make" to get the bouncing penguins.
04:39:30 <Kokko> Well written
04:39:46 <shapr> but I saw you mention that you were working on a binding, so I thought you might find that info useful.
04:39:51 <Kokko> But missing wrapper for OpenGL settings functions
04:40:06 <shapr> last I heard, dark is working on Events
04:40:13 <Kokko> Yes, mine is mostly finished too.
04:40:27 <Kokko> Good example of duplicate work :( 
04:40:46 <shapr> maybe you guys can learn good things from each other
04:41:07 <shapr> often duplicates each have their own good points, and can improve.
04:41:14 <Kokko> Yes, I can give him a working autoconf system
04:41:43 <shapr> I wanted to download your SDL binding to look at it, but I couldn't find your homepage
04:41:49 <shapr> do you have a tarball online somewhere?
04:41:59 <Kokko> It's not online, as it is not usable yet
04:42:34 <shapr> dark has also said that his binding is not usable yet.
04:42:42 <shapr> he said it's just a preview release.
04:42:43 <Kokko> I think it is going to disapear : it's a quick and dirty binding, darks'one is much more elegant
04:43:25 <shapr> maybe this could get both of closer to a working binding :-)
04:44:11 <Kokko> In fact, I could start working on a binding for SDL Mixer as both of us can't get a good way of binding audio part of SDL.
04:44:22 <Kokko> as far as I can see
04:44:48 <Kokko> The funny thing is that we have everywhere the same design choice.
04:45:12 <Kokko> On what we are binding and how we are binding
04:45:41 <shapr> are you reading from the "Programming Linux Games" book also?
04:45:53 <Kokko> But his use of hsc2hs is good. My binding use a big m4 script for replacing SDL constants. Thst's dirty. 
04:45:53 <shapr> dark said he's making the binding from reading that book.
04:46:11 <Kokko> No. I didn't read it.
04:46:25 <shapr> it's freely available online.
04:46:36 <Kokko> In fact I was mainly doing a binding for using SDL instead of GLUT for OpenGL games.
04:47:37 <Heffalump> GHC is BSD isn't it?
04:48:03 <shapr> could it be X11 artistic?
04:48:05 * shapr doesn't remember
04:48:26 <shapr> I'd like to see more OpenGL support in GHC.
04:49:13 <shapr> pygame is python's SDL binding
04:49:39 <shapr> once it was released, lots of python games suddenly appeared.
04:49:50 <shapr> I hope the same thing will be true of HaSDL
04:50:22 <shapr> I'd like to rewrite crack-attack in Haskell.
04:50:37 <shapr> Kokko: do you have other code that you've written online?
04:55:48 <shapr> does anyone know if multithreaded OpenGL has been fixed in GHC yet?
05:10:17 * shapr wishes Zope were written in Haskell.
05:10:22 <shapr> is there an nntp module for Haskell?
05:10:50 <Igloo> NAFAIK
05:11:46 <shapr> f00
05:12:06 <shapr> oh Igloo, the tiny demo code I'm writing in various languages is http://setgame.com/
05:12:19 <shapr> addictive simple card game
05:12:28 <whee> ooooo card games
05:12:50 <shapr> easy to write in C/Python/Java
05:12:59 <shapr> I'm still staring at the Haskell version
05:13:07 <Igloo> Oh, how did Fraskell inspire that?
05:13:27 <shapr> because Fraskell is not so much about the program as everything else surrounding it
05:13:42 <shapr> the code is just a vehicle for investigating the 'support structure'
05:13:50 <Igloo> Ah, right
05:14:07 <shapr> so I wanted to come up with more ways of doing that
05:15:18 <whee> I wonder how hard it would be to do haskell/cocoa bindings
05:20:35 <shapr> whee: you should ask on ghc-users, maybe someone has tried it already.
05:21:04 <whee> doubt it :|
05:21:21 <whee> someone using both haskell and OS X is extremely rare :)
05:21:34 <shapr> I think Kokko does
05:21:40 <shapr> and Wolfgang
05:21:59 <shapr> actually, I think there are quite a few
05:22:06 <whee> neat
05:23:13 <b00b> I use haskell and sometimes Os X
05:23:21 <b00b> laptop is an ibook 
05:23:49 <shapr> whee: I've seen someone discussing cocoa bindings on ghc-users, try searching the mailing list archives.
05:25:38 <whee> I only see one reference to it :|
05:29:43 <whee> I hope it happens eventually, though. that'd definately be something that'd make me use haskell more
05:30:15 <whee> there's perl and python bindings so it can't be that bad
05:31:00 <Kokko> Sorry, I was away. I have nothing written that is online.
05:31:12 <Kokko> What is crack-attack
05:31:14 <Kokko> ?
05:31:19 <shapr> Kokko: being away is normal here, we all fall into normal life
05:31:30 <shapr> crack-attack is a great OpenGL game based on tetris-attack
05:31:47 <shapr> http://aluminumangel.org/attack/
05:33:19 <Kokko> for Cocoa binding, I think there is paper of Simon Peyton-Jones on writting binding for object oriented libraries 
05:34:23 <whee> I'm going to ask on the mailing list first and hope someone who isn't an idiot will try it :)
05:34:35 <Kokko> But objective-C is quite a different language that those studied there
05:35:57 * shapr wishes Python supported literate sources
05:36:14 <shapr> the more I use Haskell, the more I like it.
05:36:55 <whee> I'm still trying to find that big reason for me to switch to using haskell more
05:45:23 <Kokko> whee : that's the only usable language
05:45:47 <lament> heh
05:46:18 <lament> shapr: literate sources?
05:46:31 <lament> shapr: docstrings aren't enough for you?
05:48:52 <shapr> lament: it's just a case where I'd like to put more doc than code into a single file.
05:49:53 <lament> docstrings are great for that.
05:50:15 <whee> hhe
05:50:35 <whee> Kokko: I'll try porting one of my ocaml programs to haskell when I get time, and we'll see :P
05:50:38 <whee> monads still scare the hell out of me
05:50:41 <lament> Especially because they're tied to whatever semantic elements they apply to
05:50:48 <lament> unlike in literate haskell
05:51:54 <shapr> otoh, literate haskell lets you turn your sources into LaTeX documentation
05:52:17 <lament> pydoc is _way_ more helpful than latex documentation
05:52:22 <lament> at least, for programmers :)
05:52:30 <shapr> I'm writing end-user docs though
05:52:34 <whee> there's no automatic documentation tool for haskell?
05:52:39 <shapr> yah there is
05:52:43 <whee> phew :)
05:52:49 <shapr> several
05:53:00 <shapr> haddock appears to be the most popular
05:53:22 <whee> the only documentation I write is whatever I put in my source to convince myself that it works. heh
05:53:45 <shapr> docs that I write to myself are unit tests
05:56:20 <whee> time for classes, and a fun day of writing 68000 assembly :|
05:56:24 <shapr> yay!
05:56:31 <o3> whee: haddock is good
05:56:39 <o3> well, actually, not quite
05:56:42 <o3> haddock produces very nice docs
05:56:48 <o3> i don't like it's markup language very much though :)
05:57:02 <Kokko> whee : what type of program do you have in Ocaml?
05:57:06 <shapr> 68k asm > i386 asm
05:57:06 <shapr> hi Andre!
05:58:05 <o3> hey shapr
06:27:17 * Igloo stops playing crack-attack and glares at shapr
06:28:30 <Heffalump> lol
06:32:24 <Kokko> Does anyone have compared Frantk and iHaskell on the point of implementation of states and events?
06:48:57 <inkedmn> shapr!
06:49:46 <Heffalump> inkedmn: I know SML, btw
06:51:57 <inkedmn> Heffalump: ah, ok :)
07:02:01 <shapr> hi inkedmn
07:02:04 <shapr> hey dark
07:02:32 <shapr> dark: Kokko is the guy who is also working on an SDL binding.
07:02:40 <mgoetze> dark: let's write a go program in haskell!
07:03:03 <shapr> I suspect many people would like a go program in Haskell
07:03:05 <dark> mgoetze: Not me :)  My life is pleasant without hard problems.
07:03:21 <inkedmn> you guys play Go?
07:03:25 <dark> Yeah.
07:03:26 <mgoetze> inkedmn: try.
07:03:30 <dark> ... sometimes.
07:03:33 * inkedmn likes Go (but sucks at it)
07:03:34 <shapr> for some reason, Haskell programmers play Go
07:03:44 <inkedmn> ah, then i was destined to learn this language...
07:03:47 * mgoetze just noticed that dark maintains some go package or other (cgoban?)...
07:03:59 <dark> Yeah, Debian package of cgoban.
07:04:15 <dark> If anyone wants it, let me know :)
07:04:19 <mgoetze> lol
07:04:32 <dark> I'm gradually getting rid of my packages.
07:04:42 <mgoetze> i want to file wishlist bugs against it... :)
07:05:07 <dark> mgoetze: Note that the upstream author doesn't want to work on it anymore, he's busy with cgoban 2.
07:05:08 <shapr> hi RichiH
07:05:23 <RichiH> lo
07:05:34 <shapr> your name sounds familiar....
07:05:36 * shapr googles
07:05:45 <mgoetze> cgoban 2? sounds interesting...
07:06:02 <RichiH> shapr: #linuxhelp, #freenode?
07:06:11 * SyntaxPolice likes go :-)
07:06:44 <shapr> RichiH: nah, your real name...
07:06:58 <dark> cgoban 2 is at http://kgs.kiseido.com/en_US/download.html
07:07:01 <shapr> do you use Haskell?
07:07:07 <RichiH> shapr: noboby?
07:07:11 <dark> Unfortunately it's specifically for KGS.  It doesn't work with IGS or NNGS.
07:07:16 <RichiH> no
07:07:18 <shapr> noboby? eh?
07:07:25 <SyntaxPolice> dark: did you happen to see my questions on haskell-cafe about Debian packages for Haskell stuff?
07:07:30 <shapr> in that case, would you like to learn Haskell? :-)
07:07:32 <RichiH> mgoetze mentioned the channel and i wanted to have a look
07:07:52 <RichiH> i don't even know what it's supposed to be :)
07:07:55 <dark> Also, it's in Java and depends on evil icky sun non-free java stuff.
07:08:06 <mgoetze> RichiH: programming language :P www.haskell.org
07:08:06 <dark> SyntaxPolice: If it was you, then I also replied :-)
07:08:15 <shapr> RichiH: oh, maybe it's your PalmOS stuff
07:08:26 <SyntaxPolice> dark: OK :) yeah, mailman screwed up my name on that email.
07:08:30 <shapr> Haskell is a very spiffy programming language.
07:08:37 * RichiH didn=t do anything with palmos
07:08:42 <shapr> I promise it will stretch your brain into shapes you've never seen before.
07:08:44 <shapr> oh
07:08:45 <RichiH> though ppl tend to ask me about it
07:08:47 <shapr> heh
07:08:48 <dark> SyntaxPolice: I was the one who suggested arch-specific build dependencies.
07:08:49 <SyntaxPolice> There was some good advice there.
07:08:57 <dark> shapr: Is this a feature?
07:08:57 <SyntaxPolice> dark: ahh. Cool.
07:09:02 <shapr> dark: yes, very much so
07:09:15 <dark> I mean, my brain's current shape nicely fits in my skull.
07:09:18 <shapr> because then you can use those brain shapes in most any language.
07:09:22 <dark> Keeping it that way has been a priority for a long time.
07:09:25 <SyntaxPolice> dark: are you good at Go?
07:09:33 <dark> SyntaxPolice: No :)
07:09:35 <shapr> dark sure creamed me when I played him.
07:09:42 <shapr> admittedly, that's the only time I've ever played Go
07:09:43 <mgoetze> is anyone here at least a 10 kyu? :)
07:10:01 * mgoetze is probably around 25 kyu...
07:10:18 <dark> mgoetze: Well kye levels differ from region to region :)
07:10:27 <SyntaxPolice> mgoetze: I have no idea what level I am.
07:10:32 <shapr> RichiH: http://c2.com/cgi-bin/wiki?AdvantagesOfFp
07:10:44 <dark> I got to around 15 kyu about eight years ago, and then I almost stopped playing, so I've been sliding back since then.
07:10:47 <mgoetze> dark: only in practice... they shouldn't in theory :)
07:11:07 <shapr> RichiH: have you heard of Functional Programming?
07:11:19 <RichiH> shapr: yes
07:11:24 <shapr> have you tried it before?
07:11:31 * RichiH is forced to learn it by university
07:11:35 <RichiH> ocaml
07:11:38 <shapr> oh, cool
07:11:39 <RichiH> i hate it
07:11:41 <shapr> really?
07:12:03 <RichiH> i gtg
07:12:05 <dark> Raise your hand if you keep associating "ocaml" with perl.
07:12:11 <RichiH> but i think i could be back sometime :)
07:12:12 * shapr raises his hand
07:12:17 <RichiH> heh
07:12:21 <shapr> why do I keep associating ocaml with perl?
07:12:23 <RichiH> they are both eeevil, yeah
07:12:26 <dark> shapr: Camel book.
07:12:29 <shapr> oh!
07:12:30 <shapr> of course!
07:12:34 * shapr duhs
07:12:36 <dark> Heh.
07:12:44 <shapr> I actually own that book
07:12:44 <SyntaxPolice> hehe
07:12:45 <shapr> no wonder
07:12:53 <jak_> dark, do you get crashes with ghci and your haskell bindings?
07:13:01 <dark> jak: I don't use ghci.
07:13:28 <dark> jak: hasdl isn't a proper package yet, that might fix it :)
07:13:35 <jak_> I use ghci by editing the makefile - taking the rule for the binary and replacing ghc with ghci and removing --make and -o
07:13:40 <jak_> dark, perhaps
07:14:00 <jak_> I usually get a crash on trying to reload the sources after having run a demo for a bit
07:14:02 <shapr> hey, Kokko said he was thinking of switching his effort a sound binding
07:14:05 <dark> If ghci loads the module without also loading libsdl, then I can see it crashing.
07:14:17 <jak_> no, it works with ghci
07:14:23 <dark> Hmm, interesting.  I wonder how :-)
07:14:35 <dark> shapr: Is he looking at libsdl-mixer too?
07:14:44 <shapr> yah, he mentioned mixer
07:14:45 <jak_> but just crashes if you try to load a different program
07:15:18 <dark> That reminds me, does anyone here have a joystick?  I have no way to test the joystick bindings.  I don't want to go out to buy one, I can see the carbon dioxide crystallizing in the air :-)
07:15:23 <shapr> I have a joystick.
07:15:39 <shapr> my joystick has thirty zillion buttons in fact
07:15:54 <shapr> something like five axes as well
07:16:18 <dark> shapr: Can you say "Oh my god, I have an axe in my head!" in swedish yet?
07:16:24 <shapr> um
07:16:26 * shapr thinks
07:16:38 <shapr> no, I guess not.
07:16:39 <dark> I can say it in finnish but not type it with this keyboard setting :)
07:16:47 * shapr uses x-symbol
07:16:53 <dark> shapr: There's a page somewhere with that phrase in a hundred different languages.
07:16:56 <shapr> hm, nifty
07:17:05 <shapr> I saw the "I can eat glass..." page
07:17:53 <dark> Apparently the finnish translation isn't all that accurate, though.  It ends up more like "By god, my head contains an axe"
07:18:12 <dark> A certain lack of flavour :-)
07:18:17 <shapr> somethings just can't cross the boundary of finnish
07:19:05 <dark> jak: I've been avoiding making it a separate package because that would mean I'd have to "make install" just to test it.
07:19:18 <shapr> Kokko mentioned that he has a working autoconf setup for you
07:19:41 <dark> shapr: Cool :)  Where?
07:19:42 <mgoetze> if i wanted to do something really hard, but rewarding, i would either try to write a go engine in haskell, or learn finnish...
07:19:56 <shapr> dark: poke him, he's here on the channel.
07:20:12 <shapr> he said the package/source isn't online because it's not usable yet.
07:20:13 <dark> Yeah but idle.
07:20:37 <dark> mgoetze: Why not write a go engine in finnish?
07:21:11 <mgoetze> dark: uuuuuuuuuuhm... because computers don't understand finnish?
07:21:14 <dark> shapr: hasdl is not usable yet but it's still online :)
07:21:30 <shapr> yah, I think "release early and often" is always the best policy
07:21:45 <shapr> I should keep my ~/src dir mirrored on my website.
07:21:47 <shapr> could be interesting.
07:21:56 <dark> shapr: Hmm, I think that releasing too early can invoke the town council effect, though.
07:22:10 <shapr> that's true
07:22:17 <dark> Yeah I've been meaning to make a proper site for my coding stuff but I've been too lame for it :)
07:22:35 <dark> So I just plunk files into my WWW directory.
07:22:37 <shapr> why not just copy your source dir?
07:22:43 <shapr> I'd love to browse it
07:22:56 <dark> shapr: The source dir isn't as important as the arch repository :)
07:23:09 <shapr> arch repos?
07:23:09 <shapr> oh!
07:23:19 <shapr> hm
07:23:32 <dark> But the arch repository by itself isn't all that useful, I'd need some way of automatically extracting the latest version as a tarfile too.
07:23:38 <SyntaxPolice> are you using the arch version control system?
07:24:00 <dark> SyntaxPolice: Yep.  I even started writing my own in Haskell :-)  (harc, it's also plunked into my WWW directory)
07:24:19 * shapr has been meaning to switch to subversion
07:24:36 <SyntaxPolice> dark: your own version control system?  I wanted to use arch, but their web page was down for a few weeks (maybe still) and so we did subversion again.
07:24:39 <SyntaxPolice> s/again/instead
07:24:42 <Kokko> dark : I am the guy who write another SDL binding.
07:24:48 <dark> Anyway, I easily create and destroy directories in ~source/haskell because everything is in the repository anyway.  So mirroring it wouldn't be very good.
07:24:54 <dark> Kokko: Yeah, shapr told me :)
07:25:06 <Kokko> It' conceptually the same thing but mine is dirtier
07:25:24 <Kokko> but have binding for SDL_GL_attr_functions
07:25:32 * Heffalump is not hugely impressed by arch
07:25:33 <Kokko> and work with windows and OS X
07:25:36 <dark> SyntaxPolice: My own frontend to the arch system, actually.  Same format, same rules, new code, new user interface.
07:25:39 <SyntaxPolice> shapr: you should try out subversion.  I'm happy w/ it so far, though havn't done very complex things.  I was very happy to be able to move my directories around freely.
07:25:40 * shapr has never read about arch
07:25:54 <dark> Kokko: How did you deal with the SDL_main thing?
07:26:02 <SyntaxPolice> dark: very cool.
07:26:12 <Kokko> I write a main function in C.
07:26:20 <shapr> SyntaxPolice: I will, as soon as the emacs support is equal to the emacs cvs support
07:26:31 <Kokko> that call the haskell RTS at start.
07:26:37 <SyntaxPolice> shapr: actually, its pretty OK, though I can't use the VC backend in xemacs
07:26:43 <dark> SyntaxPolice: At this point I have "harc get" working and not much else.  But it can access repositories over HTTP, no DAV required :)
07:26:43 <SyntaxPolice> (it works for gnu emacs I guess)
07:26:47 <Kokko> And I then link with libSDLmain.a
07:26:55 <Igloo> Heff: Oh? What's your tool of choice then?
07:27:10 <Kokko> It was quite a complex hack but it works
07:27:23 <Kokko> If we merge I can give you that
07:27:38 <dark> Kokko: Hmm, how does that affect people who use it as a package?
07:27:51 <shapr> SyntaxPolice: what's wrong with vc + xemacs? that's exactly what I require.
07:28:25 <dark> I've been looking at libsdl source, and I don't understand why they did that SDL_main thing in the first place.  I saw nothing that couldn't have been done in SDL_Init.
07:28:51 <Kokko> dark : * on Linux, no. (because it isn't linked with libSDLmain)
07:28:53 * shapr adds "test subversion vc" to his list
07:29:07 <dark> shapr: expn vc?
07:29:21 <shapr> eh?
07:29:23 <shapr> oh,
07:29:30 <shapr> the vc module for emacs
07:29:34 <Heffalump> igloo: dunno yet
07:29:41 <Kokko> * on OS X, there is a small problem that force to write the .conf file at hand. But I report and I think future version of ghc will work
07:29:44 <Heffalump> I need to play with arch more and email the list with some questions I have
07:29:47 <shapr> it's a minor mode that lets you do lots of cool vc stuff on your current file
07:29:59 <dark> shapr: vc is "version control"?
07:30:04 <Heffalump> but I suspect the answer is "the one roughly designed in my head but not yet implemented"
07:30:11 <Kokko> I also have a configure /Makefile.in that make use of sdl-config to automaticly set up the package
07:30:14 <shapr> any of cvs, arch, source-safe, subversion, etc
07:30:50 <Kokko> dark : I don't know why they use their own main function
07:30:51 <shapr> dark: yup, it's nice because it abstracts away which vc backend you're using
07:31:14 <Kokko> dark : maybe on os x because they wanted to be a Cocoa application
07:31:19 <SyntaxPolice> shapr: from what I understand, GNU Emacs has a somewhat more sophisticated VC implementation at this point
07:31:27 <SyntaxPolice> shapr: but xemacs doesn't implement it yet
07:31:27 <Kokko> Don't know windows enough to abswer on windows
07:31:37 <dark> brb, girlfriend just arrived :)
07:32:08 <SyntaxPolice> shapr: so the subversion vc backend is implemented w/ the newish gnu emacs way of doing it
07:32:22 <shapr> bah humbug
07:32:33 <SyntaxPolice> I actually got xemacs to eval the file, but it doesn't magically work :(
07:32:44 <shapr> hopefully I can fix it
07:32:49 <shapr> I have some minor elisp skillz
07:33:15 <SyntaxPolice> shapr: sweet.  I think the RIght Way would be to port the gnu emacs vc stuff to xemacs, which may not be that easy.
07:33:24 <Kokko> I have to go
07:33:29 <Kokko> see you later
07:34:15 <shapr> we'll see how it goes.
07:34:37 <inkedmn> are you guys mostly emacs foiks?  or vim?
07:34:43 <inkedmn> or neiter?
07:34:56 <inkedmn> er
07:34:59 <inkedmn> neither
07:35:08 <jak_> inkedmn: xemacs for software development, vim for configuration files
07:35:17 <shapr> I know Igloo uses vim
07:35:23 <SyntaxPolice> shapr: there is also a psvn.el with which you can do "M-x svn-status" and that works in xemacs with some minor tweaks.
07:35:26 <shapr> at least a few emacs people here.
07:37:41 * shapr grabs the latest subversion deb
07:37:53 * Heffalump uses emacs, but I don't really like the haskell-mode for it
07:38:01 <shapr> how could it be improved?
07:38:08 <Heffalump> indentation bugs
07:38:12 <shapr> yah, that's a good point
07:38:13 <Heffalump> but I can never remember what they are
07:38:25 <shapr> I've had problems with indentation in emacs
07:38:27 <Heffalump> and the syntax highlighter sometimes gets confused by comments
07:38:38 * mgoetze is happy with vim. :)
07:38:42 <shapr> admittedly, my problems are rare
07:40:44 <shapr> something like PyMacs for Haskell would be nice
07:41:16 <Igloo> vim syntax highlighting gets confused by do_foo, which really is unforgivable. I should look at it some time.
07:43:16 * inkedmn uses vim
07:43:52 * dark uses nvi.
07:43:58 <dark> I'm only temporarily back :)
07:44:03 <mgoetze> let's start a club of go-playing, *vi*-using haskell programmers!
07:44:19 <inkedmn> heh
07:44:26 <dark> mgoetze: I'm not sure if I would agree that vim qualifies :)
07:44:29 <dark> vim is the emacs of vis.
07:44:55 <mgoetze> dark: we could always pretend that we're all using vim-tiny
07:45:10 * mgoetze had better not admit that the vim package on his system is vim-perl...
07:57:28 * shapr wishes for HaSQL support in GHC
07:59:55 <shapr> er, HaskellDB
08:04:29 <shapr> has anyone seen the MySQL support for HaskellDB ?
08:20:55 <jak_> no, is it any good ?
08:23:02 <shapr> I haven't seen it myself :-)
08:24:23 * inkedmn is still trying to figure out how to do simple list stuff...
08:24:28 <shapr> inkedmn: like what?
08:25:00 <Marvin--> bleh
08:25:07 <shapr> ?
08:25:14 <Marvin--> I'm pretty sure I did fail
08:25:20 * Marvin-- sighs
08:25:21 <Heffalump> Marvin--: fail what? :(
08:25:28 <Marvin--> exam on distributed systems
08:25:35 <inkedmn> well, i'm going to be trying the soundex matching algorithm
08:25:43 <shapr> :-(
08:25:51 <Marvin--> the sad part is that it wasn't *hard*, I just didn't know the material
08:25:53 <inkedmn> so i need to go through a list and replace each element with a different one
08:26:06 <Heffalump> inkedmn: map?
08:26:20 <inkedmn> well, it's like this
08:26:34 <inkedmn> each letter has a numeric value for this algorithm
08:26:46 <inkedmn> say, a-g are equal to 5
08:26:57 <inkedmn> h-m are equal to 6, ec
08:26:59 <inkedmn> er
08:27:00 <inkedmn> etc
08:27:11 * Marvin-- couldn't for his life remember how the Snapshot algorithm worked, or give an example of an atomic broadcast in a synchronous network
08:27:28 <shapr> Marvin--: sounds rough
08:27:32 <inkedmn> so, i need to go through and replace each char with it's numeric equivalent
08:27:38 <Heffalump> Marvin--: what are the consequences of failing?
08:27:49 <Heffalump> inkedmn: so just define a function value :: Char -> Int
08:27:57 <Heffalump> and then "map value chars"
08:28:01 <Marvin--> Heffalump: *shrug* a retake, no big deal really
08:28:25 <Marvin--> Heffalump: the irritating part is that I want to focus on my master project during spring, not a zillion other things
08:28:28 <inkedmn> Heffalump: i would have to create some sort of map for the letter -> ints though, right?
08:28:38 * shapr desperately needs a decent time logging system that's integrated with emacs
08:28:41 <Marvin--> and I'm not sure I'm going to pass the number theory either, so that'd make two retakes ;)
08:28:51 <Marvin--> (oh, and this was the first time I failed an exam, which is irritating :P)
08:29:02 <Heffalump> inkedmn: well, yes
08:29:14 <Heffalump> or just write a function that does it
08:29:14 <inkedmn> i'm not sure how to do that :)
08:29:22 <Heffalump> what you described could be:
08:29:35 <Heffalump> value c | 'a' <= c && c <= 'g' = 5
08:29:47 <Heffalump>         | 'h' <= c && c <= 'm' = 6
08:29:50 <Heffalump> etc
08:30:00 <shapr> I'd use elem for readability
08:30:00 <inkedmn> ok, what about this...
08:30:09 <inkedmn> say the letters aren't sequential
08:30:16 <inkedmn> a,f,g,r are worth 5
08:30:28 <Heffalump> well, at some point you'll have to list all the cases, then
08:30:29 <inkedmn> how would that be written?
08:30:33 <Heffalump> value 'a' = 5
08:30:34 <inkedmn> ok
08:30:36 <Heffalump> value 'f' = 5
08:30:39 <Heffalump> value 'g' = 5
08:30:40 <Heffalump> etc
08:31:05 <inkedmn> there are set values for each letter, i'm trying to get an idea of how it would work...
08:31:10 <inkedmn> could i do something like:
08:31:28 <inkedmn> {'a', 'f', 'g', 'r'} = 5
08:31:38 <inkedmn> i'm sure that syntax is wrong, but you see what i'm getting at
08:32:13 <Heffalump> value c | c `elem` "afgr" = 5
08:32:19 <inkedmn> ah...
08:32:31 <Heffalump> note that doing it this way will be quite inefficient
08:32:40 <inkedmn> why?
08:32:48 <Heffalump> but it'll probably do for now - if you need efficiency later you can always rewrite value without having to change the rest of your code
08:33:04 <Heffalump> because looking for c in the list will take time linear in the length of the list
08:33:25 <Heffalump> whereas I think pattern-matching gets compiled to something that takes constant time (TICBW)
08:33:35 <Heffalump> I wouldn't worry about it for now, anyway
08:33:37 <inkedmn> ok
08:33:43 <shapr> pat match becomes case
08:33:52 <shapr> is case constant time?
08:33:58 <Heffalump> yes, but the implementation of case is still pattern matching in the end
08:38:14 * Marvin-- mutters and grumbles
08:41:12 <inkedmn> what does | mean?
08:41:18 <inkedmn> in haskell code, i mean
08:41:31 <Heffalump> "guard"
08:41:40 <Heffalump> foo x | bar = baz
08:41:43 <shapr> it means "here's a bunch of if statements"
08:41:45 <inkedmn> i don't understand
08:41:47 <Heffalump> means that foo of x is baz if bar is true
08:41:53 <inkedmn> ah
08:42:13 <Heffalump> otherwise it goes onto the next line of the definition of foo
08:42:18 <shapr> char == 'a' | 5
08:42:23 <shapr> char == 'c' | 5
08:42:49 <Heffalump> umm, no
08:42:50 <inkedmn> so that's saying "if char equals 'a', then 5"?
08:42:51 <shapr> no?
08:42:56 <Heffalump> that syntax is incorrect
08:43:05 <Heffalump> foo char | char =='a' = 5
08:43:09 <shapr> oh right
08:43:11 * shapr duhs
08:43:13 <Heffalump>          | char =='c' = 5
08:43:16 <shapr> too much Python lately
08:44:46 <inkedmn> ok, so (in english) what does "foo char |" mean in the above expression?
08:45:05 <Heffalump> it means foo char if ... equals ...
08:45:23 <inkedmn> ah, ok so:
08:45:31 <shapr> means "here is a function named foo, it takes an argument, which we call char
08:45:31 <inkedmn> do function "foo" on argument "char" if...
08:46:20 <shapr> if char is the character 'a' the value of function foo is 5
08:46:27 <inkedmn> ah, ok
08:46:38 <Heffalump> inkedmn: no, function "foo" on argument "char" is defined to be ... if ...
08:47:29 <shapr> Haskell is a lot like writing an equation to describe what you want.
08:48:42 <inkedmn> ok
08:49:33 <inkedmn> does anybody want to help me actually write this quick function? :)
08:50:01 <seth> To do what?
08:50:06 <seth> (Just got here...)
08:50:37 <inkedmn> take a char argument and return an int value (defined in a series of hashes)
08:50:46 <inkedmn> like:
08:50:51 <inkedmn> f, p, and v are worth 1
08:51:01 <inkedmn> d and t are worth 3
08:51:03 <inkedmn> and so on
08:51:18 <seth> There is a module in the library that will do most of that for you.
08:52:22 <inkedmn> well, i kinda want to do it "manually" or whatever so i can learn :)
08:52:45 <seth> OK, you can do it with list functions as well.
08:52:49 <inkedmn> ok
08:53:10 <seth> There is a function to tell you whether a value is in a list, the position, etc.
08:53:22 <inkedmn> ok
08:54:04 <inkedmn> but i'll be performing this operation on the whole list
08:54:39 <seth> I was thinking more about a list for each catagory, as in ['f', 'p', 'v'] for example
08:54:55 <inkedmn> ok
08:56:14 <inkedmn> this is frustrating
08:56:26 <inkedmn> (having no idea where to begin)
08:56:34 <seth> Might be better ways to do it than what I'm thinking of.
08:56:55 <seth> The hard part is to think differently.  No explicit loops.
08:57:12 <inkedmn> yeah, that's the problem i keep having :)
08:57:24 <inkedmn> "this would be CAKE with loop!"
08:57:44 <seth> Yes, but it isn't that hard without one.  Your input will be a list of characters, right?
08:57:55 <inkedmn> well, it could be 
08:58:09 <inkedmn> but i was thinking it would take a char, return the matching int value
08:58:15 <inkedmn> instead of doing the whole list
08:58:17 <inkedmn> but that would work too
08:58:45 <seth> Usually in Haskell you use a list, as a function operate on the head of the list, and then have the function call itself recursively for the rest of the list.
08:58:53 <seth> That's how you get the loop sort of functionality.
08:58:54 <inkedmn> yeah
08:59:01 <inkedmn> that makes sense
08:59:25 <seth> You still have a function that operates on a character, but it is called by this recursive function we are talking about.  Or it can be coded inline in the recursive function.
08:59:50 <inkedmn> well, my instinct is to seperate the two...
09:00:02 <seth> I think that is usually easier to follow.
09:00:23 <inkedmn> agreed
09:01:13 <inkedmn> so the first function would be the one that would replace the char
09:01:27 <inkedmn> then the function that calls ^^ that one recursively
09:01:29 <inkedmn> yes?
09:02:22 <seth> Yes...
09:02:32 <seth> Sorry, I'm multitasking a bit here...   :)
09:03:00 <inkedmn> no problem, i am too :)
09:03:08 <inkedmn> have to at least APPEAR to be working ;)
09:03:26 <seth> Hey you are typing, right?
09:03:36 <inkedmn> eh?
09:03:39 * inkedmn doesn't understand
09:03:46 <inkedmn> as in data type?
09:04:02 <seth> :)
09:04:36 <inkedmn> you mean am i explicitly defining the function's type?
09:04:39 <inkedmn> like:
09:05:05 <seth> No, I was just attempting to be amusing, in response to your comment about working.
09:05:07 <inkedmn> replace <string> :: char
09:05:15 <inkedmn> oh lord
09:05:19 * inkedmn is an IDIOT
09:05:22 <inkedmn> sorry :)
09:05:26 <Heffalump> types in Haskell (as opposed to type variables) start with a capital letter, btw
09:05:27 <seth> Not terribly amusing, obviously   :)
09:05:38 <inkedmn> i thought "typing" was some crazy 1337 term ;)
09:05:51 <Heffalump> lol
09:05:58 <seth> Oh no, now Heffalump is going to see all my mistakes.   :)
09:06:03 <inkedmn> heh
09:06:08 * Heffalump doesn't have time to read scrollback :-)
09:06:20 * seth is going to type VERY fast.
09:12:19 <seth> BRB, hopefully...
09:19:42 * inkedmn should call mrs. ink soon...
09:20:00 <inkedmn> make sure she's up
09:57:56 * xkb is gone.. test (log/on!page/on)
09:58:36 * xkb is gone.. not here (log/on!page/on)
09:58:53 * xkb has returned.. back again [gone.16s]
10:36:10 <neniu> Are the answers to SOE somewhere in the internet?
10:41:33 <SyntaxPolice> neniu: I don't think so, not positive, but if you have a solution that you think is right, you might post to haskell-cafe, and the author or someone else might respond.
10:45:35 <neniu> SyntaxPolice: Thank you.
10:51:57 <dark> SDL_GetKeyName is _almost_ a pure function.  A given key always has the same name, but SDL's table of names is not initialized until after SDL_Init.
10:52:14 <dark> Would it be a great crime to duplicate the table in Haskell?
10:57:10 <inkedmn> Heffalump: you still around?
11:13:02 <hdaume> hi all
11:13:53 <stepcut> hi
11:14:57 <hdaume> anyone know if there's a single-line comment in ocaml, like our '--'?
11:54:03 <Heffalump> inkedm: am now
12:00:10 <inkedmn> can somebody tell me what i'm doing wrong with this function?
12:00:24 <inkedmn> i can paste the code here or somewhere else, it's about 8 lines
12:02:51 <tez> 8 lines?  I'm not sure what the rules are.  But if you do paste them, I can try to help.
12:02:59 <inkedmn> ok, here:
12:03:03 <inkedmn> </flood>
12:03:10 <Igloo> ITYM <flood>
12:03:11 <inkedmn> replace x :: Char -> Char
12:03:11 <inkedmn> replace c | c `elem` "aehiouwy" = '0'
12:03:11 <inkedmn>           | c `elem` "fpv" = '1'
12:03:11 <inkedmn>           | c `elem` "gjkqsxz" = '2'
12:03:11 <inkedmn>           | c `elem` "dt" = '3'
12:03:12 <inkedmn>           | c `elem` "l" = '4'
12:03:14 <inkedmn>           | c `elem` "mn" = '5'
12:03:16 <inkedmn>           | c `elem` "r" = '6'
12:03:23 <inkedmn> </flood>
12:03:47 <Igloo> What makes you think there is something wrong with it?
12:03:48 <tez> Ah
12:03:54 <tez> The first line
12:03:56 <Igloo> Oh, yes
12:03:59 <inkedmn> when i try to load it into hugs
12:04:07 <tez> there should be no 'x' in the type signature.
12:04:10 <inkedmn> ?
12:04:13 <inkedmn> oh...
12:05:05 <inkedmn> EXCELLENT.
12:05:08 <Igloo> Just beacuse you are using guards doesn't mean anything else changes. A list of "| ... = ..." is just substituted in wherever you have "= ..."
12:52:57 <inkedmn> ok, i'm writing a function that "uniquifies" a list
12:53:33 <Heffalump> this already exists
12:53:52 <dark> Heffalump: all functions already exist in a platonic sense :-)
12:54:28 <inkedmn> brb
12:54:54 <Heffalump> dark: :-)
13:14:35 <inkedmn> ok
13:14:43 <inkedmn> so, my uniquifier thing...
13:15:14 <inkedmn> it's a bit different that just removing all duplicates in a list
13:15:30 <inkedmn> i only want to remove duplicates that are ajdacent to each other...
13:15:36 <inkedmn> such as:
13:15:49 <inkedmn> mississippi would be : misisipi
13:16:23 <inkedmn> (i'm doing this as part of my soundex algorithm implementation)
13:16:56 <tez> What have you got so far?
13:17:27 <inkedmn> uniquify :: [a] -> [a]
13:17:28 <inkedmn> uniquify [] = []
13:17:28 <inkedmn> uniquify [a] = [a]
13:17:28 <inkedmn> uniquify (x:y:xs) =
13:17:52 <tez> lol
13:17:55 <inkedmn> oh, and the first element in the initial list should be ignored
13:18:06 <inkedmn> ?
13:18:23 <inkedmn> keep in mind, i'm VERY new at this
13:18:27 <tez> Well, you've got the interesting case left to fill in...
13:18:54 <inkedmn> you mean lists with more than one element?
13:18:58 <tez> Well, you've made a good start.
13:19:23 <tez> yes.  uniquify (x:y:xs) = ...
13:19:43 <inkedmn> i need to compare y to the first element in xs
13:19:56 <inkedmn> if they're the same, remove y from the list
13:20:02 <inkedmn> if not, continue
13:20:13 <inkedmn> not quite sure how to do that...
13:20:34 <tez> Why don't you compare x and y?
13:20:52 <inkedmn> because initially, x is not part of the comparison
13:21:24 <inkedmn> the first element in the list will be a letter, the rest will be digit chars
13:21:31 <inkedmn> '1', '2', etc.
13:21:37 <tez> so uniquify "mmisisipi" would give mmisisipi?
13:21:47 <tez> (say)
13:22:34 <inkedmn> yes
13:22:38 <inkedmn> exactly
13:23:24 <tez> I think, then, it would be easier first to treat uniquify as if it only had to handle nubers part of your list.
13:23:41 <tez> s/nubers/numbers
13:23:43 <inkedmn> ok
13:34:52 <inkedmn> how do you remove an element from a list?
13:35:05 <andersca> you can use filter
13:35:23 <inkedmn> hmm...
13:35:53 <dark> inkedmn: Is this something you're learning from, or do you just need an answer to use it in something else?
13:36:02 <tez> You're trying to remove the adjacent duplicates?
13:36:16 <inkedmn> tez: yes
13:36:38 <dark> Because I wrote a uniq for harc, and later I saw a one-liner for it on the haskell list :)
13:36:38 <inkedmn> dark: i'm doing an "assignment" given to me by another programmer to help me learn, and this is a small part of it
13:37:23 <inkedmn> i kinda want to do it on my own, without using anybody elses code
13:38:00 <tez> So you're thinking about the (x:y:xs) case right now?
13:38:48 <inkedmn> yes
13:38:56 <inkedmn> oh, and i was wrong about the whole "ignore x" thing :)
13:39:17 <inkedmn> so, i need to compare x and y
13:39:28 <inkedmn> if they're the same, i only need y
13:39:34 <inkedmn> if not, they both stay
13:39:40 <tez> right...
13:39:52 <inkedmn> so i'd do:
13:40:10 <inkedmn> | x == y = <don't add x to the list of uniq values>
13:40:31 <inkedmn> | x != y = <add x and y to list of uniq values>
13:40:42 <dark> You're making a mistaken assumption there.
13:40:48 <inkedmn> ok
13:40:52 <inkedmn> what's that?
13:41:06 <Heffalump> that Haskell and C use the same operator for "not equals"
13:41:13 <dark> Even if x != y, you don't know if y should stay.
13:41:59 <dark> Heffalump: that, too :)  Though I wish it did.
13:42:04 <dark> x /= y
13:42:20 <inkedmn> ok
13:43:09 <dark> inkedmn: Consider uniquify "fooobar"
13:43:19 <dark> Oops, wrong example.
13:43:33 <dark> uniquify "foobbar"
13:44:17 <inkedmn> ok
13:46:33 <inkedmn> should be:
13:46:43 <inkedmn> "fobar"
13:47:25 <inkedmn> right?
13:48:16 <tez> Yes, but what I think dark's trying to say is that when x/=y, but you the add both x and y to the unique list, you might not get that.
13:48:44 <inkedmn> i don't understand how that's possible...
13:48:56 <inkedmn> well, let me tell you how i'm assuming this works
13:49:00 <inkedmn> and you can correct me if i'm wrong...
13:49:06 <inkedmn> if i do:
13:49:17 <inkedmn> uniq (x:y:xs)
13:49:25 <inkedmn> uniq "foobbar"
13:49:42 <inkedmn> first it will compare 'f' and 'o', which don't match
13:50:04 <inkedmn> then 'o' and 'o' which match, so 'o' is omitted
13:50:13 <inkedmn> then 'o' and 'b', etc...
13:50:32 <Heffalump> fooobar is important to consider too
13:51:00 <tez> Ah, so in fact, what your saying there is that if x/=y, you'll only add x.
13:51:18 <inkedmn> tez: yes, then evaluate y in x's place
13:51:19 <tez> (in x:y:xs)
13:53:00 <tez> That sounds like it would work.
13:53:57 <inkedmn> my question is, syntactically, how do i tell it to include/omit an item?
13:55:24 <tez> Oh well, you don't really do that.  What you do is just type what the resultat list will look like, uh, if you see what I mean.
13:55:27 <Heffalump> by including it in the result list or not doing so
13:55:52 <tez> Yes, what Heffalump said :-)
13:56:11 <Heffalump> for example, in the definition
13:56:13 <Heffalump> tail (x:xs) = xs
13:56:22 <Heffalump> I am leaving x out of the result list
13:56:27 <Heffalump> likewise in the definition
13:56:30 <Heffalump> last [x] = [x]
13:56:35 <Heffalump> last (x:xs) = last xs
13:56:43 <Heffalump> I'm leaving x out unless it really is the last element
13:56:46 <inkedmn> i don't understand
13:56:58 <inkedmn> will it include x unless i explicitly tell it not to?
13:57:05 <Heffalump> no.
13:57:07 <inkedmn> ok
13:57:13 <Heffalump> it will not include x unless you explicitly tell it to.
13:57:44 <Heffalump> you should try not to think of Haskell programs operationally
13:57:57 <Heffalump> instead of saying "how do I make it do foo/bar", you should say "how do I make the result foo/bar"
13:58:00 <inkedmn> heh, i'm trying not to
13:58:08 <inkedmn> yeah
13:58:20 <Heffalump> so your question really was "how do I make the result list include x or not include x"
13:58:27 <inkedmn> yes, exactly
13:58:53 <Heffalump> and then the answer becomes clear, because you can just write whatever you want for the result list, so you can choose whether to include x or not
13:59:45 * Heffalump disappears
14:01:43 <inkedmn> the problem is, i've never had to actually manipulate the result (using haskell)
14:02:09 <inkedmn> it can't be a seperate list defined within the function, since the function is going to call itself recursively...
14:02:39 <tez> Ok, let's look at this case:
14:02:47 <tez> uiquify (x:y:xs)=
14:02:47 <inkedmn> ok
14:02:52 <tez>   | x == y = <don't add x to the list of uniq values>
14:03:23 <tez> you want to replace <don't add x to the list of uniq values>
14:04:15 <tez> well, you started off with a list (x:y:xs), and x==y.  What shold you have left?
14:04:29 <tez> Rather, what would you like to remain?
14:04:30 <inkedmn> xs
14:04:39 <inkedmn> y:xs
14:04:56 <tez> lol.  Pick one!
14:05:06 <inkedmn> the second one :)
14:05:34 <tez> Right.  But of course you're not just leaving y:xs, because there might be adjacent duplicates in there, so...
14:06:08 <inkedmn> well, they're going to be passed to the function
14:06:53 <tez> yes...
14:07:11 <inkedmn> y:xs i mean
14:07:39 <tez> well, how do you write that?
14:07:47 <inkedmn> that's the think i don't know :)
14:08:19 <inkedmn> i know (now) how to evaluate whether x is equal to y or not, but i don't know how to manipulate the result list if either is true/false
14:08:28 <tez> Ok.  We've dropped the x in (x:y:xs) because we're considering the case x==y, right?
14:08:48 <inkedmn> yes
14:08:51 <tez> So we're thinking about y:xs.
14:09:29 <tez> So far, we're saying that to uniquify (x:y:xs) when x==y, we drop the x.
14:09:35 <inkedmn> yes
14:09:48 <inkedmn> then, call uniquify y:xs
14:09:54 <inkedmn> (recursively)
14:09:58 <tez> Yes!
14:10:05 <inkedmn> i understand that part :)
14:10:07 <tez> We just call uniquify (y:xs) !
14:10:19 <inkedmn> what if x /= y?
14:10:34 <tez> Ok.
14:10:38 <inkedmn> and i want to include x in the result list
14:10:43 <inkedmn> that's my problem :)
14:11:46 <tez> Well, if xs is a list, how is a list that has an element x in the front followed by the list cs written?
14:11:53 <tez> s/cs/xs
14:12:57 <inkedmn> x:xs
14:13:05 <tez> right.
14:13:23 <tez> That's how you'd "add" x to your resultant list.
14:14:07 <inkedmn> so:
14:14:32 <inkedmn> uniquify (x:y:xs) =
14:14:32 <inkedmn>     | x == y = uniquify(y:xs)
14:14:32 <inkedmn>     | x /= y = uniquify(y:xs:x) 
14:14:45 <inkedmn> i'm sure that's wrong :)
14:15:00 <tez> the last line isn't quite right...
14:15:17 <inkedmn> do i put x:y:xs?
14:15:22 <inkedmn> (if so, i'm WAY lost)
14:15:26 <tez> no.
14:15:36 <inkedmn> ok
14:16:29 <tez> with your current last line, you'd be getting uniquify to keep x, but onsider it again at the end of the list (btw, you can't use ':' that way anyway).
14:17:26 <inkedmn> ok, i think i get you
14:17:45 <inkedmn> but i'm not sure how to do it :)
14:18:22 <tez> Ok, let's try this.  Instead of thinking about how to reursively call uniquify, let's just call the rest of the list, uiquified for us, 'zs'.
14:18:53 <inkedmn> ok
14:19:43 <tez> When you call 'uniquify (x:y:xs)', you're trying to determine whether you should keep x or not.
14:19:56 <inkedmn> yes
14:20:05 <tez> The first case, where x==y, what would the result be?
14:20:16 <inkedmn> (sorry, gotta log off for just a sec, i'll be right back)
14:20:21 <tez> sure
14:26:05 <inkedmn> sorry, i'm back
14:26:20 <inkedmn> had to redock my laptop back at my desk
14:26:27 <tez> Ah.
14:26:47 <inkedmn> anyway, please continue
14:27:18 <tez> Oh yes, I said:
14:27:25 <tez> Ok, let's try this.  Instead of thinking about how to reursively call uniquify, let's just call the rest of the list, uniquified for us, 'zs'.
14:27:46 <tez> When you call 'uniquify (x:y:xs)', you're trying to determine whether you should keep x or not.
14:27:57 <tez> The first case, where x==y, what would the result be?
14:28:15 <inkedmn> the result would be no
14:28:21 <inkedmn> (don't keep x)
14:28:33 <tez> Yes, but what's the resulting list?
14:28:39 <inkedmn> y:xs
14:28:52 <tez> Not quite...
14:30:31 <inkedmn> hmm...
14:30:38 <inkedmn> xs?
14:30:44 <tez> You had it earlier!
14:31:23 <inkedmn> y:xs:x?
14:31:36 <tez> we drop the x, because x==y
14:31:51 <tez> and are left with y:xs, but we need to do something to it
14:31:59 <inkedmn> oh
14:32:07 <inkedmn> uniquify y:xs
14:32:47 <tez> Right.  But I said to make things easier (I hope), we're just going to call that remain part uniquified for us 'zs'.
14:33:10 <whee> is it bad to have one case as 'x == y' and the other as 'x /= y'? wouldn't using 'otherwise' be better?
14:33:42 <tez> So when x==y, we're left with zs (but we know this is just short hand for 'uniquify (y:xs)').
14:33:51 <inkedmn> ok
14:34:14 <tez> It doesn't make muh difference here, since you've covered all the cases.
14:34:26 <whee> the compiler knows that?
14:34:45 <whee> the ocaml compiler always complained if you would do something like that, I guess haskell handles guards differently
14:35:09 <whee> since with complicated guards it could be difficult to prove that it covers all the cases
14:35:28 <tez> Oh, in terms of autoatic compiler checking, I don't actually know which is better.
14:35:49 <tez> inkedmn: Right, now consider the case x/=y.
14:35:54 <inkedmn> ok
14:36:08 <tez> You want to keep x.
14:36:11 <inkedmn> yes
14:36:46 <tez> Using our shorthand, what does the resulting list look like?
14:37:03 <inkedmn> x:zs
14:37:09 <tez> Exactly!
14:37:10 <inkedmn> ?
14:37:12 <inkedmn> ok
14:37:35 <inkedmn> wait...
14:37:39 <inkedmn> so it's going to be:
14:37:57 <inkedmn> x : uniquify y:xs
14:37:58 <neniu> if 'ia' is Float and 'n' is Int how can I set 'ia = (n-2) * pi/n'? Is there a toFloat function?
14:37:58 <inkedmn> ?
14:38:03 <tez> yes!
14:38:11 <inkedmn> tez: EXCELLENT!!
14:38:16 <inkedmn> thank you very much !!!
14:38:17 <tez> (put brackets around (y:xs))
14:39:39 <inkedmn> here:
14:39:40 <inkedmn> uniquify :: [a] -> [a]
14:39:40 <inkedmn> uniquify [] = []
14:39:40 <inkedmn> uniquify [a] = [a]
14:39:40 <inkedmn> uniquify (x:y:xs) =
14:39:40 <inkedmn>     | x == y = uniquify [y:xs]
14:39:42 <inkedmn>     | x /= y = x : uniquify [y:xs]
14:39:44 <inkedmn>     
14:40:05 <tez> Oh, no, round parentheses.
14:40:09 <inkedmn> oh, ok
14:40:11 <tez> (y:xs).
14:40:45 <inkedmn> still getting a syntax error
14:40:55 <tez> Is it about Ord?
14:41:01 <inkedmn>   | x == y = uniquify (y:xs)
14:41:03 <inkedmn> that line
14:41:27 <tez> Oh, the line uniquify (x:y:xs) = shouldn't have that '=' sign
14:41:32 <inkedmn> ah, ok
14:42:11 <inkedmn> ERROR "e:\haskell\code\Soundex.hs":17 - Cannot justify constraints in explicitly
14:42:11 <inkedmn>  typed binding
14:42:11 <inkedmn> *** Expression    : uniquify
14:42:11 <inkedmn> *** Type          : [a] -> [a]
14:42:11 <inkedmn> *** Given context : ()
14:42:13 <inkedmn> *** Constraints   : Eq a
14:42:27 <tez> Ah, Eq, not Ord.
14:42:34 <inkedmn> line 17 is:
14:42:39 <inkedmn> uniquify [] = []
14:42:58 <tez> Since you're comparing things for equality or inequality, you should ammend the type signature:
14:43:03 <inkedmn> ok
14:43:25 <tez> You have to say that your function works on lists you equality comparable types by:
14:43:39 <tez> uniquify :: Ord a => [a] -> [a]
14:43:47 <tez> Sorry:
14:43:59 <tez> Uniquify :: Eq a => [a] -> [a]
14:45:03 <inkedmn> tez: sweet, thanks a ton man :)
14:45:17 <tez> No prob.  But now it's bedtime.  Night.
14:48:22 <inkedmn> go to bed!
14:49:03 <tez> lol
14:50:31 <whee> oooo, implementing soundex are you
14:52:59 <inkedmn> indeed i am
14:53:01 <inkedmn> well, trying :)
14:53:11 <inkedmn> my first real haskell program
14:58:03 <inkedmn> alright, going home now
14:58:04 <inkedmn> bye
15:31:00 * clausen very excited about skew binary random access lists
15:39:36 <Pseudonym> That's a lot of qualifiers.
15:39:51 <Pseudonym> skew binary random-access
15:40:09 <clausen> hehe
15:40:24 <clausen> you can read about my excitement here:
15:40:29 <Pseudonym> One of these days, the name of the data structure will be longer than the algorithm.
15:40:30 <clausen> members.optusnet.com.au/clausen/ideas/functional-fs.txt
15:40:36 <clausen> *grin*
15:40:48 <clausen> the type definition?
15:43:22 <Pseudonym> Interesting.
15:44:09 <clausen> I was hoping to be able to beat journalling though :/
15:44:16 <clausen> I think I can prove it's impossible :/
15:44:34 <Pseudonym> It depends.
15:44:39 <Pseudonym> You may be able to use a combination.
15:44:53 <clausen> well, you always have to update the metaroot
15:44:54 <clausen> to "commit"
15:45:13 <Pseudonym> True, but you may be able to journal just the operations at the root.
15:45:22 <clausen> but that means a seek to the journal
15:45:24 <clausen> that's really bad
15:45:40 <clausen> if we are given 4 bytes of seekless storage...
15:45:42 <clausen> (NVRAM)
15:45:49 <clausen> then that might be enough to beat journalling
15:45:59 <clausen> you'd think that would be affordable ;)
15:46:17 <dark> The interface would cost more than the memory :)
15:46:39 <clausen> dark: that's what I'm worried about
15:46:50 <clausen> dark: if you've got 4 bytes, why not 40 megabytes?
15:47:05 <clausen> (40 megabytes should be enough to stick a journal in NVRAM)
15:47:16 <clausen> (in which case, journaling wins?)
15:47:20 <clausen> (well, you still don't get persistence)
15:47:23 <Pseudonym> The high-end disk units we have used have 8Gb of NVRAM.
15:47:30 <clausen> 8gb?!!!!
15:47:33 <clausen> OMG!
15:47:33 <Pseudonym> Yes.
15:47:53 <clausen> that must cost a fortune!
15:48:07 <clausen> it costs about $AU 2000 / gb, right?
15:48:24 <Pseudonym> About AU$50,000 for about half a Tb of NVRAM-accelerated disk, I think.
15:48:41 <Pseudonym> Not sure.  They're not ours.
15:48:41 <clausen> crickey, that's nuts
15:48:55 <Pseudonym> The government agency in question needs fast access to their data.
15:49:19 <clausen> I need to enter that market *grin*
15:49:59 <dark> With any amount of NVRAM write cache, seeking to a well-known location becomes cheap.
15:50:21 <Pseudonym> The trouble is, when you work in this kind of field, you can't gloat as much as you'd like.
15:50:36 <clausen> hmmm, actually, in that case, my system kicks arse
15:50:39 <clausen> it halves the IO bandwidth
15:50:49 <clausen> (with journals, you have to write everything twice)
15:50:56 <dark> clausen: the journal contains the actual new data?
15:51:08 <clausen> dark: if you care about data integrity, yes
15:51:10 <Pseudonym> clausen: That's true, but the second time you write it, you batch the writes.
15:51:21 <clausen> still hogs bus bandwidth
15:51:54 <clausen> I guess it's not easy to tell what the win would be
15:52:01 <Pseudonym> What you really want is a journalling disk, not a journalling file system.
15:52:18 <clausen> Pseudonym: what transaction model would you use?
15:52:41 <clausen> transcations are a PITA
15:52:44 <Pseudonym> clausen: A very simple one.
15:52:48 <clausen> transactions
15:52:50 <Pseudonym> Either the write succeeds or it fails.
15:52:58 <Pseudonym> Writes are committed in the order that you send them.
15:52:59 <clausen> ok, how would mv(1) be atomic?
15:53:47 <dark> Pseudonym: That ordering could be costly.
15:53:50 <Pseudonym> It wouldn't.  mv would be a sequence of operations.
15:54:01 <clausen> dark: commit != write-order ;)
15:54:10 <clausen> (commit order != write order)
15:54:10 <Pseudonym> You link to the new directory entry first, then you unlink from the old entry.
15:54:47 <clausen> I think it would be hard to write an fs like that
15:54:55 <clausen> that always guarantees a consistant state
15:54:59 <Pseudonym> dark: Exactly.  You commit to NVRAM, the disk writes it out in whatever order it likes.
15:55:19 <clausen> eg: writing to the end of a file
15:55:19 <Pseudonym> If there's a crash, there's always the NVRAM-backed copy.
15:55:36 <Pseudonym> clausen: I don't see why.  You write the data first, then update the metadata.
15:55:41 <clausen> Pseudonym: yeah, but how do you know which copy you want?
15:55:44 <clausen> (which "snapshot")
15:55:54 <clausen> since not all of the snapshots will be self-consistent
15:56:04 <Pseudonym> What consistency model are you after?
15:56:12 <clausen> Pseudonym: some operations need to write more than one metadata block
15:56:14 <clausen> (eg: tree balancing)
15:56:22 <Pseudonym> Filesystems don't do consistency at the file level, only at the filesystem level..
15:56:32 <clausen> Pseudonym: ideally, fwrite() consistency, but lets start with fsck-consistency
15:56:52 <clausen> Pseudonym: my plans would do it at the file level also :)
15:57:04 <Pseudonym> For tree balancing, it's hard to get right, but there are plenty of algorithms which do it.
15:57:12 <Pseudonym> In the mid-90s there was a lot of research into this.
15:57:28 <dark> Strange how research has fashions.
15:57:31 <Pseudonym> DEC, for example, sank a lot of money into concurrent B-tree algorithms which use no locks.
15:57:36 <clausen> dark: not strange at all :)
15:57:54 * clausen should read all this stuff
15:58:08 <Pseudonym> Another option is that the writes should be atomic at the _block_ level.
15:58:20 <Pseudonym> You can fit a lot of related metadata into a single disk block.
15:58:50 <clausen> what do you mean, "atomic at the block level" ?
15:59:06 <Pseudonym> For example, you can fit quite a few internal binary tree nodes into one 512 byte disk block.
15:59:13 <clausen> bread/bwrite being atomic?
15:59:15 * clausen thought they were
15:59:19 <Pseudonym> Yes.
15:59:23 <Pseudonym> I'm talking at the disk level.
15:59:28 * clausen too
15:59:35 <Pseudonym> In my hypothetical journalling disk.
15:59:50 <clausen> I thought HDDs already guaranteed that
15:59:56 * clausen should check
15:59:56 <Pseudonym> Yes, they do.
16:00:00 <Pseudonym> I think.
16:00:11 <Pseudonym> Unless the power goes off in the middle of data transfer, I guess.
16:00:20 <clausen> well, I thought they had techniques for dealing with thtat
16:00:22 <dark> I think modern disks will finish the block.
16:00:26 <Pseudonym> Right,.
16:00:31 <Pseudonym> Tht would make sense.
16:00:33 <clausen> like, they have to have batteries to park the heads safely, etc.
16:00:39 <clausen> so, finishing the write should be easy enough
16:00:43 <clausen> I always just assumed that, hehe
16:00:48 <Pseudonym> :-)
16:00:52 <dark> Probably capacitors instead of batteries :)
16:00:53 <Pseudonym> They act like they do, anyway.
16:01:23 <clausen> HDD manufacturers don't write about their disks
16:01:25 <Pseudonym> Yes, all you need is enough charge and flywheel momentum to keep the disk rotating at the same speed until the block is finished.
16:01:26 <clausen> it's such a PITA
16:01:54 <Pseudonym> Anyway.
16:02:24 <Pseudonym> My point is that you can do a rotation on a binary tree (say) by ensuring that all the participating nodes are on the same block.
16:02:29 <Pseudonym> And just atomically write the block.
16:03:10 <clausen> I guess so
16:03:36 <Pseudonym> I'm completely guessing here.
16:03:50 <Pseudonym> This is not a well thought out idea, as I've only had this idea for about ten minutes.
16:03:51 <clausen> can you guarantee that?
16:03:59 <Pseudonym> Probably.
16:04:01 <clausen> like, what about inter-block rotations?
16:04:10 <Pseudonym> You may need to issue a commit to play with blocks first.
16:04:35 <clausen> in any case, it sounds tricky designing a file system that always keeps the fs consistent
16:04:42 <clausen> although, bsd has this thing called soft-updates
16:04:51 <clausen> I think it's a partial attempt at this
16:04:54 * clausen should read up on it
16:05:05 <Pseudonym> I think the strength of this idea is that you should in principle to be able to issue commits in any order without using up lots of seek times.
16:05:23 <Pseudonym> Whether that outweighs the problems it causes is another question.
16:05:24 <clausen> http://www.usenix.org/publications/library/proceedings/usenix99/mckusick.html
16:05:44 <clausen> Pseudonym: another big win is snapshots
16:06:15 <clausen> also, this type of file system is easy to resize in-place, etc.
16:06:15 <Pseudonym> True.
16:06:30 <clausen> (maybe that isn't so important, just I'm obsessed with file system resizing...
16:06:39 <clausen> ... I maintain GNU Parted, hehe)
16:06:39 <Pseudonym> :-)
16:06:47 <dark> Easy to make larger, but how do you make it smaller?
16:06:48 <Pseudonym> Ah, that explains a lot.
16:06:56 <Pseudonym> :-)
16:07:03 <clausen> dark: it's easy to move files around
16:07:17 <Pseudonym> You would also have to shrink the metadata, I think.
16:07:20 <clausen> dark: just make another snapshot, etc.
16:07:29 <Pseudonym> A smaller file system needs a smaller number of inodes, for example.
16:07:39 <clausen> I wouldn't statically allocate inodes
16:07:48 <clausen> it doesn't work with snapshots, anyway
16:07:58 <clausen> I'd store inodes in an rb-tree
16:08:02 <Pseudonym> Oh, I was thinking of existing filesystems, not a hypothetical new (better) one.
16:08:06 <clausen> (or a b+ tree)
16:08:16 <clausen> ah
16:08:24 <Pseudonym> I was thinking of parted.
16:08:29 <clausen> I should write a rant/paper on how parted works
16:08:40 <clausen> there are a few different techniques...
16:08:46 <clausen> there are a few tradeoffs
16:08:54 <clausen> incremental vs reconstructive
16:09:07 <clausen> if you're reconstructive, you can resize-the-start
16:09:14 <clausen> also, a perverse technique:
16:09:19 <clausen> members.optusnet.com.au/clausen/ideas/convertfs.txt
16:09:27 <clausen> (very cool!)
16:10:04 <clausen> (not my idea, btw)
16:10:07 <whee> time for my stupid question of the day: does HOpenGL come with functions dealing with vector calculations? (perhaps even a vector type class)
16:10:57 <Pseudonym> Oh, that is cool.
16:12:11 <clausen> Crazy Russians TM :)
16:12:32 <Pseudonym> It reminds me of the Solaris swap system only more so.
16:13:07 <clausen> how's that work?
16:13:14 <Pseudonym> whee: Don't know, BTW.  I suggest you either look at the manual (if it's haddockised) or start recursively looking at the source tree/hi files.
16:13:23 <Pseudonym> Assuming nobody else answers, that is.
16:13:41 <Pseudonym> clausen: Under BSD, every process was backed up by swap space.
16:13:53 <Pseudonym> So you needed at least as much swap as you had physical memory.
16:14:06 <clausen> odd
16:14:17 <Pseudonym> It simplified a whole lot of things.
16:14:31 <Pseudonym> And it made sense in an age when machines had not much RAM.
16:14:34 <clausen> I can believe that
16:14:40 <Pseudonym> Solaris introduced a new filesystem, swapfs.
16:14:45 <Pseudonym> It's a real filesystem.
16:14:55 <Pseudonym> Only it's the union of physical memory and swap space.
16:15:32 <Pseudonym> Demand paging reduces to moving data around in the filesystem.
16:15:57 <Pseudonym> Of course it's implemented a bit more efficiently than that.
16:16:02 <clausen> hehe
16:16:12 <Pseudonym> But it also means that every used page in memory is part of a filesystem.
16:16:24 <Pseudonym> It has a vnode (virtual inode) and an offset for some file.
16:16:48 <clausen> btw, is there any difference between vnodes and inodes?
16:16:53 <clausen> I've never seen them used together
16:16:56 <clausen> so I assumed they were the same
16:16:59 <Pseudonym> A vnode is a virtual inode.
16:17:08 <Pseudonym> Inodes have different structures depending on the filesystem.
16:17:14 <clausen> ah
16:17:17 <Pseudonym> A vnode is the "superclass" of all inodes, if you like.
16:17:22 <clausen> abstract class
16:17:25 <Pseudonym> Right.
16:17:37 <clausen> (doesn't seem worth the different name, IMHO, hehe)
16:17:47 <Pseudonym> Well it's the name of a C struct.
16:17:52 <clausen> yep
16:18:00 <Pseudonym> As most Unix things are.
16:18:01 <clausen> linux just calls it an inode
16:18:56 <Pseudonym> Right, so it has struct inode, plus a whole bunch of structs like struct inode_ext2, struct inode_procfs and so on.
16:19:05 <clausen> yep
16:19:52 <Pseudonym> Oh, eek.
16:19:55 * Pseudonym just checked the source
16:20:06 <Pseudonym> It's actually a union inside the inode struct.
16:20:12 * Pseudonym hates that
16:20:13 <clausen> they changed it recently
16:20:16 <clausen> everyone did
16:20:18 <Pseudonym> Oh, OK.
16:20:22 * Pseudonym nods
16:20:24 <clausen> it also made gcc generate crap code
16:20:41 <Pseudonym> I guess it made the slab allocator work a bit better.
16:20:43 <Pseudonym> That'd be about it.
16:20:45 <clausen> (imagine trying to do data-flow analysis in that...)
16:20:50 <Pseudonym> Indeed. :-)
16:21:05 <Pseudonym> How do they do it now?
16:21:36 <clausen> I don't remember how it panned out
16:21:47 * clausen takes a look
16:21:55 <Pseudonym> The two most obvious ways are: 1) put a pointer in the inode structure, 2) wrap the fs-independent structure in the fs-dependent structure
16:23:52 <clausen> ah, some bytes on the end
16:23:59 <clausen> so, you malloc how much you need
16:24:01 <Pseudonym> Ah, OK.
16:24:11 <Pseudonym> That's the one way I wouldn't do it.
16:24:13 <Pseudonym> :-)
16:24:22 <clausen> why?
16:24:24 <Pseudonym> I think it's far too "C".
16:24:26 <clausen> it's basically how C++ does it
16:24:32 <clausen> (inheritance)
16:24:35 <Pseudonym> Yes, but C++ hides it.
16:24:58 <Pseudonym> Haskell does most things with pointers, but I don't want to _see_ them.
16:25:11 <clausen> oops, it's a pointer
16:25:16 <Pseudonym> Oh, OK.
16:25:24 <Pseudonym> That makes sense.
16:25:31 <clausen> well, there's no problem in software engineering that can't be solved by adding another layer of indirection
16:25:41 <Pseudonym> :-)
16:25:52 <Pseudonym> Or in C++, by adding another layer of abstraction.
16:27:21 <dark> clausen: I think that phrase should normally be used sarcastically :)  Adding another layer of indirection is often a bad idea.
16:27:33 <clausen> dark: I was using sarcastically
16:27:38 <clausen> (it)
16:27:39 <dark> clausen: okay, just checking :-)
16:27:44 <clausen> ;)
16:28:09 <Pseudonym> Whereas adding another layer of abstraction is ALWAYS a good idea!
16:28:20 <dark> Pseudonym: Erm.
16:28:44 <Pseudonym> Erm indeed.
16:29:21 <dark> That's the kind of reasoning that leads to Swing :-)
16:30:17 <dark> "Let's make a widget system that's a strict subset of all the ones currently in use, and build our own system on top of that".
16:31:45 * clausen wondering if file systems should have a transaction interface
16:31:59 <clausen> getting isolation would be *hard*
16:31:59 <engstad> Do you guys know of any C-like language that has the power of templates (C++), but a saner syntax?
16:32:11 <Pseudonym> Objective C?
16:32:22 <Pseudonym> I'm just guessing on that point.
16:32:24 <lament> "power of templates"?
16:32:36 * lament gasps
16:32:38 <engstad> It has generic functions, maps, algos?
16:32:38 * clausen prefers the power of hindley milner :)
16:32:43 <Pseudonym> Not sure,.
16:32:54 <Pseudonym> Some people like it, anyway,.
16:33:06 <engstad> Hey, HM is fine, but some people actually don't think functional.
16:33:26 <lament> you don't need to think functional to use HM
16:33:39 <lament> also, templates are ugly :P
16:33:42 <engstad> You don't? ;-)
16:34:04 <lament> I don't think you do
16:34:06 <engstad> Yes, that's the point. I wish there was a c-like language without templates, but with map, foldl, etc.
16:34:15 <lament> Why?
16:34:18 <lament> Why c-like?
16:34:36 <engstad> Well, it should be natural for working programmers.
16:34:48 <Pseudonym> engstad: Mercury uses a H-M system, and it's a logic language.
16:34:51 <Pseudonym> Same for Goedel.
16:35:00 <dark> engstad: Sounds like perl to me :)
16:35:04 <clausen> does ocaml count?
16:35:21 <dark> perl doesn't have foldl but it should be easy to implement.
16:35:25 <engstad> No, Ocaml comes close though - it's still not imperative enough.
16:35:40 <engstad> I need the performance of C.
16:35:42 <lament> Working programmers are incapable of learning another language, so they have to use C-like syntax even when it's clearly bad?
16:35:54 <engstad> Yes. Unfortunately.
16:35:59 <lament> engstad: Ocaml does have the performance of C, pretty much - doesn't it?
16:36:04 <engstad> Nope.
16:36:16 <lament> then you're screwed, since no other language even comes close.
16:36:17 <Pseudonym> lament: It depends what you're doing.
16:36:25 <engstad> It's got GC for instance.
16:36:44 <hdaume> engstad: nope?!
16:36:58 <engstad> hdaume: nope
16:37:01 <engstad> ;-)
16:37:11 <hdaume> really?  is it so much worse than c?
16:37:26 <engstad> ocaml is roughly twice to three times slower in my experience.
16:37:27 <lament> engstad: you can't have a language that's both good AND c-like
16:37:35 <engstad> depends on compiler of course.
16:37:36 <lament> it's an oxymoron
16:38:10 <hdaume> engstad: ooooh, then C...but C++ and C# are also roughtly 2 times slower than C, so it's in the same ballpark
16:38:14 <hdaume> s/then/than
16:38:28 <lament> C++ and C# are comparable in speed?
16:39:02 <engstad> Well, C++ _is_ an alternative, because you _can_ code optimized sections quite easily (by de-c++-ing it).
16:39:23 <lament> engstad: Python is also an alternative, because you can write C-modules for it
16:39:23 <dark> There's Cyclone, but I haven't looked at it yet.
16:39:43 <engstad> C++ templates though are horrid.
16:39:49 <lament> s/Python/your scripting language of choice
16:41:10 <lament> engstad: http://c2.com/cgi/wiki?AlternateHardAndSoftLayers
16:41:39 <Pseudonym> engstad: I think that C++ templates are a locally optimal point.
16:41:50 <Pseudonym> Certainly not globally optimal.
16:42:14 <Pseudonym> I see compile-time execution as becoming more and more important in decades to come.
16:42:36 <lament> I.e. people will reinvent forth? :)
16:42:59 * Pseudonym laughs
16:43:03 <engstad> lament: Common lisp.. ;-)
16:43:06 <Pseudonym> No, people will reinvent Lisp macros.
16:43:27 <lament> engstad: Or HM
16:44:02 <Pseudonym> Preprocessing systems (e.g. template haskell) are another such model, but I suspect the problem there is they're hard to combine.
16:44:06 <engstad> lament: I think lispers will have to respect the fact that they will never be main-stream. 
16:44:22 <Pseudonym> I wouldn't like to write code which involves TH and Stafunski and, say, Happy.
16:44:40 <lament> preprocessing is bad, imho
16:44:51 * Pseudonym tends to agree
16:45:03 <Pseudonym> A decent compile-time execution system removes the need for preprocessing.
16:45:04 <engstad> Hmm, yes, but what else to do?
16:45:13 <lament> things like that should be either a language feature (consistent with the rest of the language), or not at all
16:45:31 <Pseudonym> That's one of the strengths of Lisp macros.
16:45:34 <lament> in lisp and haskell and even forth, it's consistent
16:45:39 <Pseudonym> They're consistent with the rest of the language.
16:45:42 <lament> in C++, not sure :)
16:45:50 <Pseudonym> I don't think they are in Haskell.
16:46:08 <lament> Not macros - HM
16:46:19 <engstad> The _real_ problem with lisp macros is that you _completely_ change the way your "language" works, and you get sub-languages within lisp that is completely unmaintainable.
16:46:27 <Pseudonym> In general, a Haskell template/macro processor has to manipulate someone else's custom syntax.
16:46:59 <Pseudonym> engstad: Kind of like some combinator libraries that we won't mention.
16:47:09 <engstad> Yupp.
16:50:17 <engstad> It's interesting to note that Java and C# are more pragmatical than academic languages.
16:50:53 <engstad> I'm still not buying the OO hype.
16:51:04 <Pseudonym> You're way behind.
16:51:10 <clausen> one thing though...
16:51:13 <Pseudonym> The OO hype is over.  It's patterns hype now.
16:51:26 <clausen> I thought patterns hype was over too
16:51:29 <clausen> hehe
16:51:33 <Pseudonym> No, it's widened.
16:51:35 <engstad> I know... it's really quite silly. It's ebbing out, though.
16:51:41 <clausen> Pseudonym: where?
16:51:47 <Pseudonym> Patterns are way past the GoF.  They're talking about management patterns now.
16:52:01 * clausen read "Design Patterns", and found it unhelpful
16:52:11 <Pseudonym> Really?
16:52:13 <Pseudonym> Interesting.
16:52:14 * clausen phears
16:52:21 <Pseudonym> Most people found it very interesting.
16:52:29 <clausen> I thought it was interesting, just not practical
16:52:38 <clausen> (I mean the whole point is for it to be practical...)
16:52:51 <Pseudonym> Like most technical books, when you reach a certain level, there is maybe a chapter of interesting material, the rest is what Americans call "reruns".
16:53:10 <clausen> anyway, inheritance is a pain in haskell
16:53:25 <engstad> What I miss most in languages is that it is so frickin hard to _do_ anything. The compiler doesn't know anything. I'd like to say - okey, grab data from yahoo and put them in a table.
16:53:30 <clausen> like, is there an easy way to define new types...
16:53:34 <Pseudonym> Well I think many people missed the point of the GoF book.
16:53:38 <clausen> ... and implement type classes easily?
16:53:48 <Pseudonym> People thought if it's not in the book, it's not a design pattern.
16:53:55 <stepcut> is there someway to get sed to operate on a file. Currently i have to do: cat myfile | sed -e 's/one/two/' myfile > myfile.tmp && mv myfile.tmp myfile
16:54:04 <Pseudonym> Especially in the declarative programming community.
16:54:08 <engstad> that's the standard way stepcut.
16:54:39 <stepcut> how lame
16:54:49 <engstad> sed is old.
16:54:49 <Igloo> You have some redundancy in there, though
16:54:55 <stepcut> ?
16:55:02 <Igloo> "sed -e 's/one/two/' myfile" or "cat myfile | sed -e 's/one/two/'"
16:55:04 <engstad> yes, you don't need the cat.
16:55:14 <Pseudonym> sed is quite old.
16:55:30 <Pseudonym> It's designed to be put in a pipe.
16:55:38 <Pseudonym> Which is the Unix Way(tm).
16:55:48 <clausen> with this type-class thing...
16:55:54 <Igloo> perl -pei or similar can do what you want, though
16:55:57 <stepcut> Pseudonym: well, I don't have to use sed, I just want to do some regex search and replace on a few files
16:55:59 <clausen> if you just use type synonyms, it's easy...
16:56:07 <clausen> ... you get everything for free
16:56:10 <engstad> Stepcut: Type this: Computer, replace 'one' with 'two' in myfile.
16:56:10 <clausen> (Ord, Eq, etc.)
16:56:21 <engstad> ;-)
16:56:30 <clausen> but, if you make your own type, you have to implement lots of functions
16:56:38 <clausen> (you can't just "inherit" them)
16:56:43 <Pseudonym> Yes.
16:56:46 <clausen> is this something you have to just live with?
16:56:50 <Pseudonym> Interface inheritance, not implementation inheritance.
16:56:53 <clausen> right
16:57:00 <Pseudonym> Basically, yes.
16:57:05 <Pseudonym> It's a feature.
16:57:12 <clausen> it'd be nice if there was some easy notation to do implementation inheritance
16:57:18 <clausen> I know... zoltan was arguing that
16:57:47 <clausen> it'd be nice if you could use some functor, or something
16:57:55 <Pseudonym> What you gain in return is the ability to inherit your type from a new superclass at will.
16:58:05 <Pseudonym> Without changing the type declaration.
16:58:14 <Pseudonym> That is, classes are decoupled from types.
16:58:28 <clausen> basically, what I'm looking for
16:58:37 <Pseudonym> You lose two things, as I see it: Implementation inheritance and interface recovery.
16:58:39 <clausen> is a notation for specifying implementations
16:58:55 * clausen looks for an example piece of code
16:59:35 <clausen> say, this:
16:59:37 <clausen> type Version = [Int]
16:59:43 <Pseudonym> OK.
16:59:48 <clausen> instead, you might write:
16:59:55 <clausen> data Version = Version [Int]
17:00:04 <clausen> and you might want to define your own read and show
17:00:08 <Pseudonym> Yes.
17:00:10 <clausen> which is all very nice
17:00:25 <clausen> so, how do you nicely define Eq and Ord?
17:00:48 <clausen> instance Eq Version where
17:01:20 <clausen>       (Version a) == (Version b) = a == b
17:01:26 <clausen> no better options?
17:01:36 <clausen> it'd be nice if you could just define Functor
17:01:37 <Pseudonym> Not really.
17:01:38 <clausen> and get it for free
17:01:43 <Pseudonym> Hmm.
17:02:03 <Pseudonym> I think it'd be tricky in general.
17:02:21 <Pseudonym> data Foo a = Foo (a -> Int) deriving (Functor)
17:02:34 <clausen> oh, deriving...
17:02:36 * clausen forgot about that
17:02:54 <clausen> can you derive (Eq) ?
17:02:56 * clausen tries it
17:02:59 <dark> I think there's been some work in ghc on making "deriving" more general for newtypes.
17:03:34 <Pseudonym> Yes you can.
17:03:45 <Pseudonym> But for Functor, I think it'd be hard.
17:03:55 <clausen> so, how does deriving work?
17:04:23 <dark> clausen: It's defined in the report, separately for each class that can be derived.
17:04:39 <clausen> so, you can't use it with user-defined type classes?
17:04:52 <Pseudonym> No.
17:05:18 <dark> Nope.  But ghc has some flag that makes it possible to derive any class from a newtype declaration.  (It just unwraps and rewraps the constructor)
17:05:49 <dark> This only works if the base type is already an instance, of course :)
17:08:26 <clausen> anyway, it'd be nice if you could supply your own functor
17:08:36 <clausen> and then let the compiler figure everything else out
17:08:53 <Pseudonym> As I say, I think it'd be hard in general.
17:09:05 <clausen> what's a hard case?
17:09:24 <Pseudonym> data Foo a = Foo (a -> Int)
17:09:30 <Pseudonym> That's a hard case, I think.
17:10:14 <clausen> is it only high-order types that are hard?
17:10:27 <Pseudonym> Well, abstract types, of course.
17:10:49 <clausen> ?
17:10:57 <Pseudonym> module A where
17:11:02 <Pseudonym> type Bar a = a -> Int
17:11:05 <Pseudonym> module B where
17:11:08 <Pseudonym> import A(Bar)
17:11:15 <Pseudonym> data Foo a = Foo (Bar a)
17:11:29 <Pseudonym> Not quite.
17:11:46 <Pseudonym> You need to make Bar a type where the "implementation" is not exported.
17:14:41 <inkedmn> evening friends
17:14:47 <inkedmn> (well, it's evening here :))
17:14:51 <Pseudonym> Afternoon.
17:14:57 <clausen> already?
17:15:04 <Pseudonym> Yes, by about 15 mins.
17:15:07 <inkedmn> Pseudonym: where are you?
17:15:08 <clausen> eek
17:15:10 * clausen has been wasting time
17:15:12 <clausen> hehe
17:15:14 * Pseudonym has too
17:15:17 <Pseudonym> Boss is on holiday.
17:15:22 <clausen> *grin*
17:15:29 <clausen> actually, I've learned a fair bit this morning :)
17:15:53 <inkedmn> are you guys in australia?
17:16:02 <clausen> yep
17:16:03 * inkedmn is trying to figure out who's 5 hours behind him
17:16:05 <inkedmn> cool
17:16:16 <inkedmn> actually, 19 hours ahead then
17:36:20 <inkedmn> what are the boolean values in haskell?
17:36:27 <inkedmn> i tried using true and false, got an error
17:37:00 <dark> True and False.
17:37:11 <inkedmn> ah
17:37:15 <inkedmn> have to be capitalized?
17:37:57 <whee> they're likely type constructors, so yes
17:38:16 <inkedmn> excellent, thanks :)
17:39:01 <neniu> Anyone solved exercise 2.2 of SOE?
17:42:22 <Igloo> Data constructors - Maybe is a type constructor
17:42:30 <whee> ah
17:44:22 * seth is back (gone 16:17:46)
17:55:05 <inkedmn> how would i do a type signature that involves a boolean?
17:55:21 <inkedmn> somefunc :: Char -> Bool ?
17:55:21 <Igloo> Bool
17:55:23 <Igloo> Yup
17:55:24 <inkedmn> ok
17:55:45 <Igloo> :t True in hugs or ghci would tell you it has that type
17:55:54 <inkedmn> ah, cool :)
18:01:04 <inkedmn> ok, soundex works :)
18:01:13 <inkedmn> i just have one more question...
18:01:24 <inkedmn> well, 2 :)
18:01:44 <inkedmn> i have this line:
18:01:45 <inkedmn> soundex s = take 4 ((filter (\c -> c /= '0') (uniquify(mapTail replace s))) ++ "000")
18:01:53 <inkedmn> but it's really long
18:01:56 <inkedmn> and kinda ugly
18:02:14 <inkedmn> so:
18:02:19 <whee> you could ues the function composition operator some
18:02:25 <inkedmn> ok
18:02:42 <dark> (\c -> c /= '0') could be replaced with the section (/= '0')
18:03:20 <inkedmn> ok
18:03:55 <dark> You don't need parens around (filter...replace s)), because the ++ operator already has lower priority than function application.
18:04:18 <Heffalump> better safe than sorry with parens though
18:04:36 <lament> Or with parents
18:04:40 <Heffalump> in general I'd say that that line isn't particularly ugly or long, really
18:04:48 <dark> Parens are evil and should be eliminated at every opportunity :)
18:04:50 * clausen thinks it is
18:05:03 <clausen> I'd be splitting up into different functions
18:05:26 <inkedmn> i've been thinking about that...
18:05:30 <dark> That mapTail replace business, what does it do?
18:06:16 <inkedmn> just like map, except only maps to the tail of a list
18:06:20 <dark> soundex = take 4 . (++ "000") . filter (/= '0') . uniquify . mapTail replace
18:06:24 * Igloo prefers soundex = take 4 . (++ "000") . filter (/= '0') . uniquify . mapTail replace  (if I've got that right)
18:06:34 <Igloo> Heh
18:06:36 <inkedmn> wow, nice
18:06:39 <Heffalump> Igloo appears to enjoy pointless programming.
18:06:46 * dark high5s Igloo.
18:07:04 <dark> Heffalump: Function composition was my goal.  Eliminating the parameter was a happy happenstance :)
18:07:17 <inkedmn> so should i seperate it into different functions?
18:07:27 <inkedmn> or use function composition?
18:07:27 <Heffalump> oh, and dark :-)
18:07:34 <inkedmn> or parts of both?
18:07:34 <Heffalump> inkedmn: I think opinion varies
18:07:40 <inkedmn> Heffalump: agreed
18:07:40 <emu> yes, structure is evil and should be eliminated at every opportunity
18:07:45 <Heffalump> well, mine varies from everyone else's, it would seem :-)
18:07:46 <dark> Bringing the (++ "000") forward that way improves it a lot in my opinion.
18:07:58 <Heffalump> yes, that's true
18:08:02 <inkedmn> ok, let me ask you this
18:08:09 <Heffalump> I think in this case dark/Igloo's version is superior
18:08:13 <inkedmn> how can i split it up into multiple lines?
18:08:15 <emu> only by sorting through complex precedence rules should one be allowed to determine the meaning of an expression
18:08:19 <Heffalump> but in general I dislike gratuitous introduction of composition
18:08:21 <Igloo> Yeah, I originally had that and the take 4 the wrong way round because following it as it is is harder IMO
18:08:38 <emu> s/complex/intricate/
18:08:49 <Heffalump> inkedmn: you can break a definition across multiple lines wherever you like
18:08:57 <inkedmn> oh, ok
18:08:59 <Heffalump> well, at any whitespace
18:09:09 <inkedmn> indentation?
18:09:11 <Heffalump> but make sure continuation lines are indented by more than the thing they are a continuation of
18:09:16 <inkedmn> do they have to be lined up with one another?
18:09:19 <inkedmn> ah
18:09:20 <inkedmn> ok
18:09:22 <Heffalump> so
18:09:28 <Heffalump> soundex = take 4
18:09:42 <Heffalump>            . (++ "000")
18:09:57 <Heffalump>            . filter (/='0')
18:09:58 <Heffalump> etc etc
18:10:05 <inkedmn> gotcha :)
18:10:10 <clausen> isn't ++ "000" around the wrong way?
18:10:29 <Heffalump> not from the original definition inkedmn gave
18:10:37 <clausen> (like, won't "000" be treated as the first, not second argument?)
18:10:37 <Igloo> You can line the .s up below the = there
18:10:48 <Igloo> No
18:10:59 <Igloo> ((++) "000") is what you are thinking of
18:11:18 <clausen> oh, cool :)
18:11:21 <Igloo> (++) "000" is a function application, (++ "000") is a section equivalent to (\x -> x ++ "000")
18:11:53 <Heffalump> igloo: yeah, personally I wouldn't (probably)
18:12:27 <Igloo> But then the functions are lined up. The first one is distinguished in your style
18:12:56 <Igloo> If they were arguments I would line them up under the 4, though
18:13:40 <dark> Another style is:
18:13:43 <dark> soundex =
18:13:45 <dark>   take 4 .
18:13:48 <dark>   (++ "000") .
18:14:09 <dark> This way every line makes it clear that the definition isn't complete yet.
18:14:14 <Heffalump> igloo: true.
18:14:39 <dark> Works better with a more visible operator than .
18:23:22 <inkedmn> anyway, you guys rule, thanks for your help!!!
18:24:00 <dark> If we rule, then why don't we have minions, hm?
18:25:09 <inkedmn> i'll be your minion until i become competant in haskell ;)
18:25:19 <inkedmn> in exchange for instruction/assistance :)
18:29:33 <dark> Wow, my first minion :)  Now I'll need to design a uniform.
18:30:07 <inkedmn> no loincloths, please
18:30:13 <inkedmn> :)
18:30:24 <dark> Obviously it should be one that looks cool, hides the face, provides no protection in combat, and is cheap to make.
18:30:29 <inkedmn> haha
18:30:34 <dark> (Stormtrooper model)
18:30:59 <dark> Though I think stormtroopers failed the "looks cool" test :)
18:31:30 <Igloo> I think we need a committee to design uniforms. We should organise a meeting to set one up.
18:31:48 <dark> Igloo: Can we get started on Haskell 2 in the same meeting?
18:32:33 <Igloo> Hey, I'm already working on it. All I need is for someone to declare what I'm doing to be in it  :-)
18:32:44 <dark> For Haskell minions, I guess it'll be enough to _define_ uniforms, and let the implementation take care of itself.
18:33:14 <dark> Eww, I just realized this means we'll have lazy minions.
18:33:30 * inkedmn is watching football and has no idea why
18:33:48 <dark> inkedmn: You left the TV on?  Bad habit.
18:33:56 <Igloo> Well, we certainly have some lazy rulers
18:36:37 <inkedmn> totally :)
18:38:09 * inkedmn fires up a celebratory smoke
18:40:43 <inkedmn> oh, and anonymous functions kick ass
18:46:16 <Igloo> Cool, i think I have found a libc printf testsuite I may be able to use
18:48:41 * inkedmn is away: stuff
18:59:12 <Pseudonym> Stormtroopers looked cool in 1977.
19:00:10 <dark> Darth Vader looked cool.  Stormtroopers were dorky by comparison.
20:27:00 * inkedmn is back (gone 01:38:18)
20:28:39 <tez> inkedmn: How goes the programming?
20:39:53 <inkedmn> tez: my soundex is done and working :)
20:40:17 <whee> help I think I understand monads
20:40:18 <inkedmn> gonna try something different now, something a bit shorter
20:40:22 <whee> :(
20:40:33 * whee waits for hell to freeze ovedr
20:40:48 <dark> A lot of hell is already frozen over, if you believe Dante.
20:41:20 <whee> heh
20:41:47 <whee> I'm still dreading a port of one of my programs, still unsure as to how to do parsing work :\
20:42:11 <seth> whee:  happy
20:42:21 <dark> I'm thinking of making a game called Warlords of Hell.  The idea is to recruit legions of sinners (lawyers, tax collectors, etc) in order to establish dominion over a corner of hell.
20:42:23 <inkedmn> is there a way to tell if a char is a digit?
20:42:23 <seth> whee:  or parsec
20:42:43 <inkedmn> s/way/lib
20:42:51 <whee> I think I'll try parsec again, I have no idea how to approach lexing with happy
20:42:52 <inkedmn> or function, whatever
20:42:55 <dark> inkedmn: isDigit in Data.Char
20:43:22 <seth> whee:  Were you on the other day when a lexer for happy was discussed?
20:43:29 <whee> yes
20:43:59 <whee> I'd rather not use alex until it's a bit more finalized or whatnot
20:44:05 <whee> plus parsec does look interesting
20:45:43 <inkedmn> does haskell have a "mapPartial" function?
20:45:58 <inkedmn> i guess i could just use a filter...
20:46:00 <whee> inkedmn: which would do what?
20:46:15 <inkedmn> nevermind, i was talking out o' my butt :)
20:47:04 <whee> heh
20:47:46 <inkedmn> can i access Data.Char.isDigit from within hugs?
20:48:05 <inkedmn> if so, how? ;)
20:51:38 <whee> what the
20:51:51 <whee> these example parsec parsers are making sense to me too
20:53:38 <seth> whee:  Parsec is interesting.  I've used happy a bit more but only because I'm used to lex/yacc.  I think I'll use parsec after I've had time to learn it well.
20:53:56 <whee> it looks almost like yacc, except not
20:55:48 <Pseudonym> One of these days, someone should make happy accept nondeterministic grammars.
20:56:53 <seth> whee: happy looks very much like yacc.  parsec is significantly different; the resemblance is superficial.
20:56:54 <inkedmn> is it possible get the Char.isDigit function in hugs?
20:57:53 <whee> seth: it looks almost the same to me; you just specify how to handle parsing each element and then eventually it all traces back to one thing that puts it all together
20:59:10 <seth> whee: Sure, at that level, but it isn't driven by a BNF grammar the way Happy is.
20:59:19 <Pseudonym> Happy parsers never backtrack.
21:01:12 <whee> tomorrow I think I'll try writing a parser and port this program over
21:01:29 <whee> I have a feeling the actual logic is going to end up being half the size and tons easier to write :|
21:03:25 <whee> also hoping I can be a jerk and make it depend on some ghc feature :)
21:04:39 <seth> Pseudonym: Don't they occasionally backtrack one terminal?  BNF parsers generally need to be able to backtrack a single terminal.
21:05:58 <inkedmn> is there such a thing as casting in haskell?
21:06:05 <inkedmn> like, casting a char as an int?
21:06:15 <inkedmn> or even changing the type entirely?
21:07:03 <whee> there's Char.ord for Char -> Int and Char.chr for Int -> Char
21:07:18 <seth> inkedmn: No.  That can never be statically type checked.
21:10:19 <whee> oh, I remember the question I wanted to ask a while ago
21:10:56 <whee> you can only deal with one monad at a time in a function, right? (>>= and return all deal with whatever monad the function accepts)
21:15:23 <seth> whee:  Well, you could deal with more than one but unless you have a good reason I wouldn't.  :)
21:15:43 <whee> right, that's where all those fun monad transformers that I don't quite understand come in
21:15:46 <whee> heh
21:17:39 <seth> whee: I was thinking more simple, you could always make an aggregate (a tuple, for example) with more than one monad in it, and pass the tuple to a function.
21:18:24 <whee> I don't understand how that would work
21:21:24 <seth> I'm not sure I can think of a case where you would want to do it.  But, in Haskell, you can always make a tuple type, such as (x, y, z), and I was saying that there is no reason that x and y and z couldn't all be monads.
21:21:50 <whee> right, but to actually do anything with them wouldn't you have to split them up and pass them to a function that handled a specific one?
21:34:06 <whee> heh I think I'm just making things more confusing
21:35:00 <whee> I meant to say that given a function that accepts two monads in a tuple, there's no way it could actually, say, print  a value (if one were IO); unless it went and gave that IO monad to a function that could
21:42:39 <seth> whee: As I said, one monad is confusing enough for me.  :)  My point was just that there is nothing in the language limiting you to one monad.
21:42:51 <whee> heh
22:13:43 <inkedmn> g'night
22:15:41 * shapr awakens
22:17:42 <shapr> hi cmoline
22:17:52 <cmoline> hey shapr
22:18:13 <shapr> it's 7:17 am here. good morning!
22:18:32 <cmoline> only 11:22 pm here. good evening!
22:18:59 <shapr> you're on the west coast of north america?
22:19:15 <cmoline> yep. alberta canada
22:20:44 <shapr> so, what do you do with Haskell?
22:21:06 <cmoline> my city time app on my palm tells me you might be somewhere in europe or africa. close?
22:21:18 <cmoline> right now i am making a burgerspace clone
22:21:26 <shapr> that's correct, I'm in Northern Sweden.
22:21:31 <shapr> oh, neat
22:21:42 <shapr> are you using HOpenGL? or SOE?
22:22:51 <cmoline> i am thinking of doing hopengl but i cant figure out how to pass my game enviroment around without using iorefs. so i might use hgl instead
22:25:26 <shapr> I'd like to write crack-attack
22:25:38 <shapr> I was thinking of using Curses
22:28:10 <cmoline> why curses?
22:28:42 <cmoline> so you can play without x?
22:28:45 <shapr> right
22:29:40 <cmoline> ive never heard of crack-attack before. i am going to try it out
22:29:51 <cmoline> it looks like fun
22:29:58 <shapr> it is :-)
22:30:00 <cmoline> not cheesy like burgerspace :)
22:30:00 <shapr> warning, it's way addictive
22:30:22 <shapr> burgerspace was the game where you grabbed different pieces of a burger while avoiding vicious spices, right?
22:30:28 <shapr> if that's it, I enjoyed that game.
22:30:39 <cmoline> not quite
22:31:10 * shapr google for burgerspace
22:31:35 <cmoline> you run around squishing burger ingredients through floors to make burgers while avoiding hotdogs eggs and onions that are coming after you
22:32:08 <shapr> aha
22:32:18 <cmoline> cheesy but kind of fun
22:32:20 <shapr> yah, burgerspace is a clone of the original BurgerTime
22:32:25 <shapr> hah, cheesy it is =)
22:32:54 <shapr> I played BurgerTime in the arcades
22:33:19 <cmoline> i figured itd make a good learning project since the implementation is fairly simple
22:33:35 <shapr> I thought crack-attack would be a weekend project...
22:38:23 <Pseudonym> shapr: G'day.
22:44:49 <shapr> g'day!
22:44:52 <shapr> how are ya?
22:45:22 <Pseudonym> Not bad.  Hot.
22:45:39 <shapr> I'd love to visit.
22:45:48 <shapr> -18C yesterday
22:46:00 <Pseudonym> +34C here
22:46:07 <Pseudonym> Which is not _very_ hot.
22:46:10 <shapr> nice
22:46:21 <Pseudonym> 21C is optimal for me.
22:48:40 <shapr> I'm fine with anything above freezing.
22:49:37 <Pseudonym> Well you'd be happy here.
22:49:42 <Pseudonym> Never gets below freezing.
22:49:47 <shapr> sounds nice
22:49:50 <Pseudonym> In fact, I think about 7C is the absolute minimum.
22:49:57 <Pseudonym> And when it's hot, it's hever humid.
22:49:59 <shapr> which city are you in?
22:50:03 <shapr> sydney?
22:50:07 <Pseudonym> Melbourne.
22:50:09 <shapr> ah
22:50:18 <Pseudonym> It gets humid in Sydney.
22:50:25 <shapr> I'd like to visit .au
22:50:28 <Pseudonym> I have to go home, but thought for the day:
22:50:39 <Pseudonym> Why is it that drug companies sound like designer drugs?
22:50:44 <shapr> hmm
22:50:44 <Pseudonym> Hey man, wanna score some GSK?
22:50:48 <shapr> heh
22:50:57 <Pseudonym> Like a good time?  Try some pfizers!
22:51:11 <shapr> that's an interesting poing
22:51:14 <shapr> point
22:51:14 <Pseudonym> Like, man, I was coming down of quintiles...
22:51:28 <Pseudonym> There you go.
22:51:30 <Pseudonym> Farewell all.
22:51:35 <shapr> cya!
22:55:25 <shapr> http://citeseer.nj.nec.com/Programming/Functional/
22:57:10 <cmoline> whats the link for? i got a timeout
22:59:27 <shapr> citeseer is a collection of academic papers
22:59:39 <shapr> I've just discovered that they have a section on Functional Programming
23:03:42 <shapr> cmoline: how far have you gotten in BurgerSpace?
23:08:07 <cmoline> not very
23:08:25 <cmoline> or do you mean playing?
23:08:37 <shapr> coding :-)
23:08:51 <shapr> have you used Haskell lots before?
23:09:29 <cmoline> no ive only been learning for...hmm i dont really remember. call it a couple months
23:09:59 <shapr> what do you think so far?
23:10:28 <cmoline> a bit cumbersome in places but overall i love it
23:11:18 <cmoline> for instance not having variable arguments has been kind of a pain but ive adapted
23:12:07 <cmoline> i would say ive become a functional fanatic though :)
23:12:13 <shapr> me too :-)
23:12:22 <shapr> I wish I could write all of my code in Haskell.
23:13:34 <cmoline> still have a lot to learn. i would not call myself a master of monads
23:13:54 <shapr> I'm barely a novice of monads
23:14:19 <cmoline> or foldr. i keep seeing foldr patterns but they turn out not to be
23:14:32 <shapr> ah foldr I've got a handle on
23:14:36 <shapr> map, fold, etc
23:14:45 <shapr> those are my favorite parts
23:15:07 <shapr> sometimes my code is a stack of map $ foldr $ etc etc and then a tiny bit of code
23:16:30 <shapr> I'd love to trade :-)
23:16:36 <shapr> I just can't seem to get my head around monads
23:17:57 <cmoline> yeah i know eh. i get to a moment where i think aha i get this and then something i dont understand happens :)
23:20:23 <cmoline> i love the way my code just keeps getting shorter
23:20:27 <shapr> yah, same here
23:20:56 <shapr> I feel like a Jedi or something, seeing the deeper patterns in my code and abstracting them out
23:21:10 <cmoline> yep
23:21:12 <shapr> "yes, my young padawan, partial application is a powerful tool"
23:21:21 <shapr> "but be wary of the imperative side of programming"
23:21:23 * shapr laughs
23:21:56 <cmoline> heh. "use the monad, shapr"
23:22:05 * shapr falls over laughing
23:25:28 <cmoline> darn. i dont feel like a jedi any more. i just papercutted my nose
23:25:42 * shapr grins
23:26:12 <shapr> I'd have to get my hair cut shorter to be a jedi
23:26:35 <shapr> otherwise I'd end up trimming it with my own lightsaber accidentally
23:27:20 <shapr> I've often wondered how Anakin can keep that long tiny braid while using a lightsaber all the time.
23:28:02 <cmoline> perhaps he uses the force to hold it out of way?
23:28:08 <shapr> heh
23:28:11 <shapr> probably so
23:28:34 <cmoline> id prolly cut off an arm or something
23:29:25 <shapr> I bed a tiny lightsaber would be great for electronics work
23:29:31 <shapr> melt some solder just right
23:31:40 <cmoline> have you tried mercury? i am compiling it just now. it will be my first logic programming language
23:32:17 <shapr> I've looked at it, but I'm waiting till I'm fluent in Haskell before I go for the logic paradigm
23:33:09 <cmoline> thats what i tried to do :) i cant resist learning new languages especially if they are unusual in some way :)
23:33:35 <cmoline> how long have you been using haskell?
23:33:43 <emu> intercal..
23:34:13 <cmoline> yeah. obfuscated languages are cool. i just had a look a befunge earlier
23:34:14 <shapr> cmoline: oh, have you tried Joy?
23:34:31 <shapr> I've been using Haskell for more than a year
23:34:38 <cmoline> not really. it looks cool though
23:34:49 * shapr really likes Joy
23:34:53 <lament> cmoline: if you like esoteric languages, join #esoteric
23:35:31 <shapr> hi Radek
23:35:38 * emu is planning on going on a language cruise sometime soon
23:35:44 <emu> =)
23:35:59 <emu> haskell is one of my starting points
23:36:43 <Radek> hi
23:36:46 <lament> i'm on a language cruise
23:36:55 <shapr> Radek: are you a Haskell user? or just learning?
23:37:07 <lament> I'm trying to learn about 10 simultaneously... Of course, it doesn't work :)
23:37:11 <emu> gotta see how the *real* functional programmers do it
23:37:20 <shapr> it's hard to learn 10 at the same time.
23:37:27 <Radek> Learning in free time.
23:37:59 <Radek> The Haskell isn't currently on top of my todo list, but very near.
23:38:06 <cmoline> hard to resist learning 10 at a time :)
23:38:47 <emu> but i must go to sleep now, so i can wake up and take my final on programming languages [really static type theory in functional languages, sigh]
23:38:52 <shapr> g'night
23:39:13 <emu> nd of course someone msgs me just as i say that
