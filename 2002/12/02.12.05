02:57:52 <dark> "Haskell Wiki resurrected"
06:10:18 <shapr> yay
06:10:49 <shapr> and I asked Wansbrough if we could convert to MoinMoin
06:17:09 <shapr> hi Marvin--
06:17:59 <Marvin--> ello
06:18:02 --- topic: set to '["mo' nads than you", "We put the Funk in Funktion", "See logs @ http://tunes.org/~nef/logs/haskell/", "Gtk+HS 0.14.10: http://www.cse.unsw.edu.au/~chak/haskell/gtk/", "HWS-WP: http://www.dum.chalmers.se/~marvin/hws-wp/", "HaskellWiki resurrected", "ANNOUNCE: GHC version 5.04.2 released"]' by shapr
08:13:26 <andersca> hey Marvin--
08:32:19 <hdaume> hi all
08:34:59 <Marvin--> hullo
08:55:01 * shapr bounces
08:55:08 <hdaume> why do you bounce?
08:55:32 <shapr> I'm a hyperactive person.
08:55:36 <hdaume> ah
08:55:36 <shapr> and I'm cheerful.
08:55:45 <shapr> do you bounce?
08:56:19 <jewel> shae walks up to girl at party ...
08:56:26 <jewel> "Hi, I'm Shae. Do you bounce?"
08:56:31 * shapr laughs
08:56:36 <shapr> hi jewel! how was vacation?
08:56:43 <jewel> supercool
08:57:01 <shapr> jewel: by the way, that line does work on women at parties :-P
08:57:03 <jewel> need to travel more
09:05:14 <shapr> travelling is fun
09:13:12 <dark> My associations with "women" and "bounce" don't involve shapr at all :)
09:13:21 <shapr> um, that's good to hear.
09:13:47 <Marvin--> dark: I couldn't agree more
09:13:49 <dark> Sorry, did I come to the conversation an hour late?  That happens sometimes.
10:06:08 <shapr> hi met
10:06:14 <shapr> bonjour, comment ça va?
10:07:04 <met> ca va toujours très bien
10:08:00 <shapr> c'est bien
10:08:24 <shapr> connais tu le logiciel fonctionelle?
10:08:39 <met> non, pas du tout
10:08:53 <shapr> c'est tres chouette
10:09:15 <met> j'espère apprendre Haskell un jour ;)
10:09:20 <shapr> d'accord!
10:09:30 * shapr looks for a Haskell tutorial in french... ;-)
10:09:34 <shapr> I've seen one somewhere
10:09:43 <shapr> inria.fr uses Haskell
10:09:43 <met> english is just fine
10:11:14 <shapr> hi Radek
10:12:11 <shapr> http://www.inria.fr/rapportsactivite/RA98/lande/fonde_module-7.html
10:12:16 <shapr> hm, that's minorly related
10:14:03 <shapr> http://c2.com/cgi-bin/wiki?AdvantagesOfFp
10:14:15 <ChoJin> inria uses more ocaml than haskell i guess :)
10:14:28 <shapr> http://c2.com/cgi-bin/wiki?HaskellLanguage
10:15:21 <shapr> ChoJin: d'accord
10:19:53 <RadekH> shapr: hello
10:19:58 <shapr> hi RadekH
10:20:03 <shapr> how are you?
10:20:27 <RadekH> I'm a little bit tired, but well.
10:20:59 <shapr> are you learning Haskell?
10:21:16 <RadekH> it is a long time since I was playing with Haskell.  Is there som other text like Two Dozen Lesson in Haskell?
10:21:50 <shapr> there are some online tutorials
10:22:22 <RadekH> Tutorial isn't what I'm looking for.  Do you know that book?
10:23:21 <shapr> I downloaded that text at some point.
10:24:18 <shapr> are you looking for that book again? or something else?
10:24:43 <RadekH> There is a barrier for me to play with Haskell.  I have to know too much to make some interesting.  I try the web server written in haskell but was not succesfull.
10:25:38 <RadekH> Yes that book is great.  I'm looking for similar book.
10:25:46 <shapr> there's a new version of the Haskell web server
10:25:52 <shapr> its url is in the topic
10:27:39 <ChoJin> what I found boring with haskell is the lack of enough library
10:27:56 <ChoJin> like effecient monad library (for array and other stuff)
10:29:10 <shapr> I'd like to have more everyday libraries
10:31:49 <ChoJin> I use ocaml now for this reason
10:31:58 <ChoJin> the code is efficient, a lot of library
10:32:26 <ChoJin> but some feature from haskell is lacking, like overloading, the "where" construct, the list concision
10:33:30 <RadekH> bye, I'm running home.
10:40:55 <shapr> ChoJin: Haskell has "where"
10:41:03 <shapr> ohh
10:41:03 <shapr> duh
10:41:11 <shapr> you mean it's not in OCaml
10:41:22 <shapr> yah, OCaml is faster, but Haskell is more flexible.
10:44:30 <shapr> truly, Haskell needs more libraries.
10:46:10 <hdaume> shapr: like what?
10:46:34 * Heffalump wants ImageMagick bindings
10:49:33 <hdaume> what's that?
10:50:42 <Heffalump> a general purpose image manipulation library
10:50:57 <ChoJin> :p
14:55:59 <Pseudonym> All hail the returned wiki!
14:56:15 <whee> it works now?
14:56:24 <Pseudonym> Apparently.
14:56:30 <whee> indeed it does
14:56:31 * whee dances
14:57:50 <hdaume> :)
15:07:51 <Pseudonym> There goes my productivity for the day.
15:10:29 <whee> what is this productivity that you speak of
15:11:38 <dark> I think "productivity" is part of some make-money-fast plan.
15:12:12 <dark> The theory is that there are people who will give you money after some amount of "productivity".  I tried it but it doesn't really work.
15:12:20 <whee> Oh.
15:12:24 * whee pops a penis enhancement pill
15:14:56 * Pseudonym pops a breast enlargement pill
15:15:26 <lament> XP - eXtreme Penis enlargement! Rapid Penis Development!
15:15:57 <Pseudonym> Oh, something really funny: http://www.xpexaggerated.com/
15:16:23 <whee> I'm glad I don't use Windows eXtreme Penis.
15:16:36 <whee> :|
15:27:30 <dark> One of windows xp's greatest crimes is stealing the Extreme Programming abbreviation.
15:33:08 * Pseudonym agrees
15:33:16 <Pseudonym> But the noughties is brought to you by the letter X.
15:33:28 <Pseudonym> Like how the nineties were brought to you by the letters E and i.
15:33:43 <Pseudonym> So expect more of this.
15:34:31 <lament> Xtreme C#!
15:34:46 <dark> I'm still getting used to being in a new century.
15:35:25 <dark> I'm curious if historians really will refer to "the 20th century war", as one science fiction novel predicts :)
15:35:32 <Pseudonym> If it were 1997 again, it would be eWindows or iWindows.
15:35:40 <Pseudonym> But it's post-2001, so it's XP.
15:35:46 <lament> don't forget
15:35:52 <lament> Visual X++
15:35:55 <lament> Professional Edition
15:36:00 <Pseudonym> Actually, I'm kinda sorry they dropped their previous naming scheme.
15:36:02 <Pseudonym> CE ME NT
15:36:08 <dark> When it _was_ 1997, it was Windows 98.  And then they came up with Windows ME.
15:36:24 <dark> I always thought "wince" a particularly apt description.
15:36:31 <Pseudonym> Windows CEMENT: We take the Soft out of Microsoft.
15:37:12 <lament> win98se.cx
15:37:29 * Pseudonym laughs
15:41:07 <lament> I like how they take money for not removing features from software.
15:41:14 <lament> (professional vs. home edition)
15:41:26 <lament> of course it makes sound economical sense
15:45:51 <dark> It's somewhat similar to how airlines make money.
15:46:15 <dark> Though what airlines have is probably what Scott Adams called a "confusopoly".
15:46:34 <dark> That's where people pay extra just because wading through all of the regulations and exceptions is too much work.
15:47:09 <lament> hm, traveling first class does require the airline spending extra money on you
15:47:38 <dark> I've been in planes where there was an A4 sign with "business class" on it taped to one of the seats.
15:48:14 <dark> Still, the guy in business class got a stewardess all to himself, so I guess he got something.  My friend and I had to share one.
15:48:49 <dark> I think that flight was an example of how airlines do not make money :-)
15:50:01 <Pseudonym> On long flights it makes a real difference.
15:50:08 <Pseudonym> 14 hours in economy ain't fun.
15:50:18 <Pseudonym> Not that I've ever tried 14 hours in business class.
15:50:25 <lament> 14 hours in a seat ain't fun
15:50:31 <Pseudonym> True.
15:51:13 <lament> anyway, airlines are justified.
15:51:17 <lament> microsoft isn't.
15:51:44 <lament> hm
15:51:54 <lament> actually that doesn't make any sense, either
15:52:02 <lament> so nevermind.
15:52:05 <Pseudonym> Microsoft is bad even when it's good.
15:52:08 <dark> Airline pricing does not make sense at all :)
15:52:11 <Pseudonym> It's just one of those things.
15:52:43 <Pseudonym> I'm reminded of a line from "Sleepless in Seattle", when one of the kids asks the other how much it is to fly to New York.  "Nobody knows.  It changes practically every day!"
15:52:52 <dark> I haven't yet seen a justification for why a single ticket would be more expensive than a return ticket, for the same flight.  And I have run into that situation.
15:58:30 * dark reads about the editor-deprived people on haskell-cafe.
15:58:49 <Pseudonym> Yeah, I know.
15:59:03 <Pseudonym> A text editor is the most fundamental tool of a programmer.  If you don't know how to use it properly...
15:59:26 <lament> too bad all currently existing editors suck
16:00:07 <Pseudonym> That's true, but most editors at the moment are sufficiently customisable that the suckage can be reduced to the point where you can get a lot of work done.
16:00:17 <dark> They're committing not one but two abominations: tab stops at other than the divinely mandated 8, and indentation with mixed tabs and spaces.  And then they expect the language to cope.
16:00:50 <lament> actually that's just one abomination
16:00:55 <lament> use of tabs :)
16:01:08 <dark> Nothing wrong with tabs, as long as you leave their length alone :-)
16:01:21 <lament> 8 is too big for most things
16:01:26 <dark> And I appreciate the "one indent level is one tab" idea, even if I don't use it.
16:01:49 <Pseudonym> I don't mind tabs, but I don't want to see them.
16:03:32 <lament> I set tabs to be 4 spaces
16:03:36 <lament> (that's 4 actual spaces, not a tab character equal in length to 4 spaces)
16:04:07 <Pseudonym> I set soft tabs to be 2 or 4, hard tabs at 8.
16:04:14 <Pseudonym> So I get a hard tab if I press the tab key enough times.
16:05:24 <Pseudonym> Still, tabs are probably an anachronism.
16:06:21 <Pseudonym> I once got into a heated discussion (it didn't degenerate into a flame war) with Rob Pike on this topic.  He thought fixed-width fonts were an anachronism and would eventually go the way of punched cards.
16:06:48 <lament> heh
16:06:52 <whee> I would hate that
16:06:55 <lament> that's fairly silly
16:07:04 <Pseudonym> Not really.  Not if you have true literate programming.
16:07:12 <whee> it'd be impossible for me to read half of my programs if it weren't for the fact that fixed-width fonts let me align things nicely
16:07:17 <lament> Pseudonym: that's also silly :)
16:07:24 <Pseudonym> :-)
16:07:34 <lament> whee: well, you can still align things with proportional fonts
16:07:49 <whee> not as well though
16:07:56 <Pseudonym> lament: Exactly.  After all, a space is a fixed width, even if it's not fixed to the same size as the other characters.
16:08:14 <Pseudonym> And fixed-width fonts will always be with us in various specialty areas.
16:08:35 <dark> Like digital watches!
16:08:43 <lament> what might go is the reliance on plain-text files
16:08:44 <Pseudonym> Book editors still want manuscripts in fixed width fonts.  Movie producers still want screenplays in fixed width fonts.
16:08:52 <lament> instead of something more structured than that
16:09:14 <dark> More structured than a programming language?
16:09:25 <lament> more structured than a text file
16:09:29 <lament> which is not structured at all
16:09:30 <dark> Haskell programs are not "plain-text files", they are definitely marked up :-)
16:10:10 <lament> the editors treat them as text files
16:10:13 <whee> I don't know, I wouldn't want to force any kind of structure on anyone
16:10:26 <Pseudonym> lament: Syntax highlighting is one counter-example.
16:10:29 <lament> syntax highlighting and folding and other stuff - that's only patches
16:10:33 <Pseudonym> Right.
16:10:42 <lament> it's still character-based
16:10:43 <Pseudonym> Well, on folding, it depends.
16:10:46 <lament> look at Lisp
16:10:48 <Pseudonym> It's hard to fold Haskell code.
16:11:01 <lament> treating a lisp program as a list of characters seems simply stupid
16:11:16 <whee> how else would you edit it :P
16:11:24 <lament> whee: I'm not sure.
16:11:28 <dark> I generally type my identifiers one character at a time :)
16:11:28 <Pseudonym> whee: You meta-program it. :-)
16:11:32 <whee> I mean, my keyboard is a nice matrix of characters
16:11:38 <Pseudonym> dark: I don't.  I use keyword completion.
16:11:39 <whee> so it seems like a good match
16:11:59 <lament> I don't have any actual ideas
16:12:06 <dark> whee: Keyboards are weird, though.
16:12:13 <whee> they're not going anywhere
16:12:23 <lament> however, treating lisp programs as trees could be potentially much better than simply lists of characters
16:12:29 <lament> for one, syntax errors would be impossible
16:12:40 <lament> Of course lisp is only an example, since it's so easy to parse
16:12:57 <dark> emacs keeps track of which parentheses match which.
16:13:05 <lament> that's not quite the same :)
16:13:06 <Pseudonym> Now here's a thought: A structured editor which makes it impossible to make a _type_ error.
16:13:11 <dark> And it can cut & paste whole sexps.
16:13:21 <whee> Psuedonym: you mean a compiler :)
16:13:26 <lament> dark: it still treats the program as nothing more than a list of characters
16:13:26 <dark> I don't think it really matters that it stores a list of characters internally :)
16:13:31 <Heffalump> how would you develop programs?
16:13:40 <whee> a good editor should be able to interact with a compiler and do some sort of incremental compilation
16:13:42 <Pseudonym> whee: No, I mean a tree editor with unification rules.
16:13:43 <Heffalump> editors need to be able to deal with incomplete programs too
16:13:47 <lament> dark: it's possible to have unmatched parens in your program
16:13:50 <whee> so that it would notify you of problems immediately
16:13:52 <dark> lament: I don't think it does.  No more than it treats it as an array of bits, even though that's how the underlying memory is organized.
16:14:10 <lament> dark: no, the point is, the USER can treat it as a list of characters
16:14:30 <Pseudonym> Heffalump: Obviously this isn't the whole story.
16:14:38 <lament> by ignoring syntax highlighting and other such things
16:14:42 <dark> I think that's mostly because users want to.
16:15:02 <Pseudonym> You should be able to make modifications which put it in a non-valid state so long as you make it valid at some point.
16:15:08 <Pseudonym> Like syntax highlighting now.
16:15:42 <lament> dark: also because, it seems, no one tried anything else
16:15:44 <Pseudonym> We have structured XML editors today which work on this principle.
16:15:53 <dark> lament: Oh, it's been tried :)  Just not for very long :)
16:16:01 <dark> lament: I remember such an attempt with Pascal.
16:16:11 <Pseudonym> I liked the idea behind Cogito Ergo Sum.
16:16:14 <dark> lament: It gets very very annoying to have to keep your program syntactically valid at all times while you're writing it.
16:16:24 <Pseudonym> Along with the program, you supply enough information for the system to prove the correctness of your code.
16:16:36 <lament> dark: well, perhaps it can be done in a less fascist way.
16:16:37 <whee> dark: Are you sure you want to insert the character 'e'?
16:16:50 <lament> dark: and of course not all languages are equally suitable for such approach.
16:17:10 <Pseudonym> lament: Imaging doing APL or Forth this way.
16:17:30 <dark> whee: The idea is to provide a set of commands where that simply isn't an option.  Instead, you provide various mutations on the program.  Sometimes you have to type in a new name character by character, for example with the "define a variable" mutation.  But "use a variable" would mean simply picking one from the ones in scope.
16:17:34 <lament> Pseudonym: that would make sense
16:18:10 <dark> The "Refactoring Browser" approach from XP is close to that, but note that it's geared to refactoring and not development.
16:18:19 <Pseudonym> True.
16:18:42 <whee> I'd find it slower to do any kind of development with a style like that
16:18:55 <lament> whee: in currently existing languages perhaps!
16:18:56 <Pseudonym> whee: Yes, but you'd spend less time debugging.
16:19:04 <lament> whee: which are not suited to this style
16:19:06 <Pseudonym> I think that's the general idea.
16:19:20 <dark> Pseudonym: Not sure.  It'll probably be like with a spelling checker.  You get fewer mistakes, but the ones you do make are much harder to find.
16:19:31 <lament> most currently existing languages assume that the user types the program into an editor
16:19:39 <Pseudonym> This is, in fact, a common complaint from Haskell newbies.  You spend a lot of time trying to satisfy the compiler.
16:20:01 <Pseudonym> What you are in fact doing is not satisfying the compiler, but debugging.
16:20:03 <lament> how would a language designed to be used with a structured editor look like?
16:20:05 <dark> lament: Smalltalk might have been an exception.  You still typed individual functions into an editor, but the editor "owned" them much more than is normal today.
16:20:23 <Pseudonym> lament: Ada might be a good choice.
16:20:26 <dark> Pseudonym: Do you refer to layout or to types there?
16:20:31 <Pseudonym> Or Erlang.
16:20:40 <Pseudonym> dark: I mean types, usually.
16:20:42 <lament> Pseudonym: creating a new language should probably be better
16:20:57 <Pseudonym> lament: How about XSLT?  It's not a full language, of course...
16:21:04 <lament> don't know about that...
16:21:09 <dark> Pseudonym: I see that as one of the features of Haskell :)  By the time a program compiles without warnings, it usually also runs correctly.  That's rare in other languages.
16:21:14 <Pseudonym> Right.
16:21:23 <lament> LISP is certainly one language that seems suitable for structured editing 'out of the box'
16:21:28 <Pseudonym> Well with the editor idea we're just taking it one step further.
16:21:43 <dark> Pseudonym: Oh, I missed your second comment and now I see I've been repeating you :)
16:21:51 <Pseudonym> :-)
16:22:25 <Pseudonym> Before we design this system, I suggest we all read Weinberg's "The Psychology of COmputer Programming".
16:22:25 <lament> speaking of Forth, look at colorForth
16:22:35 <dark> Mail me a copy? :-)
16:22:39 * Pseudonym laughs
16:22:44 <lament> although rather primitive, it's an example of treating a program as more than a list of characters
16:23:20 <lament> program is treated (by the editor!) as a list of tokens, each with its own colour.
16:24:30 <dark> Is that like APL?  The program is treated as a list of tokens, each with its own character :-)
16:24:45 <lament> Probably; I don't know APL
16:24:56 <dark> Neither do I, I've just seen examples.
16:25:06 <Pseudonym> Nobody knows APL.
16:25:12 <Pseudonym> Anyone who says they do are lying.
16:25:19 <dark> [1] ->0!=[]<-|[]
16:25:37 <whee> 8]-\-< to you too
16:25:44 <whee> heh
16:25:48 <dark> Apparently this takes a number and prints its absolute value.
16:26:00 <Pseudonym> I suspect APL is actually a joke.  Scott Iverson wrote some code which takes in line noise and produces a random working program.
16:26:08 <dark> whee: Whereas your program approximates the value of pi to pi digits; quite a feat.
16:26:15 <Pseudonym> Sorry, Ken Iverson.
16:26:27 <dark> Pseudonym: I thought that was TECO :)
16:26:29 <lament> dark: certainly not in APL
16:26:33 <lament> since APL doesn't use ASCII
16:26:49 <Pseudonym> (7^sK3^%_=@`
16:26:55 <dark> It uses _more_ than ASCII, I don't think it _refrains_ from ASCII.
16:27:02 <Pseudonym> That's a Haskell compiler.
16:27:17 * clausen remembers being appalled at some presentation for a language called "J"
16:27:30 <dark> Pseudonym: I liked the elegant way you handled disambiguation of instances in the K3^ sequence.
16:27:36 <clausen> the philosophy was: use as many abbreviations as possible
16:27:38 <whee> clausen: how about K?
16:27:51 <clausen> (and combinations of symbols)
16:27:59 <clausen> they had code looking like !$ %@( e) 12
16:27:59 <whee> I think K may be related to J but I can't remember
16:28:09 <Pseudonym> dark: Yes, I thought you'd appreciate that.  And the way it was combined with the sK type checker.
16:28:12 <whee> http://www.kx.com/a/k/readme.txt
16:28:38 <whee> k programs are insanely short, but there's no source or an OS X binary so I'm out of luck :|
16:28:40 <dark> I still recommend at least one dose of Intercal to every programmer.
16:28:50 <dark>                PLEASE WRITE IN :1
16:28:50 <dark>                DO .1 <- '-":1~'#32768/#0'"/#1'~#3
16:28:50 <dark>                DO (1) NEXT
16:29:20 <lament> the unlambda interpreter in intercal has some very cool comments
16:29:21 <clausen> whee: I think gzip + C is shorter :P
16:29:25 <clausen> (and more readable)
16:29:30 <dark> On the basis that once you've written anything in Intercal, you'll never hate another language again :)
16:29:35 <lament>        PLEASE NOTE DIPLOMATIC RELATIONS
16:29:40 <lament> (3101)  DON'T THINK YOU CAN HAVE YOUR CAKE AND EAT IT
16:29:54 <lament>         PLEASE STAND IN LINE FOR TERMINATION
16:30:03 <Pseudonym> Real programmers use: cat - > a.out.gz
16:30:03 <lament>         PLEASE LEARN THE DIFFERENCE BETWEEN APPLYS AND ORANGUTANS
16:30:26 <dark> Pseudonym: I tried that but I always forget whether gzip uses mm-dd or dd-mm date format.
16:30:34 <Pseudonym> I remember a story some time ago about the new DoD language called RAMBOTRAN.
16:30:35 <whee> someone should write a program that scans /dev/urandom until it outputs something that's a valid binary
16:30:50 <lament> whee: bah
16:30:56 <dark> lament: Fortrain is also fertile ground for that.
16:30:57 <lament> whee: do you know about Jot?
16:30:59 <dark> Er, Fortran.
16:31:01 <Pseudonym> You give it minimal orders and it uses its own initiative to do the job.
16:31:03 <whee> lament: nope
16:31:12 <Pseudonym> If it can't, it destroys itself, taking as many other programs as possible with it.
16:31:12 <lament> whee: Any binary number is a valid Jot program
16:31:16 <dark> And Basic had the famous "REMBRANDT WAS A PAINTER"
16:31:45 <Pseudonym> And today, we'll be looking at the "remark" command.  Or, as it's called in Unix, "rm".
16:31:55 <lament> hehe
16:32:14 <dark> Pseudonym: You know, I've never actually watched the Rambo movies :)
16:32:55 <Pseudonym> Me neither.
16:33:14 <dark> Maybe I should.  I might be missing out on an important bit of cultural heritage there.
16:34:27 <whee> what's the easy way to get a random integer (within some range)?
16:34:34 <whee> randomIO and mod that?
16:34:55 <Pseudonym> If you don't need a very random number, yes.
16:35:02 <dark> There was magic for that.
16:35:18 <whee> oh there's randomRIO for ranged, neat
16:40:42 * dark wonders if the properties of StdGen are constant across Haskell versions.
16:44:48 <whee> erm, monads still confuse me
16:45:13 <whee> if I wanted to have a function that returned a random boolean, how would that work?
16:45:39 <whee> I'm not sure how to get the random int away from the IO monad
16:46:22 <Pseudonym> do { b <- randomBool ; do_something_with b }
16:47:36 <whee> so there's no way to get a randomBool that actually returns a boolean and handles the randomRIO monad?
16:48:09 <Pseudonym> Sure there is.  The return type will be IO Bool.
16:48:21 <Pseudonym> That's how you specify a function which handles tne IO monad and returns a Bool.
16:48:48 <whee> geh heh
16:50:57 <whee> I'm still not getting this; randomRIO returns IO a, so do { blah <- randomRIO (1, 10); bloop } gives blah a binding of the integer, right?
16:51:20 <Pseudonym> Right.
16:51:42 <whee> now there's no way to go and return a straight boolean from a function like that?
16:52:05 <Pseudonym> If you mean is there a way to have a function which returns Bool, no.
16:52:13 <whee> or do I need to "return somebool" to get an IO Bool and then handle that with another do
16:52:15 <Pseudonym> It will return IO BOol.
16:52:19 <Pseudonym> Yes.
16:52:23 <whee> okay
16:59:04 <dark> If you really need to, you can pass a generator to a pure function, and work with that.
16:59:44 <dark> "randoms" will give you a lazy list of random values.
16:59:51 <whee> extremely confused still heh
17:01:15 <whee> I mean it's technically impossible to get a function that takes an IO a and returns a then right? :|
17:01:30 <dark> Right.
17:01:39 <whee> double :|
17:01:59 <Heffalump> imagine what the effect of having such a function would be
17:02:29 <Heffalump> something that could do IO could be made into a pure functional value
17:02:32 <whee> I don't know how to get a random boolean without doing something like that
17:02:40 <dark> But what you can do is call an a -> b function from an IO b function, and then move the important code into that.
17:02:42 <whee> otherwise every single function ends up dealing with IO types
17:02:47 <Heffalump> remember your entire program has to be in the IO monad to begin with
17:03:25 <dark> But if you want a different random value each time you call this function, then it either needs to be in IO, or deal with random generators directly.
17:03:38 <dark> (the basic random function is a pure function from a generator to a (value, newgenerator) pair.
17:04:01 <dark> I made a Rand monad that does exactly that :)
17:05:57 <dark> getStdGen :: IO StdGen
17:06:37 <dark> You can use getStdGen to access the generator, and use randoms or randomRs to ask it for a list of random values (but don't use the generator after that).
17:06:45 <dark> You could pass that list to any function you want to do stuff with it.
17:07:34 <whee> derr
17:07:46 <whee> okay, so anything dependent on some outside influence gets an IO type
17:08:03 <dark> Right.
17:08:39 <whee> I'm just not seeing how this doesn't turn into some infectous thing where every function dealing with info ends up being like that
17:09:07 <dark> whee: You can call pure functions from an IO function.  Just not the other way around :)
17:10:08 <dark> Like this:
17:10:11 <dark> factorial :: Integer -> Integer
17:10:11 <dark> factorial n = product [1 .. n]
17:10:11 <dark> main :: IO ()
17:10:11 <dark>   r <- randomR (1, 100)
17:10:11 <dark>   x <- factorial r
17:10:12 <dark>   print x
17:10:19 <dark> Warning, untested code :)
17:10:25 <hdaume> uhm, that's 'let x = fractorial r'
17:10:39 <dark> Oh, right.  I missed my own point :-)
17:10:54 <dark> Or "print (factorial r)" if you're so inclined.
17:11:04 <hdaume> 'main = do' might also help *grin*
17:11:14 <dark> hdaume: I always forget that until the compiler reminds me :)
17:11:17 <whee> okay you can tell me if I'm handling this correctly heh
17:11:32 <dark> I guess I perceive the foo = do part of a straight IO function as redundant.
17:12:01 <whee> I'm using the random things to get a random boolean, which I use in another function to construct a random tree
17:12:18 <whee> so this function that makes the tree must return an IO type, correct?
17:12:41 <dark> Hmm, what do you mean with "construct a random tree"?
17:12:47 <dark> Is that other function going to need more than one random boolean?
17:12:56 <whee> it just recursees and builds a tree
17:13:06 <whee> yes, one boolean per call
17:13:42 <dark> Ah, then there's three main approaches.
17:14:35 <dark> Instead of making it call a function to get one random boolean, you can give it a list of random booleans as a parameter.  The function won't know there's anything special about those booleans, it'll just be a [Bool] -> MyTree function.
17:15:47 <dark> Or, you could give the function a StdGen (random generator from System.Random) and have it use the random :: g -> (a, g) function to get values one by one, and pass the new generator to every recursive call.
17:16:15 <whee> so this is the randoms thing you were saying
17:16:28 <dark> whee: The first approach, yes :)
17:16:46 <dark> The third option is to make the function an IO MyTree, and have it use randomIO.
17:17:03 <whee> which is most efficient and/or easiest?
17:19:21 <dark> I don't know about efficiency.  The first is probably easiest if you need exactly one value per invocation.
17:19:39 <whee> roger, thanks
17:19:54 <dark> If you need a variable number of values, then the third is probably easiest, or you could try a fourth method: writing your function as a "parser" of a stream of random values.
17:38:56 <dark> I haven't programmed anything in two days!
17:38:59 <dark> Where does the time go?
17:39:44 <whee> into confusing the hell out of me :)
17:48:56 <whee> having a hell of a time trying to get a list of random ints, heh
17:51:32 <Riastradh> Can't you just read bytes from /dev/urandom?
17:52:09 <whee> that's no fun :P
17:52:14 <Riastradh> Heh.
17:52:43 <whee> can't figure out how to use randomRs with a random seed
17:57:09 <engstad> I wonder if someone could help me figure out a good name. I have a piece of code that sets up a DMA chain (for later drawing). It essentially is responsible for drawing an object onto the screen, but it isn't actually drawing itself - it's just deciding 
17:57:37 <engstad> how the object is going to be drawn, i.e. which engine to send the different parts to.
17:58:08 <engstad> So what should I call it? A foreground "bucketer"? 
18:01:34 <dark> whee: Look at the type signature.
18:01:43 <dark> whee: randomRs :: RandomGen g => (a,a) -> g -> [a]
18:05:58 <dark> engstand: presenter?
18:06:21 <whee> hbahaha I should just go take a shower and call it a day
18:06:38 <engstad> dark: Hmmm... perhaps I'll call it director (like a movie director).
18:06:41 <whee> I can't even figure out how to do the function that creates the tree either
18:08:08 <dark> Hmm, I made my interface nicer but now it's slower.
18:08:23 <dark> But I can create a gradient with SDL.fill_pixels s (\(x, y) -> SDL.RGB x 0 y)
18:08:31 <whee> neat
18:08:48 <dark> It's about half as fast as the version with an SDL.put_pixel loop :)
18:09:28 <whee> as much as I hate haskell right now I'm glad I started getting into it
18:09:33 <whee> this'll keep me busy forever
18:11:47 <dark> whee: I find that learning Haskell is like learning Go :)
18:11:55 <whee> go is easier :P
18:12:10 <dark> Except that I don't think there are any Haskell programmers who will give take three stones against God.
18:13:28 <dark> s/give take/take/
18:13:30 <whee> gah
18:13:35 <dark> I hate it when I change my mind in the middle of a sentence :)
18:15:27 <whee> this is certaintly odd
18:15:34 <whee> -t :|
18:16:19 <dark> Well, this is unfair.  The ugly iterative version that carts loads of useless data around persists in being twice as fast as the clean and neat functional version.
18:16:56 <whee> given a list of integers how would I use list comprehensions to construct a list of bools where it's True if say x == 1?
18:17:07 <whee> (where x is the next int on the list)
18:17:50 <whee> [ x == 1 | x <- randInts ] ?
18:19:27 <dark> That looks right.  But if you're trying to construct a list of Bool, you can probably get one directly from randoms.
18:19:32 <dark> There's a Random Bool instance.
18:19:49 <dark> Also, map (== 1) randInts would work.
18:20:05 <whee> hrmf. I really don't want a 50/50 chance though so this is probably better
18:22:06 * dark wonders if anyone is really going to care about the difference between 5.5ms and 4ms.
18:23:55 <whee> nuts, this isn't working and I have no clue why.  hate it when that happens
18:24:25 <dark> Does it compile?
18:24:34 <whee> yeah
18:25:02 <whee> my tree making function isn't exactly using random numbers or bools or anything, even though those two lists are correct
18:25:38 <dark> It's too predictable?
18:26:05 <whee> if I want to a function to take a list and seperate it into head/tail, I can blah (x:xs) = ... right?
18:27:10 <dark> Yes.
18:28:50 <whee> http://smaerty.ath.cx/Depth.hs.html okay, what's obviously wrong with mkTree :)
18:29:41 <whee> what's happening is that x is always True, so it's never actually getting new values 
18:29:48 <dark> You're using the same list in both branches.
18:30:20 <dark> Hmm, that's a different error than what you describe :-)
18:31:29 <whee> heh
18:31:53 <whee> both lists are  correct, it just doesn't seem to be using the right head
18:32:57 <dark> Doesn't the boolean list start with True, True, True, ?
18:33:24 <dark> Your "always" might not have gone on for long enough :)  With x from (1, 10) and x /= 1 as the test, you're going to get a lot of Trues.
18:33:47 <whee> right, that's the idea, but there are False values relatively frequently
18:33:56 <whee> and the tree is being created with the same number for each Atom
18:33:59 <dark> But what's obviously wrong with mkTree is that you re-use the tails in both branches of Node.  That means that the tree is going to be identical in all paths.
18:34:19 <whee> identical at the same depth, right?
18:34:24 <dark> Yes.
18:34:29 <whee> that's fine
18:34:33 <whee> they're identical at all depths here
18:34:49 <dark> How could that be?  You just said that you get Atoms :)
18:35:00 <whee> the number avalue tha tis
18:35:36 <dark> Aren't all your Atoms at the same depth?
18:36:06 <whee> hrmph I don't even know what's going on anymore
18:36:52 <whee> the first int on the list in my current case is 72, but all the Atoms have a value of 5
18:36:58 <whee> which I don't even see on the list
18:37:02 <whee> heh
18:37:08 <dark> Well, you also discard an y every time you recurse.
18:37:26 <whee> I was hoping doing that would get me a new int on each recurse
18:37:49 <dark> It does, but you recurse twice and you only get one new int :)
18:38:43 <whee> right, but it just seems odd that every single Atom has the same integer value
18:39:00 <dark> That's because you also recurse to the same depth in each path.
18:39:15 <dark> So all the Atoms are at the same depth, which means they all discarded the same number of ys from the y list.
18:39:38 <whee> hrmf
18:40:01 <dark> There's no easy way to fix this with randoms.
18:40:32 <dark> But you could go route#2, and pass a generator to mkTree, and use "split" on the generator when recursing.
18:41:00 <dark> The randomness properties of the split function have not been fully investigated, though :)
18:41:06 <whee> heh
18:41:42 <whee> I think I'll just find another little thing to play with :)
18:41:50 <whee> trees are boring
18:42:01 <dark> Another approach would be a parser-like construction.  You have the same problem as when parsing text: generating a subtree requires an unknown number of values from the lists, so you need some way of keeping track of how far in the list you are.
18:42:23 <dark> This is just like keeping track of how far in the text you are, when generating a syntax tree for it.
18:42:45 <dark> I've actually used Parsec to make random monsters this way, in a game I'm making :)
18:43:14 <dark> Later I found that it was easier to make a dedicated RandT monad.
18:45:51 <dark> Oh, another approach would be to make a mkTree function that doesn't work top-down so much, but instead creates a linear representation of the tree and then folds it :)
18:46:04 <whee> eh?
18:46:28 <whee> like product some sort of list of constructs and then parses that into a actual tree?
18:46:35 <whee> s/product/produce/
18:46:38 <dark> Yeah.
18:47:00 <dark> There are some nifty ways of representing a tree's structure in a linear way, but I forgot them all.
18:56:56 <dark> Cool, I got the pretty version to be as fast as the ugly version :)
18:57:49 <lament> dark: sexprs
18:57:55 <lament> :)
18:58:21 <dark> My haskell program for a red-blue gradient is now:
18:58:23 <dark> main = do
18:58:24 <dark>   SDL.init_some [SDL.VideoSystem]
18:58:24 <dark>   s <- SDL.set_video_mode 256 256 16 []
18:58:24 <dark>   SDL.fill_pixels s (\x y -> SDL.RGB x 0 y)
18:58:24 <dark>   SDL.flip_screen s
18:58:24 <dark>   SDL.delay 3.0
18:58:26 <dark>   SDL.quit
19:02:38 <dark> I was trying to be smart and giving a list [0 ..] of offsets, to avoid calculating x * w + y every time.  But apparently having two lists was worse than doing extra calculation.
19:41:45 <engstad> SDL as in the gfx library?
22:23:16 <jemfinch> Sorry to be offtopic, but #ocaml isn't doing anything and I'm looking for a quick answer :)  Does anyone here know O'Caml and have an interpreter handy to try some code that should compile, but doesn't for me?
22:29:41 <tez_h> Ugh, I would, but I'm not at my computer that has OCaml installed.
22:30:07 <jemfinch> dang it.
22:30:27 <jemfinch> I've got code here that absolutely should compile, but I'm getting unbound variables instead.
22:30:31 <tez_h> Hang on.  It's my laptop.  I'll turn it on
22:30:56 <jemfinch> that'd be wonderful, thanks :)
22:31:08 <jemfinch> I normally use SML, and I can definitely see why tonight :)
22:31:41 <jemfinch> O'Caml has *no* String folds (neither foldl nor foldr), *no* String.explode or String.implode...it's just crap as far as String manipulation goes.
22:32:36 <tez_h> Oh, well I don't use it much.
22:33:09 <jemfinch> let me know when I can post a link to the code :)
22:33:21 <tez_h> Hang on, it's an old laptop :)
22:33:23 <jemfinch> I'm IRCing through telnet, otherwise I'd just post it into the channel.
22:36:45 <jemfinch> crap, he left!
22:38:07 <tez> Hi
22:38:09 <tez> Right, that took *ages*
22:38:13 <tez> jemfinch: Ok, post that URL now!
22:38:56 <jemfinch> you're back!
22:39:03 <jemfinch> http://caml.inria.fr/archives/200106/msg00350.html
22:39:12 <jemfinch> just the explode definition.
22:39:16 <jemfinch> thanks :)
22:40:49 <tez> Just that short 6-liner?
22:41:40 <jemfinch> yeah, just that.
22:41:50 <jemfinch> I'm getting an unbound variable on loop.
22:41:56 <jemfinch> which is utterly ridiculous.
22:42:17 <jemfinch> (almost as utterly ridiculous as having to define my own explode in the first place)
22:42:25 <tez> Uh, right here's where my OCaml inexperience comes shining through.
22:42:37 <tez> I've put the 6 lines into a file called explode.ml
22:42:46 <tez> Do I need to create an mli to try to compile it?
22:42:56 <tez> do I just invoke ocaml explode.ml?
22:43:00 <jemfinch> no, you shouldn't.
22:43:09 <jemfinch> just ocamlc explode.ml
22:43:37 <tez> Yeah, no errors.
22:43:48 <jemfinch> "ocaml explode.ml" should load the interpreter and load it into it.
22:43:59 <tez> Ok...
22:44:32 <tez> "ocaml explode.ml" didn't do anything.
22:45:00 <jemfinch> thanks for doing that, now I just have to figure out what the heck's wrong my friend's O'Caml installation.
22:45:07 <jemfinch> /me hates remote debugging.
22:45:54 <tez> I tried "ocaml explode.cmo" and got some interactive prompt.
22:46:16 <tez> Would that be useful?
22:48:00 <Pseudonym> Bye everyone.
22:48:51 <jemfinch> not really for my purposes, but thanks.
22:49:32 <jemfinch> if I was using a Real IRC Client, I'd probably ask you to test some more code, but it's not online, and I can't just copy it into the window.
22:49:41 <jemfinch> unless you happen to be on AIM... :D
22:49:59 <tez> Well, I am actually...
22:50:52 <jemfinch> if you don't mind me messaging you the code to try out, I'd love to.  I can message you my screenname if you like.
22:51:09 <tez> Sure.
