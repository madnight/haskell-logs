00:26:06 * shapr dreams of a task managing app using FGL
00:26:55 <Heffalump> I hate mornings
00:27:55 <seth> I'm more egalitarian; I hate the whole day.
00:54:43 * shapr grins
01:53:48 <shapr> hi Marvin--
01:56:36 <Marvin--> morning
01:57:55 <Marvin--> http://193.11.232.159:8080/shortest_path.gif <- someone misunderstood Dijkstra's algorithm
01:58:08 * shapr laughs loudly
01:58:24 <shapr> that's funny
01:59:12 <andersca> haha
02:01:07 <lament> perhaps that IS the shortest path? :)
02:01:25 <shapr> only if you're a pizza delivery boy
02:01:38 <lament> heh
02:02:37 <Marvin--> "Sorry, this won't do, you have accidentally solved the TSP, but you didn't implement Dijkstra's so you've FAILED FAILED FAILED!"
02:02:50 <lament> heh
02:02:54 <shapr> :)
02:03:11 <lament> that certainly deserves the Fields prize.
02:04:08 <shapr> lament: what, take them out into the field and shoot them?
02:04:16 <shapr> it's not *that* bad
02:04:30 <lament> hehe
02:04:40 <Marvin--> haha
02:10:00 <shapr> stupid graph question...
02:10:32 <shapr> I want to make a mrproject like task dependency structure with the FGL in Haskell
02:11:07 <shapr> one of the FGL announcements showed how to do that, but I can't seem to find it now
02:11:15 <Marvin--> FGL?
02:11:38 <shapr> http://cs.oregonstate.edu/~erwig/fgl/haskell/
02:12:08 * shapr suddenly notices that the example is ON THAT PAGE.
02:12:10 * shapr duhs
02:12:26 <Marvin--> I was just about to say that... :)
02:12:37 * shapr sighs
02:12:51 <shapr> I'm glad I'm already humble...
02:13:07 <Marvin--> I was also just going to say "isn't it just a matter of toposorting" ;)
02:13:11 <shapr> :-PPP
02:13:27 <shapr> hah, oh ye of much education
02:14:20 * seth is away: Don't say anything until I get back.
02:14:23 * shapr needs to reread the graph section of the "Algorithms : A function approach" book
02:14:33 <andersca> I think it's snowing
02:15:02 <shapr> we actually have something resembling sunlight in Boden
02:15:07 <shapr> it's shocking
02:15:10 <Marvin--> snowing? damn
02:15:22 <andersca> Marvin--: it's something like 1 flake per minute
02:15:26 <Marvin--> andersca: yeah, so I see :P
02:15:52 <Marvin--> good measurement of snowing, flakes/minute
02:17:14 <shapr> silly question, why isn't mrproject written in Python?
02:18:03 <andersca> good question
02:18:04 <shapr> oh hey, andersca is mentioned on the front page of codefactory.se
02:18:05 <shapr> neato
02:18:16 <andersca> I am?
02:18:28 <andersca> where?
02:18:34 <shapr>  Mikael Hallendal, Richard Hult and Anders Carlsson from CodeFactory will be attending GUADEC
02:18:37 <andersca> oh right
02:18:47 <shapr> I assume andersca == Anders Carlsson ?
02:18:49 <andersca> yes
02:18:58 <andersca> valid and correct assumption
02:19:08 <shapr> excellent
02:19:38 <shapr> another silly question... have you guys tried using unit test first?
02:19:45 <andersca> no idea
02:19:52 <shapr> I'd like to use mrproject,  but it's a bit flaky
02:19:53 <andersca> I just work there, don't expect me to know everything
02:19:56 <shapr> heh, ok :-)
02:20:09 <andersca> shapr: feel free to file bugs
02:20:14 <andersca> I think there are some unit tests for libmrproject though
02:20:23 * shapr looks
02:20:41 <andersca> oh right, I wrote those tests
02:22:20 <shapr> didn't Mikael do cUnit?
02:22:27 * shapr googles
02:22:31 <andersca> no, christian did
02:22:41 <andersca> people.codefactory.se/~spotty/
02:22:45 <shapr> oh yah
02:22:52 <shapr> danl told me about that long ago
02:22:58 <shapr> haven't seen danl on irc much lately
02:23:47 <andersca> he's moving to the us I think
02:23:52 <shapr> where to?
02:23:56 <andersca> also, we're pretty much using jabber for internal communication
02:23:58 <andersca> not sure
04:12:41 <xkb> Is there a bot in this channel?
04:13:00 <mgoetze> xkb: don't think so
04:13:15 <kev> xkb: we're all bots
04:13:16 <ibid> xkb: there is no need
04:13:27 <lament> well, there's at least one bot
04:13:29 * lament points at clog
04:13:36 <ibid> hm yeah
04:13:55 * ibid hates bots whose nicks do not make it blatantly obvious that they are bots
04:13:58 <xkb> I was wondering if pesco was here
04:14:13 <xkb> or rather has been here 
04:14:18 <lament> clog is the anti-terrorist bot. It records all conversations and sends them to FBI.
04:14:25 <xkb> lol
04:14:29 <xkb> hi hoover!
04:14:31 <lament> clog is the reason America is still a free country.
04:14:52 <shapr> eh?
04:15:06 <shapr> oh
04:15:31 <xkb> anyway.. if u see pesco, tell him his ebuild for ghc 5.04.2 worked
04:15:36 <xkb> (for gentoo)
04:15:37 <ibid> xkb: try /msg nickserv info pesco?
04:15:51 <shapr> also, you can leave memos for people
04:16:03 <xkb> hmm.. it says im not registered
04:16:03 <shapr> try /msg memoserv help
04:16:17 <ibid> xkb: register yourself then
04:16:20 <xkb> k
04:16:33 <xkb> set auto-ignore off
04:16:35 <xkb> aargh
04:21:33 <xkb> hmm.. that memoserv is neat!
04:21:44 <shapr> yah, it's handy
04:28:41 <whee> got my first spam :(
04:28:45 <shapr> first??
04:28:51 <shapr> I get more spam than email
04:28:53 <whee> on this account, yes
04:29:04 <whee> I've had the account for two years and not a single spam until today
04:29:08 <shapr> I've had an email account since 1992
04:29:14 <shapr> that one gets the most spam
04:29:20 <whee> heh
04:31:46 <liiwi> shaprrrr
04:35:58 <Segora> shapr: i know that problem. and one wouldn't want to give up an address that has been stable for so long...
04:59:11 <shapr> liiwiiiii
06:21:48 * Marvin-- mutters
06:32:53 * shapr stutters
06:33:21 <shapr> Marvin--: more fun with your students?
06:34:52 <Marvin--> no
06:34:57 <Marvin--> I'm trying to solve a number theory problem
06:35:01 <shapr> oh
06:35:09 <shapr> carmichael numbers?
06:35:50 <Marvin--> "Let p be an odd prime. Show that there is a positive n < 1 + sqrt(p) such that x^2 = n (mod p) has no solutions"
06:36:03 <Marvin--> quadratic congruences are tricky
06:36:52 <shapr> whoa
06:36:55 <Marvin--> It's not a problem if p = +/- 3 (mod 8), because then x^2 = 2 (mod p) has no solutions
06:36:56 <shapr> scary stuff
06:37:10 * shapr runs back to his weenie Python code
06:37:16 <Marvin--> so I'm fighting with p = +/- 1 (mod 8)
06:37:27 <Marvin--> I think I need more coffee
06:37:36 * shapr emails coffee to Marvin--
06:39:40 <Marvin--> "I don't make jokes in base 13. Anyone who does should get help." (Douglas Adams
06:39:41 <Marvin--> )
06:39:42 <Marvin--> heh
06:48:51 <shapr> whee: you were asking about DenotationalSemantics?
06:51:52 <Marvin--> denotational semantics is fun
06:54:50 <Heffalump> sometimes
06:55:49 <Marvin--> pity it's incomplete :)
07:17:26 <neniu> What does this means? ERROR "SimpleGraphics.lhs":68 - Instances of (Floating Int, RealFrac Int) required for definition of snowflake
07:18:45 <ibid> you are using Int where you should be using some floating point number type?
07:25:18 <neniu> idib: Found it. Thanks.
07:57:33 * seth is back (gone 05:43:12)
08:33:11 * seth is away: Don't say anything until I get back.
09:03:00 <shapr> boing
09:03:51 <Igloo> What's your best score on crack-attack, shapr?
09:03:51 <Igloo> And how much have you played it?
09:03:55 <Heffalump> lol
09:03:55 <shapr> er, 37xx I think
09:03:55 * shapr looks
09:03:55 <Igloo> Eeep, 4 digits?
09:03:57 <shapr> nah, 3243
09:03:59 <Heffalump> rotfl
09:03:59 * Igloo looks scared
09:04:00 <shapr> what's your hi score?
09:04:19 <shapr> I play CA whenever I need a mental break from the code I'm staring at
09:04:29 <shapr> so, several times a day :-)
09:04:33 <Igloo> I think I just did 214 or 219 but can't see how to look
09:04:52 <Marvin--> play moon-buggy instead :P
09:05:00 <shapr> if you run it, it shows the highest score at the beginning
09:05:10 <shapr> or when the game is over, you can use the up and down arrows to scroll the scoreboard
09:05:36 <shapr> Igloo: most days I'm happy to get 1500
09:06:10 <Igloo> Yes, but it comes with a highest score of 600  :-)
09:06:10 <shapr> to be fair, I have the highest single player score of all the irc players I know
09:07:07 <shapr> note also the 6101 Joe has on the homepage
09:07:57 <shapr> wanna play CA networked? ;-)
09:08:18 <Marvin--> hmm
09:09:25 <Marvin--> I wonder if  x^2 = a (mod p)  and  x^2 = a (mod q)  having two solutions each, implies that  x^2 = a (mod pq)  has four solutions
09:10:05 <Heffalump> I doubt it
09:10:15 <Heffalump> oh, maybe
09:10:15 <Marvin--> why not?  (Z/pqZ)* = (Z/pZ)* x (Z/qZ)*
09:10:19 <shapr> Igloo: if you have a public IP, we can play two player.
09:10:27 <Heffalump> no, I doubt it
09:10:35 <Heffalump> what is the *?
09:10:56 <Heffalump> if a = 1 then the two solutions in each case are 1 and -1. What are the 4 solutions mod pq?
09:10:59 <Marvin--> (Z/pZ)^*  if you prefer, or ^x if you prefer
09:11:00 <Igloo> I do, shapr
09:11:22 <Marvin--> Heffalump: some things that reduce to 1 or -1 mod p or mod q?
09:11:37 <Marvin--> with (Z/pZ)* I mean the multiplicative group with \phi(p) elements
09:11:46 <Marvin--> (i.e. p-1 elements)
09:11:49 <shapr> Igloo: btw, I've been trying to figure out the system behind CA... I've been laboriously trying to find the max possible score for X number of blocks of X colors, etc
09:11:53 <shapr> it's harder than I thought
09:12:24 <Igloo> Do you try to avoid getting more than 3s in single player?
09:12:45 <Marvin--> Heffalump: and note that it's not the same -1 ;) mod pq it'd be p-1 and q-1
09:12:48 <shapr> huh?
09:13:14 <Igloo> Grr, silly server. I wonder if --wait does what I think it does
09:13:48 * Heffalump looks confused
09:14:13 <Heffalump> Marvin--: the solutions to x^2 = 1 mod p and mod q are 1,(p-1) and 1,(q-1) respectively. What are the solutions mod pq?
09:14:46 <Heffalump> [forcing everything mod n to be in the range 0..n-1 to avoid confusion]
09:18:53 <Marvin--> Heffalump: hmm
09:19:27 <Igloo> Well, I convincingly suck at that  :-)
09:19:27 <Heffalump> Marvin--: however, a bit of trial-and-error suggests that you are actually right
09:19:32 <Marvin--> (p-1)(q-1)?
09:19:46 <Marvin--> I'm trying to think of it group-theoretically
09:20:07 * shapr bounces happily
09:20:59 <Igloo> :-)
09:21:07 <shapr> I luv playing multiplayer games with other humans
09:21:40 <Igloo> Before, I was asking if you tried to avoid getting more than 3 in a row in single player to avoid the garbage
09:22:02 <shapr> if you're going for a high score, you try to get some, but you stage them
09:22:18 <Marvin--> Heffalump: what I'm getting at is that the solutions (abstractly) should be (1,1), (p-1,1), (1,q-1) and (p-1,q-1)
09:22:53 <shapr> so, I get seven 3s that depend on each other, that means the total score for those is 21 x 7
09:23:05 <shapr> then I get a bunch of trash and try to clean it away before I make another big match
09:23:47 <shapr> when I'm just trying to clear my mind I can get up to eleven 3s that depend on each other, but then the game is over
09:24:46 <shapr> I've often wondered about the math theory behind crack-attack
09:24:54 <Heffalump> Marvin--: I believe you, sort of, but what's the mapping?
09:25:04 <Heffalump> anyway, got to disappear
09:25:06 <Marvin--> Heffalump: that's what I'm trying to rack out of my brain
09:25:34 <shapr> Igloo: what kind of stuff are you working on recently?
09:25:35 * Marvin-- searches for his Durbin
09:25:58 <Igloo> I'm looking at printf right now
09:26:14 <Igloo> It really wasn't designed to be done partly statically and partly dynamically
09:26:15 <shapr> Printf.hs ?
09:26:24 <Igloo> .lhs, but yeah  :-)
09:26:36 <shapr> you hacking in TH support?
09:26:58 <Igloo> Ermmm, writing an implementation in TH from scratch
09:27:16 * shapr finally finds a picture of Igloo
09:27:25 <shapr> wow, your hair is longer than mine
09:27:28 <shapr> cool!
09:27:33 <Heffalump> I bet his beard is too :-)
09:27:44 <Igloo> What picture did you find?
09:27:50 <shapr> http://web.comlab.ox.ac.uk/oucl/people/ian.lynagh.html
09:27:59 * Igloo is sure I gave you the URL of one at one point
09:28:03 <Igloo> Ah
09:28:18 * shapr has long hair also
09:28:18 <Marvin--> hey, with that beard you could be a kernel hacker
09:28:28 <Marvin--> I have long hair too :)
09:28:34 <shapr> well, sort of long... past shoulder, but not to elbow
09:28:41 <shapr> Marvin--: you have a pic online?
09:28:46 * shapr looks for a pic of himself
09:28:47 <Marvin--> shapr: nothing current :/
09:29:01 <Marvin--> i.e. nothing with long hair
09:29:34 * Igloo gives up and makes %d all dynamic for now
09:30:08 <shapr> Marvin--: ok, that's part of your homework now :-P
09:30:08 <Marvin--> http://www.mdstud.chalmers.se/info/cpu/gfx/medlemmar/martin.jpg <- semi-long hair
09:30:22 <shapr> cool!
09:31:53 <Marvin--> no beard though
09:31:57 <Marvin--> not for lack of trying *g*
09:31:57 <shapr> http://kungens.kemi.fi/~shae/shaemax.jpg
09:32:08 <shapr> that's something like EIGHT WEEKS of beard there
09:32:20 <Marvin--> kungens kemi? :P
09:32:32 <shapr> hey, I have a nice shell account there
09:32:47 <Igloo> What does that mean?
09:32:49 <Marvin--> my beard doesn't grow more than that either, and much sparser :P
09:33:01 <Marvin--> Igloo: the king's chemistry :P
09:33:23 <shapr> kemi is a city in western finland
09:33:28 <shapr> kungens is a sports club in kemi
09:33:39 <shapr> I have a friend who runs that box
09:33:51 <shapr> I help him with sysadmin, code, etc and he gives me a shell account.
09:34:45 <Marvin--> bah, screw this explicit isomorphism thingy, I *know* that (Z/pqZ)* is isomorphic to (Z/pZ)* x (Z/qZ)* so there *must* be four solutions, so there :)
09:34:59 <shapr> Igloo: nice beard, I'm jealous :-)
09:35:38 * Marvin-- taps a Forest and casts Giant Growth on shapr's face
09:35:40 * shapr laughs
09:35:43 <Marvin--> sorry, taps<tm>
09:35:43 <shapr> you play too much MTG
09:35:57 * shapr used to play MTG long ago
09:36:10 <shapr> MTG got me into professional programming even
09:36:23 <Marvin--> I don't play MtG at all :) used to, though, and I played some nostalgia games with printed decks last week :P
09:36:53 <shapr> MtG is fun, but I ran up against the edges of the system
09:36:59 <Marvin--> now I play GoT instead *g*
09:37:05 <shapr> it just wasn't flexible enough
09:37:07 <shapr> what's GoT ?
09:37:07 <shapr> oh
09:37:12 <shapr> game of thrones
09:37:16 <Marvin--> yup
09:37:29 * Marvin-- has a fairly decent Stark deck
09:37:38 * shapr has never seen GoT
09:37:44 <shapr> I got really tired of card games after MtG
09:37:50 <shapr> I had a job doing MtG
09:38:01 <Marvin--> ehuh?
09:38:21 <shapr> mostly selling, buying, trading
09:38:32 <shapr> I made a lot of money for myself and the comics shop I was working at :-)
09:39:24 <shapr> I really liked trying to stretch the system
09:39:44 <shapr> you can only go so far though
09:39:49 <shapr> then you have to do programming or math
09:39:58 <shapr> Haskell is the best of both of those!
09:40:54 <Marvin--> haha
09:45:31 <shapr> the guy who designed MtG, Richard Garfield, has a degree in Combinatorial Mathematics
09:45:44 <Marvin--> I'm not surprised
09:45:46 <shapr> I guess that's why MtG is a lot like a type system
10:00:10 <Marvin--> ouch, what a bike crash
10:09:00 * shapr would like to find multiplayer network games that require cooperation to win
10:10:56 <shapr> open source is a bit like that
10:12:08 <shapr> oh, I've got one
10:12:34 <Igloo> That would be cool
10:13:26 <kev> shapr: Natural Selection
10:13:30 <kev> but really, don't touch it
10:13:35 <kev> it's addictive
10:13:39 <shapr> never heard of it
10:14:13 <kev> it's a mod for halflife
10:14:17 <kev> combines halflife with starcraft
10:14:28 <shapr> that does sound far too addictive
10:14:40 <kev> takes soo much team coordination
10:14:51 <shapr> ok, I've got an idea I just came up with
10:15:26 <shapr> you have a ball trying to fit through a collar,the collar is split into four pieces
10:15:49 <shapr> player A controls x axis movement, player B controls y axis movement
10:16:13 <shapr> but, correcting the part of the collar that you can correct also twists the collar, pushing part of the problem to your partner
10:16:41 <kev> trouble with that is the game doesn't evolve
10:16:46 <shapr> yah, I agree
10:16:50 <kev> you master doing it, it's simple
10:16:59 <shapr> but at least it's a system where you don't have total control
10:17:05 <shapr> where you rely on your partner
10:17:05 <shapr> Bridge does that
10:17:09 <kev> NS is great because each enemy has different tactics
10:17:36 <kev> there's a lot of innovation that people come up with as well
10:17:47 <kev> I once saw the marines building a ladder out of people to let someone into vents
10:18:00 <shapr> sadly, half-life doesn't easily run on linux
10:18:16 <kev> 4 people making up a ladder, two out in front gaurding, one person climbing
10:18:16 <shapr> it requires large amounts of hardware for playability
10:18:23 <kev> I thought it worked under wine?
10:18:30 <kev> and the reqs aren't that heavy these days
10:18:59 <shapr> it does work under wine
10:19:03 <kev> my flatmate has a pc chips 810mlr mobo, and the onboard vid card does the trick
10:19:30 <shapr> but it's not speedy in wine
10:20:30 * shapr looks for natural selection servers within decent ping
10:21:33 <shapr> best multiplayer coop game I've thought of is one of the large WWII bombers
10:21:47 <shapr> in that scenario, if your tail gunner sucks, you don't last long
10:22:00 <shapr> same for any other manned position
10:22:21 <shapr> there must be a tetris like multiplayer variant that would require coop
10:22:29 <shapr> but all the ideas I've come up with seem forced and artificial
10:27:01 <kev> war games always seem to turn out the best for that
10:27:34 * seth is back (gone 01:54:22)
10:28:26 <shapr> I suspect that's only because we haven't come up with any other decent coop systems
10:29:06 <kev> I guess you could do other real life situations as well
10:29:16 <kev> but generally they're a lot more dull
10:29:40 <kev> shapr: get an instrument, play in a band?
10:32:20 <shapr> yah, that's probably the best one
11:13:11 <inkedmn> are Long and Float valid data types?
11:18:37 <tez> I don't think there's a Long.  There is a Float.
11:21:45 <tez> There's also a Double
11:22:24 <hdaume> there's an Int64, which you might think is like a long :)
11:27:15 <inkedmn> ah, ok
13:12:47 <clausen> goulash: oi gata!
13:13:02 <goulash> oi***
13:45:56 <clausen> my hugs broke!
13:46:00 <clausen> satisfactory:~/common/haskell/test$ cat NullTest.hs 
13:46:01 <clausen> import List
13:46:09 <clausen> Reading file "/usr/lib/hugs/lib/Prelude.hs":
13:46:09 <clausen> Reading file "NullTest.hs":
13:46:09 <clausen> Reading file "List.hs":
13:46:09 <clausen> Reading file "NullTest.hs":
13:46:09 <clausen> Parsing
13:46:09 <clausen> ERROR "NullTest.hs" - Module "Main" already loaded
13:46:11 <clausen> Main> [Leaving Hugs]
13:46:48 <Igloo> Huh?
13:46:48 * clausen is really frustrated
13:46:54 <clausen> it makes no sense
13:47:01 <clausen> WTF did it get "Main
13:47:03 <clausen> from?
13:47:04 <andersca> prolly missing a module 
13:47:08 <Igloo> What you pated doesn't, no
13:47:09 <andersca> module Foo where
13:47:21 <Igloo> pasted
13:47:36 <Igloo> (afk)
13:47:39 <clausen> Igloo: it's one line of code
13:47:50 <clausen> s/Igloo/andersca/
13:49:01 <clausen> it's only List that's broken
13:49:07 <clausen> I can import IO
13:50:01 <Igloo> Did you not paste a line saying "satisfactory:~/common/haskell/test$ hugs NullTest.hs" then?
13:50:21 <clausen> I didn't paste that, but I typed it
13:51:04 <clausen> Prelude> :load NullTest.hs
13:51:04 <clausen> Reading file "NullTest.hs":
13:51:04 <clausen> Reading file "List.hs":
13:51:04 <clausen> Reading file "NullTest.hs":
13:51:04 <clausen> ERROR "NullTest.hs" - Module "List" not previously loaded
13:51:12 <Igloo> Right
13:51:30 <Igloo> "Main" is the nmame used for modules you don't explicitly name
13:51:45 <clausen> ah
13:52:08 <clausen> I just added: module NullTest where
13:52:14 <clausen> and it makes no difference
13:52:21 <clausen> so, it's not loading List.hs successfully?
13:52:27 <Igloo> Does a newline at the end make a difference? And did it ever work?
13:52:49 <clausen> Hugs session for:
13:52:49 <clausen> /usr/lib/hugs/lib/Prelude.hs
13:52:49 <clausen> List.hs
13:52:56 <clausen> Main> :t sort
13:52:57 <clausen> ERROR - Undefined variable "sort"
13:53:09 <clausen> Igloo: it did work, and newline makes no difference
13:53:09 <Igloo> Oh, do you have a List.hs in .?
13:53:15 <clausen> hmmm, yes
13:53:17 <clausen> thanks
13:53:20 <clausen> odd
13:53:27 <clausen> some search path issue, I guess
13:53:31 * clausen should have thought of that
13:53:42 <clausen> fixed :)
13:53:43 <clausen> thanks!@
14:11:44 <inkedmn> how can i grab the last element in a list?
14:12:21 <andersca> how about 'last'?
14:12:27 <andersca> Prelude> last [1,2,3]
14:12:27 <andersca> 3
14:13:05 <inkedmn> heh
14:13:17 <inkedmn> fst and first don't work...
14:13:19 <inkedmn> hm...
14:13:28 <andersca> head is the head of the list
14:13:30 <inkedmn> head
14:13:34 <inkedmn> yeah :)
14:13:48 <inkedmn> my brain stopped farting at that very moment :)
14:47:52 <Igloo> Chilli?
15:26:28 <ChilliX> Hi Igloo
15:28:04 <Igloo> http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/Fraskell/gtk+hs-0.14.10.patch.gz should be my latest patch. Apologies for the lack of comments.
15:34:45 <ChilliX> thanks
16:55:24 <whee> is there a shorter way of writing do { blah <- foo; return blah }?
16:56:11 <Igloo> foo
16:56:28 <whee> indeed
16:56:31 <whee> heh
16:57:16 <Igloo> Hmmm, testing this is going to be a bite slow if I call GCC for each test
16:57:41 <whee> trying to actually use parsec, this should be fun
16:57:48 <andersca> parsec is cool
16:58:24 <whee> I wrote a parser for this particular format with lex/yacc, but I want to see how parsec would do it
16:59:50 <seth> whee: I'd like to see the code when you have something working.  I've been doing similar things.
17:00:01 <whee> sure, it'll be ugly though :P
17:00:06 <whee> if it even works
17:00:25 <whee> I'm essentially ripping off as much from the examples as I can
17:02:34 <whee> although parsec does seem a hell of a lot more powerful than yacc right now, even though I have nothing done :)
17:02:52 <andersca> happy is pretty nice too
17:03:29 <seth> yacc/happy is just as powerful, but I like to avoid code generators when possible.
17:04:08 <dark> I made a code generator for hasdl yesterday.
17:04:19 <dark> That's in addition to the hsc2hs layer )
17:05:20 <Igloo> I think I might be about to write m4 to write TH code
17:05:38 <dark> That's pretty evil.
17:05:46 <Heffalump> that is exceptionally evil.
17:05:50 <Heffalump> why?
17:07:17 <Igloo> I want to have many calls like $( printf "%4.6s" ) without writing them all by hand. I guess I could do it by writing out complete declarations and split the code over two modules
17:07:21 <whee> is there a nice easy way to take a list [1, 2, 3] and a list [2] and return [1, 3]?
17:07:34 <Igloo> \\, depending on exactly what you mean
17:07:59 <Igloo> In particular depending on what [1,2,2,3] `foo` [2] should be
17:08:05 <dark> foo [1, 2, 3] [2] = [1, 3]
17:08:08 <whee> just a function that takes two lists and returns elements in the first list and not in the second
17:08:37 <whee> I can think of a list comprehension way but I'm wondering if there's a shorter one
17:10:17 <Igloo> Oh, no, I couldn't do that. I'm confusing myself again.
17:10:33 <Igloo> Yes I could. Aaargghh.
17:10:36 <dark> [ x | x <- xs, x `notElem` ys ], but that might be slow :)
17:10:47 <whee> dark: that's exactly what I was thinking. heh
17:11:01 <whee> I'm dealing with lists of a maximum length of 7, so it may not be a big deal
17:11:26 <dark> whee: So what about Igloo's question?  What should [1,2,2,3] `foo` [2] be?
17:11:32 <whee> [1, 3]
17:12:00 <Igloo> Oh, that's the bad answer
17:12:05 <dark> With lists that short, the straight filter might actually be the fastest way.
17:12:25 <whee> Igloo: that's just because \\ doesn't work that way :)
17:12:37 <Igloo> Exactly  :-)
17:13:19 <dark> hmm, I wonder if (xs \\ cycle ys) terminates.
17:13:39 <Igloo> Don't see why it should
17:14:09 <Igloo> Shouldn't even converge
17:14:37 <Heffalump> YM it'll diverge, which I think is something different
17:14:45 <Heffalump> I don't think converge actually makes sense in this context
17:15:02 <dark> I thought \\ might traverse xs, but it traverses ys :)
17:15:45 <Igloo> Hmmm, perhaps
17:16:07 <Igloo> dark: You need to check each element of ys before you know that the first x can be output
17:17:33 <dark> I'm looking at the way \\ is implemented.  I'm fairly confident that (\xs ys -> filter (`notElem` ys)) is not going to be any slower :)
17:17:45 <dark> Er, throw another xs in there.
17:18:40 <Igloo> Well, they do different things
17:19:02 <Igloo> Yours will be slower if all of ys is near the beginning of xs
17:19:04 <dark> Igloo: Yeah, but it means I don't agree with your assessment "that's the bad answer"
17:19:26 <Igloo> Oh, it's bad because it means writing more code
17:19:43 <Igloo> Not because of any sensible measure like speed or space  :-)
17:20:26 <dark> If it needs speeding up, then Data.Set is probably a good place to look.
17:20:55 <Igloo> But they aren't sets - or doesn't that matter?
17:20:59 <dark> Though I have some suspicions about the way it piggybacks on FiniteMap :)  Do all those ()'s really get optimized away?
17:21:17 <dark> Igloo: It does; I expect it would only be faster with Data.Set if they're sets all the way.
17:21:28 <Igloo> Huh?
17:21:33 <Igloo> I mean [1,2,2,3] isn't a set
17:22:32 <dark> Hmm, yeah.  And [1,2,2,3] `foo` [3] would be [1,2,2] which isn't a set either.  I was thinking that the desired result would be a set.
17:23:41 <dark> It's just that I've never seen an application which needs such a set-like list operation that doesn't secretly prefer sets altogether :)
17:25:13 <dark> whee, you still there?
17:25:17 <whee> what I'm doing is taking a list of Days and removing whatever's specified 
17:25:52 <whee> this seems like the easiest way to do it
17:26:26 <whee> I don't want to assume that each day is going to appear only once, though
17:26:48 <whee> well I guess I could if I went and removed duplicates :|
17:27:06 <dark> See?  Whee secretly wants sets :-)
17:27:12 <whee> :P
17:28:16 <whee> well, I could use a set for this actually
17:28:18 <whee> is it worth it? heh
17:29:16 <whee> I figure for a list this small it probably will get slower with sets
17:30:21 <dark> Probably.  And I don't think ghc will do any deforesting on them either.
17:30:38 <dark> (Note the choice of words indicating that I have no clue how deforesting works)
17:30:42 * Igloo decides it will be easier and better just to write the list of tests by hand
17:36:08 <whee> indeed
17:36:58 <whee> I feel like I'm writing code that won't work at all when the time comes
17:38:01 * Igloo is busily going round in circles ATM  :-)
17:39:30 <dark> whee: The solution to that is to get something to run, even if it doesn't do anything yet :)
17:53:49 <whee> oh boy, it actually almost compiled
17:54:24 <whee> excluding the 6 type errors.
17:55:04 * Igloo has written my first HUnit test and completed xkobo level 94. Happy days  :-)
17:57:04 <dark> 94??  I've been stuck at 44 for years.
17:58:49 <Igloo> My girlfriend was stuck on a level for over 2 years (or maybe it was only one, I forget which summer she started playing)
17:59:29 <dark> I'm not likely to ever get past it, my xkobo skills have rusted every time I regain interest :)
17:59:34 <cmoline> hey ive been stuck at 44 or thereabouts as well!
17:59:37 <whee> oi. okay, what's shorthand for do { blah <- foo; return $ Sometype blah } :)
17:59:51 <Igloo> liftM Sometype foo
17:59:55 <whee> smashing
18:00:07 <Igloo> I should have made a note of the ones I got stuck on
18:00:28 <dark> I always do fmap Sometime foo, am I weird?
18:00:37 <whee> Yes.
18:00:44 <Igloo> OK, freaky. Do xkobo -cheat and hav a look at 94, dark
18:01:01 <dark> Igloo: No, that would smash my xkobo barriers, I'd never enjoy the game again.
18:01:14 <Igloo> Monad m doesn't => Functor m does it?
18:01:20 <Igloo> Sorry?  :-)
18:01:47 <Igloo> 94 is the same pattern of the two rings, anyway
18:01:48 <dark> Igloo: I'm very spoiler-sensitive :)  I wouldn't enjoy the game after I've cheated even once.  In every difficult level I'd be tempted to do it again.
18:01:59 <Igloo> I wonder if levels mod 50 are similar
18:02:05 <Igloo> Oh, oops, sorry
18:02:35 * Heffalump appears to be developing double-vision.
18:02:56 <Igloo> :-)
18:02:58 <dark> xkobo is an example of a "good" difficult game, though.  With just about every level I think "This level is impossible!"
18:03:16 <dark> And then I solve it anyway, and find out that it was EASY compared to the NEXT level :)
18:03:25 <dark> Until I got stuck at level 44, of course.
18:03:32 <Igloo> Really? I find I spend ages on one and then zip through the next few until I hit another hard one
18:03:39 <dark> Some of the Battle Isle games were the same way.
18:03:50 <dark> Igloo: Maybe I just don't remember the easy ones :)
18:04:03 <dark> I had a hard time getting through 43, though.
18:04:05 <Igloo> Well, when you do them first time they're easy to forget  :-)
18:04:59 <Igloo> What makes the blue things appear on that level?
18:05:26 <whee> errr, parsec operators are confusing
18:05:35 <Igloo> Oh, just at the beginning and when you destroy a complex?
18:05:43 <whee> I don't think I can define operators on, say, strings and ints
18:06:00 <whee> unless I add more types, blah :|
18:06:07 <Igloo> They're relateively easy as you can just chip away at the structures and then kill the hordes when you finish one
18:06:20 <Igloo> It's the ones there things just keep coming at you regardless that are evil
18:06:21 <seth> whee: It isn't necessary for what you need to do.
18:07:07 <dark> Any level which has little white rings is evil :)
18:07:20 <whee> well, I'm trying to do something like this: the '~' character when preceding a string of characters will result in some function being called on whatever the result of the parsing of the following string is
18:07:26 <dark> Igloo: There's an instance Functor IO
18:07:28 <Igloo> Do you mean bullets?
18:07:35 <whee> and there's a ':' operator which takes two integers and does some things
18:07:54 <Igloo> The above might ned have been IO, though
18:08:00 <dark> The State monad is also a Functor.
18:08:09 <whee> I need to create a couple types and put those in it
18:08:12 <Heffalump> all monads are functors, aren't they?
18:08:15 <dark> I guess I never tried it on any other monad :)
18:08:42 <Heffalump> fmap f ma = do { a <- ma ; return (f a) }
18:08:57 <Heffalump> in other words instance Monad m => Functor m exists
18:09:02 <dark> Heffalump: But the instance doesn't seem defined by default.
18:09:10 <Heffalump> s/exists/can exist/
18:10:03 <whee> down to two type errors, woo :)
18:10:09 <whee> one of which I don't think I can fix
18:10:10 * Heffalump goes to bed
18:10:16 <dark> So, is there any essential difference between listM and fmap?
18:10:57 <whee> any ideas on how to approach my operator problem?
18:12:18 <Igloo> Well, liftM fits in with the liftM* functions
18:12:44 * Igloo has no parsec experience
18:21:32 <whee> gah, I don't understand this at all
18:21:46 <whee> I need to create one heck of an AST in order to do this with parsec
18:24:31 <dark> I'm having trouble dealing with those death stars.
18:25:28 <whee> oh well. I guess I'll do this the right way
18:25:45 <Igloo> The which?
18:26:18 <whee> the way which includes doing nothing but parsing and returning some huge nested structure
18:26:20 <dark> Igloo: the big square things that chase you around and launch fighters.  Then when you finally kill them they split into eight grey fighters.
18:26:26 <whee> then evaluating that afterwards
18:26:32 <whee> and nevermind
18:26:33 <whee> :)
18:26:51 <dark> Igloo: But I'm having even more trouble with the blue things that explode into a fan of bullets.
18:26:54 <Igloo> Ah, right
18:26:57 <dark> whee: Sorry for koboing on your dilemma :)
18:27:46 <Igloo> whee: Can you give a small example?
18:27:56 <whee> like?
18:28:05 <Igloo> Well, a small input first
18:28:30 <whee> http://smaerty.ath.cx/scheduler/courses.txt <- this is what I'm parsing
18:28:54 <whee> my problem is handling ~ and : as operators, as they obviously operate on different data types
18:29:28 <Igloo> What does ~ mean?
18:29:44 <whee> ~T would expand to "every day except tuesday"
18:29:56 <whee> whereas T would be tuesday.
18:30:01 <Igloo> Ah, and parsec supports prefix operators?
18:30:05 <whee> yes
18:30:15 <Igloo> And what result do you want?
18:30:37 <whee> the problem is that I apparently need to come up with some ast and not directly return a result of one of those computations
18:31:00 <Igloo> Hmmm, I don't see why, but like I said, I'm not familiar with parsec
18:31:02 <whee> because the expressions parser needs to return some single type :\
18:31:20 <whee> it'd be neat if I could hack around it with ghc's extensions somehow, heh
18:31:47 <Igloo> Aha, it sounds as though you are trying to use features too targetted at parsing to ASTs
18:32:28 <whee> I'm trying to use parsec for more than parsing, and it doesn't like that
18:33:29 <Igloo> Try using just pList, pChar (and similar functions), <|> and sequential composition, or whatever the parsec equivalents are
18:33:36 <whee> this'll be a good thing to learn how to do, anyway
18:33:55 <whee> in case I ever do want to implement something more along the lines of a programming language in the future
18:34:25 <Igloo> Ah, OK, ignore that then  :-)
18:40:06 <lament> real programming languages don't need parsers!
18:40:10 <whee> :P
19:12:53 <whee> .. amazing
19:13:04 <whee> it actually compiled the first try
19:13:25 <whee> this means it does not work
19:13:26 <whee> heh
19:14:36 <seth> It works.  I don't know what it does, but it works.   :)
19:14:51 <whee> I wish I could always use that excuse :P
19:16:16 <whee> woo! I'm right
19:18:26 <whee> you have some experience with parsec seth?
19:18:42 <seth> Some.  I've done more with Happy, but I prefer the parsec approach.
19:19:38 <whee> this should be pretty simple: I'm parsing a line of the form "1234-3434 some string {" (minus the quotes), and I'd like to deal with "some string" and place that in a variable. I'm not sure what parsec parsers would be able to do that
19:20:35 <seth> It seems like a case for the parser that takes a list of allowable characters and stops when the input stream contains a character not in the list.
19:21:03 <whee> oh, I know what you're saying
19:21:08 <whee> somehow I've managed to avoid using that so far
19:21:30 <seth> It's very general and useful.  Doesn't product particularly readable code, though.
19:21:36 <seth> s/product/produce/
19:22:07 <whee> I wonder if I could use manyTill and check for the {
19:22:10 <seth> It's better if the name (and structure) of the function suggest what it does, rather than having to look at a parameter to see what it does.
19:22:24 <seth> Yes, that would work, as long as "anything except {" is really what you want.
19:22:29 <whee> yes, it is
19:22:46 <seth> Then yes, that is a good choice.
19:24:32 <whee> err, will manyTill eat the '{'?
19:24:48 <seth> No, IIRC
19:24:54 <whee> hmmm
19:25:15 <seth> I think there is a similar one which will consume the termination character.
19:25:16 <whee> something ate it :(
19:25:30 <seth> Maybe there is another one that doesn't consume it.   :)
19:25:44 <seth> Or you can push it back.
19:27:06 <whee> yeah, I think it does consume. wonder how else I could do this
19:33:19 <whee> hooray, did it with many1 $ noneOf "{
19:39:11 <seth> Sorry, my xchat crashed.
19:39:49 <whee> you're back in time for me to ask you more questions$! don't you feel lucky
19:41:31 <whee> anyway, my parser seems to have problems with something that essentially expands to "braces (semiSep1 section)"; it appears to read the last section and then go to the next line expecting another section. except there are no more, so it dies on an unexpec
19:41:35 <seth> I may not know any answers...
19:41:35 <whee> unexpected '}', even
19:42:25 <whee> is there something stupid I'm doing here? :|
19:42:37 <seth> I'd have to see more of it.  Can you DCC the file to me?
19:43:00 <whee> putting it on my httpd okay?
19:43:11 <seth> Sure.
19:43:55 <whee> http://smaerty.ath.cx/hs/ parser.hs is where the fun is
19:45:03 <seth> OK, give me a few minutes to look at it...
19:52:54 <whee> oh, interesting
19:53:07 <whee> removing the last semicolon fixes it
19:53:52 <whee> wonder how to get it to behave more like C-style semicolons
19:58:21 <whee> it works$! woo
19:58:38 <whee> found an example in the docs to use endBy :\
19:58:44 <whee> thanks, though
19:59:10 <seth> Interesting....
20:00:01 <whee> time for a useless comparison (comparing code length against my yacc/lex version)
20:00:35 <seth> Code length isn't interesting, but execution time would be if it can be measured.
20:00:40 <whee> woop, it's shorter :)
20:01:26 <whee> I probably couldn't get a good execution time measurement; my yacc one is using ocaml
20:02:02 <seth> You would need something much larger, and with a lot of input, to get useful numbers I think.
20:02:29 <whee> parsec is lazy, right?
20:03:30 <seth> parsec is Haskell, and Haskell is lazy.  I'm not sure of the specifics of when things get forced with combinators.
20:04:01 <whee> I could easily get a huge input and something going, but I'd need to ensure it's parsed somehow
20:04:18 <whee> printing it isn't exactly optimal with the overhead that comes with that
20:04:57 <seth> No, but you can count lines, count braces, similar stuff.
20:07:21 <whee> oops I just made a file a gig large :|
20:07:57 <seth> Infinite loops R us
20:08:20 <whee> in my infinite wisdom I decided to cat courses.txt >> courses.txt
20:14:35 <whee> okay, it does appear to actually do the parsing without printing anything
20:14:47 <whee> I left in printing the error, so it must be doing it because of that
20:14:48 <seth> I expect so.
20:15:03 <seth> Oh, happy at least forces all the input.
20:15:11 <seth> Parsec may do the same.
20:16:00 <seth> In fact Happy forces all the input before generating any output, which I think is rather strange.
20:16:18 <whee> I don't think this comparison is very fair, heh
20:16:37 <whee> my ocamlyacc one goes through it in 1.5 seconds, takes the haskell one 12 :|
20:16:41 <seth> No, but just in general, why force all the input?
20:17:18 <seth> I've noticed that my first attempts at Haskell often run very slowly.  Usually I can get them to run as fast as other languages with the application of some intelligence.
20:17:39 <seth> Bad Haskell code runs much more slowly than bad code in some other languages.
20:17:48 <whee> I'm sure mine is way less than optimal
20:17:54 <whee> it is my first time using parsec after all :P
20:18:48 <seth> I had one program; the first version took 22 minutes to run, the final version took 2.4 seconds to run.
20:18:55 <whee> haha
20:19:53 <whee> well it does parse the standard size i a hundredth of a second, so this isn't even a problem
20:19:56 <seth> The first version was deliberately brute force without any optimization, but I was still amazed at the range.  In C the range was about 10 to 1.
20:22:51 <whee> I think this is actually more understandable than yacc, though
20:23:35 <seth> Yes, I agree.  Although yacc could be vastly improved simply by adding the + and * operators to what it understands.
20:26:27 <whee> time to  learn how to parse this AST now :|
20:37:25 <whee> I really like how parsec has decent error output builtin
21:33:05 <whee> hooray
21:33:36 <whee> who's good with ghc's type extensions?
21:36:59 <whee> actually i don't even know if this is possible now that I think about it
21:38:04 <whee> anyway, if I have say 'data Blah = Bloop Integer | Blah String', is it possible to create a function f :: Blah -> (whatever the data constructor argument is)
21:56:21 <cmoline> do you mean something like f :: Integer -> Blah Integer?
21:56:33 <whee> no
21:56:52 <cmoline> hm. i am not sure what youre trying to do. can you clarify?
21:57:04 <whee> what you just said, except reverse the arrow
21:57:23 <whee> f :: Blah (of some type a) -> a
21:57:51 <whee> I thought there might be some ghc extension that would allow something like that, if it's not already possible
21:57:58 <cmoline> could you pattern match? f (Blah a) = a
21:58:06 <cmoline> er 
21:58:18 <cmoline> nvrmind
21:59:21 <cmoline> case blah of Bloop i -> i; Blah s -> s. how about this?
21:59:49 <whee> does it typecheck?
22:00:01 <cmoline> lemme try it
22:01:32 <cmoline> actually i think the closest you could get is f :: Blah -> Either Int String
22:03:01 <cmoline> i gotta go to bed. i work tomorrow. cya
22:17:18 <whee> this owns. the haskell version of this program is shorter and easier to understand
22:17:30 <whee> plus a million times more maintainable
22:19:31 <whee> even produces the same result. that's always a plus :)
22:20:59 <seth> Sounds like you had a productive evening.
22:21:16 <whee> indeed
22:21:32 <whee> first time I'm actually enjoying using haskell :|
22:21:49 <whee> mainly because I actually got a parser working heh
22:22:39 <whee> haha it's even faster than the ocaml version
22:22:47 <whee> by 0.2 seconds :)
22:35:59 <Truth> can someone help me
22:36:10 <Truth> I cant figure out whats wrong with this code
22:36:15 <Truth> Can I pm it to someone
22:40:30 <Truth> anyone awake?
22:49:05 <Truth> anyone awake?
22:53:30 <tez> Yup!
22:53:37 <Truth> can u help me
22:53:46 <Truth> Do you know haskell pretty good?
22:54:15 <tez> I an try...
22:54:22 <tez> I can try...
22:55:08 <Truth> ok can i dcc u the files?
22:55:13 <Truth> there are 2
22:55:25 <Truth> file1 is supposed to find the correct code from file2
22:55:37 <tez> Uh
22:56:15 <tez> If you're having trouble, you can tell me, and I can explain things.
22:57:50 <tez> Anyway, I'm behind a NAT firewall that doesn't handle DCC very well.
22:58:07 <tez> I guess if you have the code on a webpage somewhere, I can take a look.
22:58:14 <Truth> hold on
23:27:43 <shapr> hmm
23:40:42 <tez> hmm?
