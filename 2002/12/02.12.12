06:25:03 <inkedmn> :)
06:25:24 <dbrink> what's up inky?
06:25:35 <inkedmn> not much duder :)
06:25:37 * Igloo needs OOP support in Haskell
08:30:52 <Heffalump> igloo: Object Haskell?
08:31:33 <Igloo> That's not in GHC is it?
08:32:24 <ibid> what do you need oop for?
08:32:27 <Heffalump> no
08:32:34 <Heffalump> it's a separate implementation based on Hugs, IIRC
08:32:45 * Igloo doesn't particularly want to port TH to OH or OH to GHC  :-)
08:33:04 <Igloo> ibid: I want a list of widgets without having to explicitly convert them all to that type
08:33:13 <Heffalump> existential types?
08:34:17 <Igloo> Hmmm, does that allow a list of things that are different types but in a class Widget?
08:34:51 <ibid> yes, afaik
08:34:52 <Heffalump> I've never used them, but I believe so
08:35:11 <Igloo> Ah, interesting, thanks
08:53:59 <Muad_Dibber> good morning :)
08:55:04 <ibid> good evening :-)
08:55:13 <Heffalump> good afternoon :-p
08:55:39 <Muad_Dibber> hehe
08:55:40 <Muad_Dibber> sup here?
09:54:58 <shapr> whew
10:00:38 <whee> okay, now that I'm awake I'm going to try to learn state monads. again. heh
10:00:38 <shapr> y0 pesco
10:00:42 <pesco> heya
10:00:51 * shapr writes an Alabama Monad
10:01:05 <pesco> What is an Alabama Monad?
10:01:14 <shapr> it's a state monad ;-)
10:01:20 <tez> lol
10:01:52 <dark> I wonder what it would actually do.
10:02:04 <shapr> Alabama is one of the US states (in reality, I just made really bad pun)
10:02:13 <whee> :P
10:02:15 <tez> A function of type Alabama a?
10:02:19 <Heffalump> you could at least have chosen a nice state :-)
10:02:32 <shapr> if it were really like Alabama, it would be lazily evaluated at the very least.
10:02:36 <tez> An Alabama computation tha produces a result of type a, of course!
10:02:42 <pesco> Oh, an Alabama transformer, I suppose?
10:02:55 <shapr> heh
10:02:59 * shapr laughs much
10:04:04 <shapr> geek humor is totally my style
10:04:08 <pesco> "Ever wonder how they go about computin' down in Alabama? With the Lambda calculus, you can find out!"
10:04:21 <shapr> hah!
10:04:29 <shapr> as opposed to the sheepish calculus
10:04:43 <shapr> baaaad joke
10:04:49 <Muad_Dibber> lol
10:05:04 <Muad_Dibber> haskell humor eh :)
10:05:23 <shapr> well, we go for spice
10:05:26 <shapr> especially curry
10:06:15 <tez> <groan>
10:06:22 <shapr> :-)
10:06:32 <Muad_Dibber> yuh, the spice must flow ;)
10:06:38 * shapr groans
10:07:06 <shapr> I wish the tax office here could deal with partial application
10:07:16 <whee> oh I remember my question now
10:07:25 <shapr> I've forgotten your question
10:07:27 <whee> is it possible to mix State and IO monads with do constructs?
10:07:27 <shapr> what was it?
10:07:47 * ibid is planning an advanced studies level haskell-using introductory fp course :-)
10:08:10 <shapr> yay!
10:08:26 <shapr> whee: er, I thought the do construct required monads?
10:08:29 <whee> I'm still not able to find a nice simple example of using GHC's Control.Monad.State module 
10:09:02 <whee> shapr: I'm finding I need to use case to get the tuple of value and state
10:09:12 <whee> but even then I can't figure out what I need to say, print out the current state
10:10:49 <shapr> well
10:11:14 <shapr> my first suggestion is to use monad transformers to get a dual-flavored monad
10:12:10 <whee> I'm still and idiot when it comes to monads, so heh
10:12:41 <shapr> my second suggestion is to ask both here and on the mailing lists for examples of Control.Monad.State
10:13:03 <shapr> I'm sure that Pseudonym has many examples ,though he's usually on this channel only after midnight CET
10:13:16 <shapr> er, you're in the US...
10:13:17 <whee> I tried getting something out of him yesterday :)
10:13:19 * shapr translates timezones
10:13:22 <shapr> oh, ok
10:13:24 <shapr> you know who he is
10:13:35 <shapr> Pseudonym is a fount of interesting information.
10:13:42 <shapr> he's also written lots of stuff on the HaskellWiki
10:13:46 <shapr> have you looked at the HaskellWiki?
10:13:59 <tez> Has it been fixed?
10:14:08 <whee> yes, the Wiki did have an example of using state monads, but the code wasn't complete
10:14:14 <whee> so it entirely skipped over the part I'm having problems with
10:14:18 <shapr> tez: yah, wiki has been fixed
10:14:50 <shapr> I meant to read about Monads in my many hours of busriding, but I got distracted by SICP
10:15:35 <whee> I've found an endless of supply of various ways of creating state monads, but none that show a simple example of using them
10:15:44 <shapr> by the way, if there's anyone here who hasn't read "Structure and Interpretation of Computer Programs" yet
10:15:49 <shapr> read it!!
10:16:20 <shapr> SICP is freely downloadable in HTML format, and portable in printed format
10:16:33 <shapr> imho, it's the first book any aspiring programmer should read.
10:17:00 <pesco> SICP is awesome.
10:17:14 <pesco> From the moment I read the introduction, I was hooked.
10:17:25 <shapr> yah, same here
10:17:39 <shapr> I'm reading it for the nth time
10:18:03 <shapr> every time I go through it, more of the content sinks in
10:18:04 <pesco> Oh, I still haven't finished the first pass, but I'm a slow reader at times.
10:18:22 <shapr> the first time I went through SICP, I got about 1%
10:18:27 <shapr> hi stepcut
10:18:49 <stepcut> hello
10:21:32 <Heffalump> oh, I should read that.
10:21:40 <shapr> Heffalump: you'll love it
10:22:00 <shapr> I'd like to see if I could port it to Haskell
10:22:01 * Heffalump puts it on his list of books to get
10:22:06 <shapr> I've seen a Python port of SICP
10:22:14 <shapr> doesn't quite have the same feel of course
10:24:03 <shapr> oh, my second book recommendation is "The Pragmatic Programmer"
10:24:06 <shapr> those are my top two
10:27:55 <whee> mmf haskell feels so crippling to me right about now
10:28:02 <shapr> really?
10:28:19 <whee> I feel like I need a PhD to understand how to keep track of state
10:28:57 <shapr> I think the object jump is just as hard as the monad jump
10:29:04 <shapr> but more people have made the object jump
10:29:53 <whee> the object jump was easy, it's simply a method of organizing information
10:30:07 <whee> it's just as difficult as moving from files to directories :P
10:30:25 <shapr> directories didn't do much for me in the beginning
10:30:32 <whee> everyone seems to introduce monads with tons of theory and no real examples
10:30:51 <whee> and I'm wondering why I'm even trying to learn this when I can do it in one line in any other language
10:31:03 <shapr> whee: try Parsec
10:31:10 <whee> bhahaha
10:31:11 <Heffalump> other languages don't have referential transparency :-)
10:31:22 <whee> I tried learning Parsec. that didn't go too well.
10:31:31 <shapr> what was difficult about Parsec?
10:31:35 <whee> lack of documentation killed me there. again
10:31:41 <Heffalump> monads are the "right" abstraction for mixing imperative coding and referential transparency.
10:31:55 <whee> Heffalump: perhaps they are, but I can't see it
10:32:24 <whee> there really needs to be a page with simple examples of how things are done in traditional languages, and how that translates into monadic code
10:32:44 <shapr> whee: did you go through the Parsec tutorial?
10:32:59 <whee> I tried
10:33:15 <whee> but in order to do what I wanted to do with Parsec I would need to know how state monads work
10:33:16 <Heffalump> whee: if you write the code in the "traditional" languages I'll do (at least some of) the translation into monadic code.
10:35:21 <whee> also, what's the difference between Control.Monad.State and Data.IORef?
10:36:54 <Heffalump> State monads just store state, and have a "run" operation
10:37:02 <Heffalump> IO monads can do lots of other things besides, and have no "run" operation
10:37:09 <Heffalump> (ignoring unsafePerformIO, which is just that)
10:39:05 <whee> right now I've been trying to do a simple thing with state monads, so that say, main creates a state with an initial value of 0, calls some function with this state, and that function changes the state in some way, returning the new state.
10:39:21 <whee> then main goes and does something with the value of the returned state
10:39:42 <whee> I haven't figured out where runState/evalState/* come into play with all of this
10:40:45 <Heffalump> I'd suggest you just ignore state monads for now
10:40:53 <Heffalump> write the code that explicitly passes the state around
10:41:30 <whee> well, I can't
10:42:07 <whee> with the structure I plan on merging this with that would require massive recursion 
10:42:36 <Heffalump> massive recursion is ok
10:43:14 <whee> it would have the exact opposite effect of what I want, though :P
10:43:15 <shapr> recursion is good
10:44:25 <Heffalump> what's the effect you want?
10:45:33 <whee> I'd like to keep track of and modify state as I'm doing something else (e.g. parsing), so that I don't have to effectively do the parsing twice (once to parse, once to figure out what I should've been keeping track of the entire time)
10:46:59 <Heffalump> what exactly do you want to keep track of while parsing?
10:48:19 <whee> well, in one of my programs (the k5 pfc one), I'd like to keep track of how many words I've added to a FiniteMap
10:49:05 <whee> if the original list of words is around a million elements, it takes half the run time to just calculate the length of that
10:49:06 <Heffalump> so keep a tuple of the FiniteMap and the number of words
10:49:35 <whee> that'd require recursion
10:49:43 <Heffalump> why?
10:49:51 <whee> how would I update the number of words?
10:50:04 <Heffalump> you're updating the FiniteMap, right?
10:50:29 <whee> I use list comprehensions to create a FiniteMap based on a list of (string, int)
10:50:42 <whee> using listToFM or whatever that FiniteMap function is called
10:51:00 <Heffalump> show me a fragment of code that creates the FiniteMap
10:51:04 <whee> I'd like the count to be incremented when there's a collision in this FiniteMap
10:51:22 <whee> erm, don't have it on me, let me rewrite
10:53:45 <whee> addListToFM_C (\old _ -> old + 1) emptyFM [ (w, 1) | w <- list_of_words ]
10:54:06 <whee> I believe that combination function is correct, I can't remember the order of arguments
10:54:44 <whee> what I'd like to know is how many words were entered (I'd settle for how many were entered more than twice)
10:54:45 <Heffalump> ok, so instead of using addListToFM_C write your own version, that takes in the finite map and a count of collisions so far
10:54:59 <Heffalump> then checks whether the new entry to be added is already in the finite map
10:55:04 <whee> I've done it like that previously
10:55:08 <whee> it's incredibly inefficient
10:56:00 <Heffalump> why?
10:56:25 <whee> it killed the heap 
10:56:54 <whee> is it really that difficult to keep track of this with a monad?
10:57:20 <Heffalump> I'm not convinced a monad is the appropriate way of doing it
10:57:44 <Heffalump> in general if it'll kill the heap without a state monad then using a state monad won't help
10:58:59 <whee> it may be a trivial usage, but I'd like to learn how this works :P
11:09:42 <Marvin--> hmm
11:09:52 <Marvin--> I wonder who fxn is, and why he's certified me on advogato
11:12:29 * Heffalump wonders why people still use advogato :-)
11:12:52 * ibid would use it if there was some obvious way to recover a lost password
11:13:28 <Igloo> WDYM by "still"?
11:15:03 <whee> geh
11:15:20 <Igloo> (i.e. what changed?)
11:16:14 <Heffalump> I thought it kind of died out
11:16:27 <Heffalump> as in it was a neat novelty that died out
11:16:41 <ibid> everybody forgot their password and there was no way to recover from that? :-)
11:16:47 <Heffalump> :-
11:16:48 <Heffalump> )
11:17:08 <whee> need to go to class now :|
11:17:26 <whee> and probably going to end up zoning out and debating whether or not to drop learning haskell. heh
11:18:05 <Marvin--> Heffalump: I just signed up, the site is slow as hell, so I assume that SOME people are using it
11:28:59 * shapr fights with devfs
11:30:14 <shapr> seth_: any particular combinators you favor?
11:31:08 * shapr looks for greater understanding of monads
11:32:44 <inky> shapr!
11:33:20 <shapr> hiya inkedmn
11:33:22 <shapr> what's up?
11:33:36 <inkedmn> not much , just doing some lame data entry :(
11:33:40 <inkedmn> it's REALLY boring
11:33:46 <shapr> anything you can do to automate it?
11:33:52 <inkedmn> nope
11:33:55 <shapr> suckage
11:33:58 <inkedmn> i'm typing in stuff that's handwritten
11:33:59 <inkedmn> yeah
11:34:03 <shapr> that bites
11:34:54 * shapr plays with a monadic interpreter
11:35:33 <xkb> wow.. BitchX really flipped on that :D
11:36:07 <shapr> ?
11:36:21 <xkb> It turned all blue on the / me
11:36:25 <shapr> cool
11:36:43 <xkb> think the controlling terminal has gone haywire
11:36:47 <Heffalump> shapr: check out http://spivey.oriel.ox.ac.uk/mike/proglan/outline.html
11:38:00 <shapr> whee: http://www.cs.fit.edu/~satkin/monads.html
11:38:01 <xkb> Are there any more non-formal papers/tuts on monads?
11:38:08 <shapr> try that url I just pasted.
11:38:09 <xkb> besides What the hell are..
11:38:11 <xkb> k
11:38:57 <shapr> that url that Heffalump just pasted also looks fruitful
11:39:54 <xkb> indeed
11:39:55 <xkb> looks good
11:40:13 <xkb> I can use monads.. but I dont really understand them
11:40:31 <shapr> I can't always use them...
11:40:41 <Heffalump> I think I should write a page summarising my view of monads and my "standard" introduction to them that leads in from an explanation in terms of state.
11:40:48 <shapr> I agree :-)
11:40:57 * xkb 2
11:43:18 <Heffalump> that would save me a lot of talking on here :-)
11:43:55 <xkb> Heffalump : are you a tutor?
11:44:25 <Marvin--> Heffalump: :)
11:44:30 <Heffalump> in what sense of the word tutor?
11:44:59 <xkb> a teacher of some kind
11:45:57 <Heffalump> yes
11:49:37 <xkb> Good :)
11:50:10 <xkb> Cause It seems like it takes some skill to explain monads in a understandable way
11:52:12 <Heffalump> I don't have any training as a tutor :-)
11:52:48 <shapr> re Explodey!
11:52:53 <Explodey> hello
11:52:59 <shapr> how are ya?
11:53:05 <Marvin--> wtf, it's going to become illegal to rip your own CDs?!
11:53:19 <Heffalump> in what jurisdiction?
11:53:23 <shapr> already is I think
11:53:31 <shapr> in the USA at least
11:53:39 <shapr> current European law gives you the right to make one backup copy
11:54:08 <Heffalump> well, it depends what you're ripping
11:54:44 * shapr tries to understand monads
11:55:10 <Marvin--> Denmark has passed a law that makes it (if I read it right, I read it on a Norwegian news paper site :P) illegal to copy music from CDs you've bought to your computer or to an MP3 player
11:56:01 <shapr> copyright law has been heading in that direction
11:56:17 <Marvin--> and it sounds like it'll be illegal to buy CDs, DVDs, books, computer games et.c. from outside of the EU
11:56:45 <shapr> sounds like Time Warner has taken over Denmark
11:57:46 <Marvin--> well, it also sounds like it'll be a EU directive
11:57:46 <Heffalump> wouldn't that violate WTO rules?
11:58:35 <shapr> if it becomes illegal to rip CDs I own, I'll sell all of my CDs.
12:00:15 <Marvin--> "Infosoc-reglene gjør det ulovlig å flytte innhold fra et medium til et annet, skriver danske ComOn. Du har med andre ord ikke lov til å kopiere musikk fra en CD over på en PC og for eksempel MP3-format. I praksis vil derfor alle MP3-kopier av kommersiell musikk bli ulovlige. Det blir også ulovlig å kopiere CD-plater til Minidisc eller andre lagringsformater."
12:00:50 <Marvin--> "The infosoc rules makes it illegal to move content from one medium to another, writes Danish ComOn. In other words, you are not allowed to copy music from a CD to a PC in e.g. MP3 format"
12:01:04 <Heffalump> what about playback buffers?
12:01:21 <Marvin--> "In practice, MP3 copies of commercial music will be illegal. It will also be illegal to copy CDs to Minidisc or other storage formats."
12:01:28 <Marvin--> good question :)
12:01:54 <Marvin--> I guess this means it'll also be illegal to copy CD to tape, and LP to tape? LP to CD?
12:02:39 <shapr> yup
12:02:49 <shapr> oh
12:02:58 <shapr> it'll also mean you can't video tape any video feed
12:03:23 <shapr> so News cameras won't be able to film a city from a distance because they might get video feeds from a shop window
12:04:03 <Marvin--> :)
12:04:25 <Marvin--> VCRs'll be illegal too I suppose
12:04:30 <shapr> yup
12:04:45 <shapr> so will digital cameras
12:04:54 <Marvin--> great
12:04:55 <shapr> because logos on Tshirts are content
12:05:24 <shapr> if you accidentally catch a coca-cola bottle in your picture, you need to make an agreement or be sued.
12:07:27 <dark> shapr: That's already an issue for movie makers.
12:07:50 <shapr> copyright law is very broken, and getting worse all the time
12:07:55 <dark> shapr: They have to be very careful about what kind of stuff is visible in the background.  Of course, these days they call it "product placement" and get paid for it, but they still need a license.
12:08:19 <shapr> I remember when they started putting the CDs into players upside down in ads because of copyright problems
12:08:29 <shapr> that still irritates me
12:08:40 <dark> This is also why people in movies sing "He's a jolly good fellow" instead of "Happy birthday".  The latter is still under copyright and they'd have to pay for it.
12:08:47 <Heffalump> lol
12:09:00 <Marvin--> "Det er uvist om den nye lov får konsekvenser for den afgift, der i sin tid blev pålagt digitale medier for at kompensere kunstnerne for den digitale kopiering."
12:09:23 <Marvin--> "It is unknown if the new law will have consequences for the fee that's added on digital media to compensate for the costs of digital copying"
12:09:29 <dark> shapr: That doesn't make sense.  People could conceivably decode the music from a picture of the data side, if they have the right equipment.  Not so if you show the label side.
12:09:53 <shapr> dark: I don't think anyone has thought of that.
12:09:56 <shapr> at least, no lawyers
12:11:07 * shapr thoroughly despises copyright law
12:29:52 * shapr reads more about monads
12:31:39 <shapr> one of the simons said that "deriving XML" would be possible with template haskell
12:32:04 <shapr> I don't understand how that would work.
12:32:40 <Igloo> I might have some code somewhere that doesn't work. I haven't looked at the problem properly yet, though
12:32:50 <Explodey> shapr: don't know about TH, but re monads, have a look at http://www.cse.ogi.edu/~mpj/pubs/composing.html
12:32:57 <Explodey> I learnt loads from that
12:34:00 * shapr opens that paper and begins to read
12:34:41 <shapr> this looks like something whee would be interested in
12:35:16 <Igloo> http://www.ox.compsoc.net/~igloo/Derive/
12:35:51 <Igloo> Might not make much sense ATM, though
12:37:09 <shapr> actually, it's perfectly clear.
12:37:20 <shapr> hi welw
12:37:37 <shapr> I think I could make "deriving XML" from that example.
12:37:48 <Igloo> Cool  :-)
12:39:16 <Explodey> How does that work then?  Does the compiler dynamically load & use it to generate some of the code?
12:39:27 <shapr> yup
12:39:33 <shapr> Template Haskell is very spiffy
12:39:43 <shapr> it's compile-time macros of much power
12:40:05 <shapr> hey, is TH in 5.04.2 ?
12:40:22 <shapr> or only in HEAD?
12:40:41 <Igloo> Only HEAD I believe
12:40:49 <shapr> ah well
12:41:32 <Explodey> Does it need to be part of the compiler?  I'd have thought that would be better done in a separate step, generating modules to compile later
12:42:01 <shapr> it does that too
12:42:30 <shapr> there are several tight loops of code generation, type checking, and compilation
12:42:52 <shapr> the template haskell paper is easy to read and understand
12:42:59 <shapr> even for non academics such as myself.
12:44:50 <Igloo> Hmmm, not being able to give a variable as the LHS of an assignment inside a record is annoying
12:46:39 <Explodey> As in a temp value thats used to compute a field value?
12:46:56 <Igloo> Yes
12:48:27 <dark> I've run into that too.
12:48:38 <Explodey> I think that syntax is badly designed
12:49:04 <Explodey> To do that you would have to make the assignments recursive
12:49:26 <Igloo> How do you mean?
12:50:05 <dark> I'm not sure what the type of such an assignment specifier would be, though.
12:50:38 <Explodey> Igloo: P {x=x'; y=y'; ...} === let {x=x'; y=y'} in P x y
12:51:17 <Explodey> Igloo: which stops you using the field names as functions
12:52:20 * Igloo starts to suspect the reason Derive doesn't work is because the GHC side is broken
12:53:40 <Explodey> I reckon the name of the field you are updating should have some prefix/suffix, like P {@x = (x oldP +1)} or something
12:54:22 <Explodey> sorry that should be newP {...
12:56:26 <dark> It's usually oldP { ... } or just P { ... }
12:56:35 <dark> It's then bound to newP 
12:57:29 <dark> Awkward syntax, though.  let newP = oldP { p_accessor = p_accessor oldP + 1 }
12:57:46 <dark> Lots of repetition.  I want a map construct :)
12:58:28 <dark> let newP = rmap (+1) p_accessor oldP
12:59:49 <dark> Problem is that you can't write rmap in Haskell, and the type of p_accessor is dubious here.
13:01:32 <Explodey> If the accessors had a prefix/suffix you could mix them with variables, and make the assignments recursive
13:03:14 <Explodey> I reckon it would be nice if you could write: let zeroY = ({accessorY = 0});  instead of: zeroY oldP = oldP {accessorY = 0}
13:03:30 <Explodey> i.e. the ({...}) is a section
13:04:06 <dark> Type P -> Int -> P ?
13:04:15 <Explodey> yes
13:05:01 <Explodey> Then you could use that to emulate named args
13:12:38 <dark> Hmm, but is it really less verbose than let zeroY = \p -> p { accessorY = 0 } ?
13:20:03 * shapr carefully buffs his Socket
13:33:40 * shapr switches from code to counterstrike...
14:33:23 * Marvin-- is reading a number theoretical proof in german, sigh
14:36:30 <Heffalump> heh
14:41:10 <Marvin--> "Alle Transformationen von F = {a,b,c} in sich werden durch die Formel gegeben ..."
14:45:17 <dark> Hmpf.  SDL's keysym structure has one field that's only valid if you set some global toggle.
14:45:58 <dark> Otherwise it contains garbage.
14:46:06 <dark> I'm not sure how to wrap that.
14:47:16 <Pseudonym> Easy: You find the SDL developers, and hit them with a large clue stick.
14:47:34 <dark> And say "You bastards, why didn't you just make a query function instead of adding this field"?
14:47:37 <Heffalump> can you always have the global toggle set one way or the other?
14:47:48 <Pseudonym> Or alternatively put in a sane default if the toggle is not set.
14:47:48 <Heffalump> or can you set it temporarily when needed?
14:48:04 <dark> Heffalump: Indeed, but the reason why this toggle is off by default is that it's somewhat expensive to calculate the field value and it's rarely useful. 
14:48:23 <dark> (It's the unicode translation of the keysym)
14:48:26 <Heffalump> sounds like writing your own query function is the way to go
14:48:54 <dark> Heffalump: I checked the SDL sources.  It's not feasible.  There's different code for it for every platform.
14:49:17 <dark> SDL itself could have easily done it as a query, but I can't do it from outside the system.
14:49:27 <Heffalump> there isn't any function that will turn a keysym into the unicode version?
14:49:42 <dark> Heffalump: Nope.  You ask for it up front, or you don't get it at all.
14:50:07 <Heffalump> ok, well how about a wrapper function to all your functions of type (foo -> bar) -> (foo -> (bar,unicode)) ?
14:50:29 <Heffalump> hmm
14:50:33 <Heffalump> that's probably not quite feasible
14:50:49 <Heffalump> well, it might be, depending on what the type of your functions is
14:51:00 <dark> I could make the KeyInfo type have two constructors, KeyInfo and KeyInfoU.  And then use the value of the global toggle to select which constructor to use.
14:51:12 <dark> This means doing IORef evilness, I bet.
14:51:14 <Heffalump> that'd make client code rather nasty
14:52:35 <Heffalump> are all your SDL functions in IO?
14:52:40 <dark> Well the toggle is under client control :)  Unless I don't allow its use at all, which would eliminate the problem... except that I suspect people will need it.
14:52:59 <Heffalump> if so, you could just have the unicode field be a Maybe type, and allow clients to set the toggle themselves
14:53:01 <dark> Heffalump: Most of them.  There's some exceptions like event_type
14:53:17 <Heffalump> do the ones that aren't depend on the toggle?
14:53:43 <dark> No, only the event parsing code depends on that.
14:54:41 * Heffalump thinks the Maybe type is the way to go then
14:55:26 * Heffalump disappears for a while
14:57:25 <dark> Hmm, would using (chr 0) as a non-valid value be an acceptable alternative to using a Maybe type?
14:58:02 <dark> Because that's what SDL currently does for keys that don't have a unicode value.
15:02:58 <Igloo> Doesn't the simple SDL layer just want to return what SDL does?
15:04:05 <dark> Igloo: With "simple", are you referring to the SDL.Bare interface?  That one returns events as a Ptr Event :)
15:06:53 <Igloo> Ah, well if you're abstracting a bit then Maybe is the Right Thing IMO
15:23:09 <dark> Okay, Maybe it is :)
15:23:17 <aleksi> hello
15:23:49 <aleksi> anyone could tell me about haskell's execution speed compared to something, like C?
15:24:41 <aleksi> I found an old article from '92 which said Haskell to be 5 times slower on file copy and 35 times slower on LZW-compression
15:25:09 <aleksi> is that about right, or was just that implementations, compilers etc. just sucked decade ago?
15:25:48 <aleksi> I wonder this, because I feel Haskell cleaner than Ocaml, but ocaml code goes very fast!
15:26:01 <whee> mmmm, ocaml 
15:26:21 <Pseudonym> aleksi: It's hard to find a fair comparison.
15:26:28 <aleksi> and I'm going to use functional language for the problem at hand, so I should pick up something
15:26:39 <xkb> You could also look at Clean
15:26:48 <xkb> It is said to be very fast
15:26:59 <aleksi> Pseudonym, I understand that. Things are different with different optimizations, platforms, problems, algorithms etc.
15:27:04 <Pseudonym> Mercury is also very fast.
15:27:28 <aleksi> I glanced quickly at Mercury some years ago, wasn't it quite similar to Haskell?
15:27:41 <aleksi> xkb, Clean is new to me, I'll look at it too
15:28:03 <Heffalump> implementations now are a lot better than in '92
15:28:03 <Pseudonym> No, Mercury is like Prolog, only practical.
15:28:04 <xkb> URL: http://www.cs.kun.nl/~clean/
15:28:07 <Heffalump> (well, GHC is, anyway)
15:28:11 <xkb> Merurcy is nice
15:28:17 <xkb> euh,
15:28:21 <xkb> Mercury even
15:28:31 <aleksi> being able to call the Haskell/Ocaml/Clean/Mercury code from C is anyway a must feature (I won't code any IPC to bridge these just for this task)
15:28:42 <Pseudonym> Unfortunately, Mercury's declarations break when you get to a certain level.
15:28:52 <xkb> they do?
15:28:53 <xkb> explain
15:29:06 <Pseudonym> I don't mean bugs, I mean the abstractions are wrong.
15:29:08 <xkb> please :)
15:29:09 <aleksi> and nhc's GreenCard page showed that isn't even hard to call Haskell
15:29:10 <xkb> Ah
15:29:11 <xkb> ok
15:29:34 <Pseudonym> Higher order predicates or functions deep inside data structures require highly complex mode declarations.
15:29:49 <Pseudonym> Admittedly, this case comes up rarely in practice.
15:29:57 <xkb> true.. I think the mode defenitions may well be the "Weak" point of mercury
15:30:10 <xkb> nice typing today :(
15:30:14 <Pseudonym> I don't think so personally.
15:30:25 <Pseudonym> Mode declarations are absolutely the right way to go in logic programming.
15:30:33 <Pseudonym> I just don't think Mercury has hit the "sweet spot".
15:30:49 <xkb> Could a compiler infer modes?
15:30:55 <Pseudonym> Mercury does, to some extent.
15:31:14 <xkb> for det only?
15:31:26 <Pseudonym> No, mode analysis happens before determinism analysis.
15:31:36 <xkb> aha
15:31:41 <Pseudonym> I don't think that the mode inference mechanism works with unique modes very well.
15:31:43 * Pseudonym can't remember
15:31:49 <Pseudonym> All my code had mode declarations everywhere.
15:32:03 <Pseudonym> It's way better if you do.
15:32:16 * xkb is going to bed :(
15:32:20 <Pseudonym> :-)
15:32:29 <xkb_AFK> cya
15:32:32 <Pseudonym> Night.
15:32:36 <aleksi> thanks
15:32:55 <Pseudonym> Anyway, aleksi, back to your question.
15:33:33 <Pseudonym> The Pseudoknot benchmark is probably the fairest one to date.
15:33:51 <Pseudonym> Only the results are all over five years old.
15:35:58 <Pseudonym> Really, though, you've got to weigh other things against execution speed.
15:36:36 <Pseudonym> But how could you benchmark, say, a Haskell program against equivalently robust and maintainable C code?
15:37:41 <whee> very carefully. :P
15:37:48 <Pseudonym> :-)
15:38:08 <Pseudonym> And finally, in the real world, development and maintenance _cost_ is often the deciding factor.
15:38:20 <Pseudonym> If you're Oracle, you don't even let people benchmark your software at all.
15:40:45 <dark> Pseudonym: Strange; then what about Oracle's challenge to Microsoft?
15:41:23 <aleksi> dark, what's that
15:41:44 <aleksi> Pseudonym, yes, I understand completely
15:43:05 <dark> aleksi: I don't remember the details :)  But at a techie convention, the head Oracle guy declared that an Oracle server was more than 100 times faster than Microsoft's database server, and offered a $1 000 000 prize to anyone who could prove otherwise.  It was a nifty stratagem.
15:43:07 <aleksi> my weekend task will be: 1) find functional language to try usefully with simple calculation problem, 2) develop a solution, 3) interface the working functional code from C (or other language using C as a bridge)
15:43:50 <aleksi> dark, unbelievable. But that's great to hear! Did anyone win?
15:44:11 <dark> aleksi: I don't know :)  The challenge was valid for a year, I don't know if anyone collected.
15:44:28 <aleksi> pseudonym, so I'm surfing around to pick a FP language that I can live with for some time.
15:44:34 <whee> aleksi: I think you may like ocaml
15:44:49 <whee> I do, anyway. my experience with haskell so far has been frustrating, to say the least
15:44:55 <dark> Presumably they would have been happy to pay up if someone proves it's "only" 5 times faster, or whatever :)
15:45:09 <aleksi> I know a bit of ML already, and a bit more of Haskell (meaning I've read some haskell book 150 pages, and hudak's SOE 50 pages)
15:45:26 <aleksi> whee, what has frustated you?
15:46:03 <whee> monads for one (I can't find documentation/examples other than what's in some guy's thesis which is way over my head), and performance the other
15:46:36 <aleksi> btw. at the level I'm with FPLs, I don't see any differences between them. A bit like trying to see what's different with all the imperative languages.
15:47:00 <dark> At that level, the main difference is probably the syntax :)
15:47:24 <aleksi> whee, I thought monads were something so great that I would have imagined everybody is using them.
15:47:35 <dark> I use them all over the place.
15:47:49 <aleksi> so I would have supposed there exists loads of free code to surf into
15:48:17 <whee> aleksi: perhaps, I'm still constrained to using the standard IO monad since that's what I found docs for
15:48:32 <aleksi> dark, if you know other FPLs, what would you say are the biggest flavors that one could taste and decide by
15:49:03 <dark> aleksi: Sorry, I don't know much more than Haskell.  I've seen code from others and I've decoded some of it, but I've never written any :)
15:50:28 <dark> It's probably evil for a library to export a data constructor named F.
15:50:52 <dark> Well, I used Gofer but that's pretty similar.
15:51:43 <aleksi> ok
15:52:04 <whee> aleksi: make sure you take nifty tools like camlp4 into account as well :)
15:52:11 * whee loves camlp4
15:53:03 <lament> ocaml seems to be gaining popularity
15:53:12 <lament> there's even a microsoft implementation
15:53:19 <whee> F# is pathetic
15:53:33 <lament> it is?
15:53:41 <lament> Who cares, the point is, it exists
15:53:43 <whee> yeah, it doesn't support all of ocaml
15:54:34 <lament> it _exists_
15:54:42 <whee> :P
15:54:49 <lament> hell, my _father_ knows about ocaml
15:55:04 <lament> well, knows the name
15:55:20 <Pseudonym> Sorry, back again.
15:55:27 <Pseudonym> I work for one of Oracle's competitors.
15:55:34 <Heffalump> F# has the advantage of being properly integrated with .net
15:55:43 <Pseudonym> We can't publish comparative benchmarks.
15:56:05 <Pseudonym> It's in the Oracle licence agreement.
15:57:17 <dark> Pseudonym: Maybe that's why he didn't mind offering a $1 000 000 prize.
15:57:21 <Pseudonym> Perhaps.
15:57:45 <Pseudonym> Although that offer looks to me like a grant to publish comparative benchmarks, at least between MS SQL Server and Oracle.
15:58:16 <Pseudonym> We don't do relational, incidentally.  Our DBMS is a text database system.
15:58:37 <Pseudonym> Oracle makes something sitting on top of a relational database to do text which, as you can guess, is going to be slower.
15:58:54 <Pseudonym> And bigger, too.
15:59:04 <dark> System to store text, then?  First I thought you meant textfile backends :)
15:59:10 * Pseudonym laughs
15:59:22 <Pseudonym> Yes, system to store text.  XML, SGML, MARC, that sort of thing.
15:59:27 <dark> IBM has this database for storing email.
16:00:35 <dark> Pseudonym: Hmm, does it deal sanely with UTF-16?  I've heard of databases that convert the raw values to UTF-8, instead of going back to codepoints first.
16:01:06 <Pseudonym> We store UTF-8 in the actual data store, but you can manipulate your text in UTF-16 or UTF-32.
16:02:30 <dark> Pseudonym: I meant input conversion when UTF-16 texts are inserted.
16:02:59 <Pseudonym> Oh, yes.  We have a scripting language which lets you read in as UTF-16 natively if you want.
16:04:09 <Pseudonym> And Z39.50, which is the protocol we speak, handles it cleanly too.
16:04:40 <dark> Pseudonym: There are probably countries where you could legally ignore the no-benchmarking restriction :)
16:04:52 <Pseudonym> OK, aleksi: If I had to pick functional languages to get the full ideas of the differences, I'd pick O'Caml, Haskell, Erlang and Common Lisp.
16:04:56 <Pseudonym> In approximately that order.
16:05:00 <dark> Then you could do the comparison there, and redistribute the results.
16:05:14 <Pseudonym> True.
16:05:22 <Pseudonym> Unfortunately, that isn't here.
16:05:39 <dark> Heh, I keep forgetting Lisp (and Scheme) as functional languages.
16:05:56 <Pseudonym> It's hard to define "paradigm" sometimes.
16:06:12 <Pseudonym> O'Caml is functional and object-oriented.
16:06:17 <Pseudonym> Lisp is functional and procedural.
16:06:26 <Pseudonym> And so on.
16:06:37 <dark> What makes Lisp functional that doesn't also apply to C, though?
16:06:47 <whee> the O in O'Caml is very nice, as well. You don't even need to know it's there, unless you want to use it, of course.
16:06:50 <lament> first-class functions maybe? :)
16:06:53 <Pseudonym> Functions are first-class objects.
16:07:09 <Pseudonym> You try implementing closures in C.  You'll see why they're not first class.
16:07:17 <Pseudonym> C++ comes pretty close.
16:07:20 <dark> As in, you can assign functions to variables, return them, pass them as parameters?
16:08:22 <Pseudonym> Right.
16:08:24 <dark> Technically, I did implement closures in C.  But that was in an interpreter so it probably doesn't count :-)
16:08:29 <Pseudonym> And put them in data structures.
16:08:48 <Pseudonym> Basically, do everything to them that you can to, say, structs.
16:10:07 <dark> Well, you can do all of that with function pointers.  It doesn't get you closures, though.
16:10:42 <Pseudonym> Right.
16:12:12 <dark> Hmm, Perl does have closures, and anonymous functions.
16:12:16 <Pseudonym> Yes.
16:13:32 <dark> It even has map and filter (grep) :)  So is it a functional language?
16:13:43 <Pseudonym> No.
16:14:03 <Pseudonym> The function still isn't a natural abstraction in Perl.
16:14:45 <Pseudonym> Lots of languages have map and filter or equivalents.
16:15:00 <Pseudonym> I would say that Perl has limited support for functional programming, though.
16:15:21 <Pseudonym> Just like how Haskell has limited support for OO programming.
16:16:03 <lament> what about python? I would call it functional
16:16:11 <lament> but it doesn't even have closures
16:16:16 <Pseudonym> I wouldn't.
16:16:32 <Pseudonym> I'd call Python a scripting language, whose "dominant" paradigm is OO.
16:16:54 <Pseudonym> The natural abstraction in Python is the object.
16:16:55 <lament> Hm, don't try that in #python, you might get hurt :)
16:17:04 <Pseudonym> :-)
16:17:13 <Pseudonym> I don't mean to diss scripting languages.
16:17:23 <Pseudonym> Some of my favourite languages are scripting languages.
16:17:33 <lament> What's a scripting language?
16:17:43 <Pseudonym> And merely being a scripting language doesn't make ou unsuitable for writing full-fledged applications.
16:17:52 <lament> What's a scripting language?
16:17:58 <whee> I consider languages like python, perl, ruby to be scripting languages
16:18:25 <Pseudonym> A scripting language is a) embeddable, b) lightweight and c) supports easy binding to foreign data structures.
16:19:12 <Pseudonym> Of course, some scripting languages are lighter weight than others.
16:19:42 <Pseudonym> The other characteristic which you commonly find in a scripting language is a large library.
16:19:50 <Pseudonym> Often domain-specific, but not always.
16:20:17 <Pseudonym> Oh, and it must support dynamic compilation, too.
16:20:23 <lament> Hrm.
16:20:26 * Pseudonym forgot that
16:21:40 <Pseudonym> But once again, a language is not one or the other always.
16:21:59 <Pseudonym> It requires these features to be a scripting language, but that doesn't mean it's not also an OO application development language.
16:22:07 <lament> Languages aren't embeddable. Implementations are.
16:22:36 <Pseudonym> I disagree.  A language is embeddable if the rules on how to embed it are part of the language definition.
16:22:58 <Pseudonym> Which admittedly they're usually not.
16:23:18 <lament> Hm, I don't think Python has any such rules
16:23:33 <lament> Actually I don't know any language that does
16:23:50 <Pseudonym> Now that I think about it, neither do I.  Hmm.
16:23:59 <Pseudonym> OK, let me rephrase.
16:24:04 <Pseudonym> Oh, hang on.
16:24:05 * Pseudonym thinks
16:24:14 <Pseudonym> Libraries are embeddable.
16:24:33 <Pseudonym> I think that makes sense.
16:24:49 <Pseudonym> Maybe.
16:24:51 <lament> You mean, like C? :)
16:25:03 <Pseudonym> C doesn't support dynamic compilation.,
16:25:25 <Pseudonym> I think there are language features which may rule a language out from being embeddable.
16:25:25 <lament> Like CLisp then?
16:26:13 <Pseudonym> The trouble with embeddability is it's like problems in NP.
16:26:22 <Pseudonym> You know a solution when you see it, but it's very hard to find it.
16:29:30 <lament> anyway
16:29:49 <lament> i don't see how support for OO makes python non-functional
16:29:57 <lament> You said ocaml was functional :)
16:30:40 <Pseudonym> I agree that you can program python in a functional style.
16:31:03 <Pseudonym> However, if it doesn't even have closures, as you say, then the function is definitely not a natural abstraction.
16:31:36 <lament> um
16:31:58 <lament> who did ever say a functional language must have closures?
16:33:47 <lament> closures are only relevant when you can modify variables
16:33:56 <lament> which you're not supposed to, anyway :)
16:34:06 <Pseudonym> Not realy.
16:34:18 <Pseudonym> Currying is a form of making closures.
16:34:40 <Heffalump> closures are needed to implement lexical scoping
16:34:55 <lament> Heffalump: huh?
16:35:00 <lament> Python has lexical scoping, but not closures.
16:35:16 <Heffalump> does it have higher-order functions?
16:35:19 <lament> Yes.
16:35:26 <Heffalump> it must use closures internally, then
16:36:06 <Pseudonym> I think this is all beside the point, though.
16:36:22 <Pseudonym> You can basically simulate any paradigm in any Turing-complete language.,
16:36:33 <Pseudonym> Hell, you can write garbage collected C if you want to.
16:37:01 <lament> But C doesn't have garbage collection primitives
16:37:08 <Pseudonym> I think it's a question of what are the natural abstractions of the language.
16:37:24 <Pseudonym> lament: Doesn't matter.  Use a conservative collector, like Hans Boehm's.
16:37:32 <lament> I say that functions _are_ natural abstractions in Python
16:37:36 <Pseudonym> A lot of GCC 3 is written in garbage collected C.
16:37:51 <lament> Along with objects.
16:38:29 <whee> hooray, I'm an idiot
16:38:34 <Pseudonym> I really don't know enough Python to be able to comment much further here.
16:38:40 <seth_> The big problem with C++, w.r.t. garbage collection, is the loss of control of when destructors are run.
16:38:44 <whee> anyone ever worked with trie structures when dealing with indexing strings?
16:38:54 <Pseudonym> whee: Yes.
16:39:02 <Pseudonym> seth_: Agreed, absolutely.
16:39:02 <whee> they're insanely easy to implement, correct?
16:39:12 <Pseudonym> Er... sort of.
16:39:24 <seth_> Not so insanely easy to implement efficiently.
16:39:58 <whee> I'm getting lost on insertion looking at this one implementation, I'm not seeing how it's figuring out what subtrees to create :\
16:40:10 <Pseudonym> It's like asking if binary search trees are insanely easy to implement.  They are.  The difficulty is getting them efficient.
16:40:47 <seth_> On the other hand, if you've implemented them in C, then implementing them in Haskell does look insanely easy.
16:40:50 <whee> if you were using strings, you'd be analyzing it by characters, correct?
16:41:00 <Pseudonym> lament: I contend that if it came down to a choice between using a higher-order function and passing in an object, most Python programmers would pick the object any time.
16:41:05 <Pseudonym> whee: Yes.
16:41:33 <Pseudonym> I also contend that they would have good reasons to prefer the object.
16:41:49 <lament> Pseudonym: so if haskell had neat first-class objects, it would no longer be a functional language?
16:42:11 <whee> python wasn't designed to be a functional language, haskell was
16:42:26 <Pseudonym> If they were mutable objects, it wouldn't be a pure functional language, of course.
16:42:26 <dark> About embeddability, I think tcl might be one where the embedding rules are part of the language specification.
16:42:42 <seth_> Pseudonym: The first part, anyone more accustomed to imperative programming would go for the object.  As for the reasons, I wouldn't be quite so definitive.
16:43:02 <Pseudonym> seth_: That may be true.
16:43:50 <seth_> Pseudonym: Having just spend the last two days finding heap corruption in a big C++ program, I can't wait to get back to my Haskell code.
16:43:59 <Pseudonym> :-)
16:44:19 <seth_> It almost makes you read to use Java.  But not quite.
16:44:38 <dark> seth: There's not necessarily a distinction.  The normal way of passing a function in Java is to define an object with that function as a method.
16:45:08 <dark> So is the programmer using a higher-order function, or passing in an object? :)
16:45:17 <lament> passing an object.
16:45:19 <seth_> dark: Yes; I was referring to Java compared to C++, so it was somewhat out of context.
16:46:50 <Pseudonym> I quote from the c.l.f FAQ: "It is often possible to write functional-style programs in an imperative language, and vice versa. It is then a matter of opinion whether a particular language can be described as functional or not." 
16:46:53 <dark> lament: But in this case the object doesn't even have a name, whereas the function does.
16:47:55 <lament> dark: imo, if an operation is not a primitive, it's not a part of the language
16:48:19 <lament> you can use function pointers in C, but that doesn't mean it has first-class functions
16:48:19 <lament> etc
16:49:04 <Pseudonym> lament: Perhaps you can clarify something.  When you do a lambda abstraction in Python, is applying an argument to it the only operation you can do?  Or is it an object with other methods?
16:49:06 <seth_> This is to a great extent a question of semantics.  Is X windows, written in C with OO techniques, OO?  It all depends whether you require enforcement by the compiler.
16:49:18 <lament> Pseudonym: an object
16:49:20 <seth_> And whether you believe that C++ is OO, but that is another question entirely.
16:49:37 <lament> Pseudonym: in python, everything is an object
16:49:42 <seth_> Demanding compiler enforcement is not the only definition, but it is a reasonable one in my opinion.
16:49:44 <Pseudonym> lament: That's what I thought.  If everything in Python is an object, it's OO.
16:49:55 <Pseudonym> It may support functional style, but OO dominates.
16:49:58 <lament> no, if everything in python is an object, it's sane :)
16:49:59 <seth_> Because, otherwise, it is impossible to know whether it is in fact coded functionally.
16:50:11 <whee> in soviet russia, objects inherit you.
16:50:13 * whee runs
16:50:22 <Pseudonym> Dirty slashdotter.  We don't like your kind here.
16:51:07 <seth_> I vote for:  if it has an assignment operator, it isn't a functional language.  Nice, simplistic, no thinking required.
16:51:13 <lament> seth_: no
16:51:20 <lament> seth_: s/functional/purely functional
16:51:24 <whee> well, ocaml has references, which are assignments
16:51:26 <Pseudonym> Lisp has an assignment operation.
16:51:31 <Pseudonym> ML has an assignment operator.
16:51:33 <seth_> lament: Correct, I accept the s//
16:51:37 <dark> ... I don't think of Lisp as a functional language :)
16:51:58 <Pseudonym> I do, but then I think of Simula as an object oriented language.  I'm weird like that.
16:52:04 <dark> When challenged, I'll probably agree to add it to a list of functional languages, but I would never think of putting it there in the first place.
16:52:36 <Pseudonym> Fortran is a procedural language, even back when it didn't support recursion.
16:53:08 <seth_> Simula is an OO language.
16:56:56 <Pseudonym> Anyway, these things are not hard-and-fast.  I think it makes sense to identify paradigms which dominate a language, and to acknowledge that languages provide support for other paradigms.
16:57:31 <Pseudonym> But a language always has one or more _dominant_ paradigms, and that's the qualifier I'd put before the word "language".
16:57:50 <seth_> Sure, but I make a distinction between "it is theoretically possible to write a functional program" in language X and "it is practically possible to write a functional program" in language X.
16:58:03 <Pseudonym> There are three levels here:
16:58:11 <Pseudonym> 1) It's theoretically possible.
16:58:17 <Pseudonym> 2) It's practicaly feasable.
16:58:25 <Pseudonym> 3) It's not hard at all.
16:58:29 <Pseudonym> 4) It's actively encouraged.
16:58:32 <Pseudonym> OK, that's four levels.
16:58:46 <lament> Python's 3 then
16:59:01 <lament> C is 2, i guess
16:59:07 <Pseudonym> So, for example, OO programming is theoretically possible in assembler, feasable in C, not hard in Haskell and encouraged in Python.
16:59:09 <Pseudonym> For example.
16:59:11 <lament> and any language is 1, so 1 is kinda pointless :)
16:59:17 <seth_> How about: 5) The compiler insists on it.
16:59:21 <lament> s/is/it's
16:59:45 <Pseudonym> In Python, I think the fact that everything is an object strongly suggests that Python is dominantly OO.  i.e. it's 5 on the OO scale.
17:00:21 <seth_> Perhaps internally, but not in the standards it enforces for compiled programs.
17:00:52 <Pseudonym> Well I'm referring to what it exposes at the language level.
17:00:54 * whee suppresses the uge to start functionalornot.com
17:00:56 <whee> urge :(
17:01:03 <Pseudonym> How it implements it is beside the point.
17:01:24 <seth_> Then you can't call Python highly OO.  You can write programs that are zero OO.
17:01:39 <Pseudonym> Hmmm.
17:01:52 <seth_> Most any C program can be translated to Python line for line.
17:04:44 <Igloo> Is anyone familiar with GHC's existential quantification around?
17:05:20 <Pseudonym> Yeah.
17:06:37 * Igloo starts asking a question and discovers it doesn't make sense and goes to read the docs again
17:07:21 <Pseudonym> Existential quantification is like that.
17:07:37 <Igloo> OK, is it just data constructors that can have such types on them? So if I wanted a list of things of different types they'd all have to be wrapped up in some datatype?
17:07:52 <Pseudonym> Data constructors and functions.
17:08:06 <Igloo> OK, that's no use then
17:08:11 <Pseudonym> What did you want to do?
17:08:30 <Igloo> And once more I am saved from straying to the Dark Side  :-)
17:09:10 <Igloo> I want a list of GTK+HS Widgets, but if I was going to wrap them up I could just call widget on them all and still be in H98
17:09:14 <Pseudonym> Or at least you're saved from being lynched by the awkward squad.
17:09:24 <Igloo> (+TH+FFI. *cough*)
17:09:26 * Heffalump reminds Igloo who his sponsor is :-)
17:09:53 <Igloo> :-)
17:09:57 <Pseudonym> Awkward squad sounds like a rejected 70s cop show.
17:11:00 <Igloo> Hmmm, a nasty solution would be to have mk_hbox etc widgetify their results
17:23:46 <seth_> Anyone here read this language?  It has something I need on it, and I don't even know what language it is, except that it is clearly neither of the ones I can speak.  Here is a line:
17:23:49 <dark> It's a pity you can't add "deriving" clauses to imported types.  I find myself adding (Eq, Ord, Show) to all of the library types just in case someone might need them. 
17:23:55 <seth_> PlnÃ½ text tohoto referÃ¡tu vcetne vsech jeho cÃ¡stÃ­ a prÃ­kladu si muzete stÃ¡hnout zde.
17:24:27 <seth_> Is it Romanian?
17:26:03 <lament> hm, no.
17:26:22 <lament> it's definitely slavic
17:26:47 <Heffalump> Romanian isn't slavic?
17:26:50 <lament> no
17:26:53 <lament> romanian is romance
17:26:56 <seth_> Yes.  Too bad it isn't Romanian; I have a friend who could read it if it were.
17:26:59 <Heffalump> ah, that'd make sense :-)
17:27:04 * Heffalump shows his ignorance
17:27:13 <seth_> Actually, I was surprised to learn that Romanian isn't all that far from Spanish in structure.
17:27:26 <lament> romanian and spanish are both romance
17:27:35 <lament> both descened from vulgar latin
17:27:39 <lament> descended
17:28:07 <seth_> Hey, I spent seven years learning to speak Spanish badly.  Don't call it vulgar.   :)
17:28:25 <Heffalump> vulgar latin as opposed to golden/silver latin :-)
17:29:00 <lament> seth_: anyway, that text pasted incorrectly
17:29:14 <lament> or at least shows up incorrectly in my client
17:29:24 <seth_> lament:  Ok    :)
17:29:53 <lament> try czech or something. I don't know, really.
17:32:10 <dark> I missed a bit, but if you're discussing encoding, it looks like UTF-8 to me.
17:32:34 <seth_> dark:  I'm hoping to find someone who can read it.  It has some information that I need.
17:33:51 <dark> Hmm, I need a function that takes an Int, and returns a list of the bits that are set in its binary representation.
17:35:34 <Igloo> Are you sure you don't need a functino that takes a Word32 and ...?
17:36:14 <whee> should be a quick recursion
17:36:17 <Igloo> In which case map (`testBit` x) [0..31] might do it (with Bits from FFI, IIRC)
17:36:38 <whee> or that, heh
17:39:58 <dark> Cool, I didn't know there was a testBit :)
17:41:28 <dark> bit_flags :: (Bits a) => a -> [Int]
17:41:28 <dark> bit_flags n = map (testBit n) [0 .. bitSize n - 1]
17:41:31 <dark> I think this is it.
17:42:04 <Igloo> Does it really return an Int?
17:42:24 <dark> Hmm, maybe add Bounded a to the context.  I think there's a Bits instance for Integer, and bitSize is undefined on it.
17:43:02 <dark> Oops, no.  testBit returns Bool.
17:43:09 <dark> Oh, duh.  filter :)
17:43:44 <Igloo> Oh, right, you wanted a list of bit numbers
17:44:11 <dark> Yeah.  It's to make a list of mouse buttons :)
17:45:00 <dark> SDL supports up to 8 of them.  I'm not sure if I should put the left/right/middle stuff in the datatype.
17:46:12 <dark> Since I don't remember if middle was button 2 or button 3, maybe I should :)
17:46:36 <Igloo> Are you going to invent names for the others, too?  :-)
17:48:11 <dark> Sure.  up, down, top, bottom, charmed and strange :)
17:48:24 <dark> Oh wait, that makes 9 button.
17:49:03 <Igloo> Well, a button that diverges isn't very useful, so you may as well omit bottom
17:52:40 <dark> Heh.
17:53:00 <dark> I could add it as the mystery 9th button.  You can never know if it's been pressed or not.
17:54:35 <dark> One of the best things about Finland is the smoked salmon.
17:55:09 <dark> Hmm, I have a linguistic objection to "one of the only", but it appears I freely use "one of the best".  I'm inconsistent.
17:58:34 <Igloo> :-)
18:05:30 <Igloo> I have writing usage messages for Haskell programs
18:05:35 <Igloo> s/have/hate/
18:07:19 <dark> Igloo: Because of the RTS flags?
18:08:04 <Igloo> Because of the lack of things like HERE documents
18:08:45 <dark> GHC has no trouble with them :)
18:08:54 <dark> Multi-line strings, I mean.
18:09:26 * Igloo has made it all fit sanely now  :-)
18:10:06 <Igloo> Oh, except I forgot to make it possible for --version to be passed back
18:10:15 * Igloo cheats
18:10:48 <dark> You could make the usage information really short, and then supply a manpage.
18:11:05 <Igloo> But usage information is a Good Thing
18:11:22 <dark> Well, yes.
18:11:38 <dark> harc has pages and pages of it, but I feel no shame about using multiline string literals :)
18:11:49 <Igloo> :-)
18:13:33 <dark> Another thing I did shamelessly was to define "--version" as a command instead of as an option :)
18:13:58 <Igloo> lol
18:14:00 <dark> s/command/subcommand/
18:14:19 <Igloo> And --help too?
18:14:44 <dark> No, every subcommand supports --help.  But --version can only be used as "harc --version"
18:15:13 <dark> I still do trickery with --help, though.  "harc foo bar --help" gets rewritten to "harc help foo bar" and ends up as an invocation of the "help" command.
18:15:36 <Igloo> Oh, of course, because it varies from command to command
18:15:40 <dark> (It doesn't matter where --help occurs on the command line)
18:16:00 <dark> Yeah.  But I didn't want to even suggest that "harc commit" might have a different version than "harc get" :)
18:18:09 <Igloo> :-)
18:19:42 <Igloo> Not being able to line up if-then-elses in do blocks is annoying too
18:20:10 <dark> Yeah, I changed my indenting habits for if-then-else because of that.
18:20:37 <Igloo> Anything else has things flying off to the right of the page, though
18:20:52 <dark> That might mean you're nesting too deeply :-)
18:21:24 <Igloo> Well, I have 'if "--help" `elem` args' for help, version and gtk
18:21:40 <dark> I sometimes do like this:
18:21:43 <dark> if foo
18:21:47 <dark>   then dofoo
18:21:48 <dark> else if bar
18:21:51 <dark>   then dobar
18:21:55 <dark> else if gnu
18:21:57 <dark>   then dognu
18:22:10 <Igloo> Can't do that in a do with layout either
18:22:10 <dark> Er, wait.
18:22:17 <dark> Let me look up what I did :)
18:22:27 <Igloo> :-)
18:22:41 * Igloo has just indented all but the if by 1 for now
18:22:43 <dark> if foo
18:22:49 <dark>   then do foostuff
18:22:53 <dark>   else do
18:22:55 <dark> if bar
18:22:57 <dark>   then do barstuff
18:22:58 <dark>   else do
18:23:09 <Igloo> Ewww
18:23:37 <Igloo> Is that really "do foostuff"?
18:23:47 <Igloo> If so you don't need the "do"s after the elses
18:23:59 <dark> foostuff is a bit longer :)
18:24:15 <Igloo> Well, I meant the space between do and foostuff
18:24:27 <dark> Hmm.
18:25:14 * Igloo realises that TH couldn't cope with Fraskell 0.1.0 and gtk+hs won't be able to cope with 0.2.0
18:25:28 <dark> Are you sure?  I think I need a "do" to make the following "if" start a new indent level.
18:25:54 <Igloo> Ah, do you have to be inside another do for other reasons?
18:26:11 <Igloo> if b then do x else do y :: m a
18:27:07 <dark> Well the whole thing is inside another "do", which collects some information before the branching starts.
18:27:20 <Igloo> Ah, right, OK
18:28:11 <dark> In another function I started using this technique but it got way too complicated, and I ended up converting to use of this function:
18:28:15 <dark> firstJustM :: (Monad m) => [m (Maybe a)] -> m (Maybe a)
18:29:11 <dark> Then I made all the if-then-elses into (if foo then Just foo else Nothing) style expressions, and ran this over a list of them.
18:29:26 <dark> Er, there's some returning going on as well :)
18:29:40 <dark> That cleaned it up immensely.
18:29:45 <Igloo> *nod*
18:30:28 <dark> Hmm, you may have helped me write firstJustM :)  I remember discussing it here.
18:30:45 <Igloo> Heh
20:37:53 <Pseudonym> Bah.  No joy.
20:38:14 <Pseudonym> Does anyone here know much about Linux kernel internals?
20:55:54 <seth_> Some...
20:57:20 <Pseudonym> If I mmap some or all of a file, is it also buffer cached?
20:57:26 <Pseudonym> Or is my view the buffer cache?
20:58:10 <Pseudonym> I ask because it's the same as the buffer cache under Solaris, but it's separate under Win NT.
20:58:37 <Pseudonym> Which means that if you want to mmap a large file under NT, you may in general use twice the memory.
20:58:53 <Pseudonym> OTOH, under Solaris, if you write while the area is being flushed to disk, you block.
21:16:37 <seth_> Pseudonym: I believe that Linux is closer to Solaris, and does not routinely double buffer.  I can't say that it never does; I don't know it to that level of detail.
21:18:05 <Pseudonym> Understood.  I don't know either, which is why I'm asking. :-)
21:18:08 <Pseudonym> Thanks anyway.
21:18:12 <Pseudonym> Gotta go.  Farewell.
21:22:15 <seth_> Bye
