02:47:20 <xkb> where can I find haskell cafe mailing list subscription forms?
02:48:18 <xkb> andersca: is there a ghc for Mac OSX
02:48:24 <andersca> I have no idea
02:49:02 <xkb> I could only find hugs
02:49:35 <xkb> http://lambda.weblogs.com/ for interessting links and articles btw
02:54:42 <Heffalump> xkb: Linked from http://www.haskell.org surely?
02:54:46 <norpan> wwhttp://www.haskell.org/mailinglist.html
02:54:52 <norpan> sorry, no ww
02:55:37 <Heffalump> hi
02:55:47 <opet> hello
02:56:09 <norpan> xkb: there is a ghc for mac os x, at least the ghc page says so
02:56:23 <norpan> http://www.haskell.org/ghc/dist/5.04.2/MacOSX/GHC.5.04.2.dmg
02:56:23 <xkb> norpan: keej.. checking it out now
02:56:29 <xkb> cool
03:15:35 <xkb> does anyone here have some nice examples of getException?
04:42:32 <whee> hoorj
04:58:20 <BlitzNL> I am working on a truth table for propositional logic. With list comprehension I can do something like this: [[x,y] | x <- [True, False], y <- [True,False]]. This works fine but what I would like to have is a variable number of vars([x,y] may be [x,y,z] ) . Anyone has an idea? I am trying to do this since my lunch break so.. ;)
04:59:13 <BlitzNL> btw to get the idea; [x,y,z] should yield to [[True,True,True],[True,True,False],[True,False,True],[True,False,False],[False,True,True],[False,True,False
04:59:13 <BlitzNL> ],[False,False,True],[False,False,False]] 
05:03:01 <xkb> write a function that returns that list?
05:03:08 <xkb> without list compr.
05:03:57 <xkb> but there must be a better way
05:04:44 <xkb> getCombinations :: Int > [Bool]
05:06:53 <Igloo> tf 0 = [[]]; tf (n+1) = let xs = tf n in map (True:) xs ++ map (False:) xs
05:07:24 <Igloo> Actually, the second clause is probably nicer as a list comprehension
05:07:34 * xkb applaudes
05:08:16 <Igloo> And it would avoid the ++s too
05:08:26 <Heffalump> but you'd get the results in a different order
05:08:36 <Heffalump> (not that this really matters)
05:08:36 <xkb> Is list concat slow in haskell 2?
05:08:47 <Heffalump> it's linear in the left-hand argument
05:08:50 <BlitzNL> xkb: that was quick ;) 
05:09:49 <Igloo> Not if you have your generators the right way round
05:12:16 <Heffalump> well, it'll do an implicit concat anyway
06:39:04 <shapr> so, did I miss anything exciting?
06:39:53 <shapr> Microsoft converted to Haskell while I was away?
06:41:24 <Igloo> 'fraid not - not more than they have been already, anyway
06:43:28 <shapr> oh well
06:43:30 <shapr> anything else happen?
06:43:40 <shapr> hi inkedmn, how's it goin?
06:44:00 <inkedmn> shapr: going alright, just got into work
06:44:07 <inkedmn> how about you?
06:44:12 <shapr> aha, california
06:44:20 <shapr> looks like SoCal
06:44:55 <shapr> I'm doing well, writing for-pay Python, looking forward to an evening of Haskell.
06:45:02 <shapr> inkedmn: what do you do for work?
06:45:28 <inkedmn> shapr: i'm an "exam services technician" (i'll explain)
06:45:37 <inkedmn> i work for a company that makes testing software
06:45:44 <shapr> oh neat
06:45:47 <inkedmn> for state certifications, psych testing, that sort of stuff
06:45:59 <inkedmn> so i support the java product, and do some python programming
06:46:05 <shapr> oh I have to ask if you guys do unit testing :-)
06:46:13 <shapr> if you don't I'll laugh myself silly
06:46:15 <shapr> :-)
06:46:49 <inkedmn> i'm not sure :)
06:46:55 <inkedmn> i do more of the latter than the former :)
06:47:05 <shapr> er, laughing rather than testing?
06:47:06 * shapr grins
06:47:45 * shapr prefers python over java also
06:48:17 <inkedmn> so far, i'm mostly writing stuff to help out the actual programmers
06:48:30 <inkedmn> cheeseball little odds-and-ends stuff
06:48:37 <shapr> have you tried jython?
06:48:59 <shapr> jython is very spiffy.
06:49:10 <inkedmn> i've read about it, haven't written much code in it though
06:49:12 <inkedmn> i'd like to 
06:49:44 <shapr> I wrote a tiny powerpoint app in Jython in about three weeks.
06:50:16 <inkedmn> heh, nice :)
06:50:18 <shapr> the presentations were displayed on a Nokia 9210, so it couldn't do too much.
06:51:35 <shapr> in my experience, I can write jython code in about one third the time and one quarter the lines of equivalent java code.
06:51:51 <shapr> I'm a python bigot, so that may have something to do with it.
06:51:55 <inkedmn> i'll bet
06:51:57 <inkedmn> so am i :)
06:52:16 <shapr> I'm also a Haskell bigot :-)
06:52:25 <inkedmn> i'm really curious to see how easy it would be to incorporate a class in jython into regular java...
06:52:33 <inkedmn> shapr: i can imagine
06:52:34 <inkedmn> :)
06:52:45 <inkedmn> i'm very excited to learn haskell (and fp in general)
06:52:50 <shapr> it's great
06:53:23 <shapr> I haven't quite gotten monads down, but I'm working on that.
06:53:54 <shapr> er, not to distract you from work, but do you use higher order functions much in python?
06:54:01 <inkedmn> i've written THREE functions so far :)
06:54:05 <shapr> wow cool!
06:54:08 <shapr> what did write?
06:54:18 <inkedmn> heh, well, they're all really lame :)
06:54:23 <inkedmn> a factorial
06:54:29 <inkedmn> an implementation of "map"
06:54:36 <inkedmn> and a mult function
06:54:39 <shapr> that's pretty good
06:54:49 <shapr> are you working through the Thompson book?
06:55:02 <inkedmn> not yet, i'm hoping my wife will get it for me for Xmas :)
06:55:13 <inkedmn> for now, i just have a tutorial and some friends who know more fp than me :)
06:55:23 <inkedmn> but i'm hoping to score that book soon
06:55:32 <inkedmn> i'll buy it myself if nobody buys it for me :)
06:55:56 <shapr> heh
06:56:05 <inkedmn> oh, and about the high order python functions:
06:56:09 <inkedmn> no, not really :)
06:56:16 <shapr> my fiancee bought Thompson and Hudak for my birthday last year
06:56:24 <inkedmn> heh, nice :)
06:56:26 <inkedmn> how old are you?
06:56:54 <shapr> I'm thirty one, how old are you?
06:56:58 <inkedmn> 24
06:57:22 <shapr> any children?
06:57:30 <inkedmn> heh, not yet 
06:57:44 <inkedmn> as soon as i start making some real money and my wife doesn't have to work
06:57:56 <shapr> yah, I understand that
06:58:10 <shapr> especially in SoCal, it's expensive there
06:58:14 <inkedmn> but we really want kids
06:58:18 <inkedmn> indeed :)
06:58:40 <inkedmn> i know i've already asked you, but you're in AZ?
06:58:46 <shapr> nope, sweden
06:58:57 <inkedmn> lol, ok
06:58:59 <shapr> I lived in San Diego for six months long ago
06:59:05 <inkedmn> oh, really?
06:59:08 <inkedmn> did you like it?
06:59:13 <shapr> yah, it was ok
06:59:19 <shapr> too much pollution at the time
06:59:22 <inkedmn> yeah
06:59:52 <shapr> it's the only time I've lived in a desertish climate
07:00:17 <shapr> it was quite a culture shock
07:00:30 <shapr> inkedmn: have you lived elsewhere in the states?
07:00:48 <shapr> I spent most of my life in the southeastern US states.
07:00:52 <inkedmn> no, i haven't
07:00:56 <inkedmn> been in socal my whole life
07:01:02 <inkedmn> gotta make a phone call, brb
07:01:05 <shapr> ok
07:01:08 * inkedmn is away: phone
07:05:30 * inkedmn is back (gone 00:04:22)
07:06:08 <Igloo> How's banana doing, shapr?
07:06:15 <shapr> I've fallen
07:06:18 <shapr> and I can't get up
07:06:19 <shapr> :-P
07:06:20 <inkedmn> man, getting to see the sunrise every morning is pretty cool
07:06:28 <shapr> I slipped on the banana peel I think
07:06:29 * Igloo blinks
07:06:51 <shapr> Igloo: more seriously, I don't think I can continue until I'm fluent in monads.
07:07:00 <Igloo> Ah, right  :-(
07:07:03 <shapr> so I'm trying to make that jump.
07:07:23 <shapr> monads are a serious mental wrench for me
07:08:04 <shapr> first time I did procedural programming was on a Sinclair something
07:08:21 <shapr> hi Marvin--
07:08:45 <seth_> shapr: you might be almost as old as I am.  Sinclairs haven't been around for a LONG time.
07:08:51 <shapr> Igloo: any advice for shifting paradigms?
07:08:57 <shapr> seth_: how old are you?
07:09:07 <seth_> shapr: Few months short of 50
07:09:15 <shapr> seth_: I got lucky, a friend of mine won a Sinclair in a contest.
07:09:21 * Igloo hasn't looked at monads seriously yet, I just use the interfaces provided to me
07:09:24 <shapr> nah, I'm just thirty one
07:09:31 <Marvin--> afternoon
07:09:35 <Heffalump> did Igloo just say he hasn't looked at monads seriously?
07:09:46 <Igloo> He did - why?
07:09:50 <seth_> shapr: Not all that lucky    :)
07:10:06 <Igloo> Do you disagree or just think I should have done?  :-)
07:10:10 <shapr> seth_: I was lucky to end up with lots of social connections to computer people when I was young
07:10:13 * Igloo has lost a cvs tree
07:10:23 <shapr> friend of mine was an RPG programmer when I was ... eleven?
07:10:35 <shapr> I got to use a K-Pro .. Rainbow? running CP/M
07:10:54 <seth_> shapr:  I was just being cheeky about the hardware.  The CP/M Kaypros weren't bad boxes.  I write drivers for them.
07:10:59 <shapr> the guy who had the K-Pro had 256 bytes of real core memory!
07:11:06 <shapr> that was the coolest piece of hardware I've ever seen
07:11:19 <shapr> real metal rings
07:11:29 <shapr> I could have put three of them side by side on my thumbnail
07:11:44 <seth_> shapr: The CP/M Kaypros were limited to 64K.  That must have been an early MSDOS Kaypro.
07:12:00 * Igloo prods Heff with a big stick
07:12:03 <shapr> the core memory was from something else entirely, I don't know what.
07:12:39 <shapr> seth_: drivers for Kaypros, I'm impressed
07:12:49 <shapr> seth_: have you made the jump to understanding monads?
07:13:21 <seth_> shapr: Well, I can use them effectively now, but as to whether I really _understand_ them, probably not quite there yet.
07:13:49 <shapr> how did you get to effectively using them?
07:14:16 <shapr> I've read lots about monads, I understand their properties just fine.
07:14:48 <seth_> shapr: Mostly I figured out (with help here) how to get from a monadic type to a regular type.  The docs tell you about using return to get from a regular to a monadic type, but the situation that usually arises is the monadic to regular.
07:15:04 <shapr> right exactly
07:15:06 <shapr> that's what I want to know
07:15:15 <shapr> er, I think
07:15:37 <seth_> shapr: If you ignore the do construct and use the combinators, things fall into place.
07:16:14 <seth_> I did not quit.   :)
07:16:16 <shapr> I'd like to know how to take an existing function that uses explicit argument passing, and turn that into a monad setup.
07:16:28 <shapr> ok, I'll work with combinators more.
07:17:42 * Marvin-- giggles at a funny web page
07:35:16 * Heffalump reappears
07:35:19 <Heffalump> igloo: I disagree :-)
07:35:30 <Heffalump> and how can you lose a CVS tree?
07:35:58 <Igloo> It's quite easy when you have several on 3 computers
07:36:16 <Igloo> And fair enough, but it feels like there should be more to them than what I know  :-)
07:36:19 * shapr burns these handy branches that just appeared in the channel.
07:36:44 <shapr> hard to keep warm in northern sweden.
08:04:32 <Marvin--> shapr: right now it feels hard to keep warm in *southern* sweden
08:06:06 <seth_> shapr: Are you at Chalmers?  Or is Marvin--?  I don't know my European geography north of Amsterdam.
08:10:49 <Heffalump> marvin-- is
08:20:09 <Marvin--> technically I'm at Göteborg University, but since the CS institution is shared between GU and Chalmers, I guess you could say I'm at Chalmers
08:21:43 <seth_> Marvin--: Either way you are in the same city.
08:23:31 <Marvin--> yup
08:37:36 * Marvin-- frowns
08:37:59 <Marvin--> I wonder what to do more concretely if I'm going with this topic *sighs*
08:38:05 <shapr> seth_: nay, I'm far north of Chalmers, probably ~ 800km
08:38:34 <shapr> I would like to be at chalmers, whether pursuing a degree or not
08:39:06 <shapr> since it's the closest center for Haskell research
08:39:43 <shapr> I'd enjoy being in proximity to Oxford for the same reasons.
08:40:09 <shapr> Marvin--: what's your current topic nominee?
08:41:18 <Marvin--> shapr: the article "Possibilities and Limitations of Call-by-Need Space Improvement" by Jörgen Gustavsson and David Sands
08:41:49 <Marvin--> or more in general, how program transformations alter the space and time complexity of a program
08:42:09 <shapr> do you have an url to the article, or should I google?
08:42:31 * shapr googles
08:42:52 <Marvin--> www.cs.chalmers.se/~gustavss/ and links
08:43:11 <shapr> aha
08:43:20 <shapr> http://www.math.chalmers.se/~gustavss/publications/icfp01.html
08:44:53 <shapr> heavy duty theory
08:46:11 <Marvin--> ?
08:46:39 <shapr> neat stuff
08:47:12 <Marvin--> it managed to get me interested in space complexity :)
08:47:23 <shapr> they show that using "y + x" instead of "x + y" gives space gains
08:47:26 <shapr> fascinating
08:48:00 <shapr> I wonder if this is connected to Chilli's work on Nepal
08:48:30 <Marvin--> well, they show that using  let xs = [1..n] in last xs + head xs  instead of  let xs = [1..n] in head xs + last xs  gives space gains
08:50:36 <shapr> that's very subtle
08:50:54 <Marvin--> yes :)
08:51:17 <Marvin--> but if you think of the garbage collection, it becomes rather intuitive
08:51:51 <shapr> yah, burstall and darlington should have mentioned this
08:53:48 <Heffalump> Burstall and Darlington should have done what?
09:00:23 * Marvin-- reads a bit about CPS too
09:29:33 <Marvin--> I wonder how hard it would be to semi-automatically prove things about the Core language
09:46:25 <hdaume> Marvin--: what sorts of things?
09:48:11 <Marvin--> hdaume: oh I don't know... induction over data structures for example
09:49:09 <Marvin--> hdaume: I'm reading about CPS, where they've imposed a limit on the things programs can consist of
09:56:07 <Marvin--> wow, look at the time, I should grab something to eat
11:04:06 <shapr> hi Explodey
11:09:21 <Explodey> hello
11:09:42 <shapr> are you learning Haskell?
11:10:07 <Explodey> No just using it for bits of hacking here & there
11:10:27 <shapr> you already know Haskell?
11:10:31 <shapr> cool!
11:10:36 <shapr> what do you use it for?
11:10:41 <Explodey> Quite a bit.  I'm no expert though
11:11:19 <shapr> I'm still hung up on monads.
11:12:09 <Explodey> Some web scripts, messing with text files, experimenting with other algorithms before I code them in C++ at work
11:12:21 <Explodey> It takes a while to get used to monads
11:12:57 <shapr> web scripts?
11:13:03 <shapr> are you using HWS or HTTP.hs ?
11:13:37 <shapr> I'd like to use Haskell to mess with text files, but I'm not that proficient yet
11:13:43 <shapr> at least, I don't think I am
11:13:45 * shapr wonders
11:15:32 <hdaume> Marvin--: would speculative (i.e., optimistic) evaluation solve that space problem?
11:16:03 <Explodey> HaXML
11:16:11 <shapr> oh!
11:16:22 <shapr> cool, what do you do with HaXML?
11:16:28 <Marvin--> hdaume: the head xs + last xs problem?
11:16:36 <Marvin--> hdaume: I don't know what speculative evaluation is
11:16:41 <Explodey> Turn XML into more XML (or XHTML)
11:17:03 <Heffalump> it evaluates things before demand-driven evaluation says it should, in order to avoid huge thunks building up
11:17:16 <hdaume> Marvin--: yeah, the head xs ... what Heff said :)
11:18:09 <Marvin--> before demand-driven evaluation, but after strict evaluation?
11:20:24 <Explodey> shapr: what have you learned about monads so far?
11:20:56 <shapr> well, they're a lot like aspect oriented programming
11:20:57 <shapr> kind of
11:21:05 <shapr> they're a way to make a template for function calls
11:21:07 <shapr> kind of
11:21:10 <shapr> they're wormholes
11:21:11 <shapr> sort of
11:21:19 <shapr> they're based in category theory, somewhat
11:21:57 <shapr> monads are really about defining how things combine
11:22:21 <shapr> you use them to define exactly how two combinators of the same flavor stick together and/or how they interact
11:22:55 <Explodey> OK so you haven't tried implementing any yet?
11:23:04 <shapr> that's where I'm stuck.
11:23:25 <shapr> how do I go from an existing type to a custom monad?
11:23:48 <Explodey> Like what existing type?
11:24:53 <shapr> um
11:25:40 <shapr> sadly, I'm working on some for-pay python code at the moment
11:25:50 <shapr> and I'd have to totally switch context to continue this
11:26:40 <shapr> :-(
11:26:47 <shapr> will you be here again at some point?
11:27:53 <Explodey> probably
11:27:58 <Explodey> You're not a student then?
11:28:07 <shapr> nay, I'm a professional programmer.
11:28:20 <shapr> no formal CS education though
11:28:21 <shapr> self taught
11:28:44 <shapr> are you a student?
11:28:57 <Explodey> No, but I was when I learnt Haskell
11:33:31 * shapr notes that unit tests are wonderful
11:33:41 <shapr> unit tests increase my SAN points.
11:34:14 <Explodey> SAN?
11:34:23 <shapr> sanity points
11:34:36 <shapr> from the Call of Cthulhu role playing game
11:34:51 <shapr> in short, when you met something Lovecraftian, you would lose SAN points
11:34:58 <shapr> at zero, you cracked up
11:35:35 <shapr> for me, Java the language removes SAN points, Python restores them
11:35:39 <shapr> Haskell restores lots
11:35:49 <Marvin--> Java the coffee too
11:36:27 <Explodey> I agree about java :-)
11:36:35 <shapr> unit tests and refactoring restore SAN points
11:38:09 <shapr> clients remove SAN points but give cash in exchange :-)
11:38:41 <Marvin--> number theory problems that I have to hand in solutions to on Monday, man do they lower SAN :(
11:38:51 <shapr> :-(
11:39:26 <shapr> hi systems
11:39:39 <systems> shapr are you like using a bot or something ???
11:40:30 <shapr> :-P
11:41:10 <shapr> no, I use emacs for nearly everything, including irc
11:41:23 <systems> :((((
11:41:29 <shapr> so I have one command that jumps to an irc channel with recent activity
11:41:41 <Explodey> I didn't know it did that but its no surprise
11:42:07 <shapr> if you use emacs, I can direct you to the irc client that I use
11:42:13 <systems> yea first time i thought maybe shapr likes me or something, telling me hi, whenever i pop in 
11:42:26 <shapr> systems: well, you are not boring.
11:42:27 <systems> but time after time i began to doubt it
11:42:31 <shapr> and that is a good thing.
11:43:14 <systems> ...well, am not sure how to reply to that, but thanx .... i guess
11:43:18 <shapr> :-)
11:43:19 <systems> :)
11:44:51 <systems> what's the difference between writing a program exL x-chat, and an emacs script ex: ERC , except that x-chat is waaaaaaaaaay better then ERC
11:44:59 <systems> the idea of emacs is just wrong 
11:45:17 * shapr shrugs
11:45:19 <shapr> it works for me.
11:45:36 <kev> x-chat? irssi is your friend
11:45:41 * kev starts an irc client war
11:46:06 <shapr> mirc32 r0xx0rs!
11:46:11 <systems> yea, and ...an application framework, should offer new grounds, better grounds, emacs !!! is just not better grounds
11:46:18 <systems> mirc is the best 
11:46:21 <shapr> it's coffee grounds!
11:47:36 <systems> emacs is became a shell or some sort of crippled app frameworks, it just show you how much a mission, vision, and goals are still important for a software project
11:47:46 <systems> i doubt emacs had any
11:48:02 <shapr> it does have a nice shell.
11:48:05 <systems> strategic managements for software, i call for thee
11:48:09 <shapr> eshell is spiffy.
11:48:44 <shapr> emacs has RMS for management, dunno about strategy though.
11:49:35 <systems> i read this ugly post on the serverside.com http://www2.theserverside.com/home/thread.jsp?thread_id=16927&article_count=67
11:49:49 <shapr> I'd like to use Haskell to script my editor though
11:50:00 <systems> every guy who wonna look smart , start talkin about his vision for new means for software developement
11:50:01 <shapr> I'm not so fond of elisp, even though I've written a few modules.
11:50:27 <shapr> systems: are you learning Haskell?
11:50:32 <systems> no
11:50:47 <systems> i dont have a mission , so am kinda passing time 
11:50:58 <shapr> oh, I see.
11:51:20 <systems> "if you dont have a vision, you cant buy one"...quote by some famous guy
11:51:36 <systems> i am learning C and python and Vim 
11:51:40 <shapr> I bought glasses :-)
11:51:48 <inkedmn> vim RULES
11:51:53 <inkedmn> (as well as python) :)
11:52:16 <systems> haskell is interesting, FP is interesting, i read few on its history, lambda calculus
11:52:22 <systems> turing and church 
11:52:25 <shapr> yah, I like Haskell.
11:52:34 <systems> alonzo church
11:52:52 <shapr> Haskell has stretched my brain into new ways of thinking more than most things.
11:52:56 <systems> i didnt like alonzo, and the lambda calculus scared me 
11:53:05 <shapr> I like lambda calculus
11:53:16 <shapr> combinators are elegant
11:53:21 <systems> you think its serious or hocus pocus
11:53:27 <shapr> very serious.
11:53:55 <systems> i didnt read deep into it, but i search my college day calculus book, and there was no mention of it
11:54:16 <shapr> there's good stuff about it on Wikipedia
11:54:30 <systems> and it seems from what i read, alonzo gave up on it, after turing prove that some sort of problem cannot be solved by it 
11:54:47 <systems> that halting algorithm thingie i think
11:55:03 <Marvin--> the halting problem
11:55:05 <systems> and this turing guy looked more interesting to me anyway 
11:55:43 <Marvin--> turing machines don't solve the halting problems
11:55:44 <shapr> he is very interesting.
11:55:44 <systems> did turing guy invent the bases for creating procedural langs
11:56:02 <Marvin--> in fact, turing machines and the lambda calculus are equally expressive
11:56:16 <systems> what is the turing machine?? 
11:56:31 <systems> how did it think?
11:56:33 <Marvin--> an abstract machine that turing created to model what can be computed
11:56:47 <systems> if then else , and loops ???
11:56:56 <shapr> sort of
11:57:21 <shapr> you would really like the wikipedia entries on this
11:57:26 <systems> so turing invented the if them else and loops, and alonzo invented recursion 
11:57:29 <Marvin--> yeah, sort of, in practice, if a language has sequentiation, choice and iteration it is turing complete
11:59:14 <systems> i can live without recursion
11:59:30 <shapr> heh
11:59:42 <shapr> amusing thought
11:59:56 <shapr> I'm fond of recursion.
12:00:07 <systems> shapr you were gonna make a lang?
12:00:15 <shapr> yup
12:00:18 <systems> can i suggest the loop statement for you 
12:00:24 <shapr> sure, suggest away
12:01:13 <systems> i thought about all the loops i saw 
12:01:49 <shapr> note that recursion is a superset of looping
12:01:50 <systems> for in : of python, while{}, do {} while , for ( start, cond, step) {}
12:02:01 <systems> foreach(){}
12:02:02 <shapr> you should check out looping in Haskell
12:02:16 <systems> and they are all the same with syntatic sugar
12:02:29 <shapr> length (x:xs) = 1 + length xs
12:02:31 <systems> which is nothing but confusing for new comer 
12:02:34 <shapr> length [x] = 1
12:02:41 <shapr> length [] = 0
12:02:54 <systems> until they get its just that the same thing with sintatic sugar
12:03:03 <Heffalump> you don't need the [x] case
12:03:14 <shapr> right
12:03:26 <systems> haskell syntax is wayyyyy, unusual 
12:03:38 <systems> i cant even guess what that could mean 
12:03:38 <shapr> that's a loop that finds the length of any list
12:04:05 <systems> is haskell == lisp with more sane syntax 
12:04:12 <shapr> not really
12:04:18 <shapr> lisp isn't purely functional
12:04:30 <shapr> lisp has a much simpler syntax also
12:04:35 <shapr> haskell has lots more sugar
12:04:45 <shapr> so sane syntax depends on how you define sanity
12:05:33 <systems> i always read great stuff about lisp, until i look at something writing in it, suprisingly, i can guess what it means without any knoweldge if the lang, but on the other hand, it hurt the eyes, counting the ()() to know whats inside what!
12:06:26 <shapr> with a bit of practice, the parens stop hurting
12:06:41 <systems> and dont say you dont have to count ()())))(((((, cause i am so anti- assumption
12:07:15 <shapr> you could ask the guys on #lisp what they think
12:07:26 <systems> no
12:07:39 <systems> this is not a question to be asked there
12:07:51 <shapr> about parens?
12:07:57 <systems> dont wont em to think of me as a troll or somethng 
12:08:04 <systems> :)
12:08:20 <shapr> I really don't have any trouble keeping track of parens.
12:08:36 <systems> i believe you
12:08:39 <shapr> I much prefer using whitespace, but I can work with parens just fine.
12:08:52 <shapr> I can also work with braces, but I like that less than parens.
12:08:57 <systems> but that doesnt make the parens any cooler or friendlier or a good idea 
12:09:05 <shapr> well, try Joy
12:09:13 <shapr> no parens, no whitespace, no braces
12:09:26 <Marvin--> no *whitespace*?
12:09:27 <systems> so what then 
12:09:34 <shapr> it's a stack based purely functional concatenative language.
12:09:35 <systems> do end stuff
12:09:49 <shapr> it's much fun to play with.
12:10:01 <shapr> you do have lists, which use square braces
12:10:06 <systems> it's lisp without the parens
12:10:11 <shapr> not really
12:10:28 <shapr> it's more Haskell without named variables and a stack instead
12:10:29 <systems> to make tottaly un-maintanable programs
12:10:41 <shapr> I find Joy quite elegant.
12:10:44 <systems> give a new meaning to write once, never look at again 
12:10:56 <shapr> it's easier to read Joy than you might think
12:11:05 * kev starts a new lang called lithp
12:11:17 <systems> if you trust the indentation 
12:11:20 <shapr> (* x y percent approxEqual *)
12:11:21 <shapr> DEFINE approxEqual == 100.0 / rotate [0 =] [pop] [dup rolldown - swap /] ifte > .
12:11:31 <shapr> that's a Joy er, function I wrote
12:11:42 <systems> haskell uses whitespace
12:11:57 <shapr> yes, or braces
12:12:06 <systems> or ?
12:12:15 <shapr> whitespace or braces
12:12:18 <shapr> your choice
12:12:22 <shapr> you can use both at the same time as well.
12:12:27 <Marvin--> kev: sorry, it already exists
12:13:06 <kev> damn
12:13:52 * shapr would like to write a Joy interpreter in Haskell
12:14:37 <systems> haskell is dynamic right
12:14:48 <shapr> what do you mean by dynamic?
12:14:57 <systems> like python 
12:15:04 <shapr> no, not like python.
12:15:12 <systems> haskell keeps track of types
12:15:14 <shapr> Haskell is dynamic at compile time, but not at runtime.
12:15:22 <shapr> not unless you use o3's RuntimeLoader
12:15:22 <systems> hmmmm
12:15:31 <shapr> then all bets are off
12:15:54 <shapr> Haskell is strongly, statically, inferredly typed
12:16:07 <systems> inferredly typed???
12:16:18 <shapr> I just made up that word :-)
12:16:29 <systems> doesnt do type inference 
12:16:30 <shapr> it means Haskell is dynamically typed at compile time
12:16:34 <shapr> yes, it does.
12:16:44 <systems> so what did inferredly typed mean
12:16:57 <shapr> that the type is optionally inferred
12:17:16 <shapr> you don't need to give types to your variables in many cases
12:17:22 <shapr> because Haskell can figure it out for you.
12:17:54 <systems> is polymorphism, relevant, or important or usefull???
12:18:10 <shapr> it is useful
12:18:33 <shapr> and relevant
12:18:36 <systems> and i mean by polumorphism .... mmm... a function that can deal with different types of object
12:18:46 <systems> am i right !!!
12:18:54 <shapr> yes, if you look at the length function above, it works for any type
12:19:17 * shapr finds the problem with his python code
12:19:26 <systems> what code
12:19:43 <shapr> oh, I'm working on a nntp to database python script I wrote for someone
12:19:44 <systems> does what this code
12:19:54 <systems> nntp 
12:20:02 <shapr> yah, usenet, aka netnews
12:20:52 <systems> why didnt you use haskell 
12:21:02 <shapr> I wrote this script originally before I knew Haskell.
12:21:17 <systems> :)
12:21:30 <shapr> since I'm charging my client for this, it will cost them less for me to make some fixes to the Python code rather than rewriting it in Haskell.
12:21:59 <kev> tbh, I'd still stick with python for code I write for 3rd parties
12:22:02 <Marvin--> "Java is platform independent" HAH
12:22:04 * Marvin-- mutters
12:22:27 <shapr> Marvin--: sure, write once debug everywhere
12:22:29 <Marvin--> this program works fine on the university system, on my computer it just prints "null" and exits
12:22:40 <systems> java is a platform 
12:22:48 <shapr> shaky and unstable, but yes
12:22:56 <shapr> not very flat either
12:23:03 <kev> java is a far better lang than half of the others out there though
12:23:14 <systems> parrot will be a nice platform to watch 
12:23:22 <kev> that python's vm?
12:23:35 <systems> nope thats a VM
12:23:40 <shapr> supposedly perl and python will both run on parrot
12:23:46 <systems> mainly for perl6 
12:23:56 <systems> and any other lang
12:24:03 <Marvin--> and perhaps ruby too
12:24:07 * kev won't touch perl with a bargepole
12:24:26 <systems> kev is not really that 
12:24:34 <kev> systems: yeah, i know, it's the vm
12:24:47 <systems> it's more, what is better, learn more on the langs i already know, or learn a new lang
12:24:53 <kev> I thought they made an open vm for python as well?
12:24:55 <shapr> systems: both
12:25:06 <systems> nope you didnt get me kev
12:25:27 <kev> systems: ah, just thought that's what you were gonna follow with
12:25:28 <systems> when you say i wont touch perl, it only makes sense, when for example you know a replacement 
12:25:36 <systems> like ruby or python 
12:25:40 <kev> yes, python ;)
12:25:59 <kev> and I don't think I can name a single situation where I'd see perl as a better option than python
12:26:25 <systems> now thats a good reason, not to learn perl 
12:26:31 <systems> :)
12:27:35 <systems> when someone say i wont touch Java, i wonder what he think can replace Java for building enterprise software? and large scale information systems
12:28:10 <kev> I'd probably got with java for some stuff
12:28:41 <shapr> what benefit does Java have for enterprise software?
12:28:47 <shapr> an existing codebase?
12:28:54 <kev> shapr: better than the alternatives ;)
12:29:07 <systems> libraries , App servers, good tools 
12:29:13 <kev> people know C, moving to java's not too hard
12:29:13 <shapr> I'd much rather go with Python in Zope and Twisted
12:29:22 <Marvin--> and what the *** does "enterprise" mean?
12:29:25 <shapr> have you used J2EE?
12:29:25 <kev> code dev in Java is much faster than C
12:29:37 <kev> Marvin--: hehe
12:30:18 <systems> no, but i saw a graph of its compenents, and read a long comparision of its compoenent vs .net components
12:30:31 <shapr> I've built webapps with both Zope and J2EE
12:30:39 <Marvin--> the system I've worked on at Strakt is described as "CAPS, the flexible and highly scalable Real-Time Enterprise Computing (RTEC) platform which is the base for all its modular collaboration and business process applications."
12:30:40 <systems> i dont know what EJBs and Java Beans means zo
12:30:42 <shapr> given the choice, I won't use J2EE again.
12:30:47 <kev> zope worried me
12:30:47 <Marvin--> when I first saw that I thought "WTF?"
12:30:55 <systems> shapr would you plz elaborate
12:31:44 <systems> if ur not busy of course
12:31:59 <shapr> imo, J2EE requires much more manual labor to get anything working.
12:32:17 <kev> Java backends are still fairly nasty, that much I do know
12:32:50 <shapr> the J2EE app I was working on still isn't completely finished
12:33:04 <kev> none of them are stable, and they provide no protection when you try to run multiple users on the one backend
12:33:10 <shapr> I think I could have written the same app by myself on Zope in four weeks or less.
12:33:27 <Marvin--> shapr: but it wouldn't be ENTERPRISE!!!11!!1!
12:33:54 <kev> ZoDB looks pretty nice, but I'd dubious about the BDB backend
12:34:02 <shapr> BDB?
12:34:07 <kev> Berkley DB
12:34:27 <shapr> actually, Zope can be enterprise
12:34:36 <kev> I'm much rather it used Postgres or something
12:34:41 <shapr> Zope Enterprise Objects let you distribute the workload nicely
12:34:54 <kev> and allowed you to do objects over multiple machines by sharing a DB
12:35:01 <kev> shapr: yeah, I wanted to play with those
12:35:21 <kev> I really didnt' like what I saw of Zope before though
12:35:30 <kev> the whole web based interface to work with stuff was just wrong
12:35:53 <shapr> I use emacs
12:36:01 <systems> from what i read mainly in sites like slashdot and the serverside, where the audience of both always seems oceans apparts .... neither camps, Java camp vs code hippies (the anything but java camp)... i dont it mainly sound like, java is not good everywhere, happy ppl are the ones who knows the details of their tools and where to use em
12:36:32 <shapr> the web based interface is both nice and useful, though I would prefer more command line interfaces
12:36:48 <shapr> yah, use the right tool for the job, I agree.
12:36:57 <shapr> thing is, where is Java the best tool for the job?
12:37:20 <shapr> imho, only when you're trying to jump many developers from C or C++ to something with more sanity
12:38:28 <systems> so it just sounds that software development only really suffer, from ppl who learn to program and worked as programmers, and lacked educations in most other relevant areas..like the underlying platform design, lang design, lang paradigms, analysis and design, different software categories
12:38:52 <systems> we have so many programmers who dont trust academia, and so many academia done wrong 
12:39:41 <systems> just a simple case of bad education !!!!
12:39:46 <shapr> I think it is each persons responsibility to be as good as they can be at what they do.
12:39:59 <shapr> I guess I'm lucky, I have no academic computer education.
12:40:20 <systems> but shapr if you lack education ....well!!
12:40:26 <kev> an academic education isn't a bad thing
12:40:28 <systems> academia is supposed to be fun 
12:40:31 <Marvin--> shapr: you're doing a fair job on reading up on it on your own though
12:40:33 <kev> it's just if you don't take it all with a pinch of salt
12:40:36 <kev> systems: yeah right ;)
12:40:45 <systems> place where all ppl study for the sake of knowledge not to make money
12:40:58 <kev> shapr: you seem to know far more than me on stuff like haskell
12:41:06 <kev> and I do ML at uni
12:41:22 <shapr> Just trying to be the best programmer I can be
12:41:22 <kev> systems: I don't buy that
12:41:34 <kev> if I was gonna study for knowledge, I'd read books at home
12:41:52 <clausen> I wouldn't
12:42:04 <Marvin--> kev: won't give you the advantage of dialog though
12:42:06 <clausen> community is really important
12:42:14 <systems> most ppl dislike academia cause academia is done bad, not because the idea of academia is bad, most academia became more about a commercial business thingie that sell diplomas not offer education
12:42:15 <shapr> yah, I agree with clausen, community is very important.
12:42:26 <shapr> and that fits with what Marvin-- just said
12:42:26 <kev> Marvin--: irc? ;)
12:42:38 <kev> yeah, community is good
12:42:53 <shapr> it's hard to learn for the sake of knowledge, and not starve in the process
12:42:54 <kev> and all I've found in academia are backstabbing glory hunters
12:43:10 <shapr> I'd love to drop Python and elisp entirely and go with Haskell
12:43:13 <shapr> but I'd starve :-)
12:43:59 <shapr> I really do believe that Haskell is superior to any other single programming language I've read about.
12:44:10 <systems> even lisp
12:44:13 <clausen> kev: it depends on your university / department
12:44:17 <shapr> yes, even lisp.
12:44:26 <systems> even ocaml
12:44:30 <shapr> yes
12:44:36 <systems> hmmm
12:44:48 <shapr> even Self, Joy, Prolog, Mercury, etc etc
12:44:56 <systems> even ruby
12:44:59 <shapr> yah, that too
12:45:02 <systems> you forgot ruby
12:45:14 <shapr> on the other hand, I don't think that one single language is the best way to solve problems
12:45:23 <shapr> like you said, use the tool that fits the job
12:45:41 <systems> thats another debate
12:45:43 <shapr> Haskell is not as good as pure imperative code as other languages, but it is superior in most ways
12:46:04 <systems> cause maybe , in software we might reach, a lang that is best for all jobs 
12:46:04 <hdaume> "pure imperative code"  hehe
12:46:12 <shapr> so I'd like to have Haskell working well with other languages so that I can use the right tool for that part of the job
12:46:19 <shapr> hdaume: heh, good point =)
12:46:19 <Explodey> I forgot ruby.  Never really took off did it?
12:46:28 <shapr> ruby is getting very popular
12:46:43 <systems> Java is not better at some jobs because if its design features, manly because of the libs and components it offer
12:46:45 <shapr> it's nice, just not my style.
12:47:02 <shapr> systems: COBOL can always offer you more, why don't you use it?
12:47:19 <systems> plus sql evoluted to procedural sql
12:47:41 <systems> and procedural everywhere evoluted to OOP
12:47:50 <systems> and OOP is gettin more functional 
12:47:57 <systems> and more AOP
12:48:10 <shapr> monads are AOP
12:48:10 <systems> so maybe in theory , one tool to rule em all can exist
12:48:21 <systems> but it doesnt
12:48:29 <shapr> but in general, AOP is a shotgun rather than a scalpel
12:48:42 <hdaume> systems: i doubt it :)
12:48:48 <systems> maybe i software there will be one best way to do anything
12:48:51 <Marvin--> shapr: could be said about OOP too
12:48:58 <hdaume> systems: i think at the very least you'll need one good lazy tool and one good strict tool
12:49:17 <shapr> Marvin--: that's true
12:49:32 <kev> AOP?
12:49:43 <shapr> aspect oriented programming
12:50:07 <systems> the few that i know AOP is that its a better way to add macros to a lang 
12:50:21 <systems> which sounds like a good thing
12:50:38 <shapr> aop isn't really that close to macros
12:50:54 <shapr> aspect oriented programming is just like emacs hooks
12:50:54 * kev is still more interested in functional languages for theorem proving
12:51:13 <kev> okay, you're not selling this ;)
12:51:16 <shapr> you have a pre-hook, a post-hook, an around-hook...
12:51:24 <shapr> hm, I've forgotten the others
12:51:30 <systems> triggers ??
12:51:31 <kev> a fish-hook?
12:51:34 <shapr> hah
12:51:35 <shapr> fish :-)
12:51:37 <systems> sounds like database triggers
12:51:44 <shapr> it's a bit like triggers
12:51:55 <kev> hooks are just functions that get called when some event happens
12:52:00 <systems> triggers are hell
12:52:09 <shapr> but it's just functions or methods that get executed in a certain relation with another function or method
12:52:20 <systems> they are good, but a hell when they cause a problem and you got to track it
12:52:28 <shapr> yes, both triggers and AOP can very easily become spaghetti code
12:52:38 <shapr> that's why I think AOP is a shotgun rather than a scalpel.
12:52:53 <systems> a trigger that trigger a trigger which conflict with the first trigger
12:53:03 <shapr> yup
12:53:11 <systems> i hate that 
12:53:21 <shapr> it's great for wrapping tracing code around functions
12:53:43 <shapr> just not a good solution for all problems.
12:54:02 <shapr> the Aspect compilers do neat stuff with AOP though, it's worth reading about.
12:57:25 <shapr> f00, Explodey left
13:14:25 <Heffalump> how does one use AOP to add macros to a language?
13:14:39 <Heffalump> oh, systems went
13:26:22 <Marvin--> goulash: why privmsg?
13:26:35 <goulash> sorry
13:26:54 <goulash> i'm new..
13:26:57 <goulash> sorry
13:27:01 <Marvin--> ask your question and we'll see what we can do :)
13:28:02 <goulash> well, i'm trying to program mastermind in haskell
13:28:39 <goulash> and i dont know how can i improve a function that gives a code (aleatory)
13:28:43 <goulash> you see?
13:29:29 <Marvin--> I'm not following...
13:29:44 <goulash> ok
13:29:48 <goulash> 5,00:4,00(
13:32:19 <clausen> I wrote mastermind in haskell
13:32:33 <argv[0]> I've hugs (december 2001) running on linux. When I change the -E setting, it doesn't save and always get changed when I run again hugs. Is this normal beavihour?
13:32:47 <clausen> aleatório == random
13:36:16 <clausen> he wants to generate random numbers
13:36:23 <clausen> unsafePerformIO is best for first years?  hehe
13:36:27 <goulash> "she"
13:36:32 <clausen> she?
13:36:35 <clausen> desculpa!
13:36:39 <goulash> 5,00:4,00)
13:36:57 <whee> I wouldn't use unsafePerformIO
13:37:07 <whee> it could turn into a bad habit, it's not something you should really use
13:37:11 <clausen> hehe
13:37:19 <clausen> actually, I think she can insulate it fairly easily
13:37:26 <clausen> goulash: perae
13:37:46 <whee> there are some random number generators that don't need a bunch of work
13:46:14 <SyntaxPolice_> argv[0]: I'm not sure I understand the question: you run "hugs -E ..." and then later you run just "hugs" and you get a different behavior?
13:49:22 <clausen> anyone explain this?
13:49:23 <clausen> Random> randoms (mkStdGen 5)
13:49:24 <clausen> ERROR: Unresolved overloading
13:49:24 <clausen> *** Type       : Random a => [a]
13:49:24 <clausen> *** Expression : randoms (mkStdGen 5)
13:49:42 <clausen>   randoms         :: RandomGen g => g -> [a]
13:50:04 <argv[0]> SyntaxPolice_: I solved the problem. I had the EDITOR enviroment var set to another editor, and hugs seems to always set -E to that one on load. tks anyway :9
13:50:25 <Marvin--> clausen:  :: [Int]
13:50:44 <clausen> Marvin--: ?
13:50:55 <clausen> do I need to give a type signature?
13:51:01 <Marvin--> clausen: you have to give an explicit type since it's overloaded
13:51:21 * clausen remembers something about type unification being undecidable
13:51:33 <clausen> Marvin--: and I do that via type sigs?
13:51:46 <SyntaxPolice_> argv[0]: your welcome :)
13:52:03 <Marvin--> clausen: randoms (mkStdGen 5) :: [Int]  will work
13:52:12 <clausen> Marvin--: thanks :)
14:43:46 <SyntaxPolice_> hmm.  I would really sometimes like something like "mapIf" which 
14:43:49 <SyntaxPolice_> oops
14:44:01 <SyntaxPolice_> which takes two functions, one to apply to each element in a list
14:44:11 <SyntaxPolice_> and the other to test that element for something
14:44:26 <SyntaxPolice_> instead of going over the list again with filter.
14:44:57 <Heffalump> so you want a one-pass version of filter p . map f ?
14:46:25 <SyntaxPolice_> yeah. since there is no reason to construct a list of the same size as f if the filter will delete a bunch of items from it.
14:47:16 <Heffalump> you could just hope that GHC's built-in deforestation will compile it to something efficient
14:47:20 <Heffalump> which it probably will
14:47:38 <SyntaxPolice_> really?  I always do sort of hope for things like that, but then I get scared that I"m writing inefficient code.
14:48:03 <Heffalump> well, unfortunately there's no guarantee
14:48:26 <SyntaxPolice_> yeah, I guess the thing to do is benchmark it and clean up stuff that needs to be cleaned up.
14:49:21 <Marvin--> why not use an LC?
14:49:54 <Heffalump> well, the LC will get translated into a bunch of filters and maps :-)
14:50:01 <SyntaxPolice_> sorry - what is an LC?
14:50:09 <Marvin--> list comprehension
14:50:21 <Marvin--> Heffalump: I thought it was the other way around, but maybe that's just hugs
14:50:26 <SyntaxPolice_> ahh.  It might look better that way.
14:50:28 <whee> Heffalump: but it may be more likely to behave better
14:50:42 <SyntaxPolice_> and maybe ghc can be better about optimizing it.
14:52:53 <hdaume> SyntaxPolice: ghc has a list of "friendly consumers" and "friendly producers"; if you use them in conjunction you get deforestation.  filter p . map f would qualify
14:54:39 <SyntaxPolice_> hdaume: that is very good to hear.  So when I run across something that seems to me to be a common pattern there is a good chance that it may be a part of this list.
14:54:46 <SyntaxPolice_> Is this a list that one can look at?
14:55:11 <Marvin--> ugh, that feels like cisc asm programming :)
14:57:19 <whee> mmm asm
14:57:26 <whee> or not :|
14:57:53 <Heffalump> hdaume: is GHC guaranteed to apply short-cut deforestation wherever possible?
14:58:51 <hdaume> Heffalump: i'm not sure...basically, ghc applies foldr/build deforestation most commonly, and so any functions from the prelude (or elsewhere) written with foldr or build will be deforested
14:58:56 <hdaume> SyntaxPolice: let me find the list...hold on
15:00:27 <Heffalump> hdaume: I'm just not 100% certain that it /always/ does so, that's all
15:00:52 <hdaume> read 7.7.3 of the user's guide.  http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html
15:01:00 <hdaume> "The RULES mechanism is used to implement fusion (deforestation) of common list functions. If a "good consumer" consumes an intermediate list constructed by a "good producer", the intermediate list should be eliminated entirely."
15:01:07 <Heffalump> and in particular, whether its heuristics guarantee that it will always inline things defined in terms of foldr or build, which would be needed to expose the transformation
15:01:17 <Heffalump> hmm.
15:01:51 <hdaume> in 7.7.1 it gives the actual deforestation rule
15:02:26 <SyntaxPolice_> hdaume: thanks.
15:10:01 <Pseudonym> I'm a bit behind on this part of the conversation, but I wrote some code to evaluate the optimal game tree for the Nokia phone version of mastermind.
15:10:15 <Pseudonym> Interestingly, the optimal tree includes making guesses with blanks.
15:14:34 <whee> haha
15:16:59 <whee> erm, odd
15:17:38 <whee> found another machine where I can do ghc profiling, and this is crazy how much changing two lines can drastically alter the heap
15:18:23 <jak_home> what lines?
15:19:06 <whee> just playing with something that I was going to enter into kuro5hin's pfc, messing with the ordering
15:19:27 <whee> probably not going to enter it since it's insanely slow
15:19:46 <Pseudonym> What's the pfc, as a matter of interest?
15:20:12 <whee> boring. counting the frequency of words in a file and listing the top ten
15:20:20 <Pseudonym> Oh, very boring.
15:20:37 <whee> I was trying to use it as an excuse to learn parsec
15:20:40 * Pseudonym seems to remember doing that as an undergrad
15:20:44 <whee> but that didn't work too well :)
15:20:49 <jak_home> can you do it one line in haskell ?
15:20:54 <Pseudonym> You could probably do it with awk and sort.
15:21:06 <hdaume> cat foo | tr ' ' '\012' | sort | uniq -c
15:21:07 <hdaume> :)
15:21:10 <whee> I'll show you my code, but using a finitemap kills performance :\
15:21:22 <Pseudonym> hdaume: You forgot the head -10
15:21:32 <hdaume> sorry, you need a 'sort -nr | head -10' at the end ;)
15:21:35 <Pseudonym> Yes.
15:21:36 <hdaume> i didn't read the full specification
15:21:58 <Pseudonym> You may need to do some sed stuff if that's not the correct definition of a word.
15:22:15 <Pseudonym> Also you strictly need to strip blank lines.
15:22:18 <whee> http://smaerty.ath.cx/pfc9.hs.html <- really slow.
15:22:19 <hdaume> bah.  word := space-separated characters
15:22:32 <jak_home> lovely highlighting
15:22:40 <whee> adding the length printout doubles the computation time
15:22:57 <Pseudonym> ["bah,", "", "word", ":=", "space-separated", "characters"]
15:23:09 <whee> doing profiling puts most of the time in wordFM and get_words (obviously)
15:23:25 <whee> I think finding a way to count without the map would  be best, but I'm lazy
15:23:44 <jak_home> I thought there was already a prelude function called 'words' ?
15:24:00 <whee> there is, but it splits on whitespace; the pfc requirement was different
15:24:08 <whee> I based mine on the source for words
15:24:09 <jak_home> oh
15:24:31 <hdaume> i've always been shocked that there isn't a wordsBy function
15:24:33 <jak_home> what's the take 10 for?
15:24:41 <whee> gets the top ten
15:24:45 <jak_home> of course
15:26:00 <whee> the C versions already submitted take ~0.2/0.3 seconds on my machine, while this haskell one takes a minute :)
15:26:07 <jak_home> lol
15:26:09 <hdaume> haha
15:26:16 <whee> half of that is that length calculation, the other half creating the map 
15:26:21 <whee> sorting surprisingly only takes a few seconds
15:26:37 <jak_home> what happens if you sort the words first?
15:26:52 <whee> I'm sorting the frequency, not the words
15:27:00 <whee> so I can only do that afterthe map is created here
15:27:45 <jak_home> does haskell have sorts that can act on arrays?
15:28:15 <hdaume> jak_home: i don't think so
15:28:20 <jak_home> might be faster than sorting a list
15:28:37 <jak_home> if you can have in place swapping
15:28:47 <whee> I'd be more interested in not using a FiniteMap
15:28:52 <whee> that's my main slowdown
15:30:01 <Pseudonym> I think you'd be better off putting the words in a list and sorting.
15:30:08 <whee> sorting how?
15:30:13 <Pseudonym> List.sort
15:30:19 <whee> right, but how would I calculate frequencies
15:30:27 <Pseudonym> FiniteMap is for situations where you need to add, delete and find entries at random.
15:30:31 <whee> I _do_ use a list to sort
15:30:38 <Pseudonym> Well, after you sort, all of the entries are together.
15:30:39 <whee> I use the FiniteMap to calculate the word frequencies.
15:30:58 <whee> hmm
15:31:11 <Pseudonym> You just compare elements next to each other.
15:32:55 <Chilli> Moin
15:32:56 <whee> I don't think I'd be able to pull that off, can't think of an easy way to do it :|
15:35:47 <whee> probably a one line solution to that too, heh
15:36:32 <Pseudonym> Easier if you use a worker-wrapper.  Three lines or so.
15:38:02 <whee> how would you do it? I'm thinking of a function that traverses a couple elements at a time and either recurses if both are the same or returns a word/count tuple otherwise
15:40:34 <jak_home> what about 'break'
15:40:38 <jak_home> and 'length'
15:40:58 <Pseudonym> That would also work.
15:41:26 <jak_home> although not as efficient
15:42:13 <Pseudonym> Probably not, no.
15:42:22 <whee> I just hope the next pfc isn't as boring
15:42:27 <Pseudonym> whee: This is untested code.
15:42:43 <Pseudonym> count_words :: [String] -> [(Int,String)]
15:42:46 <Pseudonym> count_words [] = []
15:43:03 <Pseudonym> count_words (w:ws) = count_words' 1 w ws
15:43:14 <Pseudonym> count_words' n w [] = [(n,w)]
15:43:21 <Pseudonym> count_words' n w (w':ws)
15:43:33 <Pseudonym>   | w' == w = count_words' (n+w) w ws
15:43:43 <Pseudonym>   | otherwise = (n,w) : count_words' 1 w' ws
15:43:47 <Pseudonym> That should do it.
15:44:07 <Pseudonym> The (n+w) should read (n+1)
15:44:18 <Pseudonym> Told you it was untested. :-)
15:44:47 <whee> okay, that kind of works like I was thinking
15:45:02 <jak_home> looks good
15:49:35 <whee> erm, guess this requires two sorts then
15:51:46 <Pseudonym> Yes.
15:51:54 <Pseudonym> You might want to consider using sortBy for the second one.
15:51:55 <whee> and it's actually slower :|
15:51:58 <Pseudonym> Avoid comparing strings.
15:52:02 <whee> yes, I do
15:52:08 <Pseudonym> Also, judicious use of SPECIALIZE.
15:52:19 <Pseudonym> Not sure if you can do that.
15:52:56 <whee> going to run this through the profiler to see how the heap goes and everything else
15:53:02 * whee loves numbers
15:54:00 <Pseudonym> NUmbers are interesting.
16:00:01 <jak_home> goodnight
16:00:08 <Pseudonym> Night.
16:11:53 <hdaume> anyone ever try to interface haskell with anything other than C/C++?
16:11:58 <hdaume> (like ocaml for instance)
16:15:09 <whee> yikes.
16:15:36 <whee> heap usage is much higher, but count_words itself is pretty fast. heh
16:18:36 <systems> anyone tried ghc 5.04.2 on redhat 7.3 ? and if it works fine?
16:24:33 <seth_> systems: 5.04.1, yes.  I haven't installed .2 yet.
16:26:20 <Pseudonym> whee: Where is the heap being used?  Do you know?
16:32:47 <systems> so what wrong could happen if i tried it on 7.3 
16:32:59 <systems> can it screw my system
16:35:45 <hdaume> systems: it should be fine
16:41:25 <whee> psuedonym: get_words spikes pretty early with main hitting double that shortly afterwards
16:41:35 <whee> I'm guessing the two sorts are bad
17:45:39 <whee> anyone know of a simple example of using a state monad?
17:46:07 <seth_> Hey, you used "simple" and "monad" in the same sentence.
17:46:13 <whee> :P
17:46:23 <lament> heh
17:46:57 <lament> I strongly suspect that monads are actually simple
17:47:02 <lament> But everyone sucks at explaining them
17:47:03 <Pseudonym> I agree.
17:47:04 <whee> I just want a state monad to hold a value 
17:47:12 <whee> and it should be simple :)
17:51:35 <whee> GHC's docs should really include small examples with every module
17:52:55 <Pseudonym> How about this:
17:53:02 <Pseudonym> import Control.Monad.State
17:53:08 <Pseudonym> type StateM = State Int
17:53:30 <Pseudonym> main = putStrLn (show (runState 0 main'))
17:53:32 <Pseudonym> main' = do
17:53:44 <Pseudonym>     x <- get
17:53:56 <Pseudonym>     put (x+1)
17:53:58 <Pseudonym>     return x
17:53:59 <Pseudonym> Or something.
17:54:11 <Pseudonym> The point is you have get and put.
17:54:22 <whee> what confuses me there is get and put
17:54:36 <whee> how does it know what  it's referring to
18:00:12 <Pseudonym> With the State monad, there's only one slot to put state.
18:00:46 <Pseudonym> If you need more than one item of state there's several things you can do.
18:00:50 <Pseudonym> You can put in a tuple.
18:00:56 <whee> right, but there could be more than one state monad?
18:00:59 <Pseudonym> Sure.
18:01:09 <clausen> that was the next option :P
18:01:17 <whee> so how is get knowing what one it's getting from
18:01:18 <whee> heh
18:01:24 <Pseudonym> The top one.
18:01:35 <Pseudonym> If you need one lower down, you use: lift ask
18:02:40 <whee> erm
18:03:01 <whee> you completely lost me :p
18:03:05 <Pseudonym> Another technique I occasionally use is to build a state reader (ReadT) on top of IO.
18:03:14 <Pseudonym> Then in the state you put a tuple of IORefs.
18:08:27 <whee> how does runState work :|
18:08:40 <whee> your example doesn't typecheck and the GHC docs aren't exactly helpful
18:09:07 <whee> by GHC docs I mean a single line with useless type variables like s m -> s -> (a, s)
18:09:08 <whee> heh
18:15:00 <whee> okay, I think I'm getting hung up on the scope of these
18:15:21 <whee> are MonadStates just like any other object/binding/blah or are they some sort of global thing?
18:17:15 <lament> What's the relationship between monads (not haskell monads, just monads) and monoids?
18:17:39 <whee> going crazy here. heh
18:24:14 <whee> I'd hate to have to learn haskell as an early languaage, this is insanely frustrating :P
18:25:45 <Pseudonym> Sorry, afk.
18:26:07 <Pseudonym> Monoids are something completely different.
18:26:10 <Pseudonym> Monoids are groups without inverses.  Or groups are monoids with inverses.
18:26:34 <whee> all I can seem to find are examples of how to implement state monads. zero on how to actually _use_ them. heh
18:26:39 <Pseudonym> Monoids are monads, I think.
18:26:46 <Pseudonym> Monoids are monads with plus, actually.
18:26:51 <Pseudonym> Right.
18:26:59 <Pseudonym> Would you like me to mail you an example?
18:27:07 <Pseudonym> It's a big example.
18:27:15 <whee> :|
18:27:38 <Pseudonym> Or even better:
18:27:45 <Pseudonym> http://andrew.bromage.org/Dfa.hs
18:27:52 <Pseudonym> Sorry.
18:27:55 <Pseudonym> http://andrew.bromage.org/Dfa.lhs
18:28:03 <Pseudonym> It's a regular expression to DFA converter.
18:28:37 <Pseudonym> BRB
18:36:58 <whee> heh
18:38:45 <Pseudonym> OK.
18:38:50 <Pseudonym> Take a look.
18:39:08 <whee> it's quite a bit over my head at the moment
18:41:49 <Pseudonym> You should ignore remCodeGen.  The code is very, very ugly there.
18:42:25 <clausen> Pseudonym: are there any good implementations of okasaki's stuff in mercury?
18:42:35 <Pseudonym> Some of them.
18:42:41 <clausen> (haskell is too lazy, and blows my mind for this stuff...)
18:42:57 <Pseudonym> The trouble is that his data structures often rely on lazy evaluation for their performance characteristics.
18:43:05 <clausen> mercury has lazy eval support
18:43:07 <whee> am I correct in thinking that a state monad is just like any other monad, except not? heh
18:43:15 <clausen> you actually don't want lazy eval built in
18:43:25 <clausen> (otherwise, it suspends everything)
18:43:41 <Pseudonym> whee: It's like any other monad with extra operations.
18:43:57 <Pseudonym> What Mercury has is poor man's coroutines.
18:43:59 <whee> okay, now how do I get an initial state. runState?
18:44:07 <clausen> maybe I should just use ML
18:44:11 <clausen> (it's a bit ugly, though...)
18:44:11 <Pseudonym> It also has something close to real coroutines, but I don't think that's in the release yet.
18:44:19 <Pseudonym> clausen: There's also Concurrent Clean.
18:44:26 <Pseudonym> Clean is very close to Mercury in philosophy.
18:44:33 <Pseudonym> And it lets you control where laziness happens.
18:44:44 <Pseudonym> whee: Yes.
18:44:44 <clausen> hmmm
18:44:51 <Pseudonym> Or runStateT if it's a transformer.
18:44:54 <clausen> basically, I want a good environment to learn about okasaki's stuff more
18:45:09 <clausen> you reckon [oca]ML or CC is better?
18:45:16 * clausen should bite the bullet and learn ocaml?
18:45:20 <Pseudonym> Well I'm currently the Edison support person.
18:45:26 <Pseudonym> If you want to help out... :-)
18:45:30 <whee> I'd learn ocaml if you want to learn something
18:45:32 <whee> I love ocaml :)
18:45:38 <clausen> Pseudonym: for which language?
18:45:42 <Pseudonym> Haskell.
18:45:51 <Pseudonym> If you're going to learn ML, definitely make it O'Caml.
18:46:05 <Pseudonym> In particular, avoid SML like the plague.
18:47:59 <clausen> is it hard to do profiling, etc. in haskell?
18:47:59 <clausen> how do you control when evaluation occurs?
18:47:59 <Pseudonym> It depends what statistics you want.
18:47:59 <clausen> (I'm interested in this whole "O(1) worst-case time through lazy-eval/memoization" thing)
18:48:00 <clausen> (well O(x), but O(1) is good ;)
18:48:00 <Pseudonym> Since the wiki is back: http://users.aber.ac.uk/ajc99/stricthaskell.html
18:48:00 <whee> Pseudonym: okay, the type on runState is State s a -> s (a, s), so where am I getting this first State 
18:48:00 <Pseudonym> Sorry, that isn't a wiki page.
18:48:00 <Pseudonym> But it's good. :-)
18:48:03 <whee> missing a  -> in there :\
18:48:34 <Pseudonym> whee: You supply it.
18:48:43 <Pseudonym> State s a -> sState s a -> s -> (a, s)
18:48:48 <Pseudonym> State s a -> s -> (a, s)
18:48:49 <Pseudonym> Sorry.
18:48:57 <Pseudonym> You supply  a monad and an initial state.
18:48:58 <whee> then what is s?
18:49:04 <Pseudonym> s is the type of the state
18:49:11 <whee> errmf 
18:50:46 <Pseudonym> clausen: Edison is designed very cleverly, actually.  All data types are strict unless they should be lazy.
18:51:01 <Pseudonym> Either for performance reasons or for semantic reasons.
18:51:24 <Pseudonym> Many of the Okasaki data structures rely on lazy evaluation for performance characteristics.
18:51:56 <Pseudonym> Eagerly evaluated, performance would be O(n) amortized, but with judicious lazy evaluation, it's O(n) actual.
18:52:23 <Pseudonym> This happens a lot in lazy programming.
18:54:00 <whee> aieeee
18:56:53 <clausen> but, if you have full lazy evaluation , you get O(n) amortized also
18:56:56 <clausen> you won't to spread out evaluation
18:57:00 <clausen> lazy will put it all at the end
18:57:05 <clausen> eager will put it all at the start
18:57:10 <clausen> you need middle ground
18:57:13 <clausen> s/need/want/
18:58:25 <Pseudonym> In Haskell, you have judicious use of strict evaluation.  In ML, you have judicious use of lazy evaluation.
18:58:36 <Pseudonym> In real programs, you get the middle ground one way or another.
18:58:45 <clausen> aha, thanks
18:58:54 <Pseudonym> Have a look at the GHC source some time.
18:58:59 <Pseudonym> On second thoughts, don't. :-)
18:59:21 <whee> heh
18:59:22 * clausen has already had the "pleasure"
18:59:24 <Pseudonym> There's a lot of deep-seq-ing in there.
18:59:26 <lament> No, in real programs you have judicious use of encapsulation, inheritance and object polymorphism :)
18:59:28 <whee> this is crazy
18:59:40 <whee> spent an hour and I still can't figure out how to create a simple counter :|
18:59:46 <Pseudonym> :-)
18:59:48 <whee> I thought ocaml had documentation problems :)
19:00:43 <whee> either 1) noone uses runState, 2) noone uses GHC's state monads, or 3) noone uses haskell. I'm guessing 1
19:00:55 <clausen> I'm guessing 3
19:00:57 <clausen> it's all academics
19:01:01 <lament> i'm guessing 3, too
19:01:20 <Pseudonym> There's also a lot of 2.
19:01:25 <Pseudonym> People roll their own.
19:01:54 <whee> I'm tempted to just learn FFI and use C to do the counter
19:02:01 <whee> heh
19:02:47 <Pseudonym> While that would be a sueful exercise...
19:04:22 <Pseudonym> Actually, here's an ugly counter: http://groups.google.com/groups?selm=fa.ec20b4v.a6c29t%40ifi.uio.no
19:04:29 <Pseudonym> I wrote that as a joke a few months ago.
19:04:56 <whee> doesn't use the State thing though :|
19:05:04 <whee> well, it looks like you reimplemented it
19:05:08 <whee> heh
19:05:09 <Pseudonym> No, but evalCounterT does something similar.
19:05:24 <Pseudonym> You provide the monadic code (count) and an initial state (0).
19:07:53 <whee> can I just get a state out of nowhere and pass that to some function to play with
19:08:03 <Pseudonym> In general, no.
19:08:10 <Pseudonym> You can't construct a general type out of nothing.
19:08:16 <Pseudonym> You need to supply an initial state.
19:08:21 <whee> well, say a state with an initial value of 0
19:08:26 <Pseudonym> That you can do.
19:08:31 <whee> give that to a function, it uses get/put
19:08:50 <whee> I guess my question is how do I get the initial state without runState
19:08:59 <Pseudonym> You don't.
19:09:06 <Pseudonym> Or you can use evalState or execState.
19:09:17 <Pseudonym> Either way you need to supply an initial state.
19:09:24 <whee> execState with an initial state will return that state?
19:09:28 <whee> (monad)
19:09:37 <Pseudonym> No, it will return the state after the monad has executed.
19:10:02 <whee> I don't see what this monad is doing if I give it an initial state
19:11:15 <Pseudonym> Well, the state monad has a hidden state, which you can read and modify, right?
19:11:22 <whee> right
19:11:30 <Pseudonym> Within that code, if the first operation is a "get", what would it return?
19:11:40 <whee> the initial state
19:11:41 <Pseudonym> You have to supply some initial state for that to make any sense.
19:11:43 <Pseudonym> Right.
19:11:59 <Pseudonym> Now if you modify the state, that's what execState returns.
19:12:02 <Pseudonym> The modified state.
19:12:04 <whee> okay, but what if I don't want to do anything with this state at the moment
19:12:20 <Pseudonym> Er... you don't call get or put.
19:12:38 <whee> so I would have to provide a function that does nothing?
19:12:47 <Pseudonym> Er... yes.
19:12:51 <Pseudonym> Like "return ()" or something.
19:13:41 <Pseudonym> Try it: runState (return ()) 0
19:14:30 <whee> okay, so when is providing a function that does something useful if you can specify the initial right there
19:41:28 <whee> I give up :|
19:41:53 <whee> can't even get anything to typecheck
19:46:52 <Pseudonym> Perhaps if you paste some simple code which fails to typecheck.
19:47:26 <whee> anything with runState in it fails to typecheck
19:47:29 <whee> :P
19:49:38 <Pseudonym> Do you have a specific short example?
19:50:30 <whee> no, heh
19:52:29 <whee> still trying to work out what arguments to give runState
19:52:54 <whee> and what exactly it returns. I thought it would be a tuple of a value and the monad, but I don't know anymore
20:08:30 <Pseudonym> No, it's a pair of the return value and the final state.
20:10:53 <whee> still, runState doesn't like anything I give it
20:11:06 <Pseudonym> Give me an example.
20:12:19 <whee> I would, except I still don't know how to get that first State that it wants.
20:12:40 <whee> so I'm pulling random expressions like using the State constructor with a function that returns (0, ())
20:30:15 <Pseudonym> You shouldn't need to use the State constructor.
20:30:28 <Pseudonym> It's an abstract type, nominally.
20:40:00 <whee> oh, that's nice.
20:40:30 <whee> evalState works, but I'd rather have the state monad and not the result of this
20:45:22 <Pseudonym> Er...
20:45:25 <Pseudonym> I don't understand.
20:45:30 <Pseudonym> What do you want?
20:45:33 <whee> I still can't figure out how to use runState
20:45:37 <whee> I want a state.
20:45:38 <whee> heh
20:45:51 <Pseudonym> runState is like evalState only it returns a pair of the return value and the final state.
20:46:02 <whee> I want something I can go and give to another function, and that function can go call get or modify or something to modify that state
20:46:06 <Pseudonym> Apart from that, it's identical.
20:46:35 <Pseudonym> You mean like an IORef or an STRef?
20:47:29 <whee> not really
20:47:44 <whee> as all this will do is increment by one, I don't need one of those. I assume.
20:48:00 <Pseudonym> I don't actually understand what problem you're trying to solve.
