01:19:25 * sethk is away: I'm busy
02:02:51 <dark> Yawn and stuff.
02:03:10 * shapr tries to run DtdToHaskell on xml-rpc.dtd
02:03:44 <dark> When I went to bed I had hasdl drawing an actual picture, but it was 200 times slower than the C version :)
02:04:07 <shapr> running code is good code
02:04:23 <dark> and code that runs longer is better?
02:04:36 <shapr> not necessarily
02:04:43 <shapr> but runs > doesn't run
02:23:48 <dark> Interesting... adding -prof -auto-all got me a lot more warnings and errors than previously.
02:24:16 <dark> Some of the import declarations returned IO CInt when they should be IO (), and this time gcc actually complained about that.
02:50:09 <jak_> dark, you should be able to achieve about 6 times slower than C
02:51:56 <mgoetze> what does ghc actually use gcc for?
02:51:58 * dark makes it faster by drawing the wrong picture.
02:52:54 <dark> mgoetze: backend.  It can do without, but I use -fvia-C
02:53:30 <dark> And I don't think I can do without -fvia-C in this case, because I include several C header files to get the SDL symbols in scope :)
02:53:54 <dark> Hmm, actually, that's not true.  The FFI declarations are enough for ghc to generate code that links with SDL.
02:54:26 <jak_> the imports happen with hsc I think
02:54:30 <dark> Oho!  Now I see.  I actually wasn't using -fvia-C.  Adding -prof must have added that implicitly.
02:55:19 <mgoetze> dark: so basically it's just a better assembler for ghc, or what?
02:56:26 <jak_> an alternative
02:56:32 <jak_> I don't think it is necessarily better
02:58:40 <dark> gcc is better at register allocation, IIRC
03:02:44 <jak_> yes - gcc is better at lots of optimisation related things. But sometimes there is an overhead in translating to C first
03:04:16 <mgoetze> can i use ghc with nasm?
03:07:54 <dark> Duh.  I also wasn't using -O2.  Adding that made a 10x speed difference.
03:11:33 <mgoetze> dark: lol
03:12:46 <dark> I guess 0.05 seconds is acceptable for now, compared to 0.002 seconds for the C version.
03:13:59 <dark> Direct pixel munging isn't likely to be the dominant model for Haskell SDL programs anyway :-)
03:15:31 <jak_> true
03:15:39 <jak_> more likely things will be bitblt operations
03:15:58 <jak_> besides the programmer can always provide absolutely speed critical ops in C
03:16:11 <jak_> but haskell has gotta be cool to program the game logic
03:18:13 <dark> Yeah :)
03:18:20 <dark> I just didn't want to wait 0.5s for a simple red-blue gradient :-)
03:18:48 <jak_> dark, can you paste an example of how you draw such a gradient ?
03:18:54 <dark> In Haskell?
03:19:01 <jak_> yeah
03:19:06 <dark>   SDL.with_pixels s $ do
03:19:06 <dark>     let pix (x, y) = SDL.set_RGB x y (x, 0, y)
03:19:06 <dark>     sequence_ $ map pix $ range ((0, 0), (255, 255))
03:19:53 <jak_> so with_pixels takes a surface
03:19:58 <dark> with_pixels isn't optimized for setting all of the pixels this way... I think I'll make a create_surface call for that sort of thing.  Then you can create a surface that way, and blit it over to the screen.
03:20:17 <dark> jak: Yeah, the surface returned by SetVideoMode in this case.
03:20:47 <jak_> I always think that these kinds of loop suck a bit in haskell
03:20:52 <jak_> though I can never write them better.
03:21:09 <dark> Technically this is not a loop :-)
03:21:50 <dark> create_surface could just take a function (x, y) -> (r, g, b)
03:22:03 <jak_> that's true
03:22:20 <dark> But taking a list might be a more flexible interface.  Or I could just add create_surface_from_list.
03:22:24 <jak_> quite a nice 'functional' view of a surface
03:24:30 <dark> One problem is that SDL has three views of pixels :)  They can be palette indices, or (r, g, b), or (r, g, b, a).  I should probably make a Pixel class or something.
03:25:00 <jak_> tricky
03:25:05 * mgoetze doesn't like palette indices.
03:25:35 <jak_> I suppose you could get haskell to specialise the functions for each pixel type
03:25:53 <dark> Yeah.  And if there are only three then that's not a big problem.
03:26:13 <dark> Also, inlining might take care of it automatically.  As long as the pixel-type check is made outside the loop it'll be okay.
03:26:44 <jak_> I wonder how much work get's done with pixels anyway
03:26:52 <jak_> I suspect that most operations will be with surfaces
03:27:18 <dark> From what I gather, single-pixel operations are usually thing like drawing a line from one place to another.
03:27:39 <jak_> but there are SDL primitives for that, no ?
03:27:51 <dark> I don't think so.  At least I didn't see any :)
03:27:58 <dark> There are openGL primitives for it, though.
03:28:24 <jak_> perhaps you could get the opengl library to work with your SDL mode
03:28:33 <jak_> since SDL can work with opengl
03:28:56 <dark> Yeah, but that's a later project.  I'm hoping that the HOpenGL modules in fptools will be completed in the meantime :)
03:29:21 <kev> hmmm... can you do remote opengl?
03:29:33 <kev> ala remote X
03:29:51 <dark> kev: I think the library can, but it wouldn't be accelerated.
03:30:22 <dark> But I could be totally off here :)  Maybe the X protocol got extended with GL operations.
03:30:37 <kev> would be very nice if it was, even if the idea's a little silly
03:30:58 <kev> would mean I could play with haskell and GL from home and run it in the labs here
03:31:09 <dark> kev: Not all that silly.  Programs could be using openGL for convenience even if they don't need the acceleration.  It has some nice perspective and projection functions.
03:32:03 <kev> dark: yeah, exactly. It's just that the idea of putting what's normally used for fast realtime 3d apps, over an slow internet link to a remote machine
03:32:39 <dark> kev: Investigate lbxproxy in such a setup :)
03:32:50 <kev> hehe
03:33:05 <dark> It made a remarkable difference when playing spellcaster over a modem.
03:33:21 <kev> give me a few months and I'll have quake running at 1fps ;)
03:33:35 <dark> kev: You might be better off with textquake :)
03:33:50 <dark> (Someone made an svgalib interface to aalib once)
03:34:16 <kev> I've done that before
03:34:39 <kev> I didn't have a TV for a while, so I had an ascii DVD player rigged up over telnet on my lan
03:35:14 <dark> Heh, cool.
03:35:28 <dark> I guess you didn't get sound?
03:36:23 <kev> Nah, I had some speakers plugged in, so I got sound as well
03:36:34 <kev> it was actually watchable
03:36:47 <aps> remote opengl works quite nice on a fast network, can use whatever "acceleration" available on the display-host.. but of course quite slow compared to non-networked..
03:37:06 <kev> aps: so you can actually put it over an X connection?
03:37:23 <dark> aps: Even 3D acceleration, or just the usual acceleration done by X servers for window moving and such?
03:37:50 * kev would assume it would do 3d accel if you can put it over the X protocol - no reason it shouldn't
03:38:20 <aps> sure.. it sends opengl commands over the network and does the rendering on the card.. approximately..
03:38:43 <aps> using huge scenes or lots of textures is slow...
03:38:57 <kev> yeah, because you need to load the texture data over the network
03:58:11 <tinus> hmm, someone here that could help me?
03:58:24 <tinus> i am stuck with my assignment
03:58:43 <clausen> maybe
03:58:54 <tinus> i am not asking for answers
03:58:56 <tinus> just hints
03:59:06 <tinus> i have a type like:
03:59:13 <tinus> type DTD = (Doctype,[Elements])
03:59:13 <clausen> (it's just that I'm tired
03:59:17 <clausen> and thinking of sleeping soon ;)
03:59:20 <tinus> nm what Doctype or Elements is
03:59:25 <tinus> oh, hmm, go sleep then :)
03:59:36 <clausen> not yet ;)
03:59:39 <clausen> but keep talking ;)
03:59:50 <tinus> anyways, i am supposed to write an algebra for this DTD
03:59:57 <tinus> so that i can write a fold for it
04:00:13 <tinus> but i have no clue howto write an Algebra for a non-recursive data type
04:00:14 <clausen> what's an algebra?  (in this context)
04:00:28 <tinus> well, an example algebra is like this:
04:00:36 <tinus> data ExprAS  =  If ExprAS ExprAS ExprAS
04:00:36 <tinus>              |  Apply ExprAS ExprAS
04:00:36 <tinus>              |  ConInt Int
04:00:36 <tinus>              |  ConBool Bool deriving Show
04:00:44 <tinus> that's the data, the algebra for it is like:
04:00:48 <tinus> type ExprASAlgebra a = (a -> a -> a -> a
04:00:48 <tinus>                        ,a -> a -> a
04:00:48 <tinus>                        ,Int -> a
04:00:48 <tinus>                        ,Bool -> a
04:00:48 <tinus>                        )
04:01:37 <tinus> then we need to write a fold like:
04:01:41 <tinus> foldExprAS :: ExprASAlgebra a -> ExprAS -> a
04:01:41 <tinus> foldExprAS (iff,apply,conint,conbool) = fold
04:01:41 <tinus>   where fold (If ce te ee) = iff (fold ce) (fold te) (fold ee)
04:01:41 <tinus>         fold (Apply fe ae) = apply (fold fe) (fold ae)
04:01:41 <tinus>         fold (ConInt i)    = conint i
04:01:42 <tinus>         fold (ConBool b)   = conbool b
04:01:58 <tinus> i understand this example perfectly
04:02:06 <tinus> since it's recursive
04:02:11 <tinus> but my datatype isn't
04:02:22 <clausen> if it isn't recursive, isn't it trivial?
04:02:43 <tinus> well, see
04:02:48 <tinus> there is recursion in my data type
04:02:56 <tinus> just not in DTD, but a little further:
04:03:09 <tinus> type Doctype = String
04:03:12 <tinus> type Elements = (Element,Element)
04:03:15 <tinus> data Element = Item String [Multiplier]
04:03:15 <tinus>              | Data String
04:03:15 <tinus>              | Element :|: Element
04:03:15 <tinus>              | Element :^: Element  -- Comma
04:03:15 <tinus>      deriving Show
04:03:24 <tinus> Element is recursive
04:03:31 <clausen> also, lists are recursive
04:03:44 <tinus> hmm, yes
04:03:48 <tinus> that is true
04:04:06 <tinus> but i think he is aiming at the Elements part
04:04:15 <tinus> since this is a DTD check
04:04:21 <clausen> well, I still don't understand what an algebra is
04:04:42 <tinus> well, it's kind of vague in the textbook as well
04:04:54 <tinus> http://www.cs.uu.nl/docs/vakken/gont/2002/praktikum/opgave4/index.html
04:05:00 <tinus> maybe that clears things up
04:06:36 * clausen wonders if it is akin to skeletons in logic programming
04:09:11 <clausen> do you know prolog?
04:09:25 <tinus> i know it, but cannot write it
04:11:17 <tinus> i need to write a DTD checker, so it would be more logical to be looking at the Elements
04:12:17 <clausen> take a look at this:
04:12:33 <clausen> http://www.cs.mu.oz.au/471/structure.ps
04:12:44 <clausen> you might find the whole site interesting: http://www.cs.mu.oz.au/471
04:12:54 <tinus> looking ..
04:14:23 <clausen> look for the slides on skeletons, and fold
04:14:36 <clausen> (in the structural induction set, which I pasted above)
04:15:11 <tinus> hmm
04:15:41 <tinus> i don't really see what it has to do with my problem :/
04:16:04 <clausen> well, you have to write "fold"
04:16:12 <clausen> I suspect algebra == skeleton
04:16:23 <clausen> (just a different notation)
04:17:33 <tinus> hmm
04:18:03 <clausen> basically, I think it's irrelevant that Element is recursive
04:18:34 <clausen> the skeleton for DTD is trivial, IMHO
04:18:40 <clausen> but the skeleton for Element is non-trivial
04:19:15 <tinus> hmm, ok
04:19:35 <clausen> I think it's a stupid question
04:19:41 <clausen> there is no obvious fold implementation
04:19:49 <clausen> (there are several equally sensible options)
04:19:53 <tinus> it it would be recursive there would be
04:19:55 <clausen> (or equally stupid ;)
04:20:04 <clausen> right
04:20:06 <tinus> if it*
04:20:12 <tinus> but see
04:20:18 <tinus> i had to make the DTD datatype myself
04:20:18 <clausen> fold is only really useful for non-trivial skeletons
04:20:22 <clausen> hmmm
04:20:23 <tinus> so now i am like thinking
04:20:31 <tinus> i did something wrong
04:21:53 <tinus> but my datatype seems to be correct for capturing DTD's
04:21:58 <tinus> doesn't it?
04:25:15 <clausen> well, maybe you should think backwards:
04:25:22 <clausen> what would you expect "fold" on DTD's do?
04:27:47 <andersca> shapr:|?
04:28:53 <tinus> clausen: to make things more abstract is what i think
04:29:42 <clausen> but how?
04:29:48 <clausen> what would it's type signature be?
04:29:55 <clausen> what would the higher-order parameter do?
04:31:09 <tinus> the higher-order parameter?
04:31:22 <clausen> fold takes a high order parameter
04:31:35 <clausen> "higher-order" == a function being passed as a parameter
04:31:42 <tinus> oh, ok
04:31:42 <clausen> eg: foldl (+) 0 [1..5]
04:31:48 <clausen> (+) is the high order parameter
04:32:42 <tinus> hmm
04:34:33 <tinus> in my case i have no clue what it'll do
04:34:47 <tinus> i don't really get the point why he wants to use a fold here
04:36:08 <clausen> why don't you ask?
04:36:28 <tinus> because i am at home atm
04:36:32 <clausen> email?
04:36:32 <tinus> and it's due today
04:36:35 <clausen> ah
04:36:37 <tinus> hm, i might try
04:36:47 <tinus> i've been fiddling with this for over 4 days now
04:36:58 <tinus> since i was feeling sick before
04:37:19 <dark> It looks to me like the question is underspecified.  Either that or you missed some lectures :)
04:37:33 <tinus> i think the 2nd
04:37:40 <tinus> since i was sick for a few days
04:40:25 <andersca> fib = 1:1:zipWith (+) fib (tail fib)
04:40:27 <andersca> this one is nice
04:40:30 <andersca> (thanks dennisb)
04:41:07 <dennisb> hoho
04:41:59 <dark> Might be time to also start a collection of different ways to do fib.  We could call it "1001 bunnies" :-)
04:43:14 <dennisb> why are we talking about fib?
04:44:30 <dark> Isn't it sort of a default topic?
04:45:03 * ibid asks again, what does (head topic) mean?
04:45:31 <dark> ibid: colloquially?
04:45:45 <ibid> ?
04:45:52 <dark> "nads" is an abbreviation of "gonads", i.e. balls, testicles, machismo.
04:46:02 <tinus> heh
04:46:02 <ibid> ahh
04:47:45 <andersca> fib and factorials are the default topics
04:50:33 <dark> Looking at a computer screen while using an electric toothbrush gives interesting effects :)
04:51:51 <dark> The image seems to dance around, while the monitor frame stays fixed.  The image doesn't even stay completely inside the frame.
04:54:03 <dark> Obviously I need to increase my refresh rate :-)
05:07:05 <tinus> dark: heh, same effect happens when you move around your alarm clock
05:07:12 <tinus> dark: the ones with the red LEDs
05:07:18 <dark> Yeah I have one of those :)
05:07:29 <tinus> weird effect
05:26:29 * ibid ircs over gprs :-)
06:18:47 <dark> Cool, adding a Pixel class makes it much prettier.
06:20:14 <dark> But now I have to go :)
06:34:52 <shapr> ibid: wow, cool
06:36:46 <ibid> not anymore, though
06:37:00 <ibid> the lag is not something one tolerates if one has a choice
06:37:10 <shapr> andersca:|?
06:37:29 * shapr now knows more swedish
06:38:05 <kev> far jag klappa din hockeyfrilla?
06:38:10 <andersca> shapr: do you know daniel lundin?
06:38:46 <shapr> andersca: yah sure.
06:38:46 <shapr> why?
06:38:56 <andersca> shapr: we work for the same company
06:39:00 <shapr> spiffy
06:39:03 <shapr> He's a cool guy.
06:39:21 <shapr> well, I know him via #emacs on irc
06:39:27 <shapr> I haven't actually met him.
06:40:01 <shapr> doesn't he run/own codefactory.se also?
06:40:01 <andersca> you were cited in our fortune file
06:40:13 <shapr> ono... what's the quote?
06:41:00 <shapr> he's danl on irc.. iirc, he made the emacswiki logo
06:41:15 <shapr> he also started ... esmerelda?
06:41:19 <shapr> I think that's the name of it.
06:41:56 * shapr checks
06:42:17 <shapr> oh, and danl has an extra spiffy x-face :-)
06:42:56 <shapr> andersca: you work for codefactory.se ?
06:43:06 * kev has someone coming up from Manchester tomorrow, that he's never met, but has known on irc for 4 years
06:43:17 <shapr> cool!
06:43:29 <shapr> kev: talar du svenska?
06:43:37 <kev> shapr: nope
06:43:42 <shapr> oh, ok
06:44:02 <kev> I just know enough to embarass myself if I ever meet any swedish people ;)
06:44:05 <shapr> heh
06:44:20 <shapr> I'm just a backwards american :-)
06:44:34 <shapr> well, USAer
06:44:49 <andersca> shapr: yes
06:44:53 * shapr notes that american could mean either north or south.. and that's a lot of countries
06:45:12 <kev> hmmm... any of you know if it's possible to implement a turning machine using cellular automata?
06:45:19 <shapr> andersca: cool! do you work on MrProject or RoadRunner?
06:45:44 * shapr wonders if you could consider a turing machine as a cellular automata
06:45:54 <shapr> andersca: I wanna know what quote you found :-)
06:46:12 <andersca> shapr: I work on other things (secret stuff)
06:46:18 <shapr> andersca: ah, ok
06:46:28 <kev> I really just want to know if I can use this game of life engine to do real processing
06:46:30 <shapr> andersca: you must be at the sthlm office then...
06:46:44 <shapr> I'd like to visit the head office, and it's not too far from here.
06:46:58 <andersca> shapr: no, I'm at the göteborg office
06:47:55 <shapr> andersca: how was I cited in your fortune file? I'm terribly curious.
06:48:01 <andersca> shapr: trying to find it
06:48:15 <andersca> wow, now I found another one
06:48:20 <andersca> <shapr> how do I correctly display two byte fonts?
06:48:20 <andersca> <liiwi> you take the first byte and display it
06:48:20 <andersca> <liiwi> then you take the other byte and display it
06:48:21 <shapr> from me?
06:48:24 <shapr> ohh
06:48:27 <shapr> those are from emacswiki!
06:49:17 <andersca> <shapr> I should finish things more often
06:49:17 <andersca> <shapr> like code, not juice cartons
06:49:28 <shapr> http://emacswiki.org/cgi-bin/wiki.pl?EmacsChannelQuotes
06:49:34 <shapr> yup, that's from emacswiki
06:49:43 <shapr> oddly enough, I get quoted regularly.
06:49:55 <shapr> I'm not sure if that's a compliment or not :-)
06:50:57 <shapr> andersca: most likely danl is slurping off the EmacsChannelQuotes and stuffing them into the fortune files.
06:51:52 <liiwi> shapr: you're a quotable person
06:52:04 <shapr> liiwi: it seems so... but is that a good thing?
06:52:26 <liiwi> is ice-cream a good thing if you eat too much?
06:52:31 <shapr> hm, good point.
06:52:55 <shapr> oh hey, I want to post xmms-shell.el to g.e.sources today
06:55:14 <kev> liiwi: it definitely is ;)
06:56:27 <kev> Wolfram was the first to
06:56:28 <kev>    study it, and concluded that it obviously could not be Turing
06:56:28 <kev>    complete. Matthew Cook later proved it actually is Turing complete,
06:56:28 <kev>    and presented the proof at a Santa Fe Institute conference, but
06:56:28 <kev>    Wolfram suppressed its publication with a court order.
06:56:30 <kev> whoa!
06:56:42 <shapr> eh?
06:56:44 <shapr> what's that about?
06:56:50 <kev> cellular automata
06:56:55 <shapr> oh, nifty
06:57:13 <kev> in particular the 110 linear automata 
06:59:22 <kev> I can't find anything on that injunction though, would be interesting to find out what happened
07:00:00 <shapr> yah, I agree.
07:00:37 <kev> ah, found it
07:00:47 <kev> http://www.math.usf.edu/~eclark/ANKOS_rule_110.html
07:02:14 <shapr> bah, wolfram == microsoftie
07:02:37 * shapr wonders if tail call optimization == booty call
07:02:42 * shapr obviously needs sleep
07:02:52 <kev> yeah, I got that impression of wolfram when I first ever saw his site
07:03:00 <kev> it's really just sickening tbh
07:15:48 <shapr> hi isaac
07:16:02 <isaac> hi shapr :)
07:16:16 <shapr> how's the world of funk treating you? ;-)
07:17:07 <isaac> I can't complain too much.  I'm about to start looking at FFI options for an application I've been working on.
07:17:49 <isaac> SyntaxPolice is me :)
07:17:54 <shapr> aha
07:18:54 <SyntaxPolice> how are you?
07:19:00 <shapr> I'm doing well.
07:20:00 <shapr> how are you?
07:21:55 <SyntaxPolice> pretty good. I had some success with using HUnit to unit test yesterday and flushed out some bugs which pleased me.
07:22:19 <shapr> oh, HUnit is good
07:22:23 <shapr> have you tried QuickCheck also?
07:24:52 <SyntaxPolice> no, I haven't.  Does it have any more features than HUnit?
07:25:06 <shapr> er... kind of?
07:25:14 <shapr> QuickCheck is a generative testing tool.
07:25:35 <SyntaxPolice> I want to settle on one very soon.  I'm hoping to package the stuff I use every day for Debian.
07:25:41 <SyntaxPolice> shapr: I'll check it out.
07:25:55 <shapr> I'd very much like to see HUnit in Debian
07:27:11 <shapr> HUnit and QC have different feature sets
07:27:22 <shapr> though I think they could be stuck together into one piece of software
07:27:32 <SyntaxPolice> You would? Great, that gives me a lot more motivation.
07:27:53 <shapr> I have HUnit stuck into my home dir right now
07:28:02 <shapr> along with runTestDots that Dean came up with for me
07:28:05 <SyntaxPolice> yeah, I've got it in /usr/local/lib I guess.
08:00:19 * sethk is back (gone 06:40:53)
08:01:54 <shapr> of course.... my quotes are nothing compared to the top 100 on bash.org
08:05:20 * shapr bounces
08:08:26 <shapr> any HaXml clueful people around?
08:11:07 * Heffalump attaches some lead weights to shapr
08:11:10 <Heffalump> (no, sorry :-)
08:12:04 <shapr> heh
08:28:22 * shapr notes that Simon Marlowe wishes to pass on maintainership of haskell-mode
08:46:17 * shapr looks at haskell-mode deb
08:46:55 --- topic: set to '["mo' nads than you", "We put the Funk in Funktion", "See logs @ http://tunes.org/~nef/logs/haskell/", "Gtk+HS 0.14.10: http://www.cse.unsw.edu.au/~chak/haskell/gtk/", "HWS-WP: http://www.dum.chalmers.se/~marvin/hws-wp/", "need HaskellWiki source text, contact shapr", "ANNOUNCE: GHC version 5.04.2 released"]' by shapr
08:57:32 <shapr> hi aps
08:57:46 <aps> hi
08:57:47 <shapr> ghc 5.04.2 released.. yay!
08:57:56 * shapr downloads
09:00:59 <norpan> what's new
09:02:30 <shapr> http://www.haskell.org/ghc/docs/latest/html/users_guide/release-5-04.html
09:05:23 <Heffalump> just bugfixes, right?
09:06:09 <Heffalump> shapr: Keith Wansborough talking about "assistance welcome" for fixing the Wiki on the list
09:06:16 <SyntaxPolice> shapr: I think you shouldn't have told me about bash.org.
09:07:11 <shapr> SyntaxPolice: yah, it's addictive ;-)
09:07:17 <shapr> Heffalump: cool, I'll look for that.
09:37:57 * sethk is away: I'm busy
09:39:03 * sethk is back (gone 00:01:06)
09:39:53 * sethk is away: I'm busy
09:40:06 * sethk is back (gone 00:00:11)
09:40:18 * shapr watches seth bounce
09:41:08 <sethk> sorry about that, fixed.
09:42:05 <sethk> last time   :)
09:42:17 * sethk is away: I'm busy
09:42:28 * shapr grins
10:49:59 <shapr> hi tmoertel, ltns
10:50:09 <shapr> how are ya?
10:50:26 <tmoertel> shapr: yes, ltns, indeed; work, travel, and the ususual suspects have kept me away
10:51:09 <Heffalump> 'lo
10:51:12 * tmoertel wonders if Chilli is at this very moment building 5.04.2 RPMS...
10:51:34 <shapr> usually he's not awake yet :)
10:51:54 <Heffalump> :-)
10:51:54 * shapr bounces
10:52:53 <shapr> tmoertel: written any cool code lately?
10:56:00 <shapr> hi BlitzNL
10:56:14 <BlitzNL> hi shapr
10:56:44 <shapr> what's up?
10:57:19 <BlitzNL> Nothing, I am writing a paper on different package managers for linux/bsd, no haskell I am afraid
10:57:30 * shapr votes for apt
10:58:00 <BlitzNL> shapr: hehe why? (this is research ;))
10:58:14 <shapr> because apt is the best package manager :-)
10:58:23 <BlitzNL> yeah ;) 
10:58:48 <shapr> actually, the real problem is third party packages
10:58:54 <BlitzNL> people seem to defend their favorite with religious fervor
10:59:09 <shapr> nearly any packaging system can be broken by releasing stupid packages with screwy version numbers.
11:00:00 <shapr> when I switched from redhat to debian, redhat didn't have network updating of package lists and packages
11:00:03 <BlitzNL> yeah that's correct, but my conclusion will be that the biggest problem of package management is the absence of configurability
11:00:07 <shapr> I know mandrake does have that now.
11:00:19 <shapr> how so?
11:00:34 <BlitzNL> shapr: up2date is rpm's network updating tool
11:00:50 <shapr> what kind of configurability are you looking for?
11:01:17 <BlitzNL> shapr: well the configurability a make install gives you. Packages are preconfigured.
11:01:55 <shapr> can you give me some examples?
11:02:26 <BlitzNL> I have no ability to custom build a package. I may want to be able to install a package with: debug info. 
11:03:13 <shapr> hm
11:03:19 <BlitzNL> Maybe this is a better example: When I have windows 2k profession and home ;) The difference maybe nothing but some compiler flags but you have to release 2 different packages because the have to be preconfigured
11:03:53 <shapr> I just grab the source of the debian package, make my changes, and rebuild it.
11:04:04 <shapr> apt-get source haskell-mode
11:04:11 <BlitzNL> shapr: but damn shapr I am thinking about this all day, I was looking for some distraction ;)
11:04:19 <shapr> throw in the new version of the files
11:04:24 <shapr> dpkg-buildpackage
11:05:09 <BlitzNL> shapr: that's interesting .. mmm
11:05:29 <shapr> the source of a debian package includes the original package, and the diffs the package maintainer has made.
11:05:48 * Heffalump thinks Debian source packages are really annoying
11:06:05 <Heffalump> (just to get in my pet rant while Igloo's not around :-)
11:06:08 <BlitzNL> Heffalump: use alien to adapt a rpm ;)
11:06:21 <shapr> Heffalump: why?
11:06:31 <Heffalump> blitznl: ugh!
11:06:44 <Heffalump> shapr: it makes it very hard to have multiple upstream sources
11:07:06 <Heffalump> packaging isn't always just "debianise this tarball"
11:07:21 <Heffalump> not only that, but they insist on renaming the upstream tarball to suit their naming scheme
11:08:05 <Heffalump> also, it's very easy to screw up so that "debian/rules clean" doesn't produce the same result as re-unpacking the sources
11:08:45 <BlitzNL> Heffalump: so you prefer rpm?
11:09:38 <Heffalump> mostly, yes
11:09:49 <Heffalump> deb binary packages are superior to rpms because of the debconf thing
11:10:07 <Heffalump> so I'm somewhat ambivalent
11:10:12 <shapr> debconf, defoma, update-alternatives
11:10:29 <Heffalump> the issue tends to get clouded by the fact that Debian packages are usually superior to Redhat packages in quality
11:10:49 <shapr> I can have five different JVMs installed, and switch which one is default easily
11:10:49 <Heffalump> and by the existence and easy usability of apt-get (and I know apt-rpm exists, I use it a lot, but it's more hassle and not as reliable)
11:10:56 <Heffalump> what is defoma?
11:11:01 <shapr> debian font manager
11:11:19 <shapr> etherconf
11:11:22 * sethk is back (gone 01:29:03)
11:11:41 <Heffalump> there's nothing fundamental that stops rpm having those though
11:11:59 <shapr> also, I installed Debian 2.0 on this box, and it's now running 3.0
11:12:06 <Heffalump> it's the hooks that allow it to ask the user and record the results in a centralised fashion that make deb superior as a binary format
11:12:15 <Heffalump> that's a quality of packages issue
11:12:36 <Heffalump> I've upgraded RH5->6 and 6->7 on the fly but things break cos RH don't design their packages for it
11:14:25 <shapr> I like the quality of most debian packages.
11:14:33 <SyntaxPolice> I understand that redhat has some apt-get like feature which allows users to download and install a package, right?
11:14:49 <BlitzNL> SyntaxPolice: yes, up2date
11:15:37 <SyntaxPolice> Does rpm have a facility for checking those files to be sure they're really from redhat?
11:15:52 <Heffalump> I imagine up2date can check GPG signatures
11:16:26 <SyntaxPolice> Heffalump: does that mean that you think that it does check gpg signatures, or that it wouldn't be hard to do so?
11:16:38 <SyntaxPolice> Do the packages come w/ sigs or md5 sums or something?
11:16:55 <BlitzNL> SyntaxPolice: well you have to subscribe so I this is a restricted area
11:17:07 <shapr> gpg signed rpms are subscriber only?
11:17:48 <shapr> hi systems
11:17:49 <BlitzNL> well up2date only downloads from redhats servers. I can't influence this (I think). this makes it safe enough for me
11:17:55 <systems> shapr hi
11:18:25 <SyntaxPolice> hm, so you can't tell up2date what servers to download from? So I couldn't tell it to use my nearest mirror or something?
11:18:33 <shapr> part of being a debian developer is having your gpg key signed so that you're in the web of trust of debian developers
11:19:03 <shapr> I think it's the first requirement even
11:19:20 <SyntaxPolice> shapr: yeah, so thats how debian knows on their end whether the packages you upload are OK, but at the moment, there is no real facility for the downloading user to know whether the packages are OK.
11:19:48 <SyntaxPolice> but there is a script to check the MD5 sums of the Packages files and verify the signed Release file.
11:19:49 <shapr> I'm nearly positive that I can verify debs
11:19:52 * shapr checks
11:19:53 <SyntaxPolice> I was wondering how redhat does it.
11:20:28 <shapr> ah, you mean no facility built into apt-get or dpkg
11:20:28 <Heffalump> I don't think the signature is available any more after the debian archives have accepted pacakges
11:20:45 <Heffalump> it's a known weakness of the debian package distribution system that they're trying to fix
11:20:51 <SyntaxPolice> since the autobuilders take over after that, I would guess not.
11:21:09 <Heffalump> redhat packages are signed by just one key which makes things much easier
11:23:53 * tmoertel returns from a phone call . . .
11:24:26 <shapr> when I rebuild debs, or when I build kernel debs, it tries to sign them with my GPG key
11:24:50 <Heffalump> yes, but the debian archive system checks this and then throws it away when developers upload, AIUI
11:37:49 * sethk is away: I'm busy
11:44:10 <SyntaxPolice> I have a question; I'm considering packaging some Haskell stuff for Debian, including HUnit.  I'm considering just creating /usr/lib/HUnit-1.0 or something does that sound reasonable?  I can think of at least one problem.
11:45:38 <SyntaxPolice> I think that ghc would complain of permissions problems if it tried to compile stuff in there.
11:51:56 <SyntaxPolice> any ideas, shapr?
12:18:48 <Riastradh> I'm new to Haskell.  The examples of 'Gentle Introduction to Haskell' don'
12:18:51 <Riastradh> Er.
12:19:06 <Riastradh> ...don't seem to work in hugs -- i.e., inc n = n + 1
12:19:20 <Riastradh> Is there something I'm doing wrong?
12:21:11 <SyntaxPolice> Riastradh: you cannot define functions on the top level of hugs.
12:21:24 <Riastradh> Oh.
12:21:34 <Riastradh> I assume that applies to types, as well?
12:21:36 <SyntaxPolice> Riastradh: you could, for instance say "let inc n = n + 1 in inc 5"
12:21:46 <Riastradh> I see.
12:22:15 <SyntaxPolice> Riastradh: I'm not sure if there is a better way to do so, but I would just open up a file and use :load to try stuff out.
12:22:56 <Riastradh> Is there a standard or common Haskell file extension?
12:23:09 <SyntaxPolice> When I was going through the gentle intro, I was also reading the hugs manual at the same time: http://cvs.haskell.org/Hugs/pages/hugsman/index.html
12:23:17 <SyntaxPolice> Riastradh: yes, its Filename.hs
12:23:23 <Riastradh> OK, thanks.
12:23:26 <SyntaxPolice> where Filename is probably the name of the module declared int he file.
13:04:20 <whee> erm
13:04:31 <whee>     Illegal signature in pattern: Tree Int (Int -> Int -> Int)
13:04:33 <whee>         Use -fglasgow-exts to permit it
13:04:36 <whee> what exactly is illegal about that?
13:06:08 <whee> oh, it just didn't like how I formatted the code. odd
13:42:52 <hdaume> anyone here have 5.04.2 installed yet?
13:47:24 <whee> 5.04.2 is out?
14:02:01 <whee> if I'm using a type a lot, can I simply it using newtype to save typing?
14:02:48 <whee> specifically I'm using a lot of types like "Tree a (a->a->a)" and would like to be able to represent that type with "FunTree a" or something similar
14:09:28 <SyntaxPolice> whee: I think you can say "type FunTree a = Tree a (a->a->a)"
14:10:04 <SyntaxPolice> or you could say "type FunTreeInt = Tree Int (Int->Int->Int)
14:10:05 <SyntaxPolice> "
14:10:30 <SyntaxPolice> but if you use newtype, then you can't use any of the functions that used to take Tree a (...), since they will be considered different types.
14:11:15 <whee> that works. woo
14:11:34 <whee> so type is for aliasing types and newtype for creating an entirely new type which is just a minor extension of an existing one?
14:16:10 <SyntaxPolice> whee: that is my understanding, yeah :)
14:56:39 <Pseudonym> shapr, now's your chance.  Keith Wansbrough wants assistance with the wiki. :-)
15:01:56 <Marvin--> heh
15:42:09 * sethk is back (gone 04:04:19)
18:43:46 <whee> is there any reason why using the Memo module's memo function would actually make things slower?
18:43:55 <whee> (GHC)
18:49:27 <Pseudonym> Several reasons.
18:49:49 <Pseudonym> The function might be quite quick as it is, or the cost of comparing keys might be high.
18:50:00 <Pseudonym> Or it might be worse memory performance.
18:51:17 <whee> yeah I think you're right with the function being too fast to begin with
18:51:24 <whee> memo is probably just adding overhead
18:51:38 <whee> guess it's time to learn template haskell and use that to generate a huge binary tree for me to test with :)
18:53:06 <Pseudonym> What are you memoing?
18:53:49 <whee> one function that checks if a tree is balanced and another to get the depth
18:54:20 <Pseudonym> It might be worth caching the depth in your nodes.
18:54:21 <whee> just wanted to see what kind of gains I could get from memoing but I need larger data to work with
19:04:09 <engstad> Is there a way to define ternary operations like C's ?: in Haskell?
19:06:08 <whee> I really wish I knew since I'd like to know as well. heh
19:06:45 <lament> engstad: that's what if..then..else is
19:07:09 <whee> shorthand is nice sometimes
19:07:49 <lament> yes, but other than that
19:08:04 <lament> if(){}else{} and ?: are two completely different constructs in C
19:08:11 <lament> one is a statement and the other an operator
19:08:34 <engstad> Well, in this case I'm not looking for the ?: constructs, rather:   f [ a := b ]
19:09:05 <engstad> Or: f [ a := b ] = \x -> if x = a then b else f x
19:09:18 <engstad> Now, I don't think I can write that in Haskell.
19:10:24 <engstad> In other words, it is a function that changes the original f in such a way that if the input happens to be a it maps it to b.
19:11:13 <engstad> This works:   update f a b = \x -> if x == a then b else f x
19:11:25 <engstad> But I wanted a nicer syntax.
19:11:29 <whee> hmm
19:12:13 * whee wonders how then if/then/else construct is defined
19:15:15 <Heffalump> internally
19:15:24 <Pseudonym> engstad: There's a paper recently by CHris Okasaki about implementing postfix operations.
19:15:29 <Pseudonym> It's pretty close.
19:16:14 <whee> would it be possible/easier to do some sort of preprocessing instead?
19:17:12 <Pseudonym> Depends whether or not you find it easy to write a preprocessor.
19:19:26 <engstad> Pseudonym: Do you have a link to it, or is google my friend?
19:19:47 <Pseudonym> I have a link to it at the ACM digital library.  Do you have access to that?
19:19:58 <engstad> No, afraid not.
19:21:37 <Pseudonym> Hmmm.
19:21:51 <engstad> Not on Citeseer either...
19:24:01 <Heffalump> the okasaki paper was on his homepage IIRC
19:33:27 <Pseudonym> Hete it is:
19:33:29 <Pseudonym> http://www.eecs.usma.edu/Personnel/okasaki/pubs.html#hw02
19:42:22 <engstad> Have to run, see yas!
21:52:20 <dark> Heh... you know it's too early in the morning when black-on-white windows are too bright to read.
22:56:21 <drast> r there any users of this weird language?
22:56:38 <lament> what weird language?
22:57:26 <drast> haskell
22:57:34 <drast> isn't this channel about that language
22:57:37 <drast> functional language
22:57:48 <jemfinch> yes.
22:58:05 <drast> so I am asking are there any users of this weird language
22:58:09 <drast> do you actually use it
22:58:10 <lament> it's not weird
22:58:31 <jemfinch> lament: it's weird, man.
22:58:34 <drast> no it is weird
22:58:35 <jemfinch> heck, all functional languages are weird.
22:58:39 <drast> it is functional language
22:58:42 <jemfinch> it's something to be proud of.
22:58:45 <drast> you have to change your mind to learn it
22:59:01 <drast> no it is not something to be proud of
22:59:01 <lament> jemfinch: they're only weird if you know C, Java and C++
22:59:05 <drast> it is a shame
22:59:15 <jemfinch> that 99% of the world thinks Haskell is "weird" means that we're the only ones who can really appreciate it for what it's worth.  And that means we're smarter than all those other folk.
22:59:18 <lament> jemfinch: if you knew Haskell, ML and Scheme and tried to learn Java, java would look weird
22:59:31 <jemfinch> lament: not really.
22:59:38 <lament> yes really
22:59:41 <drast> jemfinch: yeah you are smarter than everbodyelse who doesn't know Haskell
22:59:44 <jemfinch> I know Haskell, ML, and Scheme, and I haven't gone to the trouble of learning Java, but I don't think it's weird.
22:59:44 <drast> that's weird in itself
22:59:46 <drast> though
23:00:01 <lament> jemfinch: well, if haskell, ml and scheme were the only languages you knew
23:00:02 <jemfinch> I don't think Python's weird because I prefer FP.
23:00:07 <drast> I learned Haskell too, and I think it is weird
23:00:08 <lament> jemfinch: and then you tried to learn java.
23:00:11 <drast> useless
23:00:16 <drast> maybe useful for weird projects
23:00:17 <drast> :)
23:00:25 <jemfinch> lament: but that's just it: we wouldn't think Java's weird because we'd be prepared for everything it offers.
23:00:36 <lament> jemfinch: hmm, perhaps.
23:00:38 <jemfinch> Haskell, ML, and Scheme prepare a programmer well for the concepts he'll contend with in other languages.
23:00:41 <lament> jemfinch: you're right. Silly, not weird.
23:00:47 <jemfinch> Whereas Java/C/C++ don't :)
23:01:15 <jemfinch> We'd be like, "Oh, Objects?  They just look like closures to me."
23:01:15 <drast> you are weird people
23:01:33 <lament> drast: what's your point?
23:01:35 <jemfinch> whereas C people coming over to, say, ML, think "How in the world is he making a function at runtime?"
23:02:01 <drast> lament: what's your point?
23:02:17 <drast> i don't have any point, do I have to 
23:02:29 <drast> whatever, good learn and use whatever you want
23:02:47 <drast> do you think that I will try to persuade you how weird Haskell and you should normally use others
23:02:49 <jemfinch> drast: why are you here?  do you want to know Haskell?  Do you want to argue about Haskell?  What?
23:02:53 <drast> I don't care
23:02:59 <drast> no
23:03:11 <drast> I just wanted to make sure that it is really about the haskell that I know
23:03:20 <jemfinch> drast: it is.
23:03:24 <drast> and I would never think that there would be a channel on IRC about this weird language
23:03:27 <drast> so I came in 
23:03:30 <drast> and I checked it out
23:08:40 <dennisb> I can only speak for myself and knowing haskell (and FP) made me a better C programmer, and I had programmed C about 5-6 years before I saw FP the first time
23:12:49 <dennisb> It could of course be unrelated and that I just matured as a programmer at the same time, but I got better at abstract thinking and resoning that helps me no matter what language
23:13:04 <dark> Apparently in some parts of the world the proper etiquette when meeting a new group of people is to insult the one interest you know they all have in common.  Is this related to that "male bonding" thing I've heard of?
23:13:24 <dennisb> dark: must be :-)
23:13:41 <drast> no I think it is mostly because of getting bored
23:14:10 <dennisb> I tend to just treat people in the most resonable way and they get tired, it's no fun to try to upset someone who don't get upset
23:14:34 <drast> well me too, i totally agree with you
23:14:57 <drast> but sometimes the other guy feels insulted because of your jokes
23:15:01 <drast> or you not so serious comments
23:16:45 <dennisb> Well, I have to go. I have some haskell programs to write at work...
23:17:02 <dark> Anyway, in one language we have: factorial n = product [1 .. n]
23:17:10 <dark> And in another, we have: int factorial (int n) { return n == 0 ? 1 : n * factorial(n-1); }
23:17:14 <dark> Now tell me again which one is weird :-)
23:23:01 <drast> dark: second one
23:23:35 <drast> but since I knew recursion it is not realy weird to me
23:24:42 <lament> recursion or not, it looks unhealthy :)
