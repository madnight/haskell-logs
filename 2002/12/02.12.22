03:20:51 <olczyk> Anyone hear?
03:21:12 <olczyk> Anyone here?
03:27:32 <Heffalump> me
03:27:35 <Heffalump> sort of
03:27:52 <Heffalump> very sort of, really
03:33:47 <olczyk> I was wondering.
03:34:02 <olczyk> How do you do "handshaking" in FP.
03:34:39 <olczyk> Since "handshaking" by definition requires side effects.
03:40:18 <Heffalump> what kind of handshaking?
03:40:42 <Heffalump> but using the IO monad, almost certainly
03:40:59 <Heffalump> you could probably build a nice elegant state machine
03:41:20 <olczyk> Hmmm. trying to think of a good example but can't.
03:41:40 <olczyk> Basically things like handshaking with peripherals.
03:41:55 <olczyk> Say you want to send data, but before the peripheral has to say it's OK.
03:42:20 <olczyk> But I'm thinking software tosoftware. Mostly in event driven systems.
03:42:28 <Heffalump> well, you'd have to use IO to talk to peripherals anyway
03:42:30 <Heffalump> or to other processes
03:42:53 <Heffalump> though event driven stuff is probably nicer using callbacks
03:42:58 <olczyk> Function A has to make sure that Function B has completed a part of it's task before it cando it's
03:43:00 <olczyk> thing.
03:46:59 <Heffalump> anyway, got to go
03:47:10 <Heffalump> there's plenty of examples of this sort of thing around, I'm sure
05:12:46 <Janni> hi
07:31:14 <shapr> y0
07:39:47 <Janni> re
08:00:38 <dark> shapr: Are you there?
08:01:03 <dark> I need someone to test the joystick support in hasdl.  I don't have a joystick :)
08:01:16 <dark> hasdl-0.1pre7.tar.gz
09:56:01 <shapr> hmm
09:56:10 <mgoetze> hi shapr 
09:56:13 <shapr> hi mgoetze, what's up?
09:56:27 <mgoetze> the party is in #happyholidays :)
09:56:34 * shapr is idly working on MrsProject using FGL
09:56:57 * mgoetze started a new project called GoNads!
09:56:59 * shapr thinks of user stories for a task tracking app
09:57:03 <shapr> heh, great name
09:57:13 <shapr> what's the project about?
09:57:36 <mgoetze> it's about a bunch of monads which give the appearance of being able to play go :)
09:57:41 <shapr> oh, cool
09:57:49 <shapr> that's a really excellent name in that case
09:58:17 <mgoetze> yeah. so far, it can at least draw the board on a text terminal... hehe
09:58:41 <shapr> nice
09:59:31 <shapr> is there some way to run all of my unit tests in main?
09:59:45 <shapr> any HUnit clusers here?
09:59:48 <shapr> (clueful users)
10:07:00 <shapr> sometimes I wish I could look at the types of a line of code rather than the code itself
10:08:40 <mgoetze> you mean like Int = Int + Int?
10:08:46 <shapr> yah, like that
10:08:54 <shapr> would be handy in some cases
10:09:51 <mgoetze> yeah, prolly
10:16:39 * shapr is having a typing problem
10:16:47 <shapr> no one is surprised I'm sure
10:17:48 <shapr> runTestTT in HUnit takes a TestList
10:17:52 <shapr> runTestTT mrsProjectTestList
10:18:05 <shapr> which is :: IO Counts
10:18:16 <shapr> Counts are an instance of Show
10:18:40 <shapr> after some blind hacking, I came up with this:
10:18:43 <shapr> > main = join $ liftM putStr $ liftM show $ runTestTT mrsProjectTestList
10:18:58 <shapr> it satisfies the expected type of main :: IO ()
10:19:04 <shapr> but ghc won't compile happily
10:19:09 <shapr> it keeps exploding
10:19:43 <shapr>  /usr/lib/ghc-5.04.2/libHSrts.a(Main.o)(.text+0x7): In function `main':
10:19:43 <shapr> : undefined reference to `__stginit_Main'
10:19:43 <shapr>  /usr/lib/ghc-5.04.2/libHSrts.a(Main.o)(.text+0x1e): In function `main':
10:19:43 <shapr> : undefined reference to `Main_zdmain_closure'
10:19:43 <shapr> collect2: ld returned 1 exit status
10:20:01 <shapr> I've seen some people use -fvia-C to get around weird errors like that, but it doesn't change anything
10:20:08 <shapr> am I making a typing mistake?
10:20:55 <mgoetze> hm
10:21:19 <mgoetze> typing mistakes ought to be caught much earlier than that by ghc
10:21:27 <shapr> I can run main interactively in ghci just fine
10:21:40 <shapr> yah, I agree
10:24:49 * sethk is away: Don't say anything until I return.
10:25:07 * sethk is back (gone 00:00:01)
12:08:47 <xkb_away> hmm.. I have a problem with a real simple haskell program
12:10:22 <xkb> the problem is !! goes out of bounds sometimes
12:10:35 <xkb> I think it is related to lazy eval..
12:10:36 <xkb> perhpas
12:10:39 <xkb> haps
12:12:02 <xkb> Can anyone help?
12:12:14 <xkb> Ill sketch the problem the program is supposed to solve:
12:12:29 <xkb> The aim is to pair 2 people according to the following rules:
12:12:44 <xkb> 1) people can not be paired to themselves
12:13:03 <xkb> 2) someone who is paired cannot be paired again
12:13:15 <xkb> 3) pairing must be random (or semi-random)
12:13:25 <xkb> 4) the group of people is of size N
12:14:35 <sethk> xkb:  There is (supposedly) no way to get out of bounds situations with Haskell.
12:14:45 <xkb> hmm
12:14:58 <sethk> What exactly do you see?
12:14:58 <xkb> I think it really is a programming error of myself
12:15:01 <xkb> but I can find it
12:15:09 <sethk> What is the symptom?
12:15:48 <xkb_> Program error: Prelude.!!: index too large
12:15:49 <xkb_> Program error: Prelude.!!: index too large
12:15:49 <xkb_> Program error: Prelude.!!: index too large
12:15:50 <xkb_> in hugs
12:15:51 <xkb_> ow
12:15:55 <xkb_> sorry for the repeat
12:16:28 <sethk> DCC the program file to me.
12:16:33 <xkb_> k
12:17:51 <xkb_> sethk: should be on its way now
12:18:36 <sethk> It's sitting there waiting.  I hate DCC.  Email it to me at seth@cql.com
12:18:42 <xkb_> k
12:18:46 <xkb_> I hate it to :D
12:20:23 <xkb_> should be there now
12:21:08 <sethk> OK, I'll check.
12:21:12 <xkb_> k
12:26:04 <xkb_> sethk: any clues yet?
12:26:26 <sethk> Had to take a support call.  Give me a few more minutes.  :)
12:26:54 <xkb_> :D
12:27:01 <xkb_> thanks again anyway :)
12:28:39 <xkb_> The program works as expected, however sometime I get the !! out-of-ounds
12:28:42 <xkb_> bounds
12:42:47 <sethk> Got the program, looking at it.
12:42:56 <xkb_> cool
12:50:22 <sethk> Does the error message give you any line numbers?
12:50:41 <xkb_> not in hugs
12:50:45 <xkb_> ill try ghc
12:51:13 <xkb_> Fail: Prelude.(!!): negative index
12:51:14 <xkb_> hmm
12:51:15 <xkb_> no
12:51:34 <xkb_> the only difference between hugs and ghc
12:51:35 <xkb_> is
12:51:38 <sethk> OK, so all we know is that it is the !! operator.
12:51:52 <xkb_> hugs says: index too large, ghc: negative index
12:52:13 <xkb_> yes.. And we know the error does not alway occur
12:52:15 <sethk> OK, that makes sense, one is considering it signed and negative, the other is considering it unsigned an very large.
12:52:24 <xkb_> ah
12:52:37 <xkb_> hmm.. so the error is on the lower bound?
12:53:00 <sethk> Probably but not necessarily.  Put in some tracing so we can find out which !! call it is.  There are two.
12:53:23 <xkb_> Im not that fluent on haskell IO. How could I do that?
12:53:47 <sethk> Let me check the syntax.  There is an import, then a tracing function.
12:54:02 <xkb_> ahh.. I thought I had to do that using do
12:54:15 <xkb_> which is quite a pain in the ass :)
12:55:14 <sethk> Yes, it is, the tracing function is something like:   trace(somethingToPrint, whatever was here without the trace)
12:55:29 <xkb_> no import?
12:56:06 <sethk> Yes, there is an import.  I'll hunt up a file where I did this, it was a few weeks ago.
12:56:22 <xkb_> im searching haskell.org
13:02:38 <xkb_> hmm.. I cant find it yet
13:02:59 <sethk> I'll find it eventually.   :)
13:03:12 <xkb_> k
13:03:20 <xkb_> I found the function def
13:03:31 <xkb_> trace :: String -> a -> a
13:03:39 <xkb_> but not the module name
13:04:13 <sethk> If you have the ghc source installed, you can grep for the name.
13:04:28 <xkb_> only bin :(
13:05:06 <sethk> I had the source, but I had to reload my machine, so I'll have to download the source again.
13:05:13 <xkb_> Isnt it just Debug?
13:06:14 <xkb_> in haddock docs it says: Debug.trace
13:07:46 <xkb_> ah
13:07:47 <xkb_> found it
13:07:49 <xkb_> IOExts
13:08:13 <sethk> good.
13:09:01 <xkb_> Please type your name (with a capital first letter) followed by enter:
13:09:01 <xkb_> kip
13:09:01 <xkb_> "treklootjerecusiveDrawtreklootjerecusiveDrawtreklootjerecusiveDrawtreklootjerecusiveDrawtreklootjerecusiveDrawtreklootjerecusiveDrawtreklootjerecusiveDraw
13:09:01 <xkb_> Program error: Prelude.!!: index too large
13:09:11 <xkb_> thats a trace of an error
13:09:24 <xkb_> with the name of the function in the trace function just b4 the !!
13:09:57 <xkb_> Seems like recusiveDraw throws
13:10:27 <xkb_> That is possible only if n becomes to large
13:10:42 <xkb_> Can I also get information in the trace?
13:10:47 <xkb_> like n
13:11:23 <sethk> Anything used in the function.
13:11:33 <sethk> That is, any argument to the function.
13:11:35 <xkb_> with concatenation ?
13:12:48 <sethk> Anything you could use in the function you can display.
13:12:56 <xkb_> ok
13:15:09 <xkb_> hmm
13:15:16 <xkb_> anyway to convert n to string?
13:15:25 <xkb_> I tried show
13:15:43 <sethk> yes, but you have to assign it to an object that supports show.
13:15:49 <sethk> Integer, I believe.
13:15:58 <xkb_> hmm
13:16:00 <xkb_> not int?
13:16:01 <xkb_> Int
13:16:15 <sethk> Might be Int.  :)
13:16:44 <xkb_> hmm
13:16:58 <xkb_> now I replaced the function name of recursiveDraw by n
13:17:05 <xkb_> and got the following result on error
13:17:17 <xkb_> "treklootje0treklootje1treklootje2treklootje3treklootje4treklootje5treklootje6
13:17:17 <xkb_> Program error: Prelude.!!: index too large
13:17:25 <xkb_> with length a = 7
13:17:37 <xkb_> So that should NOT cause any errors
13:17:55 <sethk> 7 is obviously not too large.  Paste the line with the trace for me?
13:18:43 <xkb_> k
13:18:54 <xkb_> main
13:18:54 <xkb_> Please type your name (with a capital first letter) followed by enter:
13:18:54 <xkb_> kip
13:18:54 <xkb_> "treklootje0treklootje1treklootje2treklootje3treklootje4treklootje5treklootje6
13:18:54 <xkb_> Program error: Prelude.!!: index too large
13:19:02 <xkb_> thats the whole trace
13:20:10 <sethk> I meant the Haskell statement that produces the trace.
13:20:28 <xkb_> ah
13:20:30 <xkb_> sorry
13:20:41 <xkb_> I changed somthing again now.. but ill paste it anyway
13:20:52 <xkb_> recursiveDraw xs n r = b : recursiveDraw c (n+1) r 
13:20:52 <xkb_> 	where p = treklootje (trace (show n) a!!n) r xs 
13:20:52 <xkb_>               b = fst p
13:20:52 <xkb_> 	      c = snd p 
13:21:03 <xkb_> that is for the numbers in the trace
13:22:24 <xkb_> aha
13:22:52 <xkb_> just printed a trace with d: prefixing the value of d
13:22:58 <xkb_> and d evaluates to -1 
13:23:01 <xkb_> at error
13:23:22 <xkb_> Please type your name (with a capital first letter) followed by enter:
13:23:22 <xkb_> kip
13:23:22 <xkb_> "d:n:00d:n:10d:n:22d:n:30d:n:40d:n:50d:n:6-1
13:23:22 <xkb_> Program error: Prelude.!!: index too large
13:24:52 <xkb_> It seems like the list b becomes of length 0
13:25:04 <sethk> Yes, but why?
13:25:19 <xkb_> no idea yet
13:26:48 <xkb_> This only happens when the only element in the list is the user you are trying to match
13:27:45 <xkb_> so if head l == x && lenght l == 1 the error can occur
13:28:58 <sethk> Print both a and n.  Unless you've already done that.
13:29:09 <xkb_> a is fixed
13:29:11 <xkb_> constant
13:29:41 <sethk> What is the value of a?
13:29:51 <sethk> zero?
13:29:54 <xkb_> a=["Sander","Stasja","Marco","Wim","Hennie","Karin","kip"]
13:30:00 <xkb_> some list of names
13:30:14 <sethk> In the call to recursiveDraw?  Oh, it is a.  :)
13:30:41 <sethk> where is it initialized?  I don't see it in test.hs.
13:30:51 <xkb_> on line 3
13:31:20 <sethk> OK.  I see it.
13:31:28 <xkb_> ok
13:36:08 <xkb_> I still have no clue
13:36:14 <sethk> Which length is one where the error occurs?  Which line in the program?
13:36:59 <xkb_> treklootje x g l =
13:36:59 <xkb_>         ( c, removeNameFromList l c)
13:36:59 <xkb_> 	where b = removeNameFromList l x
13:36:59 <xkb_>               c = trace ("d:"++(show d)++"b: "++(show (b!!0))) (b!!d)
13:36:59 <xkb_>               d = (getRandomNr 0 (length b-1) g)
13:37:03 <xkb_> around line 14
13:38:34 <sethk> then is the failing !! the one on line 15?
13:39:56 <xkb_> yes
13:40:16 <xkb_> because the random gen has to generate a nr between 0 and -1
13:40:25 <xkb_> because the list is of size 0
13:40:50 <sethk> OK, I was looking at the wrong trace call.
13:42:03 <sethk> OK, add tracing everything b changes, and you should find out where it becomes empty.
13:45:29 <xkb_> It happens because troughout the random selection somehow the only name remaining is the name of the "active" name
13:45:37 <xkb_> a trace:
13:45:50 <xkb_> Please type your name (with a capital first letter) followed by enter:
13:45:50 <xkb_> kip
13:45:50 <xkb_> "["Sander","Stasja","Marco","Wim","Hennie","Karin","kip"]d:4b: 6["Sander","Stasja","Marco","Wim","Hennie","kip"]d:3b: 5["Sander","Stasja","Marco","Wim","kip"]d:0b: 4["Stasja","Marco","Wim","kip"]d:1b: 3["Stasja","Wim","kip"]d:1b: 3["Stasja","kip"]d:0b: 2d:["kip"]-1b: 0
13:45:50 <xkb_> Program error: Prelude.!!: index too large
13:46:24 <sethk> Is that "-1" correct?
13:47:11 <xkb_> yes, because the input list to treklootje is of size 1, and the only element in it is the user selecting, this user is removed resulting in a list of size 0, []
13:47:18 <xkb_> 0-1 yields 01
13:47:19 <xkb_> -1
13:48:03 <sethk> but b!!-1 is an error.  Or am I misunderstanding what the code does?
13:49:06 <xkb_> I think you understand it correctly. The function treklootje tries to draw one person from the list a
13:49:42 <xkb_> and returns the tuple of (personchosen, list_without_person_chosen)
13:50:04 <xkb_> recursive draw iterates over a matching a person to each person in a
13:50:19 <xkb_> using the list returned by treklootje
13:50:29 <xkb_> hence the c = snd p
13:51:11 <xkb_> Perhaps this is caused by the uneven nr of persons
13:51:34 <sethk> Yes, then snd would not find anything.
13:53:00 <xkb_> Thats the big problem with random generators.. there hard to bebug
13:53:02 <xkb_> debug
13:53:07 <xkb_> darn ibook keyboards
13:55:31 <xkb_> I think ill just catch the conditions on which error is possible in the code
13:55:36 <xkb_> perhaps using exceptions
13:56:00 <sethk> That should work.
13:57:44 <xkb_> not a nice sollution
13:58:18 <xkb_> Does Fudget work on Mac OSX using X?
13:58:21 <sethk> No, I think a pattern for the case where the list has only one member is nicer.
13:58:36 <sethk> xkb_ I haven't worked with OSX at all.
14:02:00 <xkb_> sethk: thanks for the help.. Im gonna read some more now ;)
14:02:16 <sethk> OK, wish I could have been more helpful.
14:02:39 <xkb_> Helpful enough, we found the error!
14:41:31 <inkedmn> howdy friends
14:56:47 <sethk> hello
14:56:50 <sethk> belatedly
14:56:59 <inkedmn> heh
14:57:27 <Pseudonym> G'day.  Also belatedly.
14:58:12 * inkedmn got his haskell book in the mail yesterday :)
15:02:37 <Pseudonym> Which one?
15:07:41 <Pseudonym> G'day.
15:07:47 <clausen> gday mate
15:07:52 <Pseudonym> How's things?
15:07:58 <clausen> ok :)
15:08:09 <clausen> social life is a bit boring ATM
15:08:19 <clausen> (christmas sucks)
15:08:23 <sethk> could be worse.  You could be married.
15:08:29 <clausen> hehe
15:08:31 <Pseudonym> Kinda odd.  This is the time of year when other peoples' social lives ramp up.
15:08:40 <Pseudonym> Actually, could be worse.  You could have children. :-)
15:08:53 <clausen> no, it's the time of the year when everyone retreats into their own families
15:09:17 <Pseudonym> Married isn't so much of a problem, so long as you and your SO have similar social interests.
15:09:27 <Pseudonym> Children complicate things.
15:09:39 * Pseudonym hasn't even been to a cinema in about a year
15:09:49 <clausen> cinemas are very anti-social
15:10:03 <Pseudonym> It depends.
15:10:05 <Pseudonym> The actual movie is.
15:10:05 * clausen prefers interaction :)
15:10:15 <Pseudonym> The gathering before and afterwards can be quite social.
15:10:18 <Pseudonym> Movie == excuse
15:10:39 <clausen> meals are a better excuse
15:10:44 <clausen> parks also
15:10:46 <Pseudonym> This is true.
15:10:47 <clausen> (good weather!)
15:10:56 <Pseudonym> Well, good weather _now_.
15:10:58 <Pseudonym> Not last week.
15:11:06 <clausen> it's a bit cold today :/
15:11:13 <Pseudonym> I like the cold.
15:11:19 <Pseudonym> Not to go to a park, of course.
15:11:40 * clausen thinking about writing a paper
15:12:00 <clausen> about using skew binary random access lists in file systems
15:12:24 <Pseudonym> Incidentally, for those northern hemispherians present, "cold" here is about 15C.
15:12:33 * clausen hates it :(
15:12:44 <clausen> I start to feel comfortable at 25C :(
15:12:52 <Pseudonym> I like about 21C.
15:13:00 <Pseudonym> But the thing is, when it's cold, you can do something about it.
15:13:05 <clausen> I can't
15:13:05 <Pseudonym> There's little you can do about heat.
15:13:12 <Pseudonym> You can put layers on.
15:13:15 <clausen> that doesn't help me
15:13:19 <clausen> I have bad blood circulation :/
15:13:19 <Pseudonym> Really?
15:13:25 <Pseudonym> Oh, that's not good.
15:13:40 <clausen> so, my feet/hands stay cold
15:13:47 <Pseudonym> Back to geekiness... the paper (and our discussion about it last week) sounds interesting.
15:13:50 <sethk> clausen: Come hang out here for a few months.
15:14:08 <Pseudonym> clausen: So why do you live in Melbourne again?
15:14:09 <clausen> Pseudonym: so, what do you think I should aim to publish?
15:14:13 <clausen> Pseudonym: I'm young
15:14:15 <clausen> (parents)
15:14:16 * clausen is 21
15:14:26 <Pseudonym> clausen: I wouldn't do it without implementing a proof of concept.
15:14:27 <clausen> I'll probably go and live in Rio de Janeiro
15:14:28 <clausen> nice place :)
15:14:38 <clausen> yeah, I was thinking that
15:14:42 <clausen> options:
15:14:48 <clausen> (1) add it to ext2?
15:14:59 <clausen> also, should I try to exploit the persitence properties?
15:15:08 <clausen> like, I think there is a benefit for ordinary file systems
15:15:16 <clausen> not just tux2/wafl "snapshotable" ones
15:15:23 <Pseudonym> I'd adapt a simpler one.
15:15:26 <Pseudonym> Like minixfs.
15:15:35 <sethk> clausen:  What are you designing?
15:15:40 <clausen> option 2: write a userland simulation?
15:15:51 <clausen> sethk: members.optusnet.com.au/clausen/ideas/functional-fs.txt
15:16:01 <Pseudonym> I'd adapt something like minixfs and start by running it on ram disks.
15:16:11 <sethk> OK.  You should start with a userland simulation regardless of the eventual target.
15:16:19 <Pseudonym> This is true.
15:16:30 <clausen> another option is writing an NFS server
15:16:52 <clausen> rather than a kernel interface
15:16:59 <clausen> that way, you can still mount it ;)
15:17:04 <sethk> clausen: Not NFS, one of the better network file system specs.
15:17:05 <clausen> (and do real-life tests)
15:17:05 <Pseudonym> That doesn't sound fun.
15:17:10 <clausen> why?
15:17:12 <clausen> nfs is simple
15:17:14 <Pseudonym> NFS == Nightmare File System
15:17:15 <inkedmn> Pseudonym: sorry, it's "haskell: the craft of functional programming"
15:17:17 <inkedmn> (the book)
15:17:24 <Pseudonym> inkedmn: Right.  Cool. 
15:17:44 <Pseudonym> Have you played with sunrpc before?
15:17:50 <clausen> I've never had the pleasure
15:17:56 <clausen> *grin*
15:17:58 <dark> NFS wouldn't be a good test, it's too weird.  No Filesystem Semantics.
15:18:13 <clausen> so, what's a better option?
15:18:17 <clausen> coda/intermezzo?
15:18:20 <Pseudonym> I'd just go ahead and adapt an existing simple file system.
15:18:28 <Pseudonym> Like minix, as I mentioned.
15:18:36 <clausen> kernel hacking is a PITA
15:18:43 <clausen> the other advantage of ext2, btw
15:18:46 <sethk> I agree with pseudo; the issues with a network file system are much more complex.
15:18:53 <dark> I don't know... the functional-fs approach is so different, I think an existing fs might be more hindrance than help.
15:18:55 <clausen> is that ext2 already does something kind-of similar
15:18:58 <clausen> (hmm, probably not important)
15:19:13 <sethk> clausen: Do BSD rather than linux; the hacking is less aggrevating.
15:19:14 <clausen> dark: see note2
15:19:24 <clausen> sethk: is their usermode-bsd?
15:19:29 <clausen> (a linux port, even?)
15:19:29 <Pseudonym> Does the linux kernel interface have facilities for making certain cached buffers dependent on others?
15:19:36 <sethk> clausen: I think so, but I'm not sure.
15:19:38 <Pseudonym> So if you flush this one, make sure you flush this other one first.
15:19:47 <clausen> user-mode-linux is a good reason to do linux
15:19:52 <clausen> Pseudonym: dunno, but ext3 must do this
15:19:54 <sethk> clausen: OK.
15:20:04 <Pseudonym> Perhaps ext3 explicitly flushes.
15:20:08 * Pseudonym doesn't know
15:20:11 <sethk> clausen: Could be handled in the ext3 code.
15:20:23 <clausen> Pseudonym: ?
15:20:30 <clausen> Pseudonym: you need to guarantee journal writes occur first, right?
15:20:41 <clausen> (hmmm, I guess you could wait before issuing requests)
15:20:49 <clausen> (that would be yucky)
15:21:05 <Pseudonym> What I'm suggesting is that ext3 flushes the journal explicitly, and handles other blocks normally.
15:21:16 <Pseudonym> This is entirely a guess.
15:21:48 <clausen> just, you need to guarantee that the journal writes occur before their corresponding live buffers in the fs
15:21:59 <Pseudonym> Right.
15:22:02 <clausen> so, you'd need to issue the live-write requests *after* flushing the journal
15:22:09 <clausen> which would be very painful to implement
15:22:10 <sethk> Pseudonym:  That's almost a certainty, there is no other reasonable way to do journaling.
15:22:35 <sethk> clausen:  Why?  Once the journal is flushed, other writes can be delayed.
15:23:12 <clausen> sethk: right, that's what I meant ;)
15:23:30 <clausen> (OTOH, it is good to complete transactions)
15:24:24 <sethk> clausen: Sooner or later.  Let the o/s handle caching.
15:26:42 <clausen> sethk: well, it depends...
15:26:52 <clausen> sethk: with journals, you write everything twice, and get that liberty
15:27:00 <clausen> sethk: OTOH, if you don't want to write twice, you want to commit quickly
15:27:16 <clausen> (i.e. you want to write quickly to journal, or if you have no journal, you want to commit quickly to disk)
15:31:19 <Pseudonym> Here's what it looks like ext3 does:
15:31:38 <Pseudonym> It puts a bunch of operations in a transaction structure.
15:31:55 <Pseudonym> Then the disk operations happen on transaction structures rather than individual operations.
15:32:26 <Pseudonym> I can't follow the logic right now because O_SYNC complicates everything.
15:32:41 * clausen is building ctags...
15:32:49 <Pseudonym> It's all in fs/jbd
15:33:16 <Pseudonym> In particular, fs/jbd/commit.c
15:33:37 <clausen> so, how does this sound as a strategy:
15:33:58 <clausen> (1) take minix or ext2 (cut out irrelevant crap out of ext2)
15:34:10 <clausen> (2) replace indirect blocks with skew binary random access lists
15:34:17 <clausen> (3) publish something about that
15:34:25 <clausen> (4) try to turn that into a fast atomic f/s
15:34:30 <clausen> (a la WAFL/tux2)
15:34:32 <clausen> (5) publish some more
15:34:42 <Pseudonym> That sounds good to me.
15:34:59 <jak> did tux2 ever see the light of day?
15:35:07 <clausen> jak: it never got implemented
15:35:13 <jak> a shame
15:35:29 <clausen> well, I'm going to do something better :)
15:35:32 * Pseudonym is probably one of the few people who still uses minix file systems
15:35:52 <jak> the next thing I would like to see filesystems wise, is an implementation of a versioning one - ala elephant
15:35:53 <clausen> (actually, I'm experimenting with stuff, and have no idea how it's going to turn out...)
15:36:15 <Pseudonym> jak: Very retro.
15:36:22 <jak> hehe
15:36:28 <jak> Pseudonym, you thinking about VAX?
15:36:32 <Pseudonym> The VAX had a versioning file system.  And there's the Amoeba bullet file server.
15:36:57 <Pseudonym> Now if you had a versioning file system which actually did diffs, that would be interesting.
15:37:03 <clausen> well, what I'm doing is kind of similar
15:37:06 <Pseudonym> rcsfs
15:37:11 <clausen> snapshots are a similar kind of animal
15:37:24 <clausen> just, it's much harder to do GCing at a file level
15:37:31 <jak> the idea with elephant was so that you could audit after a hack attempt
15:37:40 <clausen> you could do that with snapshots too
15:37:57 <jak> true, but not probably to the same level of detail
15:38:00 <clausen> right
15:38:10 <Pseudonym> The problem with versioning file systems, I think, is that they fill up.
15:38:16 <jak> lol
15:38:20 <jak> of course
15:38:33 <clausen> a better option might be to just journal
15:38:39 <jak> but the argument goes that if you buy a 120 gb disk then you should have infinite disk space, right :)
15:38:41 <clausen> (in parallel)
15:38:48 <jak> I mean 120G roughly equal to infinity
15:38:54 * Pseudonym could fill up 120Gb pretty damn quickly
15:38:55 <clausen> well, it should be enough for a couple of weeks, anyway
15:38:57 <jak> (just kidding)
15:39:01 <Pseudonym> I used to work in visual effects.
15:39:20 <Pseudonym> The bullet server was an interesting approach.
15:39:26 <jak> having said that we have a 200gb fileserver here at DoC, and it has only 17gb left
15:39:28 <Pseudonym> It was a farm of write-only disks.
15:39:35 <Pseudonym> Like optical disks.
15:39:39 <jak> ah
15:39:55 <Pseudonym> When it was about to run out of space, it ejected one and told the operator to stick in a new one.
15:40:07 <jak> was information ever retrieved?
15:40:24 <Pseudonym> If you had to retrieve very old data, the operator would have to stick in some disks.
15:40:54 <Pseudonym> This approach made sense once, but nowadays a lot of applications use random writes to files.
15:41:04 <Pseudonym> Databases particularly.
15:41:14 <jak> sometimes it's better to start from scratch
15:41:15 <clausen> Pseudonym: just databases?
15:41:23 * clausen can't think of any other applications that do random writes
15:41:28 <clausen> (well, lots of them, anyway)
15:41:59 <Pseudonym> Databases are embedded in a lot of applications nowadays.
15:42:02 <jak> I used to upgrade my email client about once a year
15:42:09 <jak> and all the email would be effectively lost
15:42:12 <jak> folder structure and new
15:42:15 <jak> new/all
15:42:22 <Pseudonym> Even a word processor like MS Word modifies the file in-place.
15:42:32 <jak> then I would build a new folder structure, better than before
15:42:49 <jak> now that I have imap (leaving mail on server) I am accumulating lots of irrelevant folders :(!
15:42:52 <clausen> Pseudonym: that is scary
15:43:02 <clausen> Pseudonym: does it do it atomically?
15:43:22 <Pseudonym> clausen: Yes and no.
15:43:29 <clausen> ?!!!
15:43:39 <sethk> clausen:  The journaling code in my database engine might be useful to you.  (www.cql.com)
15:43:49 <Pseudonym> Some Office files can be left in a locked state where nobody can open it for writing.
15:44:18 <Pseudonym> Anyone who has done tech support for an office-like establishment learns this the hard way after a while.
15:44:18 <clausen> Pseudonym: how about power interruptions?
15:44:24 <clausen> I see :/
15:44:47 <Pseudonym> You have to clear the lock manually.
15:44:55 <sethk> clausen: The code in my engine has guaranteed transactional semantics even in the presense of failures.
15:45:30 <clausen> sethk: I guess I'm trying to avoid journalling
15:45:46 <sethk> OK, but there is no way to guarantee anything without it.
15:45:50 <jak> clausen: have you reviewed freebsd's "soft-updates" ?
15:45:52 <sethk> which may be ok.
15:45:57 <clausen> sethk: I'm arguing otherwise
15:46:01 <clausen> jak: yes
15:46:12 <sethk> clausen:  If you can prove that, it will be revolutionary.
15:46:24 <clausen> sethk: read up on WAFL
15:46:26 * clausen finds the URL
15:47:10 <sethk> clausen: I know it, although I may not have read this particular info so I'll appreciate the URL.  I think, though, that there goals are different.  Which, of course, may be perfectly appropriate depending on the requirements.
15:47:42 <clausen> www.netapp.com/tech_library/3002.html
15:48:08 <clausen> also, members.optusnet.com.au/clausen/ideas/functional-fs.txt
15:48:22 <clausen> basically: by avoiding destructive updates, you can make snapshots
15:48:26 <clausen> and therefore rollback eficient
15:48:31 <clausen> (efficient)
15:48:59 <sethk> clausen: It is foolish to design for efficient rollback.  Rollback is the abnormal case.  Also, snapshots are just journaling by another name.
15:48:59 <clausen> WAFL actually does use journalling to reduce commit latency
15:49:38 <clausen> snapshots != journaling
15:49:44 <clausen> journaling is an implementation technique
15:49:51 <clausen> snapshots are a feature
15:49:55 <sethk> clausen: That's just semantics.
15:50:10 <clausen> no, the wafl/tux2 implementation of snapshots is totally different to journaling
15:50:29 <clausen> basically: the file system is a tree
15:50:35 <clausen> you have more than one root for different snapshots
15:50:35 <sethk> clausen: You said journaling is an implementation.   :)  I'm not using the same definition of journaling that you are.
15:51:00 <clausen> sethk: what's your definition?
15:51:32 <clausen> I said "implementation technique", btw
15:52:23 <clausen> well, here's my big definition of journaling:
15:52:25 <sethk> clausen:  It would be more correct to call what they are doing journaling.  My definition is not really correct, but what I meant is that copies of all data that may be needed are kept, with a certain subset, to guarantee transactional semantics, flushed to disk.
15:52:33 <sethk> s/journaling/versioning/
15:52:56 <clausen> "journaling is when you write down everything you plan to do before you actually do it
15:53:25 <clausen> - this is done by sequential writes that are efficient for conventional hard disks"
15:53:52 <sethk> clausen: No, I would differ with that definition, because some of the work, that is the writing of non-journal data, is frequently eliminated altogether.
15:54:15 <clausen> sethk: the whole "wandering logs" idea?
15:55:00 <sethk> That is part of it.  I do it slightly differently, with nesting of transactions.  When you get down into the bowels of the code, what actually happens is similar for the various methods of transactional semantics.
15:55:14 <clausen> sethk: how do you nest transactions?
15:55:46 <clausen> (I'm curious about the transaction model you chose)
15:55:53 <sethk> clausen: The real answer to that is in the source code.  I have some documentation of how I did it somewhere.  Shoot me an email and I'll send it to you.  seth@cql.com
15:56:08 * inkedmn has a quick question...
15:56:09 <inkedmn> ERROR "e:\haskell\code\Rot13.hs":5 - Instance of Num Char required for definitio
15:56:09 <inkedmn> n of switchChar
15:56:22 <inkedmn> "Instance of Num Char" <-- ?
15:56:30 <sethk> inkedmn: A class.
15:56:47 <inkedmn> so i have to import something?
15:56:59 <clausen> sethk: it isn't on your website?
15:57:28 <sethk> Yes, but that is not the main point.  You are using a method on an object (excuse my lapse into OO terminology) and to use that method, the object has to implement class Num Char
15:57:58 <inkedmn> i'm using 'ord' and 'chr'
15:58:03 <inkedmn> thought those were builtins
15:58:27 <Pseudonym> What you probably have is an error, then.
15:58:39 <Pseudonym> You're accidentally using + or - (or something) on a Char.
15:58:43 <sethk> Yes and no.  It appears you are calling chr on a piece of data for which that makes no sense.
15:58:48 <inkedmn> ok
15:58:52 <sethk> Sorry, num, not chr
16:01:38 <clausen> sethk: I sent an email :)
16:03:03 <inkedmn> hmm...
16:03:09 * inkedmn thinks his login is all jacked up...
16:12:53 <inkedmn> can i show you guys this code real quick?
16:12:53 <inkedmn> switchChar :: Char -> Char
16:12:53 <inkedmn> switchChar c | (ord c) + 13 > 123   = chr ((ord c - 123) + 97)
16:12:53 <inkedmn>              | otherwise chr (ord c + 13)
16:13:37 * inkedmn is sure that this code is TOTALLY screwed up...
16:13:48 <Pseudonym> That's not a direct cut and paste, is it.
16:14:01 <Pseudonym> The syntax error is a bit of a giveaway.
16:14:24 <Pseudonym> You should also avoid magic numbers like 123 and 97.
16:14:25 <inkedmn> well, i changed a few things since posting the error
16:14:47 <inkedmn> ok
16:14:48 <inkedmn> s/123/ord z -1/ ?
16:14:52 <Pseudonym> Yes.
16:15:05 <Pseudonym> Magic numbers are almost completely unnecessary in Haskell thanks to lazy evaluation.
16:15:10 <inkedmn> (or something)
16:15:18 <Pseudonym> Make it a complex expression.  It'll only ever be executed once.
16:15:54 * inkedmn isn't sure what a complex expression is
16:21:23 <Pseudonym> In this case, if you write:
16:22:01 <Pseudonym> ord c + (ord 'a' - ord 'z' - 1)
16:22:24 <Pseudonym> Then the latter part is a fairly complex expression (two function calls, some arithmetic), but it's a CAF.
16:22:38 <Pseudonym> It should only be evaluated at most once.
16:22:42 <inkedmn> ok
16:22:52 <Pseudonym> Although Haskell semantics don't guarantee this, in fact.
16:23:01 <Pseudonym> Unless you pull it out as a CAF, anyway.
16:23:32 <Pseudonym> Haskell guarantees laziness, but not "full laziness".
18:03:19 <inkedmn> is there a way to create a list of the numbers 0 - 127 without manually typing it in?
18:03:28 <inkedmn> s/it/all the numbers/g
18:06:39 <inkedmn> lament!
18:07:19 <lament> inkedmn!
18:07:25 <inkedmn> is there a way to create a list of the numbers 0 - 127 without manually typing it in?
18:08:30 <clausen> [0..127]
18:08:58 <clausen> take 128 (iterate (+1) 0)
18:11:52 <lament> is [0..127] lazy?
18:21:01 <inkedmn> hmm...
18:21:11 <inkedmn> say i wanted to print out the ascii values for 0-127
18:21:19 <inkedmn> using a recursive function and putStrLn
18:25:01 * inkedmn strokes his goatee and thinks REALLY hard...
18:27:12 <inkedmn> is there any way to print a Char?
18:27:18 <inkedmn> (as opposed to a string)
18:27:38 <mgoetze> inkedmn: uhm, putChar?
18:27:48 <inkedmn> oh, ok
18:27:57 * inkedmn didn't know that
18:28:06 <mgoetze> :)
18:30:01 <inkedmn> ok, how about this...
18:30:22 <inkedmn> i want to map putChar to a list of integers, and apply chr to each integer before it's printed...
18:31:21 <mgoetze> inkedmn: uhm, don't you mean the other way around?
18:31:44 <mgoetze> map chr (whatever that is) to a list of integers, then putChar them?
18:31:45 <inkedmn> being a n00b, i'm not quite sure WHAT i mean :)
18:31:53 <inkedmn> yes
18:32:55 <mgoetze> so, sequence (map putChar (map chr [0..127]))
18:33:01 <inkedmn> ah...
18:33:02 <inkedmn> :)
18:33:26 <dark> Also available is mapM putChar (map chr [0 .. 127])
18:34:13 <clausen> (sequence . map (putChar . chr)) [0..127]
18:34:14 <clausen> ?
18:34:29 <mgoetze> TIMTOWTDI
18:34:38 <clausen> ?
18:34:40 <mgoetze> :)
18:34:52 <mgoetze> it's the perl slogan, "there's more than one way to do it"
18:36:09 <clausen> perl is *dirty* :P
18:36:47 <mgoetze> yeah, and in haskell you get lots of clean ways to do it :)
18:37:40 <inkedmn> any way to append a \n to putChar?
18:37:46 <inkedmn> or will i have to call putChar again?
18:38:08 <mgoetze> \n is a char, and putChar will only put one of those at a time :)
18:38:14 <inkedmn> ok, thought so
18:38:16 <clausen> you could intersperse the [0..127]...
18:38:36 <clausen> (sequence . map putChar . intersperse '\n' . map chr)) [0..127]
18:38:39 <inkedmn> because right now, it just prints all the values run together on the same line
18:39:28 <mgoetze> do something like this to be pretty:
18:39:48 <mgoetze> asciitable :: Int -> IO ()
18:39:59 <mgoetze> asciitable 128 = do return ()
18:40:10 <mgoetze> asciitable n = ...
18:40:41 <inkedmn> do i have to import something to use intersperse?
18:40:58 <inkedmn> hugs complained when i called it
18:41:34 <clausen> (sequence . map putChar . intersperse '\n' . map chr) [0..127]
18:41:36 <clausen> import List
18:41:39 <inkedmn> ah
18:41:40 <inkedmn> ok
18:41:42 <clausen> (I had an extra ")")
18:43:03 <inkedmn> i haven't read about sequence, what is it?
18:43:44 <mgoetze> inkedmn: it makes a single io operation out of a list of them
18:43:53 <mgoetze> (s/io operation/monad/ for generality)
18:43:58 <inkedmn> hmm
18:44:10 <inkedmn> looks like i'll have to read up on monads
18:44:48 <mgoetze> inkedmn: you should read the "gentle introduction to haskell 98"
19:14:06 <Janni> hi
19:14:20 <Pseudonym> G'day.
19:14:23 <mgoetze> hiya
19:14:35 <Pseudonym> http://haskell.org/wiki/wiki?CommonHaskellIdioms
19:14:38 <Pseudonym> Reworked the page a bit.
19:43:17 <Pseudonym> Question.  Is this a "basic technique" or not?
19:43:21 <Pseudonym> http://haskell.org/wiki/wiki?AvoidingParameterPassing
19:43:28 <Pseudonym> Just trying to work out what heading it fits under.
19:50:10 <dark> Well, I've used it a couple of times.
19:50:24 <dark> Never for cases this small, though :)
19:51:03 <Pseudonym> Obviously. :-)
19:51:12 <Pseudonym> It's an illustrative example,.
19:51:28 <Pseudonym> I'm just wondering if it counts as "basic" or not.
19:55:23 <inkedmn> just so i'm clear, it's not possible to define functions in Hugs
19:55:27 <inkedmn> right?
19:55:32 <Pseudonym> Er...
19:55:38 <lament> heh
19:55:43 * Pseudonym boggles
19:55:44 <dark> Pseudonym: I have no idea, I haven't seen any of the other basic techniques :)
19:55:46 * inkedmn thinks he's wrong
19:55:51 <Pseudonym> It's a functional programming language.
19:56:00 <lament> inkedmn: not in the interactive interpreter.
19:56:02 <Pseudonym> If you can't define functions, you're styck.
19:56:04 <Pseudonym> Oh.
19:56:06 * Pseudonym duhs
19:56:11 <inkedmn> lament: ok, thanks :)
19:56:24 <inkedmn> you can in python's, that's why i asked
19:56:34 <Pseudonym> You can use a let or where expression.
19:57:06 <lament> unfortunately, haskell is not python.
19:57:21 <Pseudonym> lament: Or fortunately, depending on your point of view.
19:57:26 <inkedmn> heh
19:57:27 <lament> yes :)
19:57:39 <Pseudonym> dark: http://haskell.org/wiki/wiki?CommonHaskellIdioms
19:57:50 <Pseudonym> You can see the other things I consider "basic" there.
19:58:08 * inkedmn is going to attempt a ISBN verifier in haskell...
20:19:30 <olczyk> How can you do hanshaking in an FP language?
20:20:12 <clausen> ?
20:20:12 <Pseudonym> What do you mean?
20:21:04 <Pseudonym> shake :: Hand -> IO ()
20:21:20 <lament> hehe
20:21:31 <Pseudonym> Actually, it'd be:
20:21:42 <Pseudonym> class BodyPart bp where
20:21:46 <Pseudonym>     shake :: bp -> IO ()
20:21:52 <Pseudonym> instance BodyPart Hand where
20:21:55 <lament> hahaha
20:21:55 <Pseudonym>     {- ... -}
20:22:34 <clausen> olczyk: do you mean in the networking sense, or the combinatorial sense?
20:22:38 <Pseudonym> module KC where
20:22:42 <Pseudonym> instance BodyPart Booty where
20:22:45 <Pseudonym>     {- ... -}
20:22:55 <clausen> LOL
20:23:12 <clausen> shake that booty, yeah!
20:24:06 <Pseudonym> module HokeyPokey where
20:24:10 <Pseudonym> All right, I'll stop now.
20:24:15 <mgoetze> lol
20:24:54 * inkedmn has a scenario he'd like to share
20:25:19 <inkedmn> i need to work with three lists
20:25:29 <inkedmn> the first will be a list of 10 numbers
20:25:46 <inkedmn> the second 2 will be empty initially
20:26:32 * inkedmn is trying to think of how to explain this..
20:26:59 <inkedmn> the second list will contain ten elements also
20:27:17 <inkedmn> will be like a running total of the elements in the first list
20:27:22 <inkedmn> something like this:
20:27:35 <inkedmn> first list [1, 2, 3, 4, 5]
20:27:54 <inkedmn> second list [1, 3, 6, 10, 15]
20:28:18 * inkedmn wonders if he's making any sense at all right now
20:28:24 <mgoetze> so far...
20:28:27 <inkedmn> ok
20:28:28 <clausen> I reckon I can do it in 1 line of code :)
20:28:36 <inkedmn> clausen: not done yet :)
20:28:54 <Pseudonym> I reckon I can do it with a built-in function.
20:28:56 <Pseudonym> Go on.
20:29:06 <clausen> Pseudonym: which one?
20:29:12 <inkedmn> so, each element in the second list is the same element in the first list plus the previous element in the second
20:29:37 <Pseudonym> scan
20:29:49 <inkedmn> now, here's the fun part
20:30:16 <inkedmn> each time an element is added to the second list, i need to increment a third value by that amount
20:30:27 <inkedmn> (i was wrong about the three lists, it's just 2)
20:31:04 <clausen> scanl1 (+) [1..5]
20:31:12 <Pseudonym> clausen: That's the one.
20:31:42 <inkedmn> if my explanation is unclear, i can link you to some python code that does what i'm talking about
20:31:45 <Pseudonym> inkedmn: So in the above example, what will this third value be?
20:32:00 <inkedmn> 35
20:32:09 <inkedmn> the total of all values in the second list
20:32:21 <Pseudonym> So basically you want: sum (scanl1 (+) xs)
20:32:24 <Pseudonym> Where xs is the first list.
20:32:35 <inkedmn> well, i'm not sure what that code does :)
20:32:57 * clausen 's brother walks in, smelling of petrol
20:33:05 <clausen> "I tried to put some petrol in my car..."
20:33:33 <Pseudonym> Or alternatively: sum (scanl (+) 0 xs)
20:33:38 <Pseudonym> I think that's more robust.
20:33:44 <clausen> or sum . scanl1 (+)
20:33:50 <Pseudonym> Depending on what you want when xs is [].
20:33:57 <olczyk> clausen: I'm not sure what you mean "combinatorial sense". I pretty much believe that the network
20:34:27 <clausen> olczyk: combinatorial sense is in the sense of "how many handshakes can there be between everyone in a room"
20:34:34 <clausen> i.e. nP2
20:34:43 <clausen> nC2, rather
20:34:54 <inkedmn> what does scanl do?
20:35:01 <clausen> olczyk: anyway, in the networking sense, you'll want some kind of finite state machine, etc.
20:35:09 <olczyk> sense is what I mean, but more like wtween pieces of software.
20:35:21 <clausen> olczyk: sounds like a non-trivial excerise
20:35:45 <mgoetze> inkedmn: rtfp :)
20:35:59 <olczyk> Yeah. But there are times when it probably can't be avoided.
20:36:00 <Pseudonym> inkedmn: In general, it's a finite state machine skeleton.
20:36:21 <Pseudonym> In your case, scanl1 (+) 0 keeps a running total, just like your second list.
20:36:29 <olczyk> Even when it can, it's nice to know because then you may understand the ways to avoid it better.
20:37:03 <inkedmn> mgoetze: it just shows me the function signature (which i'm not literate enough to understand yet :) )
20:37:14 <inkedmn> Pseudonym: ah, ok
20:37:38 <Pseudonym> Then you just "sum" the list and you're done.
20:37:58 <inkedmn> NICE
20:38:04 <inkedmn> man, this is going to be cake
20:38:40 <olczyk> clausen: Is there a paper or book that describes the technique.
20:39:09 <olczyk> clausen: Also how can you implement a finite state machine in FP.
20:39:33 <clausen> olczyk: well, "handshaking" in networking is obviously a networking topic
20:39:50 <clausen> olczyk: tanenbaum's book "Computer Networks" isn't too bad, but not fantastic
20:39:58 <clausen> olczyk: for FSMs in FP...
20:40:30 <clausen> olczyk: I haven't seen any literature on it...
20:40:44 <clausen> (use the STMonad thingy?)
20:41:31 <Pseudonym> inkedmn: Can I ask what you're doing?
20:41:52 <olczyk> I was thinking handshaking in communicatingto peripherals in general.
20:41:54 <inkedmn> Pseudonym: i'm writing an ISBN verifier
20:41:59 <Pseudonym> olczyk: Depending on what you're doing there may be something at the application level.
20:42:03 <olczyk> Or between pieces of code.
20:42:15 <Pseudonym> For example, the IRC protocol supports the PING command which basically does simple handshaking.
20:42:19 <olczyk> Basically accomplished by setting a boolean variable.
20:42:22 <Pseudonym> inkedmn: Cool.
20:42:36 <olczyk> How do you get an FP to handle that.
20:42:47 <Pseudonym> olczyk: Are you looking at a specific protocol?
20:42:49 <clausen> <olczyk> Or between pieces of code.
20:42:52 <clausen> what do you mean by that?
20:43:05 <clausen> can you be more specific about what you want?
20:43:11 <clausen> I suspect you are using incorrect terminology
20:43:34 <clausen> (oops, I see now)
20:43:38 <clausen> <olczyk> I was thinking handshaking in communicatingto peripherals in general.
20:43:45 <clausen> (you are talking about networking after all :)
20:44:13 <inkedmn> dude, Jack Black can sing pretty freakin' well
20:44:45 <Pseudonym> Better than he can act.
20:44:54 <inkedmn> haha
20:44:59 <inkedmn> he's pretty funny
20:45:30 <Pseudonym> That's true, actually.  Comedians are a strange class of actor.
20:46:28 <Pseudonym> I don't know much about his career.  Was he a comedian?
20:46:49 <inkedmn> i think he did sketch comedy for awhile
20:46:59 <inkedmn> not sure if he ever did stand-up or anything
20:47:53 <inkedmn> but tenacious d is freakin' hilarious
20:48:24 <inkedmn> man, i've smoked WAY too much this evening...
20:49:04 <Pseudonym> Uh... I guess I don't want to see your code after all.
20:49:37 <inkedmn> eh?
20:49:47 <Pseudonym> Depending on what you've been smoking.
20:49:54 <inkedmn> just cigarettes :)
20:50:01 <Pseudonym> Oh, OK.
20:50:03 * inkedmn is t3h dru6 fr33 :)
20:50:26 <Pseudonym> Apart from nicotine, apparently.
20:51:09 <olczyk> clausen: It's one of those things. When I write a program, I think "How would I do this in FP?"
20:51:16 <Pseudonym> Some time point google at the phrase "drunk fix later".
20:51:38 <olczyk> Then aftwards I decide to ask but when the time comes I forget.
20:51:46 <olczyk> Let's take a specific example:
20:52:00 <clausen> so, what causes state transitions?
20:52:01 <olczyk> How do you synchronise threads in FP?
20:52:21 <clausen> it would be an action, right?
20:52:24 <Pseudonym> See, synchronising threads in FP is different than in other languages.
20:52:50 <Pseudonym> Because in other languages, you protect an area of code.
20:53:16 <Pseudonym> In FP, that's pointless.  Lazy evaluation means your code isn't run unless the value is needed.
20:53:24 <Pseudonym> So you protect values instead.
20:54:40 <olczyk> Lets say you want to write a GUI that displays some data ( say the cells in a
20:54:54 <olczyk> cellular automation ie Game of Life" ).
20:55:46 <olczyk> Multiple threads can send data which isn't dealtwith till you execute a flush.
20:56:00 <olczyk> THen the screen is updated.
20:56:32 <olczyk> But each thread can't be processed untill the last is finished.
20:56:45 <Pseudonym> OK.
20:57:06 <olczyk> rather then have the calling code do it, you have the GUI code macke sure the proccessing
20:57:08 <Pseudonym> The imperative synchronisation object that you want is a "barrier".
20:57:10 <olczyk> is done correctly.
20:57:32 <olczyk> A mutex.
20:57:59 <Pseudonym> You know what a barrier is?
20:58:36 <Pseudonym> Actually, no, you don't want a barrier.
20:58:39 * Pseudonym thinks
20:58:44 <Pseudonym> Several ways to do it.
20:58:52 <Pseudonym> One is a semaphore.
20:59:32 <Pseudonym> A more Haskell-esque way to do it would be to use an unbounded channel.
20:59:41 <Pseudonym> Worker threads put their results in the channel.
21:00:00 <Pseudonym> The client thread grabs them until it finds all the results it needs.
21:09:13 <olczyk> I'm not sure you quite understand wht I was suggesting, The GUI is written using FP anf the calling code is done in an imperative language.
21:09:27 <Pseudonym> Oh.
21:09:30 * Pseudonym hmms
21:09:32 <inkedmn> how can i convert "12345" to [1,2,3,4,5] ?
21:09:49 <Pseudonym> olczyk: You're using FFI or something?
21:10:06 <mgoetze> inkedmn: map ord over it? :)
21:10:22 <mgoetze> and then subtract something...
21:10:23 <Pseudonym> inkedmn: map (\c -> ord c - ord '0') "12345"
21:11:23 <olczyk> PRobably will.
21:11:24 <clausen> inkedmn: map digitToInt "12345"
21:11:52 <Pseudonym> Then I don't know.
21:12:09 <Pseudonym> It's a good question, but I haven't played with FFI enough.
21:17:55 <inkedmn> hmm...
21:18:05 <inkedmn> how about this... :)
21:18:32 <inkedmn> "12345X" -> [1,2,3,4,5,'X']
21:18:36 <inkedmn> possible?
21:19:33 * inkedmn guesses it is, but probably not easy
21:20:25 <clausen> you need heterogeneous lists
21:20:39 <clausen> (not part of standard haskell98)
21:20:46 <inkedmn> well, there is one point i should mention
21:21:03 <inkedmn> the only non-int char will be X and it will only be at the very end of the list
21:21:23 <Pseudonym> So perhaps you want ([Int], Bool)
21:21:29 * inkedmn realizes that "non-int char" is a retarded thing to say
21:22:22 <olczyk> Is there a pattern matching library for C++?
21:22:47 <inkedmn> would it be easier to filter out all the non-ints and, if the list length is nine, append 10 (what X signifies) to the list?
21:22:59 <Pseudonym> olczyk: You mean like regular expressions or something?
21:23:18 <olczyk> No like Hasckell style pattern matching.
21:23:40 <Pseudonym> Not really.  C++ doesn't support algebraic data types natively.
21:23:51 <olczyk> Sorry Haskell.
21:23:55 <Pseudonym> You can hack it.
21:24:00 <Pseudonym> But it's ugly.
21:24:32 <Pseudonym> People who need it often write preprocessors, like lburg.
21:24:40 <Pseudonym> Your code ends up looking like yacc.
21:29:28 <clausen> anyone know the website that keeps web history, so you can read old delete pages?
21:29:38 <Pseudonym> archive.org
21:29:41 <clausen> thanks!
21:29:52 <Pseudonym> There's also more recent stuff in the google cache, of course.
21:30:06 <clausen> google cache is very inconvenient
21:30:14 <clausen> for following urls within the old site
21:30:34 <inkedmn> i can't seem to find some sort of 'append' function for lists...
21:30:48 <Pseudonym> ++
21:30:54 <inkedmn> duh
21:31:01 * inkedmn thonks himself on the head with his new haskell book
21:31:05 <Pseudonym> :-)
21:31:18 <clausen> http://web.archive.org/web/20011019074751/www.math.toronto.edu/~pivato/latex/stoch/
21:31:22 <clausen> great! :)
21:32:17 <Pseudonym> :-)
21:32:24 <clausen> really slow though :(
21:32:25 <Pseudonym> What did you want to know about this, as a matter of interest?
21:32:47 <clausen> I'm teaching myself statistics so I can read all this sociology literature
21:32:53 <Pseudonym> Ah. :-)
21:33:04 <clausen> and, I think it's a good idea to teach myself stochastics and statistics together in parallel
21:33:11 <clausen> they are rather complimentary :)
21:33:22 <Pseudonym> I think the magic term you're looking for is "monte carlo".
21:33:29 <mgoetze> clausen: so far, in fact, that many people can't keep them apart :)
21:33:39 <clausen> Pseudonym: ?
21:34:09 <clausen> (isn't monte carlo that RP technique...
21:34:14 <clausen> ... "random polynomial time")
21:34:33 <Pseudonym> Monte Carlo techniques refer to basically any stochastic simulation technique.
21:34:45 <clausen> ah, no I'm not interested in stochastic simulation
21:34:53 <clausen> (right now, anyway)
21:34:57 <clausen> just the theory
21:34:57 <Pseudonym> So, for example, "monte carlo integration" refers to stochastic integration techniques.
21:35:01 <Pseudonym> Oh, OK.
21:35:03 <clausen> really?!
21:35:06 <Pseudonym> Yes.
21:35:10 <clausen> I am interested in stochastic integration
21:35:12 <clausen> thanks
21:35:26 <Pseudonym> Another thing to look into is "quasi monte carlo" techniques.
21:35:29 <clausen> (it's such a surreal concept!)
21:35:42 <Pseudonym> http://mathworld.wolfram.com/MonteCarloIntegration.html
21:49:55 <Pseudonym> Not really.  Stochastic integration is just statistical sampling.
22:09:37 <Pseudonym> Night all.
22:09:58 <inkedmn> w00h00!
23:03:23 <inkedmn> tez!
23:03:59 <tez> hi!
23:04:30 <tez> What's up?
23:05:20 <inkedmn> i wrote 2 haskell programs tonight :)
23:05:27 <inkedmn> they're small, but they both work :)
23:05:45 <inkedmn> a rot13 and an ISBN verifier
23:05:47 <tez> And that (presumably) is the important thing.
23:05:56 <inkedmn> that they work?
23:06:05 <tez> Yes
23:07:09 <tez> Does your rot13 work on stdin?  Or is it more interactive?
23:07:42 <inkedmn> only works in hugs at the moment :)
23:07:49 <inkedmn> haven't learned how to take command line args yet
23:08:49 <inkedmn> both programs are on sourcereview.net if you wanna peek at the code
23:19:47 <tez> In the fuctional programming section? I'll have a quick look.
23:19:58 <inkedmn> yeah :)
23:21:18 <tez> That regexp-to-english one sounds like it would be good to write.
23:21:34 <inkedmn> yeah, i've been thinking about that one
23:22:45 * tez would have to keep looking up all the regexp symbols though
23:22:59 <inkedmn> heh, me too :)
23:28:52 <tez> Your rot13 script only handle alphabet chars ad spaces right now?
23:29:01 <inkedmn> yes
23:29:13 <inkedmn> and i just discovered the isbn deal doesn't work right...
23:29:26 <tez> lol
23:30:15 <tez> Well, a small change in the rot13 one would let it work on arbitrary strings.
23:31:06 <inkedmn> ?
23:32:06 <tez> Well, if you just add an 'otherwise' guard to the rotate function that leaves the char alone, you're done.
23:32:36 <inkedmn> actually i did that :)
23:32:48 <tez> Oh.
23:32:49 <inkedmn> added that after i posted the code
23:32:51 <inkedmn> :)
23:33:00 <tez> Ah.
23:33:14 <inkedmn> ok, i have no idea why the other one doesn't work though
23:33:46 <tez> How doesn't it work?  Just produces the wrong answer, or it won't type check?
23:34:08 <inkedmn> produces the wrong answer
23:34:59 <tez> How does one verify ISBN codes anyway (or is that description on the message board somewhere)?
23:35:12 <inkedmn> i can link you to an explanation
23:35:14 <inkedmn> one sec
23:36:15 <inkedmn> http://acm.uva.es/p/v3/333.html
23:42:01 <tez> It looks like it should work...
23:43:23 <inkedmn> ISBN> main "0684874350"
23:43:23 <inkedmn> Valid
23:43:23 <inkedmn> ISBN> main "THISSUCKS"
23:43:23 <inkedmn> Valid
23:43:23 <inkedmn> ISBN> main "T"
23:43:24 <inkedmn> Valid
23:43:26 <inkedmn> ISBN> main "1234567890"
23:43:28 <inkedmn> Invalid
23:43:31 <inkedmn> the first one is an actual isbn
23:43:34 <inkedmn> the rest aren't
23:43:52 <tez> Also, I don't know if this is a machine specific problem or the font your board uses, but l and 1 look exactly alike when looking at code on your board.
23:44:18 <inkedmn> it should be scanLONE, right?
23:44:51 <tez> Yeah, I got that.  I'm just saying, sometimes the ariable l looks like a one.
23:44:58 <inkedmn> yeah, it does
23:45:53 <tez> The reason "THISSUCKS" gives valid is because 0 'mod' 11 is 0.
23:45:59 <tez> I think that's the reason anyway.
23:46:08 <inkedmn> hmm...
23:46:42 <inkedmn> but shouldn't it complain if getTotal gets an char list?
23:47:57 <inkedmn> hmm
23:48:51 <tez> But it ever gets a char list.  createList takes care of that.
23:49:17 <inkedmn> i bet it's getting an empty list and returning 0
23:49:48 <tez> Is you give createList the string "ABCDE", it will retur [] because isDigit will be false for each character in the string.
23:49:59 <inkedmn> yeah
23:50:01 <tez> Yeah, you're correct.
23:50:08 <inkedmn> wonder how to get around that...
23:50:48 <tez> I guess you ould create a function that also checks that a given string contains exactly 9 or 10 digits.
23:50:54 <tez> s/ould/could
23:51:28 <inkedmn> then i'd need to exit the program somehow...
23:52:11 <tez> Oh, wait.  You could modify checkLength slightly.
23:52:26 <inkedmn> ok
23:53:03 <tez> Explicitly check for length 10, ad make the 'otherwise' case return a list that will guarantee an invalid result.
23:53:21 <inkedmn> hmm, good idea :)
23:53:24 <tez> (Of course, this loses a little clarity).
23:54:45 <inkedmn> well, it works now :)
23:55:07 <tez> And that's what's important ;)
23:56:17 <inkedmn> alright, bed time
23:56:21 <inkedmn> thanks for your help :)
23:56:30 <tez> Night.
