01:14:24 * seth_ is away: Don't say anything until I get back.
03:01:11 <systems> any one tried GHC version 5.04.2 rpms on redhat 7.3
03:21:25 <systems> any one tried GHC version 5.04.2 rpms on redhat 7.3
03:27:29 <Heffalump> not me, but I plan to
03:28:01 <systems> oka try and tell me the result
03:28:14 <systems> go download it now and tell me :)
03:31:29 <Heffalump> oh, I might be going to build it myself
03:32:13 * Heffalump too busy right now anyway
03:32:34 <systems> why?
03:33:06 <systems> why?
03:34:57 <Heffalump> I think I have some patches to Manuel's RPMs that either are useful just for me or that are bugfixes but he hasn't got round to looking at
05:32:42 <shapr> y0
05:32:44 <shapr> wassup?
05:33:05 <shapr> hi aleksi
05:33:42 <shapr> so, did I miss anything?
05:38:39 * shapr guesses not
05:43:00 <Segora> depends... maybe we should set up a log service ;)
05:44:12 <shapr> actually this channel is logged...
05:44:20 <shapr> I could go look at the logs
05:44:25 <shapr> hi Segora, what's up?
05:44:50 <Segora> well, feeling not too well which is a shame since tonight is our famous x-mas party
05:45:13 <shapr> :-(
05:45:47 <Segora> have been learning a bit of lisp lately
05:45:58 <shapr> cool
05:46:02 <shapr> which flavor of lisp?
05:46:12 <Segora> Common Lisp
05:46:15 <shapr> ah
05:46:24 <shapr> I've heard some good things about it.
05:46:50 <Segora> well, it seems nice if you want to do lots of metaprogramming
05:47:40 <Segora> but I find Haskell programs much more readable. Perhaps my mind hasn't adapted to heaps of parentheses yet. ;)
05:47:56 <Segora> (which Paul Graham suggests it will do eventually)
05:48:27 <shapr> I use elisp regularly, but I still find Haskell more readable.
05:48:42 <shapr> I really prefer significant whitespace
05:49:01 <shapr> lisp has a lot of good points, but I still prefer Haskell.
05:50:44 <Segora> well, sometimes I feel I spend too much time getting things right in Haskell. It's nice to have correct programs, but there are times when I just want a quick solution which somewhat works. *g*
06:05:15 <shapr> Segora: what parts do you find hard to get right?
06:05:34 <shapr> I've had the same problem in the past
06:06:04 <shapr> sometimes I have to really push my brain to find a functional solution that's comparable to imperative solutions that I've used
06:06:30 <shapr> so far, my difficult functional solutions have always been far more elegant and efficient though
06:13:06 * shapr reads up on the XRENDER extension
06:13:32 <Segora> shapr: I don't have a concise example to present right now. It's been some time since I last had the time to hack up something.
06:14:09 <Segora> fortunately, I'm not stuck in wasteland - I can program in Erlang at work
06:15:55 <shapr> wow neat!
06:16:02 <shapr> that's cool, do you work in sweden?
06:16:04 <Segora> my last toy projects in Haskell all led to the same basic problem: Is there a really elegant way to express network-centric services like IRC bots or a MUD server in Haskell?
06:16:10 <Segora> no. germany.
06:16:39 <shapr> I think Arrows will probably lead to more elegant network expressions.
06:17:33 <Segora> as far as I understand, Arrows call for some syntactic sugar which isn't available in current Haskell implementations
06:17:49 <shapr> there's an Arrow preprocessor
06:18:15 <shapr> when Template Haskell is released, you won't require the preproc anymore.
06:18:31 <shapr> have you read Hughes' Arrows paper?
06:18:51 <Segora> I took a quick glance but didn't really read it yet.
06:19:12 <shapr> I think it's worth it.
06:20:53 <shapr> not that I understand it enough to have written something that demonstrates what I'm claiming :-)
06:21:13 <Segora> *g* I know that problem
06:21:38 <Segora> do you mean 'Generalising Monads to Arrows (1998)' ?
06:21:43 <shapr> yah, that's it.
06:21:46 <Segora> thanks
06:21:56 <shapr> sadly, very little has been written about Arrows
06:22:08 <shapr> http://haskell.cs.yale.edu/arrows/
06:22:35 <dark> People are still figuring out monads, they're not ready to generalize them yet :-)
06:22:43 <shapr> hi dark!
06:22:51 <dark> Hello!
06:22:52 <shapr> oh, I had a question to ask you...
06:22:54 <shapr> I wonder it was
06:22:57 <shapr> oh well
06:23:07 <shapr> Arrows seem more intuitive to me
06:23:12 <shapr> they make more sense
06:23:17 <dark> hasdl related?
06:23:22 <shapr> I have no idea
06:23:48 <shapr> could have been anything
06:23:53 <shapr> oh, it was Curses.hs related
06:23:56 * shapr thinks harder
06:24:08 <shapr> oh
06:24:20 <shapr> there was a HaSDL q also
06:24:41 <shapr> do you mind if I give the url to the package to that guy who's writing his own SDL wrapper?
06:24:58 <shapr> I got the impression that your wrapper is more complete than his, so I thought I'd send him in your direction
06:25:05 <shapr> he may want to contribute to HaSDL
06:25:33 * shapr occasionally wishes his memory were deterministic
06:27:58 <dark> Well, as long as he understands it's not an actual release yet. 
06:28:10 <shapr> ok
06:29:14 * shapr discovers the rsxs debian package
07:03:27 <dark> I'm going to work some more on hasdl today.  There are some bugs I have to fix in SDL.Events, after that I can make another prerelease.
07:03:38 <dark> But first, breakfast and other morning things :)
07:15:19 <shapr> f00
07:15:22 <shapr> I was shopping
07:16:25 <shapr> btw, if you have nice OpenGL support, the rsxs debian package is worthwhile
07:16:46 * shapr upgrades his nvidia drivers, hoping for a fix to his problems
07:59:07 <dark> Maybe I should get a new graphics card.
08:50:31 <shapr> boo
09:18:34 <shapr> oy
09:35:33 <whee> oi
09:35:41 <tez> Oi?
09:35:55 <whee> Yes, oi.
09:36:00 <tez> Have we dispensed with formalities now?
09:38:40 <whee> there were formalities? :P
09:38:42 <hdaume> 'morning
09:39:27 <tez> No, they were dispensed with.
09:51:36 <whee> Indeed.
09:57:02 <whee> I hope template haskell gets documentation in the near future
09:57:08 <whee> I'd like to play with that
10:01:43 <Janni> hi.
10:02:15 <Janni> i finally got compiled HOpenGL on FreeBSD succesfully.
10:02:35 <Janni> it isn't really a problem, it was just one for me :)
10:02:45 <Janni> is anybody else running HOpenGL on *BSD
10:02:51 <Janni> there still is a problem
10:03:33 <Janni> i have to compile every program with the -pthread switch. otherwise the screen won't be drawn. that's ok, but...
10:04:28 <Janni> if i use double- instead of single-buffering this effect shows despite the -pthread flag
10:18:47 <whee> this is insane, I've been debating with myself all day on whether or not to continue using haskell :|
10:18:59 <stepcut> oh?
10:19:42 <whee> I'm still learning a bunch, so it's not really a loss either way
10:20:04 <whee> but it just seems like it's more trouble than it's worth 
10:27:28 <whee> shapr!(*%(
10:27:59 <whee> when you were doing things with monads did you find anything that would easily be used to model a simple counter :|
10:28:29 <shapr> the Paul Grahan increment thing might do that for you
10:29:29 <whee> I think I saw that somewhere, hmm
10:29:30 <shapr> whee: you should be able to use a state monad
10:30:19 <whee> I know I should be able to, but I'm an idiot when it comes to monads.
10:31:35 <shapr> me too
10:31:49 <shapr> I suspect it just takes practice, like any other sklil
10:31:53 <shapr> er, skill
10:32:09 <whee> how would you suggest I learn this?
10:32:20 <whee> start with doing things like reimplementing the State monad and using that?
10:36:45 <shapr> the most common path seems to be learning to just use Monads first without worrying about fully understanding them.
10:38:04 <whee> then I'm pretty screwed :)
10:38:33 <whee> I've really only been able to find references to implementing crazy things with monads, and not just using some basic ones
10:46:39 <shapr> there's a bunch of monad tutorials that use the state monad
10:46:47 <shapr> google should turn up several
10:47:33 <whee> what search terms are you using? I'm still finding papers on this and that and nothing straightforward
10:48:08 <shapr> I don't remember, probably monad tutorial
10:57:55 <whee> heh
10:57:57 <shapr> does that work for you?
10:58:13 <whee> yes and no :)
10:58:53 <whee> I'm finding things on the IO monad and some basic state things, but the useful ones actually seem to be embedded in papers that I can't read here on the CS lab machines :|
10:58:57 <whee> have to wait until I get home I suppose
10:59:54 <shapr> there are some nice web pages
11:02:33 * shapr reads Okasaki's "Embedding Postfix Languages into Haskell" paper
11:07:01 <shapr> there must be a simpler, saner way to do this
11:07:28 <ibid> shapr: url?
11:07:53 <shapr> http://www.eecs.usma.edu/Personnel/okasaki/pubs.html#jfp02
11:07:57 <whee> define embedding; parsing them, or what?
11:08:03 <shapr> err
11:08:05 <shapr> um
11:08:16 <shapr> checking types in a stack based language actually
11:08:16 <aps> whee: I think "Monadic Parser Combinators" by Graham Hutton can be a quite nice introduction to monads.. it covers exception, non-determinism & state-monads and uses them to build a parser-monad.. 
11:08:49 <shapr> the problem that Okasaki mentions in the conclusion of his paper is that GHC regularly explodes
11:09:03 <whee> haha
11:09:21 <shapr> "Second, the problem with huge types and functions with dozens of arguments make compilation slow."
11:09:52 <whee> isn't this a job for something like template haskell? or am I understanding this incorrectly
11:10:06 <ibid> hilarious introduction :-)
11:10:19 <shapr> "Today's compilers do not expect such large arities and appear in incorporate algorithms that are quadratic (or worse!) in the number of arguments."
11:10:35 <shapr> I think he has a typo there, should be "appear to incorporate"
11:11:16 <shapr> whee: yah, I think TH would make this much much easier
11:11:40 <shapr> thing is, TH hasn't been released yet, you gotta grab the CVS tree or a nightly build.
11:11:43 <whee> I'd know for sure if I had some *cough*documentation on TH
11:11:44 <whee> heh
11:11:51 <shapr> there's a TH paper online
11:11:56 <whee> I know it's trivial to add a syntax extension like that in camlp4, as I've done it
11:12:03 * whee doesn't count a paper as documentation
11:12:03 <shapr> it's relatively calm and easy reading compared to some other Haskell papers.
11:12:19 <shapr> imho, papers are often the best documentation
11:12:27 <whee> http://caml.inria.fr/camlp4/index.html <- this is documentation :P
11:12:45 <shapr> many are the times I've wished for a "spirit of the law" explanation rather than a detailed table of syntax
11:13:01 <whee> camlp4 documentation does both
11:13:12 <whee> there's a standard "how do I do this" tutorial structure, and of course the reference manual
11:13:24 <whee> which is a lot easier to understand and use than a paper
11:13:32 <shapr> Haskell could have better docs, I agree.
11:13:33 <whee> if I could find something like that for monads, I'd be in heaven
11:13:54 <shapr> speaking of which, I need to reformat my ssh2 key for OpenSSH
11:17:20 <shapr> crap, OpenSSH doesn't support 3des-cbc >:-(
11:18:48 <shapr> okasaki rocks
11:21:45 <whee> hmm, arrows look interesting
11:24:04 <seth_> Why didn't they make Haskell postfix in the first place?  I've wondered about that for a while.
11:24:45 <whee> I don't think postfix would work too well
11:25:07 <whee> I like how you can go between prefix/infix notation easily, there shouldve been another way to do postfix
11:25:51 <seth> I crashed after asking that question; I wonder if there is a cause and effect relationship there?
11:29:28 <whee> mmf okay if a function has a type signature of "incr :: StateMonad m Int => m Int" and is "incr = update (+1)", how is this updating the correct state?
11:29:45 <whee> I think this is the source of all my confusion about state monads.
11:31:01 <shapr> how would you use that function?
11:31:29 <whee> that's what I want to know
11:31:46 <whee> I got this out of one of Okasaki's papers.
11:31:55 <whee> the one that supposedly inspired the State monad, among others
11:32:34 <shapr> I'd guess the code would look like "incr StM"
11:33:50 <shapr> seth: why would you have made Haskell postfix?
11:34:16 <shapr> hi Explodey
11:34:39 <Explodey> hi shapr
11:34:48 <whee> I don't think postfix reads well
11:35:06 <seth> shapr: I just like postfix better; it seems more natural to me.  Plus, if you are adding it per Okasaki's paper, it must have some purpose in life.  :)
11:35:07 <shapr> I've only had experience with Joy, but I loved it.
11:35:14 <whee> you'd have to do nasty things to make me stop using postfix on things like my calculators, but longer programs could be confusing
11:35:38 <shapr> I've found Joy to be really elegant.
11:35:45 <seth> Prefix and postfix are equally clear or confusing w.r.t. reading, with perhaps a slight edge to postfix (IMHO)
11:36:50 <shapr> I'm used to seeing the subject come before the verb
11:37:02 <shapr> so "2 4 5 + +" works fine for me
11:37:14 <seth> What is Joy?
11:37:32 <shapr> Manfred von Thun's language
11:37:34 <shapr> lemme get the url
11:38:00 <shapr> http://www.latrobe.edu.au/philosophy/phimvt/joy.html
11:38:12 <shapr> it's great fun
11:39:41 <shapr> joy code I wrote:
11:39:41 <shapr> (* x y percent approxEqual *)
11:39:41 <shapr> DEFINE approxEqual == 100.0 / rotate [0 =] [pop] [dup rolldown - swap /] ifte > .
11:39:47 <shapr> I'm not sure it's correct though
11:39:59 <seth> I guess if I wasn't sufficiently confused...   :)
11:40:10 <seth> Looks interesting.  I've got to get these KDE fonts fixed, though.
11:41:54 <shapr> "[0 =] filter" is probably obvious
11:42:08 <shapr> ifte is if then else
11:44:17 <shapr> so "[0 =] [pop] [dup rolldown - swap /] ifte" says if it's equal to zero, pop it off the stack, otherwise duplicate it, put the top item below the next two elements (1 2 3 to 3 1 2 I think) subtract, swap the top two, and divide
11:44:33 <shapr> most of the logic happens in the else
11:45:22 <seth> Looks like an HP-41 program.
11:45:46 <shapr> one of the cute tricks in Joy is that [] is a list, and also a program fragment
11:45:57 <shapr> so you can operate on a list, and then execute it
11:46:06 <Explodey> Looks like its not lazy though :-(
11:46:12 <shapr> nah, it's not lazy.
11:46:14 <Explodey> I was hoping for lazy forth
11:46:19 <shapr> well, fix it :-)
11:46:43 <Explodey> I'll let someone who likes postfix fix it :-)
11:46:49 <shapr> random trivia, one of the head lojban guys wrote one of the Joy interpreters
11:46:54 <shapr> Cowan
11:48:10 <shapr> there's a yahoo group dedicated to concatenative languages, that's the main place where Joy people chat
11:48:19 <Explodey> Thats not new, it looks like a simple variation of lisp
11:48:46 <shapr> Brent Kerby posted a fascinating paper about combinators in Joy
11:48:55 <Explodey> The lists being program fragments that is
11:49:05 <shapr> http://tunes.org/~iepos/joy.html
11:49:45 <kev> shapr: you know much on functors?
11:49:53 <shapr> probably not :-)
11:49:56 <kev> as in, for ML
11:49:57 <kev> ack
11:50:08 <shapr> I have a vague idea what they are
11:50:15 <shapr> I know nothing about ML
11:51:11 <shapr> after reading kerby's paper, I had the idea of adding function equality to combinator based languages
11:51:51 <shapr> since then, I ran across the history of lambda calculus
11:51:57 <shapr> specifically http://www.wikipedia.org/wiki/Entscheidungsproblem
11:52:54 <shapr> but I haven't figured out if the Entscheidungsproblem means that there are cases where function equality can't be decided
11:53:02 <shapr> does anyone know more about this?
11:53:18 <shapr> kev: do you have a specific question about functors in ML?
11:53:27 <kev> I just think I'm going about this wrong
11:53:42 <kev> I have a board, containing cells, and an algorithm that operates on those cells
11:53:59 <shapr> yah
11:54:05 <kev> and ML doesn't seem to like my type matchine
11:54:07 <kev> matching
11:54:17 <kev> The board is a functor of cell type
11:54:26 <kev> but so is the algorithm...
11:54:33 <kev> I'm just too used to OOP I think
11:54:56 <shapr> the only thing I know about functors is that they're a typeclass in Haskell
11:55:09 <shapr> and that you need to define an instance of that typeclass if you want to use map on your datatype
11:55:21 <shapr> so it sounds to me like you are going about that the right way
11:55:32 <shapr> assuming that functors mean something similar in ML
11:55:39 <shapr> hi Marvin--
11:55:40 <kev> the problem is, I need to make a functor of the algorithm as well, which seems wrong
11:55:46 <kev> but like I say, I'm used to OOP
11:55:59 <kev> if this was OOP, I'd make the cell a virtual base class, and just have the algo work with that
11:56:08 <shapr> well, I'm used to OOP also, which might be why it also sounds wrong to me.
11:56:15 <shapr> yah, I understand.
11:56:29 * shapr looks at the Functor typeclass in Haskell for inspiration
11:57:55 <shapr> class  Functor f  where
11:57:55 <shapr>     fmap              :: (a -> b) -> f a -> f b
11:58:27 <Marvin--> evening
12:01:51 <shapr> kev: can you explain it further?
12:02:10 <shapr> for a board, I probably would have made a list of cells in Haskell
12:02:11 <kev> shapr: I would need to make an algorithm instance for each board implementation I make
12:02:33 <kev> twodimboard = board(twodimcell)
12:02:40 <Marvin--> now I have even *more* suggestions for the master project
12:02:40 <kev> twodimalgo = algo1(twodimcell)
12:02:57 * shapr looks at the Functor instances defined in the prelude: http://www.haskell.org/onlinereport/standard-prelude.html
12:05:47 <shapr> kev: iirc, ML doesn't have typeclasses. In Haskell, I think you would make each board an instance of Functor, which would give you a generic name to call a type specific implementation of "how to traverse this type"
12:06:08 <shapr> Marvin--: good suggestions?
12:06:10 <seth> The ML functor is not very close to the Haskell functor, if I understand them.
12:07:05 <seth> In ML what makes it a functor is the higher level arguments.
12:07:11 <Marvin--> shapr: something with polytypic programming, which seems awesome
12:07:38 <shapr> Marvin--: the more I think about Koen's original suggestion, the more it sounds like the coolest thing yet.
12:08:38 <shapr> I'll definitely be reading up on semi-automatic program proofs soon.
12:08:58 <Marvin--> shapr: check out CPS/Sparkle
12:09:05 <shapr> what sort of polytypic programming?
12:09:30 <Marvin--> a *working* interpreter/compiler for Cayenne for example ;)
12:09:50 <Marvin--> perhaps investigate if it's possible to plug it into an existing compiler after the type checking phase
12:11:40 <shapr> I suspect that working with Lennart Augustsson would be rewarding.
12:12:47 <Marvin--> I'm not sure he's still at Chalmers
12:14:01 * shapr still isn't exactly sure what a dependent type is
12:15:15 <Marvin--> I suppose the easiest example to understand is that you can implement printf in Haskell :)
12:15:33 <Marvin--> i.e. the type of the function depends on the value of the format string
12:16:23 <shapr> oh
12:16:34 <shapr> that makes sense
12:17:21 <shapr> hey, you probably know something about the Entscheidungsproblem
12:17:54 <shapr> I had the idea of adding function equality to a language that's explicity combinator based.
12:18:13 <Explodey> marvin: you can in Haskell98 I believe
12:18:21 <shapr> so that you could compare the equality of two functions by comparing the combinators that they're made of
12:20:01 <shapr> do you know if the Entscheidungsproblem says that I can't compare extrinsic equality for two sets of combinators?
12:24:34 <seth> Marvin--: Except that the implementation of printf in the TH paper doesn't do what it claims to do.
12:25:46 * shapr notes that wikipedia.org can easily suck up hours of free time
12:30:01 <kev> dammit, I just can't get these things to bind
12:30:09 * kev goes in search of ML channels
12:30:32 <shapr> afaik, Heffalump knows a lot about ML
12:30:43 <shapr> I don't know when he will next be here though.
12:37:41 <Marvin--> seth: which paper?
12:37:48 <Marvin--> Explodey: how?
12:39:24 <seth> Marvin--: The one on SPJ's page where printf is described.
12:40:41 <Marvin--> seth: okay... I've only seen the one in Augustsson's Cayenne paper
12:41:01 <seth> Marvin--: Haven't read that one.  Is it on line?
12:41:15 <Marvin--> http://www.cs.chalmers.se/~augustss/cayenne/index.html
12:51:40 <LantrnJaw> marvin: 2 people posted implementations of printf to the haskell mailing list, but I can't find them in the archive (theres a gap between Jan '01 & May '02)
12:57:09 <LantrnJaw> marvin: I'll forward them to you if you like
13:01:15 <Marvin--> Explodey: sure, md9ms@mdstud.chalmers.se
13:07:50 <Explodey> Marvin: I just noticed its not quite Haskell 98, but I think it could be with a minor modification
13:08:15 <Explodey> There was another version but unfortunately I threw it away
13:08:37 <shapr> I have a Printf.hs here
13:09:22 <shapr> 199 lines
13:13:03 <Marvin--> ah, yeah, you can use function types for it, yes
13:15:31 <Explodey> I remember when I looked at that code I tried to write a Haskell 98 scanf the same way, but I didn't succeed
13:20:59 * shapr grumbles at HaXml
13:21:20 <shapr> I wish HaXml were not included with the base install of ghc5
13:21:57 <Explodey> shapr: why is that?
13:22:23 <shapr> because then I could newer versions in GHCi
13:22:29 <Explodey> ah
13:22:33 <shapr> as it is, I get:
13:22:40 <shapr> GHCi runtime linker: fatal error: I found a duplicate definition for symbol
13:22:41 <shapr>    TextziPrettyPrintziHughesPJ_quotes_fast1
13:22:55 <shapr> hi emu
13:23:11 * shapr installs the latest ghc5 deb to see which version of HaXml it has
13:23:14 <Explodey> But can't you just not import it?
13:23:32 <shapr> huh?
13:24:02 <shapr> jag verståh inte
13:24:09 <whee> shapr: try a recompile of whatever contains that symbol
13:24:20 <dark> I wonder if it's possible to construct identifiers that become pretty poems after mangling.
13:24:34 <dark> "TextziPrettyPrintzi" is a nice start.
13:24:37 <shapr> last I checked, that symbol is the base libs
13:25:04 <shapr> hi dbrink
13:25:17 <Explodey> I don't know a lot about GHC's linking
13:25:18 * shapr checks to see where that symbol really is
13:25:54 <whee> look for a Text/PrettyPrint/ directory
13:26:01 <Explodey> But I've never had that problem when I've used base lib names
13:26:07 <dbrink> hello
13:26:57 <shapr> dbrink: are you new to Haskell?
13:26:59 <seth> lucijan: I've committed the change.  To turn on logging for C library functions, set CQL_TRACE_CONFIG=1 in your environment.
13:27:04 <seth> Sorry, wrong window...
13:27:15 * shapr waits for ghc5 deb to finish setting up
13:27:20 <emu> hello
13:27:33 <whee> shapr: how long does ghc take to do a full rebuild for you?
13:27:35 <emu> ah, debian folk... I was just about to rebuild ghc5 deb to get extensions
13:27:45 <dbrink> shapr: I have no clue what it is....inkedmn told me he hangs out here some so I thought I'd see what's going on here :)
13:27:45 <shapr> whee: forever and then some.
13:27:47 <emu> that is necessary right?
13:28:07 <whee> just wondering, it takes about the same amount of time here. heh
13:28:15 <shapr> whee: actually, not very long compared to most, my box is very fast at compiling stuff
13:28:33 <whee> my compiles go for at least an hour
13:28:39 <shapr> I can compile 2.4.19 and modules in two minutes ten seconds
13:28:56 <shapr> ghc5 takes a very long time though
13:29:03 <emu> how long?
13:29:08 <whee> :P
13:29:10 <emu> and what box you have?
13:29:24 <shapr> I don't remember exactly. I think it was four hours or so to do the two stage build
13:29:26 <dbrink> shapr: It's a language I suppose?
13:29:32 <shapr> I have a dual Athlon MP 1800+
13:29:36 <shapr> dbrink: yes it is
13:29:38 <emu> and it takes you four hours?!
13:29:47 <shapr> Haskell is a very spiffy language.
13:29:56 <emu> and I thought SBCL was slow to build
13:30:01 <shapr> what's SBCL?
13:30:13 <emu> CMUCL with all the compiler speed-ups ripped out =) j/k
13:30:14 <shapr> oh
13:30:19 <shapr> heh
13:30:30 <shapr> dbrink: have you heard of functional programming?
13:31:17 <emu> so anyway, I need to rebuild to get extensions, the deb doesn't have them enabled by default?
13:31:33 <whee> hah, damn
13:31:51 <dbrink> shapr: heard the term a time or two...
13:31:52 <shapr> emu: which extensions?
13:32:02 <emu> i'm interested in the existential types mostly
13:32:17 <shapr> dbrink: http://c2.com/cgi-bin/wiki?AdvantagesOfFp
13:32:35 <shapr> that should give you an overview of FP
13:32:38 <whee> I don't have exact measurements on me, but mine takes somewhere from 1-3 hours (on a 800mhz G4)
13:32:38 <whee> you don't get glasgow extensions in the default deb? that's odd
13:32:49 <shapr> I think you do
13:32:54 <emu> at least it wouldn't compile. maybe I made another mistake.
13:33:03 <shapr> whee: are you doing the two stage build?
13:33:15 <dbrink> shapr: thanks, I'll check it out
13:33:26 <shapr> dbrink: feel free to ask questions here
13:34:21 <shapr> emu: are you using -fglasgow-exts in your compile command line?
13:34:40 <emu> shapr: I have the deb installed
13:35:40 <shapr> what are you trying to compile?
13:36:18 <emu> http://groups.google.com/groups?as_umsgid=m3isyu2x6v.fsf@dino.dnsalias.com
13:37:09 <whee> shapr: yes
13:37:09 <whee> building my daily version right now, actually :)
13:37:18 <emu> does the ghc build take advantage of the dual proc?
13:38:51 <shapr> somewhat
13:39:09 <shapr> there are still a few spots where the dependencies in the makefile are screwy
13:39:47 <emu> okay--but first... do I need to recompile at all?
13:39:58 <shapr> no, you don't
13:40:10 <shapr> ghc --make ProtoShape.hs
13:40:18 <emu> when I try to compile that example it barfed on forall
13:40:18 <shapr> ProtoShape.hs:6: Not a constructor: `forall'
13:40:27 <shapr> ghc --make -fglasgow-exts ProtoShape.hs
13:40:34 <shapr> ghc: linking ...
13:41:44 <shapr> you only need to add -fglasgow-exts to your command line when compiling
13:42:26 <emu> hrm. for some reason I think I must have read that as 'you need it when compiling ghc'
13:47:32 * shapr installs HaXml 1.08
13:48:25 <emu> I taught myself Haskell today, so I'm a bit rough on the edges here
13:48:43 <stepcut> mmm ... HaXml
13:49:13 <shapr> emu: I've been working on Haskell for more than a year, I'm still rough on the edges.
13:49:29 <dark> Hmm, mallocForeignPtr seems to be missing from Foreign.ForeignPtr.
13:52:25 <shapr> strange, HaXml can't find Maybe
13:56:27 <Marvin--> while(((queue.size())-1)>=((2*pos)+1))
13:56:28 <Marvin--> ???
13:56:37 <Marvin--> Obviously these students haven't heard of a) spaces, b) precedence
13:56:50 <whee> where did you get that code
13:56:56 <Marvin--> assignments I'm marking
13:57:03 <whee> I wouldn't know where to start.
13:57:39 * shapr gets out the really big red marker
13:57:53 <whee> gah, flashbacks again
13:58:01 <whee> story time :)
13:58:03 <shapr> just dip their paper in red ink so that the whole paper is colored
13:58:08 <shapr> maybe they'll get the hint ;-)
13:58:36 <whee> I took french in high school for a couple years, and the second year required us to write essays (in french) every week or so that described some image we were given
13:58:55 <shapr> sounds like fun
13:58:56 <dark> Marvin: Those are not the worst mistakes a beginner could be making :)
13:59:10 <Marvin--> dark: well, no
13:59:12 <Marvin--> but the code is unreadable
13:59:18 <shapr> whee: I'm biased, I enjoy French.
13:59:26 <whee> so this one time I get my essay back, and there's this red line across the side with ticks every now and then; I ask some kid "erf, what's this?" "that's odd."
13:59:28 <shapr> and I'm learning Swedish which is lots of fun.
13:59:37 <whee> then about five minutes later I realize it's actually a vertical string of -1's.
13:59:41 <shapr> svenska är kul
13:59:56 <shapr> whee: oh that sucks, I got that too when I started learning French.
14:00:02 <whee> it went down the entire length of the page and across on the back
14:00:06 <whee> it was insanely funny :)
14:00:06 * shapr laughs
14:00:19 <emu> Marvin--: I don't blame them though
14:00:29 <emu> well, at least about the precedencce
14:00:33 * emu never remembers
14:00:36 <dark> I give up.  I was trying to add a constructor UnknownEvent Int (ForeignPtr SDL_Event).  First I run into gaps in GHC's FFI implementation, then I find out that this means I can't have Ord Event.
14:00:52 <shapr> dark: why can't you have Ord Event?
14:01:12 <dark> I'd have to define Ord ForeignPtr first.
14:01:17 <shapr> I thought the latest and greatest GHC fully implement the FFI spec now?
14:01:21 <shapr> oh
14:01:25 <dark> Well, unless I fake one up.  I do not want to write an Ord by hand for this type, it's huge :)
14:01:43 <dark> shapr: So did I, but mallocForeignPtr is missing.
14:01:48 <shapr> suckage
14:01:54 <shapr> you should complain on ghc-users
14:02:17 * shapr tries to fix HaXml 1.08 for hierarchical modules
14:02:21 * shapr gets out the hammer
14:02:28 <dark> I was thinking of reporting a bug instead :)
14:02:39 <shapr> that would be sensible.
14:03:04 <shapr> hi clausen
14:03:10 <shapr> clausen: written any cool Haskell code lately?
14:03:11 <clausen> hi shapr
14:03:23 <clausen> nope, I've been thinking in haskell though
14:03:26 <dark> Maybe I could provide the unknown event data as a UArray Int Word8.  But that might suck.
14:03:35 <clausen> members.optusnet.com.au/clausen/ideas/functional-fs.txt
14:04:27 <shapr> oh, you should read "Algorithms, A Purely Functional Approach" or whatever the real title is, by Rabhi and LaPalme
14:04:34 <shapr> I really enjoyed that book.
14:04:36 <clausen> I've read okasaki
14:04:44 <shapr> I want to read okasaki next.
14:05:01 * clausen looks for rabhi and lapalme
14:05:05 <shapr> the Rabhi and Lapalme book is incredibly clear.
14:06:30 <shapr> clausen: I think you have something worthwhile there
14:07:07 * clausen hopes so :)
14:07:34 <clausen> it's going to be hard-going though, and I think I'm going to end up with something looking a lot like journaling, hehe
14:08:01 <emu> dark: you are trying to FFI ghc to SDL? =)
14:08:19 <dark> emu: Yep :)
14:08:20 <shapr> clausen: I think you could get something better than journaling
14:08:52 <clausen> yes
14:08:54 <Marvin--> WHOA, six points in one round
14:08:57 * Marvin-- is watching curling
14:08:59 <clausen> it would have fewer write-order dependencies
14:09:13 <clausen> but, I think I'll have to do lazy rebuilding
14:09:29 <clausen> to make sequential writes O(1)
14:09:46 <clausen> (well, O(n), where n is the length of the write)
14:10:03 <shapr> I don't understand enough about the subject to know what you're saying, but I'd like to read a more detailed description if you come up with one
14:10:45 <clausen> well, if you keep fwrite()ing to a file
14:11:02 <clausen> you don't want to have to do O(log n) writes to update that file each time
14:11:12 <clausen> (the file itself is a leaf in a tree)
14:11:26 <dark> ... splay trees!
14:11:33 <clausen> dark: that gets you amortized time
14:11:39 <clausen> dark: but I'd like something like that, yes
14:11:41 <emu> i've been delving into SDL a bit myself
14:11:46 <clausen> (or lazy rebuilding)
14:12:07 <dark> clausen: What's that?
14:12:32 <clausen> basically: keeping a list of updates to apply
14:12:44 <clausen> and doing a bit of the application during each operation
14:13:28 <clausen> some data structures are expensive to do incremental updates on
14:13:43 <clausen> but are cheap to rebuild
14:13:52 <clausen> so, you keep a list, and rebuild when the list gets long
14:14:04 <clausen> you want to do that lazily, so the "rebuild" cost gets spread out
14:15:09 <dark> Aha, I see.
14:15:37 <clausen> (or, spread it out *somehow*)
14:16:45 <dark> I've seen the list-of-updates approach, but I've never seen spreading-out before.
14:17:07 <clausen> okasaki has a chapter on it
14:17:30 <clausen> also, tux2 (a file system) reinvents it in that context
14:17:45 <clausen> (actually, the ideas for tux2 may well predate okasaki & friends)
14:18:15 <dark> tux2, is that related to linux? :)
14:19:07 <clausen> yes
14:19:21 <clausen> google daniel phillips
14:19:28 <clausen> also, WAFL is related to this stuff
14:19:41 <clausen> it has a similar approach
14:19:50 <clausen> (WAFL is a file system used on netapp servers)
14:24:06 * shapr gets frustrated with HaXml and goes off to play CounterStrike
14:24:13 <shapr> bbl
14:26:45 <clausen> rabhi and lapalme doesn't look very interesting
14:26:52 <clausen> (from reading contents page)
14:27:03 <clausen> it doesn't deal with persistence, lazy evaluation and memoization
14:27:12 <clausen> which are really important for good data structures in haskell
14:29:31 <dark> clausen: This is interesting.  It seems to solve the same problems as a journaling filesystem, but more simply and without the slow startup.
14:30:10 <clausen> dark: what are you refering to?  my idea? wafl?  tux2?
14:30:28 <dark> clausen: tux2 :)  sorry, I went off to read it and then came back.
14:30:35 <clausen> aha :)
14:30:44 <clausen> the big disadvantage of tux2 is a slow commit time
14:31:08 <dark> You mean the delay between a filesystem operation and when it actually appears on disk?
14:31:15 <clausen> right
14:31:22 <dark> I guess that depends on how many operations are collected into a "phase", right?
14:31:28 <clausen> right
14:31:40 <clausen> in practice, that phase seems to need to be fairly long for good performance
14:31:50 <dark> Does the depth of the trees it uses reflect the actual directory hierarchy, or are they independent?
14:31:53 <clausen> (that said, tux2 was never implemented properly, so maybe that's a myth)
14:31:58 <clausen> independent
14:32:14 <clausen> you'd implement it as a tree indexed by inode-number
14:32:22 <clausen> (inode == file)
14:33:45 <dark> Hmm, then I don't see why it would be all that slow.  Especially since the relative cost of a short phase time goes down if the frequency of operations increases.
14:34:43 <clausen> lots of seeks
14:34:49 <clausen> remember: disks and random-access like RAM is
14:34:53 <clausen> s/and/aren't/
14:35:18 <dark> Or... hm.  Indexing by inode might actually be bad, if operations are normally clustered by directory.
14:35:31 <dark> Lots more metadata to update than in a directory-tree based system.
14:35:44 <clausen> inodes in a particular directory usually have nearby numbers
14:35:52 <dark> Ah, okay.
14:35:55 <clausen> (typical inode allocation algorithms do that)
14:36:13 <clausen> all unix file systems are inode based
14:36:23 <clausen> (hmmm, reiserfs isn't really)
14:36:30 <clausen> xfs, ext2 are
14:37:02 <dark> Hmm, this is going to have a big hot spot at the metaroot location.  Will that wear out a disk? :)
14:37:19 <clausen> you can move it around
14:37:32 <clausen> (the metaroot)
14:38:20 <clausen> actually, modern HDs will move it around for you ;)
14:38:36 <dark> I think it's creepy, what modern disks do :)
14:38:40 * clausen too
14:38:43 <clausen> I wished they documented it
14:53:36 <dark> Turns out that all_events = unsafeInterleaveIO $ sequence (repeat wait_event) does not work :)
14:55:32 <dark> Cool, it w0rx0rz.
14:56:09 <Marvin--> my god this code is unreadable
14:56:39 <Marvin--> SNode neighbour =(SNode)((Vector)((Vector)cityMap.getSuccesors()).elementAt(vpos)).elementAt(i);
14:56:47 <whee> haha
14:56:54 <whee> I could confuse that with lisp if I squinted
14:57:18 <Marvin--> I need an electronic equivalent of dipping their papers in red paint
14:57:53 <dark> The problem here is obviously Java.
14:58:16 <whee> Java is evil
14:58:21 <Marvin--> no, the problem is their design
14:58:34 <dark> Having to use casts just to get values out of the data structure you put them into, what madness is that?
14:58:49 <Marvin--> instead of designing a remotely linked structure (like a node-list graph implementation) they put everything in vectors of vectors and have ints everywhere
15:01:00 <Marvin--> even without the casting, SNode neighbour = cityMap.getSuccessors().elementAt(vpos).elementAt(i) is pretty damn bad
15:05:24 * Marvin-- feels like running to the hills
15:05:58 <dark> Heh.  Every SDL function returns 0 for success and -1 for error, except for SDL_WaitEvent which returns 1 for success and 0 for error.
15:07:18 <Marvin--> sounds like someone made a mistake :)
15:10:18 <dark> Looks like a clumsy notation for 2-d arrays :)
15:10:48 <dark> In C that would be city_map->successors[vpos][i]
15:11:05 <dark> So I'll stand by my statement that the problem here is Java.
15:11:11 <whee> .. array?!?$@ what? I've been using variable names like foo2 foo3 and foo4 in combination with a preprocessor for nothing?$!
15:11:18 <Marvin--> heh
15:11:33 <Marvin--> dark: I still say they should have a *linked* data structure
15:11:38 <dark> whee: What's up?
15:11:50 <whee> it was a bad attempt at a joke :)
15:11:52 <Marvin--> successors[vpos][i] is the ith successor of the vpos node... ugh
15:12:21 <dark> Oh, it's not a city map with x and y coordinates?  I thought "vpos" might refer to "vertical".
15:12:49 <Marvin--> no no no, it's a graph of bus stops in Göteborg, they're implementing Dijkstra's algorithm to find the shortest path
15:13:28 <dark> My father (geologist) always gets annoyed when people use "above" and "below" to refer to north and south.  "20 kilometers under Amsterdam, you only get rock."  (He'd know the exact type of rock, of course.)
15:13:40 <emu> whee: in Lisp, every parenthesis has a meaning
15:13:54 <dark> (I don't know how common this "under" is with native english speakers)
15:14:08 <emu> whee: Java is far mroe unreadable, because you're never quite sure if they are necessary, and it tends to be written out like that above, with all sorts of strange punctuation thrown in
15:14:54 <dark> Marvin: Do you know what the difference is between A* and Dijkstra's algorithm?  I've been trying to figure it out.  They look pretty similar to me, iff you apply the estimated-distance optimization.
15:15:21 <Marvin--> A*?
15:16:19 <dark> Marvin: http://www.geocities.com/jheyesjones/astar.html
15:16:35 <dark> Marvin: It's what I used in Mage :)
15:17:36 <clausen> dijkstra and a* are similar, I think
15:17:54 <clausen> but dijkstra will give you the shortest path between one node and every other node
15:18:04 <clausen> a* gets you the shortest path between two particular nodes
15:18:11 <clausen> (all off the top of my head :)
15:18:33 <dark> clausen: But every node on the path must also be the shortest path, right?
15:19:27 <dark> I've actually been thinking of ways to use astar to find "the shortest path to the closest winning node", I think it's just a matter of tweaking the win function and using "min" a lot in the estimation function.
15:20:08 <emu> A* uses a heuristic
15:20:14 <dark> Er, "the shortest path to the winning node with the shortest path" would be more accurate :)  (It's to plan monster paths on levels that have fixed teleporters)
15:20:28 <dark> emu: Yeah, but I've seen descriptions of Dijkstra that include a similar heuristic.
15:22:30 <clausen> dark: yes, but dijkstra doesn't give you a path
15:22:40 <clausen> (it gives you a tree)
15:22:53 <emu> I used A* to do the TSP at the beginning of the semester, getting a bit rusty now =)
15:23:44 <jak_home> does a* guarantee the shortest path?
15:23:50 <jak_home> I thought it didn't
15:23:50 <emu> it's optimal
15:24:01 <emu> so long as you satisfy some constraints
15:24:34 <clausen> you're heuristic must always over-estimate
15:24:35 <jak_home> so dijkstra doesn't have constraints, but a* does
15:24:47 <clausen> a* is faster than dijkstra
15:24:56 <clausen> (if you have a good heuristic)
15:24:56 <emu> no
15:25:00 <emu> never overestimates
15:25:28 <emu> ``The restriction is to choose an h function that never overestimates the cost to reach the goal.  Such an h is called an admissable heuristic.''
15:25:33 <emu> -- AIMA
15:25:40 <clausen> ah, thanks
15:25:55 <emu> h is the estimated cost to the goal
15:26:01 <emu> g is the path so far
15:26:07 <clausen> in any case, if you have a good heuristic, you might only need to look at the nodes on the path
15:26:11 <emu> so the heuristic for A* is f = g + h
15:26:17 <clausen> with dijkstra, it's somewhat like DFS
15:26:39 <emu> A*-search = BEST-FIRST-SEARCH [g + h] 
15:26:41 <Marvin--> wha, there are actually people who don't implement heaps with arrays?!
15:27:04 <clausen> Marvin--: of course!
15:27:08 <clausen> Marvin--: arrays suck for heaps
15:27:16 <clausen> particularly if you want persistence
15:27:36 <clausen> eg: you can't merge efficiently with arrays
15:27:52 <clausen> binomial heaps or leftist heaps are much better
15:27:54 <Marvin--> true, but no merging needed here
15:28:06 <clausen> besides, if you're using haskell
15:28:13 <clausen> you have persistence
15:28:16 <clausen> (no destructive update)
15:28:29 <Marvin--> *cough*Java*cough*
15:28:39 <clausen> poor lad
15:30:00 <dark> I was actually wondering how to implement a heap in Haskell.
15:30:09 <dark> Efficiently, that is :)
15:30:47 <Marvin--> I'm just using this channel as my general whine medium tonight
15:30:53 <dark> My attempt at it can be found as Util.PQueue in Mage.
15:30:57 <clausen> read okasaki's paper
15:30:59 <clausen> (thesis)
15:31:10 <clausen> it's available free online... I linked it from members.optusnet.com.au/clausen/books.html
15:31:20 <emu> Marvin--: just be thankfuly you're not doing arithmetic with Java Integers and etc
15:31:42 <dark> clausen: thanks.
15:31:43 <Marvin--> been there, done that
15:33:33 <emu> perhaps A* requires a monotonic heuristic
15:33:44 * Marvin-- sings along with 'Maiden... can I play with madneeeessss?
15:34:03 <dark> I think Java is a showcase for the theorem that every language's libraries will grow until everything is an API and the actual language features are irrelevant.
15:34:28 <dark> emu: I remember reading that it's been shown that A* will decay gracefully if the heuristic overestimates.
15:34:33 <clausen> java's lack-of-language features are very relevant, however
15:34:37 <Marvin--> bah, everybody just use vectors for everything anyway *sobs*
15:34:43 <emu> dark: well, this was only to satisfy the proof of optimality
15:34:55 <clausen> (lack of multiple inheritance bites!)
15:35:02 <dark> Marvin: That's part of what I mean :)  Eventually, types don't matter, and method calls are the only operations.
15:35:20 <emu> dark: well, Java has no interesting semantics anyway
15:35:30 <dark> It's happening in C too.
15:35:34 <emu> you mean like Smalltalk?
15:35:39 <emu> message-passing is everything? =)
15:35:39 <dark> Haskell seems immune to it... so far :)
15:35:51 <clausen> that's because no-one uses haskell
15:36:11 <whee> or understands it 
15:36:15 <dark> But just wait until it becomes "good practice" to make all datatypes abstract and not use pattern matching.
15:36:21 <Marvin--> I thought OO just *was* objects and message passing?
15:36:32 <emu> OO is a lot of things apparently...
15:36:42 <emu> there's at least one other paradigm than message passing =)
15:36:43 * Marvin-- digs out A Theory of Objects
15:36:44 <whee> I don't think java OO is really message passing
15:37:18 <jak_home> c++ view of OO is encapsulation, inheritance and polymorphism :)
15:37:30 <emu> and single-dispatch
15:37:54 <jak_home> yes
15:38:03 <dark> I think it's silly how Java requires variables to be accessed through query functions, just in case you might ever want to replace the variable with a function.  If it's so important, then why not build it into the language, like Python does, and allow definition of functions that override variables?
15:38:10 <jak_home> typed cecil is a wonderful idea
15:38:25 <whee> it doesn't require that, dark
15:38:35 <whee> instructors like to beat it into their students, though
15:38:49 <dark> whee: Not just instructors :)  It's everyone.
15:39:21 <emu> wouldn't it be nice if accessor functions were defined for member slots automatically ? =)
15:39:41 <whee> at this point, that's a job for the text editor or a preprocessor
15:40:00 <emu> Java's fault
15:40:03 <Marvin--> I told my students explicitly to dump the getNext(), getPrev(), getAbove() ... methods and make the helper class private static instead, and after that, their program was about four times faster
15:40:23 <dark> Marvin: Did I mention that the Java spec explicitly forbids inlining of such accessor functions? :)
15:40:32 <whee> haha
15:40:34 <Marvin--> ?
15:40:50 <dark> Marvin: It's to maintain binary compatibility if you replace some, but not all classes.
15:40:51 <Marvin--> you can't optimize them away?
15:40:59 <dark> Marvin: Java has no "AS IF" rule like C does.
15:41:05 <Marvin--> :)
15:41:31 <dark> Marvin: I could look up the relevant part of the spec for you, but that would mean getting near Sun's licensing again :)
15:41:46 <Marvin--> nah, don't bother
15:42:01 * Marvin-- is happy he's going to do a haskell-related master thesis, yay, no Java at all during spring
15:42:05 <emu> Java has poor abstraction facilities in general. I don't know how anyone manages to write reusable[usable] code in it
15:42:35 <dark> emu: well, interfaces are somewhat nice, but I'd like them to be better integrated into the language.
15:43:00 <emu> but do they save you coding effort?
15:43:03 <dark> Mainly, I'd want to be able to declare that a class implements the interface of another class.
15:43:22 <dark> emu: I don't know, I got disgusted with Java and went to Haskell after a relatively short time :)
15:43:28 <emu> not too surprised
15:44:01 <dark> It was partly a political move, dealing with Sun's licensing is like working at a biohazard facility.
15:44:13 <emu> I could never understand why open-source ppl like Java
15:44:25 <Marvin--> error: compiler message file broken: key=compiler.err.sun.io.MalformedInputException arguments=null, null, null, null, null, null, null
15:44:25 <Marvin--> 1 error
15:44:27 * Marvin-- boggles
15:44:57 <dark> emu: I consider pseudo-free and quasi-free to be much more dangerous than non-free :)
15:45:32 <dark> Marvin: Now I have fond memories of the trs-80 assembler which said "00001 error(s)".  It's nice to know it had such faith in me :)
15:45:42 <Marvin--> haha
15:46:02 <Marvin--> it just smacks of "come on, do your worst!"
15:46:36 * Marvin-- installs jikes instead
15:48:01 <emu> off to watch LotR "extended" DVD
15:48:09 * emu boggles at the concept
15:49:14 --- topic: set to '["mo' nads than you", "We put the Funk in Funktion", "See logs @ http://tunes.org/~nef/logs/haskell/", "Gtk+HS 0.14.10: http://www.cse.unsw.edu.au/~chak/haskell/gtk/", "HWS-WP: http://www.dum.chalmers.se/~marvin/hws-wp/", "HaskellWiki resurrected", "ANNOUNCE: GHC version 5.04.2 released","dark's SDL binding http://www.xs4all.nl/~dark/hasdl-0.1pre3.tar.gz"]' by dark
15:49:48 <jak_home> excellent
15:49:53 <jak_home> what's new?
15:49:57 <dark> Events :)
15:50:03 <jak_home> keyboard, mouse
15:50:11 <dark> I'm afraid the new Main.hs example is far more boring than dancing penguins.
15:50:12 <jak_home> user?
15:50:12 <emu> did you do OpenGL yet?
15:50:39 <dark> jak: Only rudimentary support for user events, and no support for pushing events back onto the queue yet.
15:51:25 <dark> emu: No, that might even come last.  I'm hoping HOpenGL will become better integrated in fptools before I get to that :-)
15:52:48 <emu> amusingly enough, OpenGL was the drive behind cl-sdl for me =)
15:53:12 <dark> emu: You didn't like GLUT?
15:53:22 <emu> well, GLUT takes away the toplevel and requires callbacks
15:53:56 <emu> and foreign callbacks aren't supported by every CL implementation at this time, particularly CMUCL (the one i use)
15:54:15 <emu> and it sucks compared to SDL (except SDL can't open multiple windows)
15:54:42 <dark> What do you mean with "takes away the toplevel"?
15:55:05 <emu> it has it's own event loop
15:55:15 <emu> so I can't use my own (which might be the CL REPL)
15:55:24 <dark> Ah, I see.
15:55:33 <dark> So all you get to do is callbacks.
15:56:03 <dark> This sounds like a "more functional" approach than driving the loop yourself, though :)
15:56:21 <emu> yes, but I like to be able to fiddle with stuff as its running
15:56:45 <emu> anyway, who wants C calling you? =)
15:58:21 <dark> emu: This is going to be a problem with SDL audio :)  asynchronous callbacks.
15:58:45 <emu> I've only done a little bit of SDL_mixer, not too much with SDL audio
15:59:00 <jak_home> callbacks aren't always necessary
15:59:09 <jak_home> you can just query if you like :)
15:59:11 <jak_home> poll
15:59:25 <jak_home> or have a thread that waits
15:59:31 <dark> jak: SDL uses callbacks to feed data to the sound system.
16:00:26 <jak_home> it's also possible to abstract that into a thread
16:00:48 <jak_home> I can't remember the details now
16:02:46 <dark> I'm thinking of making a Haskell interface to it somewhat similar to openal: you specify a "background music", and also tell it when to start samples.  Each sample gets an id that you can use to cancel it later.  All the mixing happens at a lower level.
16:03:01 <dark> The drawback is that this would be somewhat far away from the normal SDL interface.
16:04:59 <jak_home> ah
16:05:10 <jak_home> I think I know why I have differing views to you
16:05:18 <jak_home> perhaps you are talking about SDL audio
16:05:21 <jak_home> while I was talking about
16:05:23 <jak_home> SDL_mixer audio
16:05:33 <jak_home> which gives a higher level interface to SDL audio
16:05:41 <dark> Oh, I didn't know about that.
16:05:48 <dark> I've never done audio before :-)
16:06:01 <jak_home> there is built in audio support into the base SDL library
16:06:13 <dark> Yeah, and Programming Linux Games only talks about that, I think.
16:06:34 <jak_home> but SDL mixer allows you more freedom ilke ability to play OGG files and queue samples and multiple channels to mix etc
16:07:01 <clausen> that's pretty trivial to implement
16:07:51 <clausen> (hmmm, playing ogg isn't, hehe)
16:08:13 <jak_home> it also includes a cut-down mikmod library for the more popular kinds of mod files
16:08:36 <jak_home> http://jcatki.no-ip.org/SDL_mixer/
16:09:02 <dark> It's packaged for Debian :)
16:09:15 <jak_home> i thought *everything* was packaged for debian
16:09:27 <jak_home> even the stuff that supposedly violates their social charter
16:09:56 <jak_home> you just have to know the right line to add to apt sources
16:10:18 <jak_home> then apt-get some magic and after about 34534 packages have downloaded you have a completely broken machine :)
16:10:27 <jak_home> that's if you're unwise, like me
16:11:47 <dark> Install vrms :-)
16:12:12 <dark> I currently have 3 non-free packages installed: pgp, unarj, and xanim.
16:12:28 <dark> I currently have 2 non-free packages installed: pgp and unarj.
16:13:07 <Igloo> Why pgp?
16:13:13 <jak_home> i'm off to bed
16:13:16 <jak_home> goodnight !
16:19:21 <dark> Igloo: I maintain it :)
16:19:31 <clausen> grrr, okasaki isn't in citeseer
16:19:37 <clausen> it's got a lot of references...
16:19:48 <Igloo> And again I ask why?  :-)
16:19:53 <Heffalump> it's on his homepage
16:20:17 <Heffalump> IM his papers are
16:20:32 <clausen> yeah, I've got his book
16:20:41 <clausen> just, I want to navigate his citations
16:20:51 <Igloo> Hmmm, I think GTK is giving me nasty artifacts
16:21:36 <clausen> it has 10 pages of citations!
16:23:04 <Heffalump> ahh
16:24:52 <dark> clausen: Would you recommend the book to someone who's reading the thesis? :)
16:25:12 <clausen> dark: yes
16:25:18 <clausen> the book is better
16:25:30 <clausen> (most of the book is cut&paste out of the thesis)
16:25:37 <clausen> (the book is a strict superset
16:25:40 <dark> clausen: Should I skip reading the thesis and wait for the book instead?
16:25:42 <clausen> and some bits are explained better)
16:25:48 <clausen> dark: if you're patient, yes
16:26:03 <dark> I'm not patient :-)
16:26:32 <clausen> then read his thesis, and get the book ASAP, hehe
16:36:19 <Marvin--> and see the movie
16:36:48 <clausen> LOL
16:36:54 <clausen> action figures coming out shortly...
16:46:41 <clausen> anyone know okasaki's home page?
17:09:56 <dark> You know it's late when it takes three tries to type ./foo
17:21:28 <philc> gr
17:21:36 <philc> sorry, wrong window
17:23:34 <lament> gr
17:29:27 <dark> Keyboard repeat works too :-)
18:16:54 <clausen> dark: so, did you find it easy to understand my functional-fs.txt thing?
18:17:07 <clausen> dark: I guess I should add some more definitions/references to make it more accessible
18:17:11 <clausen> (alive?)
18:18:50 <dark> clausen: Sorry, I didn't look at it yet.  I'm reading Okasaki's thesis :)
18:18:56 <clausen> LOL
18:18:59 <clausen> it's not very long!
18:19:04 <clausen> (a page!)
18:19:18 <dark> Well how was I supposed to know that :)
18:27:25 <clausen> dark: well...
18:27:33 <clausen> ?
18:27:59 <dark> clausen: Hold on, someone on #sdl finally woke up and answered a question :)
18:28:05 <clausen> :)
18:31:09 <dark> clausen: I wouldn't have understood the distinction between "good amortized time" and "good worst-case performance" if I hadn't read part of the thesis first :)
18:31:36 <clausen> hmmm, thanks
18:32:00 <Igloo> Surely you have worst-case amortized times?
18:32:29 <dark> clausen: You might be pessimistic in your final note; as far as I know, merging filesystems with version control is the "next big thing".  Certainly Reiser is working on it, and it'll be very useful for resolving conflicting updates in scattered (a la codafs) filesystems.
18:32:47 <clausen> dark: good point
18:33:02 <clausen> Igloo: ?
18:33:57 <Igloo> clausen: I suspect I'd have to read the thesis in question to find out what's being talked about  :-)
18:34:12 <dark> I think the point about garbage collection went over my head.  Doesn't tux2 do it implicitly, by only ever looking at structures that can be reached from the current or future metaroot?
18:34:15 <clausen> Igloo: did you read it?
18:34:23 <clausen> (my rant, not the thesis)
18:34:36 <Igloo> No
18:34:37 <clausen> dark: it still has to do block allocation
18:34:47 <clausen> Igloo: members.optusnet.com.au/clausen/ideas/functional-fs.txt
18:34:54 <dark> clausen: Technically it's an "idea", not a "rant" :)
18:35:10 <clausen> dark: yeah, ok :)
18:35:25 <clausen> dark: I've got a separate rant section: members.optusnet.com.au/clausen/rants :)
18:38:46 <dark> clausen: Ah, garbage collection along the lines of, keep a file around as long as any process has it open, even if it's no longer linked from the filesystem?
18:39:30 <clausen> dark: as in, as long as a snapshot refers to it
18:39:40 <clausen> dark: i.e. you have multiple trees
18:39:53 <clausen> dark: and when you allocate blocks, you want to allocate *free* blocks
18:40:08 <clausen> dark: determining if a particular block is free is a hard problem
18:40:11 <clausen> dark: hence, garbage collection
18:40:39 <dark> clausen: Aha, so it solves a problem introduced by persistence?
18:40:50 <clausen> dark: that's the hope
18:40:51 <dark> clausen: the defree list is tux2's implementation of garbage collection?
18:40:56 <clausen> dark: yes
18:41:04 <dark> Okay, now I get it :)
18:41:11 <clausen> dark: basically, references are made in a very controlled way
18:41:20 <clausen> dark: so you don't need to be very sophisticated about your GCing
18:41:28 <clausen> dark: but it's still non-trivial
18:44:15 * clausen wonders if continuations might be useful
19:19:36 <dark> clausen: You misspelled "Quantum Computing" in your books list :)
19:19:58 * clausen checks
19:20:24 <clausen> oops
19:20:28 <clausen> thanks
19:24:46 <whee> okay, stupid question. if I want to define an operator that operates on some data type (and only that type), I just go and define it like any other infix function?
19:25:15 <whee> the instance (..) => ... where ... form is only for deriving those other things?
19:26:09 <clausen> operators == functions, yes
19:27:04 <whee> so if I wanted to create something like Eq or Ord, I use the class ... where blah blah form 
19:27:23 <clausen> a type-class?
19:27:23 <whee> smashing :|
19:27:36 <clausen> hint: read haskell'
19:27:38 <clausen> oop
19:27:39 <whee> I suppose.
19:27:42 <clausen> read hug's prelude
19:27:52 <clausen> (and libraries)
19:28:00 <clausen> the source is very concise, and informative
