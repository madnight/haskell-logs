02:01:49 <shapr> hi philc
02:02:19 * shapr bounces
02:02:20 <philc> hello
02:02:30 <philc> huh?
02:02:43 <shapr> sorry, I was bouncing for entirely separate reasons.
02:02:56 <shapr> philc: do you use Haskell?
02:03:37 <philc> not really for the fun of it (yet)
02:04:02 <shapr> do you have any questions?
02:05:03 <philc> not yet but I think they will come soon
02:05:22 <shapr> ok, we're here for when they arrive.
02:07:09 <philc> that's what I have hoped :)
02:07:49 <philc> and maybe to learn something from other people who have questions
02:10:29 <shapr> there are some excellent discussions here
02:10:55 <philc> good
02:11:05 <shapr> most of the discussions happen during european evening and australian morning.
02:11:48 <Heffalump> shapr: how big was #haskell when you joined?
02:11:57 <Heffalump> or did you create it?
02:12:02 <shapr> Heffalump: zero size :-)
02:12:03 <philc> ok, that includes the time when I'm usually online
02:12:14 <Heffalump> it's grown pretty well :-)
02:12:18 <shapr> heh, I think so
02:14:22 <Marvin--> it sure is bigger than #debian-boot :/
02:15:09 <shapr> hm, 34 on #haskell not counting the loggingbot
02:15:33 * Marvin-- grins at shapr
02:15:39 <philc> and luckily not as big as #debian ... or we couldn't have this conversation because it would scroll by too fast
02:15:43 <shapr> truly
02:15:47 <shapr> #debian is massive
02:16:04 * Marvin-- says "oh well" and keeps hacking on d-i
02:16:12 <shapr> d-i?
02:16:19 <shapr> debian-insults?
02:16:29 <Marvin--> heh, no
02:16:31 <Marvin--> debian-installer
02:16:47 <shapr> on the good side, #debian is so large that there's #debian.se, #debian-fi, #debian-fr, etc
02:17:22 <philc> yup, but #debian-de was so unfriendly that I left again
02:17:29 <shapr> so if #haskell were that large we'd probably have #haskell.template #haskell.eager
02:17:49 * Marvin-- ponders if the snake udeb should have a menu item
02:17:56 <shapr> philc: I've only spent time in #debian-fi #debian.se #debian-fr and #debian
02:18:21 <shapr> my german isn't even enough to irc chat
02:18:28 <philc> I don't speak finish or swedish and my french isn't good enough
02:19:40 <shapr> I think you'd find swedish is pretty easy for a native german speaker.
02:19:55 <shapr> finnish is just hard :-)
02:20:18 <Marvin--> that's because finnish is totally unrelated
02:20:18 <shapr> kind of like being an expert C programmer and then trying to learn Haskell
02:20:43 <philc> we started programming with haskell at university
02:20:51 <shapr> oh nice
02:21:06 <shapr> I started programming haskell slightly more than a year ago
02:21:22 <shapr> it's addictive
02:21:33 <Marvin--> hmm. should I have a cup of coffee, or go to the university
02:21:37 <shapr> Marvin--: both!
02:21:39 <Marvin--> coffee or university, tough choice
02:22:02 <Marvin--> I suppose first of all I should go check on my bike (repaired a flat tire yesterday) to see what my time frames are
02:22:03 <philc> currently most of us are only swearing at it... or at our professor
02:22:13 <Marvin--> philc: tsk tsk :)
02:22:25 <shapr> philc: have you used other programming languages?
02:22:58 <philc> I learned a bit of java before
02:23:03 <shapr> hm
02:23:32 <shapr> doesn't help much with Haskell
02:23:41 <philc> well, this is my second week with haskell so I already learned the basics (I hope)
02:24:07 <shapr> I wonder if I know the basics.
02:25:46 <shapr> I still have trouble with monads
02:26:29 <philc> well, with basics I meant a general idea of the syntax
02:26:50 <Marvin--> fuck, there must have been another hole in the tube
02:26:59 <Marvin--> I'd better leave at once so I won't be late
02:27:05 <dennisb> Marvin--: there, there
02:27:31 * Marvin-- waves
02:28:16 <shapr> I really prefer Haskell over any other language I've used.
03:04:24 * sethk is away: I'm busy
03:24:14 <tetryl> monads is very difficult
03:24:31 <shapr> I can understand how they work
03:24:34 <shapr> but I can't seem to use them myself.
03:26:28 <tetryl> yea, I can't see the necessity of it.
03:27:20 <shapr> I've found places where I know a monad would be better, but I haven't made the jump into using them.
03:31:18 <tetryl> for difficulty of syntax?
03:32:01 <shapr> I think for difficulty of jumping from an existing structure to a monadic structure
03:32:26 <shapr> I would like to see some examples of before and after
03:33:01 <shapr> even better, explain what about the code motivated someone to switch to a monadic structure.
03:42:30 <tetryl> hmm
04:41:12 <Rochler> hi
05:29:18 <Rochler> re
05:29:50 <philc> w
05:29:52 <philc> wb
05:29:53 <shapr> hi Rochler
06:01:26 <shapr> hi dark
06:07:44 <dark> Hello :)
06:08:12 <dark> The problem with being out of sync in a country like this is that it's still dark when I go to bed and dark again when I wake up.  I might as well live in the Underdeep.
06:09:14 <janni> cu
06:09:53 <shapr> yah, I agree.
06:16:16 <dark> Whoops... looks like I was talking to myself there :)
06:16:45 <dark> Did you get any of my Flags ramblings/
06:17:57 <Igloo> No
06:18:37 <jak_> botch up with IRC server
06:19:30 <jak_> to quote:
06:19:33 <jak_> 19:38:29 <dark> Hmm. I have a type error here that I don't understand:
06:19:33 <jak_> 19:38:36 <dark> SDL.hs:28:
06:19:33 <jak_> 19:38:37 <dark>     Cannot unify the type-signature variable `f'
06:19:33 <jak_> 19:38:37 <dark>         with the type `GHC.Word.Word32'
06:19:33 <jak_> 19:38:37 <dark>         Expected type: f
06:19:34 <jak_> 19:38:37 <dark>         Inferred type: GHC.Word.Word32
06:19:36 <jak_> 19:38:37 <dark>     In the definition of `flagValue': sdl_INIT_TIMER
06:19:38 <jak_> 19:38:52 <dark> How can it possibly fail to unify a bare "f" with another type?
06:19:42 <jak_> 19:39:24 <dark> flagValue is a class function of Flags, defined as:
06:19:44 <jak_> 19:39:28 <dark>   flagValue :: (Bits f) => a -> f
06:20:03 <dark> Hmm half of that was from last night :)
06:20:29 <jak_> well, that's all that the logs have got :)
06:20:33 <dark> I "fixed" that unification error by adding some more fromIntegrals, even though I didn't really understand why they were needed.
06:20:39 <dark> Oh wait, all of that was from last night :)
06:20:54 <dark> Today's Flags ramblings are:
06:20:59 <dark> I have a class Flags a, which has a member: allFlags :: [a]
06:21:01 <jak_> lol
06:21:04 <dark> I would like to provide a default definition allFlags = [minBound .. maxBound]
06:21:16 <dark> But that means putting Bounded a in the context.
06:21:40 <dark> What I'd like to do is provide that default only in instances where it's possible, and have the compiler insist on a definition otherwise.
06:21:48 <dark> It looks like the type system can't do this.
06:22:44 <jak_> you're probably right, dark
06:23:19 <jak_> it's an easy enough function to right, though, for each instance
06:24:07 <jak_> s/right/write/
06:24:49 <dark> Yeah, it's just that the duplication annoys me :)
06:27:06 <jak_> how is your SDL library coming along. Are you planning on doing sound as well ?
06:27:27 <dark> I'm planning on doing everything :)
06:27:37 <jak_> excellent
06:27:46 <dark> I have the low-level wrappers done, except for the large structs declared in SDL_video.h
06:28:07 <dark> I'm starting on the high-level interface.
06:28:16 <jak_> what, like pixelformat /
06:28:17 <dark> For that purpose I'm porting Penguin Warrior to Haskell, so I can test as I go along :-)
06:28:20 <dark> jak: Yep, those.
06:28:38 <jak_> penguin warrior?!
06:29:17 <dark> jak: It's the example game from Programming Linux Games.
06:29:47 <dark> jak: Thanks for the sample code, by the way.  I gained Insight from the way you handled SDL_Rect.
06:30:31 <jak_> I can't even remember how I did it now :)
06:30:35 <dark> I fear that getting audio right might prove difficult, btw.  It relies on asynchronous callbacks to feed data to the soundcard.
06:30:44 <dark> I don't know if those will work at all with Haskell.
06:31:06 <jak_> well, the SDL_mixer stuff can run in a separate posix thread
06:31:19 <jak_> so it shouldn't be too bad
06:31:52 <jak_> a problem I had with a game I helped with was that sometimes the main logic thread took too much CPU time, and starved the music thread
06:32:17 <jak_> this happened on machines without accelerated graphics
06:34:20 <dark> On which OS was that?
06:35:41 <jak_> linux
06:36:10 <jak_> I think one solution in that circumstance is to make the sound thread a real-time one
06:36:25 <dark> Or maybe add some sleeps to the main thread ;-)
06:36:29 <jak_> hehe
06:36:32 <jak_> yeah
06:36:45 <dark> Realtime threads in haskell would be, um, interesting.
06:37:22 <jak_> they've been discussing threads and things a lot on the ghc mailing list. Can't say I followed most of it. Looks complicated
07:04:57 <dark> Hmm.  I like to compile with -odir and -hidir, in order to keep the generated files out of my source tree.  But that means my module names have to be globally unique again.  I can't have both SDL.Bare.Video and SDL.Video.
07:10:47 <dark> Cool, it makes a blank screen :-)
07:11:46 <jak_> hooray!
07:12:06 <jak_> have you done the sdl-events ?
07:13:06 <dark> Er, no :)  Well, I did at low level.  But the high-level interface currently does init, quit, and set_video_mode.
07:21:10 <bas> i am making a raytracer in haskell... i only have one problem, how can i output graphical data to the screen on a unix system? i know there is some m$ guy doing graphical stuff..
07:22:25 <dark> What timing :)  I'm currently working on an Haskell interface to SDL (Simple DirectMedia Layer)
07:23:32 <bas> dark: finished any time soon? :)
07:24:37 <Igloo> You can use gtk+hs
07:24:54 <Igloo> Or the 2D functions of hOpenGl presumably, although I've not used that
07:27:23 <dark> bas: I'm not even at the "90% done" stage yet :)
07:28:14 <bas> dark: ok... is it hard to do? i have no idea how one would interface such thing in haskell...
07:35:04 <dark> bas: There are a number of tools that help, and there's plenty of language support.  The hardest part is designing a nice Haskellish interface.
07:35:21 <dark> bas: Read up on the Foreign Function Interface (http://www.cse.unsw.edu.au/~chak/haskell/ffi/) if you're interested.
07:36:38 <dark> bas: There are also helper tools like c2hs and hsc2hs, you can use them to generate Haskell code using information from the C header files of what you're wrapping.
07:36:48 <bas> dark: ok thanks... i will take a look at it...
07:52:40 <dark> Hum hum.  I just realized that if I define an SDL-specific Color type, it's going to be a pain to use together with HOpenGL.  But if I use HOpenGL's Color type, then my package will depend on that package, and it's not a working part of fptools yet.
07:53:39 <Igloo> Make a Colour class?
07:55:04 <mgoetze> Igloo: are you suggest orthographic revisionism? :)
08:01:51 <hdaume> hi all
08:02:02 <mgoetze> hi
08:27:10 <jak_> SDL_image would be useful as well
08:32:31 * sethk is back (gone 05:28:07)
08:33:30 <Janni> hellas
08:34:40 <Janni> im a happy person. i just got the news, that i can get 384 kbit/s internet connection + flatrate (im living in the under developed germany)
08:35:04 <Janni> i mean: _at least_ 384 kbit/s
08:35:52 <Janni> btw: i'm the one who's nick was Rochler until now...
08:46:39 <philc> bbiab
08:53:35 <dark> Igloo: HOpenGL already has a Color class, so I would need to import that to use it :-)
08:54:05 <dark> Igloo: Oh, you meant "Colour" specifically?  That's not really the point, Pixel makes more sense for SDL anyway :)  The point is that having the user do casts between SDL colors and OpenGL colors is annoying.
09:05:29 <Igloo> Ermmm, a class with a method colour :: a -> SDLColour is what I meant
09:06:45 <dark> Then the user can declare GL.Color3 and GL.Color4 to be instances of that class?
09:07:58 <Igloo> Or you can provide such a module for those that have HOpenGL
09:31:33 <ibid> anybody know a historical reason why we talk about currying and not about shcönfinkel's device?
09:31:47 <ibid> did curry popularize it somehow?
09:38:11 <sethk> ibid:  The books say, somewhat unseriously I suspect, that it is because Curry is easier to say
09:39:13 <sethk> In the early part of the 20th century, you won't find many things credited to a person with an ethnic name like Moses Shconfinkel
09:39:59 <ibid> well, church credits him in one of his lambda calculus papers
09:40:16 <ibid> (the one about undecidable statements in number theory)
09:40:37 <ibid> the easy part is not a historical reason :-)
09:40:46 <sethk> As does Barendregt, & Hinkley & Seldon.  Now.
09:40:52 <sethk> But this is a different time, thank god.
09:41:08 <ibid> and i don't think curry was a random choice, there has to be a reason
09:41:23 <ibid> yeah, but the curry article was in 1930's
09:41:32 <sethk> That's true, Curry applied the principle more specifically.
09:41:42 <ibid> ?
09:42:04 <sethk> From what I read, Schonfinkle just sort of tossed it off as a remark, which is in itself quite remarkable.
09:42:36 <sethk> But Schonfinkel was at least 10 years ahead of Curry here.
09:42:42 <ibid> well, church used it quite specifically :-)
09:42:48 <ibid> and credits schönfinkel
09:43:00 <ibid> "a device due to schönfinkel"
09:43:24 <ibid> when did curry use it?
09:43:40 <sethk> There is no question that schonfinkel formulated the principle first.  I believe Curry first used it in the early 30's.
09:43:51 <sethk> But then all of them more or less abandoned it for 15 years or so.
09:44:08 <ibid> so curry used it about the same time as church
09:44:24 <sethk> I believe so.  I know that Curry was already writing in the 30s.
09:44:26 <ibid> why don't we talk about churchying?
09:44:40 <ibid> did curry write a widely-read textbook that uses it?
09:44:46 <ibid> or something
09:45:04 <sethk> Barendgregt sites a Curry paper from 1930.
09:45:57 <sethk> Also, historically, Church and the others were ready to abandon the theory altogether, and only Curry wanted to continue it, so he is something of a hero in that regard.
09:46:12 <ibid> abandon what theory?
09:46:23 <ibid> lambda calculus? logic?
09:46:47 <ibid> you mean they were discouraged by gödel?
09:46:53 <sethk> No, not exactly.
09:47:04 <sethk> Originally the theory was hoped to have much wider application
09:47:06 <ibid> abandon what theory?
09:47:26 <sethk> Then Kleene & Rosser identified a paradox
09:47:28 <ibid> the device?
09:47:46 <ibid> which theory are you talking about?
09:47:54 <sethk> And Curry is quoted as saying he didn't want to "run away from the paradoxes"
09:48:02 <sethk> Well, technically...
09:48:21 <ibid> well, shopping, brb
09:48:29 <sethk> The lambda-I calculus
09:48:37 <sethk> OK  :)
09:50:04 <Heffalump> what paradox?
09:50:46 <sethk> The Kleene-Rosser paradox.  I can give you the cite in Barendgredt
09:50:59 <Heffalump> is it in the index?
09:51:06 * Heffalump assumes so and goes to grab it from the library
09:51:41 <sethk> Page 4, which is good because I get lost at about page 7
09:53:31 <dark> Would it be cruel to make my users deal with a function like with_pixels :: Surface -> (StateT PixelState IO a) -> IO a
09:53:55 <sethk> Why would that be _especially_ cruel?
09:54:28 <dark> Some people would run away from monad transformers :)
09:55:10 <sethk> I think people expect to have to deal with monadic stuff for I/O, so I wouldn't think it is a problem, unless of course there is a better way to do it.
09:55:40 <dark> I tried to figure out a way to do it with just State PixelState, but that would probably involve first reading them all from the Ptr and then writing them all back.
09:56:11 <dark> With unsafeIO, even the State monad won't help to ensure that updates are done before the result is returned.  I think.
09:56:41 <dark> hmm, maybe the strict ST could do it.
09:56:54 <sethk> I don't know it well enough to comment.
09:57:29 <sethk> How does Hudak deal with it in his book?
09:58:56 <Heffalump> grr, one of the copies is missing and the other copy is a month out of date
09:59:12 <Heffalump> s/out of date/overdue/
09:59:55 <sethk> It doesn't really go into the details of the paradox until a lot later in the book.
10:00:20 <sethk> And they aren't for the casual reader.
10:00:38 <sethk> I can sort of follow it, but not in any detail.
10:02:04 <Heffalump> I understand reasonable chunks of Barendregt, but there are lots of bits I don't
10:02:43 <sethk> I keep trying...
10:06:11 <ibid> back
10:06:51 <ibid> google finds nothing with Barendgredt
10:07:14 <sethk> He wrote the lambda calculus bible
10:07:47 <sethk> You want the ISBN or cite?
10:08:03 <Heffalump> Barendregt
10:08:06 <ibid> are you sure you spelled the name right?
10:08:07 <Heffalump> is the correct spelling
10:09:00 <ibid> ugh. 44 pounds
10:09:04 <sethk> Sorry, I had an extra letter or two   :)
10:09:59 <ibid> hmm, our library has a 1984 edition
10:11:07 <ibid> of course its taken...
10:11:09 <Heffalump> that's the revised one, isn't it?
10:11:15 <Heffalump> or is the 199something one the revised one
10:11:35 <dark> I think we should establish a standards body for streamlining the names of scientists.
10:11:55 <ibid> Rev. ed.
10:12:04 <ibid> is there a 1990's ed?
10:12:08 <Heffalump> I don't think so
10:12:12 <ibid> amazon shows a 1988 edition
10:12:18 <Heffalump> I think there's only one revision
10:12:20 <Heffalump> title?
10:12:21 <ibid> 1987 actually
10:12:22 <sethk> The 84 is revised, yes.
10:12:37 * Heffalump wants a book grant
10:12:38 <ibid> http://www.amazon.co.uk/exec/obidos/ASIN/0444875085/ref=sr_aps_books_1_1/026-5758589-1082059
10:12:57 <Heffalump> Maybe I should devote some of my salary to establishing myself one.
10:13:10 <ibid> maybe i should spend that 44 pounds
10:13:22 <sethk> There was a 1998 reprinting (not revision) so it is available.
10:13:26 <ibid> (the equivalent in euros of course)
10:13:37 <sethk> How much is 44 pounds in dollars or euros?
10:13:40 <ibid> yes it's available
10:13:49 <ibid> ~10/6 :-)
10:14:02 <Heffalump> about 70
10:14:15 <sethk> Steep
10:14:21 <Heffalump> where would ibid be buying it from in pounds?
10:14:40 <Heffalump> well, academic books tend to have limited appeal and they still have large fixed costs for setting up the print run
10:15:10 <ibid> amazon.co.uk
10:15:12 <sethk> If you want inexpensive books, you should be programming in visual basic     :)
10:15:17 <Heffalump> :-)
10:15:25 <Heffalump> ibid: ah, does it make sense for you to buy from there then?
10:15:35 <ibid> it seems to me
10:15:36 <Heffalump> there isn't an amazon.co.fi
10:15:37 <Heffalump> ?
10:15:45 <ibid> there are no real finnish competition
10:16:06 <sethk> You can probably find a used copy for much less.  I suspect most people who buy it don't actually keep it.
10:16:12 <ibid> there used to be (bol.fi) but despite my frequent purchases they folded
10:16:31 * ibid likes printer-new books :-)
10:16:43 * sethk likes to eat, also
10:16:53 <ibid> the cost is not prohibitive for me
10:16:59 <Heffalump> I don't mind too much, if they're in good condition.
10:17:02 <Heffalump> I need a copy of CLR.
10:17:10 <ibid> i just need to consider whether i want it *that* much
10:17:19 <ibid> i have a copy of CLR :-)
10:17:26 <sethk> The algorithm book?
10:17:29 <Heffalump> having a job helps with not having to decide between books and food :-)
10:17:30 <ibid> yeah
10:17:31 <Heffalump> sethk: yeah
10:17:36 <ibid> really never read it
10:17:41 * ibid prefers knuth :-)
10:17:54 <sethk> ibid:  You can't be serious
10:18:03 <ibid> i am
10:18:34 <sethk> You like mainframe assembly language and tape drive storage algorithms?
10:18:39 <ibid> no :-)
10:18:50 <ibid> but you don't have to read all of it to appreciate it
10:19:09 <Heffalump> I would like a copy of Knuth too.
10:19:15 <sethk> I've used it many times, but to me he is deliberately obtuse.
10:19:19 <ibid> it's probably because it was the first real algotithmics book i read
10:19:36 <ibid> it managed to explain linked lists and trees to me :-)
10:19:46 <sethk> Also, CLR algorithms often can be translated line for line into Haskell.  Try that with Knuth
10:20:01 <ibid> of course, right now i'd probably recommend the haskell algo book
10:20:09 <Heffalump> what is that?
10:20:20 <sethk> Okasaki?
10:20:32 <ibid> yeah, i think
10:20:33 <Heffalump> oh, right, yeah
10:20:40 <Heffalump> that's mostly data structure stuff, isn't it?
10:20:51 <ibid> hm, probably not okasaki
10:21:01 <ibid> not the functional data structures book
10:21:06 <Heffalump> ah, ok
10:21:12 <sethk> Then I haven't read it, which one?
10:21:16 <ibid> but the data structures and algorithms in haskell book :-)
10:21:19 <ibid> let me check haskell.org
10:21:24 <ibid> my copy is at work
10:21:36 <sethk> Don't worry, I can dig it up if you don't know.
10:21:46 <ibid> Fethi Rabhi and Guy Lapalme: Algorithms: A functional programming approach , Addison-Wesley, 235 pages, paperback, 1999. ISBN 0-201-59604-0
10:21:50 <sethk> I'm just being lazy
10:22:05 <sethk> Worthwhile?
10:22:37 <ibid> if you are a undergrad student taking algorithms, yeah :-)
10:22:47 <ibid> maybe not for reference
10:23:51 <sethk> I like Okasaki's book, but I keep telling him his proof arguments are circular and he keeps telling me they aren't.  He is correct, no doubt, but I can't see it.
10:24:35 <Heffalump> which proof arguments?
10:24:51 <sethk> Well, running time computations, really, not proofs.
10:25:21 <ibid> what does (head topic) mean?
10:25:33 <sethk> But I can't convince myself that induction is not hand waving, either.
10:25:45 <ibid> induction is perfectly acceptable
10:25:54 <ibid> it's one of the fundamental proof mechanisms
10:25:55 <sethk> I know, I just have a mental block.
10:26:07 <sethk> Actually, it is axiomatic, not provable
10:26:26 <ibid> actually, it's by definition :-)
10:26:38 <sethk> That's what axiomatic means, I think    :)
10:26:41 <ibid> "in the nature of natural numbers" :-)
10:27:07 <ibid> the terms overlap but are not identical
10:27:32 <ibid> depends really on how you define naturals
10:27:43 <ibid> in the set theoretic definition, it's a theorem
10:28:05 <sethk> Circular.
10:28:08 <ibid> in peano axiomatization it's an axion
10:28:11 <ibid> sethk: no
10:28:37 <ibid> it is possible to construct set theory without using naturals
10:28:45 <ibid> (in the object language)
10:28:57 <sethk> ibid:  Sure it is.  That doesn't make it invalid.  Anything axiomatic is at root circular.
10:29:10 <ibid> uhh. no?
10:29:18 <sethk> ibid:  OK, but then you assume something else.  Somewhere there is a circle.
10:29:24 <ibid> no
10:29:28 <sethk> Goedel proved that.
10:29:35 <ibid> no he didn't
10:29:55 <ibid> gödel proved that in every interesting axiom system there are contingent formulae
10:30:24 <sethk> Yes, but he proved that you can't prove a formal system is correct using the methods of that formal system.
10:30:28 <ibid> (or really, there is a contingent formula)
10:30:37 <ibid> sethk: true, and that's why we don't do that
10:30:54 <sethk> You can only prove things consistent, not correct.
10:30:58 <dark> We wave our hands at it instead? :)
10:31:21 <sethk> Of course.
10:31:23 <ibid> oh, btw, how do you define correct? gödel didn't use that term
10:31:25 <ibid> no
10:31:34 <ibid> well
10:31:36 <sethk> Church uses it.
10:31:42 <ibid> we just say we don't know :-)
10:31:53 <ibid> sethk: in what context?
10:31:56 <Heffalump> "completeness" is what godel proved that about, right?
10:32:26 <ibid> Heffalump: no, that's the first theorem. we are talking about the second (a corollary)
10:32:26 <sethk> I'll have to dig it up.  Or I could always be confused.
10:32:35 <Heffalump> i.e. given a "sufficiently complex" formal system (where "sufficiently complex" is carefully defined and is satisfied by anything that can do arithmetic, IIRC), there are true statements in that system that cannot be proved in it.
10:32:39 <Heffalump> ah, ok.
10:33:02 <ibid> hmm
10:33:19 <Heffalump> ibid sounds like he knows more details than I remember,
10:33:21 <Heffalump> s/,//
10:33:27 <dark> Heffalump: With that formulation I might question the assertion that those statements are "true statements in that system" :)
10:33:52 <ibid> dark: truth is not the same thing as provability
10:34:30 <ibid> truth is semantic, provability is syntactic
10:35:10 <sethk> ibid:  Hmm.  Truth is used in the propositional calculus, which is purely syntactic
10:35:17 <ibid> sethk: no
10:35:34 <ibid> sethk: truth is semantic even there
10:35:40 <sethk> How so?
10:36:56 <dark> But the system says nothing about truth, only about provability.  It's our interpretation that maps statements in the system to truths.
10:37:28 <sethk> That doesn't change the fact that the definition of truth is syntactic
10:37:36 <ibid> a proposition's truth value is a semantic thing... the truth value depends on the model (the possible world)
10:37:36 <dark> And apparently this mapping doesn't go both ways :)
10:37:39 <ibid> it isn't
10:37:53 <ibid> truth tables are semantics
10:37:54 <sethk> ibid:  Enlighten me.
10:38:18 <ibid> i don't know how :-)
10:38:58 <dark> Silly, you can't get enlightened on irc.  You have to go to a monastery on top of a mountain, and restrict your diet.
10:39:00 <sethk> probably impossible  :)
10:39:44 <ibid> Heffalump said something that forces me to check gödel's paper...
10:40:29 <ibid> btw, gödel said that consistency is not provable in an interesting axiom system
10:41:39 <dark> Hmm, the only reason I'm using a StateT at all here is to make sure the caller can't access the state after the computation is done (because it's invalidated when with_pixels unlocks the underlying value).  I don't actually modify the state.  Is there some simpler construct I could use?
10:41:50 <Heffalump> a Reader monad?
10:42:25 <dark> I'll go look at Control.Monad.Reader :)
10:42:44 <ibid> where does the following idea come from?
10:43:05 <ibid> 20:32 < Heffalump> i.e. given a "sufficiently complex" formal system (where "sufficiently complex" is carefully 
10:43:08 <ibid>                    defined and is satisfied by anything that can do arithmetic, IIRC), there are true statements 
10:43:11 <ibid>                    in that system that cannot be proved in it.
10:43:22 <Heffalump> ibid: my understanding of what Godel said.
10:43:25 <dark> Hmm, maybe what I really need is just an IORef that I don't give to the user.
10:43:32 <Heffalump> which I'm quite prepared to accept is wrong
10:43:35 <ibid> yeah, but that's an interpretation of it
10:43:44 <ibid> he didn't state that directly
10:43:49 <ibid> and mine is different :-)
10:43:52 <Heffalump> ok :-)
10:44:04 <ibid> i've heard that elsewhere though too
10:44:39 <Heffalump> it may be that consistency is the thing he demonstrated to be an unprovable true fact.
10:46:28 <ibid> Heffalump: that's the second theorem
10:46:34 <sethk> dark:  What are you doing talking about haskell on #haskell?   :)
10:46:34 <ibid> a corollary of the first
10:46:43 <ibid> which is what we are talking about this time :-)
10:47:40 <Heffalump> ah.
10:50:01 <ibid> the theorem actually says that for an omega-consistent, primitive-recursive set of formulae there exists a formula P for which neither P not ~P is provable from the set
10:50:38 <Heffalump> right.
10:51:03 <Heffalump> a closed formula, presumably?
10:51:27 <sethk> But does that imply a true, unprovable formula, or just a formula whose truth is unknown?
10:52:10 <ibid> omega-consistent: if you can prove a statement P(x) for all natural numbers separately, then you can prove its generalization forall x in nat . P(x)
10:52:31 <ibid> sethk: define true and false (and this is *not* pedantry, it's an important question)
10:52:43 <ibid> as far as i can tell, gödel does not discuss truth at all
10:53:25 <sethk> Well, say truth means that for all inputs the formula produces the correct results.
10:53:45 <ibid> yeah, closed
10:53:54 <ibid> define correct
10:53:59 <ibid> define input
10:54:42 <sethk> I understand what you are saying; but my question is, what was Godel implying?  Or is the answer "not relevent"?
10:55:07 <ibid> sethk: my interpretation is that "every interesting axiom system has contingencies"
10:55:48 <sethk> OK, I think I follow that.
10:56:23 <ibid> you can only discuss truth and falsity with respect to a fixed model and a fixed interpretation
10:56:49 <ibid> proof does not imply "true", it implies "tautology" (true in every model and every interpretation)
10:57:26 <ibid> sometimes though people abuse true and false and mean by them tautology and refutable, respectively
10:57:57 <ibid> in that terminology, the statement would be false, in my understanding
10:59:31 <sethk> If false is refutable, and neither P nor ~P is provable, doesn't that mean neither P nor ~P is refutable?
10:59:39 <ibid> no
10:59:53 <ibid> one of them must be refutable
11:00:16 <ibid> but neither has to be tautology
11:00:52 <ibid> (of course, we assume here that provable and tautology have the same extension)
11:00:57 <Heffalump> x==True satisfies that condition, though
11:01:40 <ibid> closed formula!
11:01:46 <sethk> I'm going to have to study what refutable means.
11:02:06 <ibid> it took me a year to reach this state of (mis?)understanding :-)
11:03:52 <Heffalump> ok, just checking :-)
11:04:06 <Heffalump> oh, you said "yeah, closed" above
11:04:08 <Heffalump> I missed that, sorry
11:04:36 <ibid> aiui, gödel's result implies that every interesting axiom system has a nonstandard model
11:05:09 <ibid> (and if my interpretation stated above is correct, this is certainly the case)
11:05:24 <sethk> what does nonstandard mean in this context?
11:05:58 <ibid> not standard
11:06:06 <ibid> not the intended one
11:06:59 * sethk heads back to the bookshelf
11:10:05 <ibid> the current draft of my thesis recounts this according to my interpretation (and defines refutable etc)
11:10:25 <Heffalump> what is your thesis about?
11:11:13 <ibid> a good question :-)
11:11:23 <ibid> i need to figure that out before i submit it
11:11:47 <ibid> it has evolved beyond the original subject matter
11:11:58 <ibid> maybe you can help? :-)
11:12:30 <sethk> I'd love to read it.
11:12:49 <Heffalump> got a URL?
11:12:59 <Heffalump> and what degree is it for, Masters or PhD?
11:13:04 <ibid> http://www.mit.jyu.fi/antkaij/tmp/gradu3.pdf
11:13:05 <ibid> masters
11:13:20 * ibid should finish it in two weeks
11:14:02 <Heffalump> I think the second offered title is more useful for me to get an impression about what it is about
11:14:09 <Heffalump> whether said impression is accurate is another matter :-)
11:14:19 <ibid> there is no second offered title
11:14:27 <ibid> there is only one title
11:14:31 <ibid> currently
11:14:37 <ibid> the or is a part of it
11:14:44 <Heffalump> oh, right.
11:14:53 <Heffalump> well, the bit after the "or" is nicer, I think :-)
11:14:57 <ibid> hehe
11:15:06 <Heffalump> I'll have a proper read tomorrow or this evening
11:15:07 <ibid> the problem is, is it accurate :-)
11:15:15 <Heffalump> well, "proper" = semi-skim
11:15:18 <ibid> at one point, i thought i was going to do that
11:15:22 <ibid> semi-skim?
11:15:25 <ibid> ahh
11:15:33 <tinus> heh, yay formal methods ... :/
11:16:05 <ibid> please don't tell me if you find an uncorrectable error :-)
11:16:17 <ibid> well, tell me after i've graduated
11:16:34 <Heffalump> :-)
11:16:36 <sethk> tinus:  There is an engineer at AT&T who keeps a wooden cross in his desk, and takes it out if I mention formal methods.
11:16:45 <tinus> stepcut: lol
11:16:51 <tinus> erm, sethk that is
11:17:08 <tinus> i mean, i notice their use, but i hate doing the work
11:17:23 <sethk> I just want to fully understand them some day
11:17:33 <ibid> my dream is to make a formal method that it as easy to use as current compilers and pl's are
11:17:34 <tinus> me too
11:17:54 <Heffalump> hmm, your introduction implies that the work is about implementing the B method, rather than a critical review of it
11:17:58 <ibid> but i realize that i'll probably be retiring around the time it'll come to pass
11:18:06 <ibid> yeah
11:18:12 <Heffalump> (of course a critical review may be a natural consequence of implementing it)
11:18:16 <ibid> it's looking for its identity :-)
11:18:21 <Janni> hi
11:18:29 <Heffalump> which is more likely to describe the contents, the introduction or the title? :-)
11:18:44 <ibid> the title and the intro were written at different times
11:18:51 <ibid> if i knew, i'd probably tell you
11:18:58 <ibid> the intro is later
11:19:08 <ibid> from this autumn
11:19:13 <ibid> the title is from late spring
11:19:43 <ibid> the gödel etc stuff is in the latter part of chapter 2
11:19:56 <Heffalump> btw, hyperlinked PDFs make reading really nice, if you can easily generate them
11:20:30 <Heffalump> YM chapter 3
11:20:33 <Heffalump> (I hope!)
11:20:41 <tinus> Heffalump: can they be generated by using LaTeX's index, or need one make them himself?
11:20:42 <ibid> the historical review one
11:20:44 <ibid> yeah
11:20:50 <ibid> Heffalump: it's not hyperlinked?
11:20:53 <ibid> lets correct it
11:21:02 <Heffalump> doesn't seem to be
11:21:07 <Heffalump> tinus: there's a hyperref package
11:21:12 <Heffalump> it does most of the work
11:21:12 <tinus> ah, ok
11:21:16 <tinus> nea
11:21:16 <tinus> t
11:21:23 <Heffalump> I remember having to do a bit of hacking around to make it and something else work together nicely
11:21:29 <ibid> or not
11:21:32 <ibid> ugh
11:21:39 <ibid> hyperref breaks the build
11:21:42 <Heffalump> I'm leaving really soon anyway
11:21:48 <Heffalump> yeah, that was what I found when I first introduced it too
11:21:58 <ibid> it doesn't do that always
11:22:02 <Heffalump> I spent some time fixing it cos it was for my PhD thesis so I thought it was worth it :-)
11:22:18 * Heffalump goes
11:23:56 * ibid is reading putnam
11:24:09 <ibid> (s?)he seems to confirm my interpretation of gödel
11:32:58 <ibid> bah
12:10:52 <ibid> hmm. *now* it works
12:13:51 <ibid> Heffalump: http://www.mit.jyu.fi/antkaij/tmp/gradu3.pdf - now comes with hyperrefs
13:30:57 <philc> no soe graphics for MacOS X Aqua?
13:39:06 * ibid is a gödel guru wannabe
14:10:54 <whee> great, packages are broken in my ghc build. heh
14:38:05 <Marvin--> "the constant is almost constant"
14:40:03 <Pseudonym> Is that like a Fortran thing?
14:40:54 <Marvin--> no, it was from the complexity analysis some of my student wrote for their assignments
14:43:33 <Pseudonym> Ah, OK.
14:44:01 <Pseudonym> That reminds me of something I wrote in a high school physics test.
14:44:09 <Pseudonym> "Current is never consumed, only demanded."
14:44:18 <Marvin--> You used Jenks' constant? ;)
14:44:21 <Marvin--> haha
14:44:56 <Pseudonym> Actually, I was a common user of Fixes Law.
14:45:22 <Pseudonym> The results of an experiment will change to fit what the lab notes say should happen.
14:46:08 <Pseudonym> Or, in the strong form, the amount of uncertainty increases until it encompasses the theoretical value.
14:46:28 <Marvin--> and that difference is known as Jenks' constant
14:46:40 <Pseudonym> Oh, I didn't know that one.
14:46:52 <Marvin--> I think that's what it's called
14:46:57 * Pseudonym nods
14:47:16 <Pseudonym> Let's see... add 10% uncertainty for the effect of the Sun's magnetic field...
14:56:22 <whee> haha
14:56:37 <whee> that's pretty much how half of my physics lab reports went
14:56:45 <whee> boosted uncertainties here and there until it all agreed
15:15:41 <whee> der I'm having a stupid problem
15:16:23 <whee> I have a data type that has a constructor of Blah b (Hoorj a b) (Hoorj a b), and I'm trying to use it so that the type of b is a function
15:17:05 <whee> so I'm trying for example Blah min (Der 3) (Der 2) but it appears to be having a problem with min 
15:17:32 <Pseudonym> What sort of problem?
15:17:42 <Pseudonym> Exact error message is...?
15:17:45 <whee>     Ambiguous type variable(s) `a' in the constraint (Ord a)
15:17:45 <whee>       arising from use of `min' at Depth.hs:22
15:17:45 <whee>     In the first argument of `Node', namely `(min)'
15:17:51 <Pseudonym> Aha.
15:18:04 <Pseudonym> There's your problem.
15:18:08 <whee> should I be adding a type constraint to fix it?
15:18:13 <Pseudonym> Yes.
15:18:42 <whee> I don't see why or where though, I don't actually do anything with this function
15:18:49 <Pseudonym> Hmm.
15:18:58 <whee> it just exists in this structure and isn't used at the moment
15:19:43 <Pseudonym> I assume Hoorj ignores one of its type arguments.
15:20:01 <whee> lemme just show you the source
15:20:03 <Pseudonym> What's the line of code where the error is triggered?
15:20:05 <Pseudonym> OK.
15:20:34 <whee> http://smaerty.ath.cx/Depth.hs.html
15:20:39 <whee> line 22, which is the last one
15:20:53 <whee> well it got reformatted so the numbers arent the same heh
15:22:15 <Pseudonym> Yeah, that's your problem.
15:22:38 <Pseudonym> Monomorphism restriction.
15:22:48 <Marvin--> whee: vim user?
15:22:50 <Igloo> Why is everything always either one line too long or one character too wide?
15:22:51 <Pseudonym> Try adding an explicit type to root.
15:22:53 <whee> Marvin: what else :)
15:22:56 <Marvin--> whee: :)
15:23:06 <Marvin--> whee: thought I recognized the colour scheme :P
15:23:06 * Pseudonym is a vim user
15:23:20 <Pseudonym> You use different colours than me, though. :-)
15:23:33 <whee> Pseudonym: and how would I add that type? heh
15:23:58 <Pseudonym> root :: (Ord a) => Tree b (a -> a)
15:24:01 <Pseudonym> That should do it.
15:24:19 <Pseudonym> Or Tree a (a -> a) if that's what you intend.
15:24:28 <Pseudonym> Or just Tree Int (Int -> Int)
15:24:34 <Marvin--> not (a -> a -> a) then?
15:24:41 <Pseudonym> Oh, yes, sorry.
15:24:46 * Pseudonym duhs
15:25:34 <Marvin--> this is incredible... a lot of the students have implemented fairly nice skip lists, but many of their _plain_ double linked lists suck
15:25:54 <whee> gah I don' tknow what the hell I'm doing
15:25:55 <Pseudonym> Double linked lists are harder than most people realise.
15:26:12 <Pseudonym> Particularly the end of the list.
15:26:32 <Pseudonym> Lots more invariants to consider.
15:26:42 <whee> what's the right way to embed a type constraint with the code structure I have (right being the nicest looking way)
15:27:00 <Marvin--> Pseudonym: well, with sentinel nodes it's quite okay
15:27:01 <Pseudonym> I don't understand the question.
15:27:22 <Pseudonym> Marvin: Yes, but there's not always a nice sentinel value.
15:27:36 <whee> how should I format this code after adding the constraint
15:27:45 <Marvin--> Pseudonym: oh, but most of them handle that with comparator classes
15:27:52 <Pseudonym> Another thing to consider is that a wrong implementation of skip lists will probably perform well.
15:28:06 <Marvin--> they make stupid mistakes like not taking advantage of the fact that they sort their lists in the findElement method :)
15:28:23 <Pseudonym> :-)
15:28:28 <Marvin--> well, I'm talking not only code works / works not, I'm talking about how the code looks
15:28:35 <Pseudonym> Oh, OK.
15:28:47 <Pseudonym> Pointer hacking is ugly no matter what you do.
15:28:51 <Pseudonym> whee: I still don't understand.
15:29:02 <engstad> What _is_ a "skip list" ?
15:29:07 * Pseudonym hasn't had caffeine today, so go slowly
15:29:39 <Pseudonym> engstad: Kind of like Chris Okasaki's random access lists, only with pointers.
15:29:44 <whee> Pseudonym: should I be putting the type inline with the binding or what
15:30:24 <engstad> I haven't read Chris' book, could you explain it to me in ten words?
15:30:30 <Marvin--> engstad: sort-of parallel linked lists where randomness decided how many of the lists an element go in when you insert
15:30:51 <Marvin--> engstad: so you can search for elements in amortized logarithmic time
15:31:07 <engstad> Ah, okey. :-)
15:31:38 <engstad> Wasn't part of my curriculum when I was a student... :-)
15:32:05 <Pseudonym> BBIAB.  We have cakes on Wednesday morning.  Nice workplace. :-)
15:35:02 <whee> hooray adding the type worked
15:37:00 <dark> I've never found an actual use for double-linked lists.  If a structure is too complex for a single-linked list, then I generally want something else anyway.  And double-linked lists aren't worth their complexity.
15:40:31 <dark> s/structure/algorithm/
15:40:51 <Marvin--> they can be nice for O(1) removal
15:41:21 <dark> So can single-linked lists, if you keep track of the parent :)
15:41:45 <Marvin--> well, that's almost like an implicit double link :P
15:43:10 <dark> Except that you don't have to maintain it on updates :)  Usually when you're fiddling with list elements, either you're traversing the list or you just searched it for your element.  In both cases you can easily get a parent pointer.
15:43:14 <engstad> Hmm, I'm reading about the skip-list idea (Skip Lists: A Probabilist Alternative to Balanced Trees, by William Pugh, 1990). Very cool.
15:43:37 <Marvin--> engstad: and they're often faster than AVL trees
15:43:45 <engstad> Interesting.
15:44:00 <engstad> But, of course, no worst case guarantees, right?
15:44:33 <dark> Do they have an upper bound on memory use?
15:45:11 <Marvin--> dark: you can decide on an upper bound on memory used as a function of the number of elements if you like
15:45:45 <Marvin--> engstad: well, worst case on search is O(n) because of the randomness...
15:45:51 <dark> Okay, cool.
15:46:15 <dark> My other vote for a cool datatype is splay trees :)
15:46:24 <Marvin--> dark: I mean, you can determine how many levels you need to get good probabilistic logarithmic behaviour for the number of elements you've got
15:46:49 <Marvin--> I think (a,b)-trees are cool
15:47:15 <whee> are there any modules for matrices included with either ghc or haskell itself? (or what's the easy way to do them)
15:48:30 * Marvin-- just uploaded his first package to Debian, yay
15:48:39 <dark> Marvin--: which one?
15:49:23 <Marvin--> dark: libdebian-installer :P we're aiming for an alpha release towards the weekend. Since we just increased soversion on libd-i we wanted it up asap
15:49:37 <dark> Aha :)
15:49:45 <Marvin--> I mean, I've had packages in the archive for a while, but I got my account a few days ago
15:49:57 <andersca> oh dear
15:50:02 <dark> That reminds me that packaging ghc for some other arches than i386 would be a Good Thing.
15:50:23 <Marvin--> andersca: what?
15:50:33 <Marvin--> dark: yeah, that'd be neat-o
15:50:36 <andersca> just realized it's late and stuff
15:50:44 <andersca> congrats on the debian account :)
15:50:55 <Marvin--> andersca: yeah, me too
15:50:55 <Marvin--> thanks :)
15:51:01 <dark> whee: I don't know of any modules for them, but you can do a lot by indexing Array with tuple types.
15:51:05 * andersca remembers when he got his gnome account
15:51:37 <Marvin--> andersca: are those procedures as rigorous as the debian ones?
15:51:56 <andersca> Marvin--: nah
15:52:07 <Marvin--> andersca: so no waiting for six months? ;)
15:52:07 * andersca asked rasterman and got an account the same day
15:57:05 <Marvin--> oh well, I should get to bed
16:31:10 <tinus> hmm
16:31:18 <tinus> "this mission sucks."
16:45:53 <dark> Reminds me of Battle Isle II, where the difficulty ramped up steeply but each mission was eventually doable.
16:46:24 <tinus> heh
16:46:30 <tinus> mine seems way from doable atm
16:46:31 <dark> With each new mission, my initial reaction was "well, maybe the previous mission wasn't as impossible as I thought, but this mission really IS impossible"
16:47:18 <tinus> A fold on DTD
16:47:18 <tinus>  
16:47:18 <tinus> To express the DTD check you will have to write a recursive function over the abstract syntax for DTD's. Recursive functions can often be expressed as folds. Write a fold (and hence also an algebra) for the data type DTD. 
16:47:18 <tinus> A pretty-printer for DTD
16:47:22 <tinus> well
16:47:27 <tinus> i can do a fold
16:47:33 <tinus> but only on a 'data'
16:47:36 <tinus> not on a 'type'
16:47:40 <tinus> and DTD is a type:
16:47:44 <tinus> type DTD = (Doctype,[Elements])
16:47:57 <tinus> so there's my mission
16:53:15 <dark> A type is just an alias.  (Doctype,[Elements]) itself is a "data", which uses the 2-tuple constructor.
16:53:37 <tinus> so it's like
16:53:54 <tinus> data DTD = Doctype | Elements or something?
16:54:21 <dark> No, but you could rewrite it as data DTD = DTD Doctype [Elements]
16:54:32 <tinus> data DTD'  = DTD' Doctype' [Elements'] deriving (Eq,Show)
16:54:34 <tinus> i got that
16:54:50 <tinus> hmm
16:55:07 <tinus> but this fold think confuses me, then
16:56:08 <dark> What's the type Elements?
16:56:38 <tinus> type Elements = (Element,Element)
16:56:47 <tinus> data Element = Item String [Multiplier]
16:56:47 <tinus>              | Data String
16:56:47 <tinus>              | Element :|: Element
16:56:47 <tinus>              | Element :^: Element  -- Comma
16:56:55 <tinus> there's the full monty
16:57:04 <tinus> data Multiplier = Vraagteken | Ster | Plus deriving Show
16:57:10 <tinus> no, there it is.
16:57:17 <tinus> Doctype is just String
16:57:19 <dark> Interesting... why are elements paired?
16:57:46 <tinus> because of this:
16:57:55 <tinus> recipe (title,ingredients,preparation)
16:58:00 <tinus> title (#PCDATA)
16:58:01 <tinus> etc
16:58:15 <tinus> so this recipe thing will get
16:58:53 <tinus> (Item "recipe", Item "title" :^: Item "ingredients" :^: Item "preparation")
16:58:55 <tinus> after being parsed
16:59:02 <dark> Can the left side really be any kind of Element?
16:59:16 <tinus> no, it can only be an Item really
16:59:27 <tinus> so that's a small error
17:00:55 <tinus> so parsing isn't a problem, atm
17:00:59 <tinus> the fold is :(
17:01:34 <tinus> i have no clue howto represent it
17:02:30 <tinus> since there's no recursion in my data type
17:02:44 <tinus> well, only in Element
17:02:50 <tinus> but i need to write a fold over DTD
17:05:15 <tinus> hmm
17:05:20 <dark> Hmm, what is "the DTD check" anyway?
17:05:49 <tinus> http://www.cs.uu.nl/docs/vakken/gont/2002/praktikum/opgave4/index.html
17:05:56 <dark> [Elements] itself is recursive, because lists are :)
17:06:06 <tinus> to check whether or not all vars have been covered
17:06:24 <tinus> yeah, but the data is not recursive like Element is
17:06:47 <tinus> i have no clue what the teacher expects from me
17:08:48 <tinus> oh well
17:08:51 <tinus> i'd better sleep
17:08:57 <tinus> i'll see about it tomorrow
17:09:02 <tinus> thanks for the help
17:09:52 <dark> Hmm, I think you're supposed to create this type DTD_Algebra.
17:09:57 <dark> Which is not the same as DTD.
17:10:23 <tinus> yeah, i know
17:10:29 <dark> Looks like DTD_Algebra is a type constructor, in fact.
17:10:54 <tinus> but in all the examples i have here
17:11:12 <tinus> the data type from which you need to make an Algebra out of
17:11:18 <tinus> are recursive data's
17:11:25 <tinus> but mine is just a plain type
17:11:35 <dark> So the DTD_Algebra would actually be a way to associate values with the parts of a DTD, and calculate with them.
17:12:15 <tinus> yeah
17:12:44 <tinus> see what i have atm:
17:12:46 <Pseudonym> dark: On doubly-linked lists, you never implement it yourself.
17:12:47 <tinus> type DTD_Algebra a = (String -> [Multiplier] -> a
17:12:47 <tinus>                      ,String -> a
17:12:47 <tinus>                      ,a -> a -> a
17:12:47 <tinus>                      ,a -> a -> a)
17:12:49 <tinus> and
17:12:52 <tinus> fold_DTD :: DTD_Algebra dtdt -> Element -> dtdt
17:12:52 <tinus> fold_DTD (item,dat,or,and) = fold
17:12:52 <tinus>   where fold (Item a b) = item a b
17:12:53 <dark> Hmm, well, Element is recursive.  And if you add some extra operators to Elements, such as pair-with-a-left-hand-side, and add-a-doctype, then Element can represent DTD.
17:12:54 <tinus>         fold (Data a)   = dat a
17:12:56 <tinus>         fold (a :|: b)  = or  (fold a) (fold b)
17:12:58 <tinus>         fold (a :^: b)  = and (fold a) (fold b)
17:13:05 <Pseudonym> In C++, for example, you use the STL one and you're done.
17:13:24 * Pseudonym reads some more
17:13:28 <Pseudonym> Oh, and splay trees are useless.
17:13:29 <dark> Pseudonym: In that case, what's the exercise for? :-)
17:13:41 <Pseudonym> True.
17:13:56 <dark> Splay trees useless?!?  You pierce my heart!
17:14:00 <Pseudonym> :-)
17:14:15 <Pseudonym> They're useless for multithreaded use because access are effectively serialised.
17:14:40 <Pseudonym> And for non-multithreaded use, you do writes for every lookup, which fills your cache with dirt.
17:14:44 <tinus> dark: hmm, i don't get what you mean
17:14:57 <tinus> dark: altering Elements would just result in the same problem
17:15:12 <tinus> dark: you'll just get another (one level up) non-recursive type
17:15:35 <Heffalump> Pseudonym: so what's better (for non-multithreaded use in particular)?
17:15:49 <tinus> dark: am i wrong?
17:16:23 <dark> tinus: You could make a type that can represent Elements, [Elements], and DTD, as well as Element.
17:16:26 <Pseudonym> Heffalump: Any balanced tree where you don't mutate the structure on every _read_.
17:16:32 <dark> tinus: By adding constructors.
17:16:55 <Pseudonym> Say, BBB trees (e.g. FiniteMap).
17:17:05 <Pseudonym> Or red-black trees.  Or anything, really.
17:17:11 <dark> tinus: But the exercise might not intend for you to include doctype in the algebra.
17:17:13 <Pseudonym> Except AVL trees.  Way too many rotations.
17:18:21 <dark> You probably wouldn't need to actually define that type, just construct an algebra for it :)
17:18:31 <Pseudonym> For multithreaded use, hash tables seem to be pretty good, because you can put a read-write lock on every hash table entry.
17:18:39 <Pseudonym> That way, you can read some chains while you write to others.
17:18:43 <Pseudonym> Lots of concurrency.
17:18:51 <tinus> dark: yeah, but the Algebra-fold should result in data type DTD
17:19:03 <dark> Pseudonym: hash tables seem to be pretty good for almost anything :)
17:19:10 <Pseudonym> dark: Not true.
17:19:23 <Pseudonym> The problem with hash tables is you need to scan the key twice.
17:19:40 <dark> tinus: No, the example says fold_DTD :: DTD_Algebra dtdt ... -> DTD -> dtdt
17:19:42 <Pseudonym> Once to compute the hash function, another to compare once you've found a potential match.
17:19:50 <Pseudonym> Tries only scan the key once.
17:20:05 <dark> tinus: The result type is dtdt
17:20:25 <tinus> dark: but a DTD goes in
17:20:36 <tinus> dark: and not just Element or something
17:20:49 <tinus> so how about the current fold i wrote?
17:21:30 <tinus> the Algebra is for Elements, rather than DTD
17:21:57 <dark> tinus: Hmm, then I don't know.
17:22:09 <Heffalump> Pseudonym: right, ta
17:22:13 <tinus> hmm, bugger
17:22:20 <tinus> i am stuck, then
17:22:32 <tinus> thanks, anyways
17:22:38 * Heffalump uses Splaymaps quite heavily in SML in a project I'm working on atm, might investigate doing something else at some point
17:22:58 <tinus> must be me not understanding "the fold thing"
17:24:05 <Pseudonym> Yeah, I'd definitely replace them with something else.
17:24:24 <Pseudonym> BBB trees, IMO, are an excellent choice.
17:24:50 <Pseudonym> Especially if you choose the balance factor well.
17:24:59 <tinus> i'm off to bed
17:25:44 <Pseudonym> Night.
17:25:48 <tinus> night :)
17:27:30 <Heffalump> BBB?
17:28:32 <Pseudonym> Bounded balanced binary tree.
17:29:05 <Pseudonym> Stephen Adams. Functional pearls: Efficient sets -- a balancing act. Journal of Functional Programming, 3(4):553-561, October 1993. 
17:29:55 <Pseudonym> Oh, there's even some SML code here: http://www.swiss.ai.mit.edu/~adams/BB/
17:31:44 <Heffalump> ah, it's his Splaymap implementation I'm using too, IIRC :-)
17:31:50 <Pseudonym> :-)
17:31:54 <Pseudonym> Probably the same interface, then.
17:32:39 <Heffalump> well, except the Splaymap one got changed a bit for Moscow ML I think
17:47:57 <engstad> Btw, has there been any good Haskell implementation of graphs lately? I know someone was studying graphs for SML..
17:49:40 <whee> graphs are hard to do in haskell?
17:50:37 <engstad> Not easy to see how you would mark nodes without appending the original graph with states.
18:02:35 <dark> I wonder if something like fromJust (elemIndex (minimum xs) xs) is a reasonable definition of findMinimum.
18:03:14 <dark> A recursive definition gets pretty icky, with three scratch parameters.
18:03:49 <Igloo> snd $ minimum (zip xs [0..])
18:04:10 <Igloo> Assuming either minimum gives the left-most one or you are happy with it doing that
18:05:23 <dark> hmm, looks good :-)
18:51:59 <dark> Igloo: It turns out there is a way to export everything declared in a module, plus extra symbols.  You can add the module's own name to its export list.
18:52:25 <Igloo> Ah, right
18:58:46 <Pseudonym> engstad: Is there a reason why FGL isn't sufficient for your needs?
19:56:07 <dark> Hmm, with direct pixel drawing, hasdl is considerably slower than C.
19:56:21 <dark> a-profiling we go :-)
20:05:41 <dark> Hmm... hasdl takes about .5 seconds to fill a 256x256 surface.  The C version takes about .002 seconds.  There is some room for improvement here :)
22:55:00 <shapr> oy
22:55:18 <dennisb> hej
22:55:47 <shapr> hej dennisb
22:57:11 <shapr> tjena grabbar
22:57:28 <shapr> god morgon
22:59:03 <shapr> du, ska sover?
23:02:05 <dennisb> jag har just vaknat (I just woke up)
23:02:36 <dennisb> Actually, i've been up for a while but in a non-wake-mode
23:04:22 <shapr> jag har just vaknat ocksa
23:13:09 <shapr> are there any tutorials on "when to switch to a monad" and "how to go from a type to a monadic type" ?
23:17:15 <dennisb> I'm not sure. I started to use it for state the very first time, once you have used it I guess it's esier the next time to know when/if you need it
23:18:08 <shapr> I'll try that
23:28:10 <dennisb> The first time I used it I hade a updatable lookuptable as the state with methods to add and retrieve values from the (hidden) lookuptable
